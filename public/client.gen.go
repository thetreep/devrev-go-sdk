// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	Auth_tokenScopes = "auth_token.Scopes"
)

// Defines values for AccessLevel.
const (
	AccessLevelExternal   AccessLevel = "external"
	AccessLevelInternal   AccessLevel = "internal"
	AccessLevelPrivate    AccessLevel = "private"
	AccessLevelPublic     AccessLevel = "public"
	AccessLevelRestricted AccessLevel = "restricted"
)

// Defines values for AiAgentEventExecuteProgressProgressState.
const (
	SkillExecuted  AiAgentEventExecuteProgressProgressState = "skill_executed"
	SkillTriggered AiAgentEventExecuteProgressProgressState = "skill_triggered"
)

// Defines values for ArticleContentFormat.
const (
	Drdfv2 ArticleContentFormat = "drdfv2"
	Rt     ArticleContentFormat = "rt"
)

// Defines values for ArticleStatus.
const (
	ArticleStatusArchived     ArticleStatus = "archived"
	ArticleStatusDraft        ArticleStatus = "draft"
	ArticleStatusPublished    ArticleStatus = "published"
	ArticleStatusReviewNeeded ArticleStatus = "review_needed"
)

// Defines values for ArticleType.
const (
	ArticleTypeArticle      ArticleType = "article"
	ArticleTypeContentBlock ArticleType = "content_block"
	ArticleTypePage         ArticleType = "page"
)

// Defines values for ArtifactConfigurationSet.
const (
	ArtifactConfigurationSetArticleMedia           ArtifactConfigurationSet = "article_media"
	ArtifactConfigurationSetDefault                ArtifactConfigurationSet = "default"
	ArtifactConfigurationSetEmailMedia             ArtifactConfigurationSet = "email_media"
	ArtifactConfigurationSetJobData                ArtifactConfigurationSet = "job_data"
	ArtifactConfigurationSetMarketplaceListingIcon ArtifactConfigurationSet = "marketplace_listing_icon"
	ArtifactConfigurationSetMarketplaceMedia       ArtifactConfigurationSet = "marketplace_media"
	ArtifactConfigurationSetOrgLogo                ArtifactConfigurationSet = "org_logo"
	ArtifactConfigurationSetPlugSetting            ArtifactConfigurationSet = "plug_setting"
	ArtifactConfigurationSetPlugSettingBannerCard  ArtifactConfigurationSet = "plug_setting_banner_card"
	ArtifactConfigurationSetPortalCss              ArtifactConfigurationSet = "portal_css"
	ArtifactConfigurationSetSnapInFunctionsCode    ArtifactConfigurationSet = "snap_in_functions_code"
	ArtifactConfigurationSetSnapWidget             ArtifactConfigurationSet = "snap_widget"
	ArtifactConfigurationSetUserProfilePicture     ArtifactConfigurationSet = "user_profile_picture"
	ArtifactConfigurationSetWork                   ArtifactConfigurationSet = "work"
)

// Defines values for AtomType.
const (
	AtomTypeAuthToken       AtomType = "auth_token"
	AtomTypeCapability      AtomType = "capability"
	AtomTypeConversation    AtomType = "conversation"
	AtomTypeDevUser         AtomType = "dev_user"
	AtomTypeEnhancement     AtomType = "enhancement"
	AtomTypeFeature         AtomType = "feature"
	AtomTypeGroup           AtomType = "group"
	AtomTypeIssue           AtomType = "issue"
	AtomTypeLink            AtomType = "link"
	AtomTypeProduct         AtomType = "product"
	AtomTypeRevOrg          AtomType = "rev_org"
	AtomTypeRevUser         AtomType = "rev_user"
	AtomTypeServiceAccount  AtomType = "service_account"
	AtomTypeSla             AtomType = "sla"
	AtomTypeSlaTracker      AtomType = "sla_tracker"
	AtomTypeSysUser         AtomType = "sys_user"
	AtomTypeTag             AtomType = "tag"
	AtomTypeTicket          AtomType = "ticket"
	AtomTypeTimelineComment AtomType = "timeline_comment"
	AtomTypeWebhook         AtomType = "webhook"
)

// Defines values for AuthConnectionToggle.
const (
	Disable AuthConnectionToggle = "disable"
	Enable  AuthConnectionToggle = "enable"
)

// Defines values for AuthConnectionType.
const (
	AuthConnectionTypeGoogleApps AuthConnectionType = "google_apps"
	AuthConnectionTypeOidc       AuthConnectionType = "oidc"
	AuthConnectionTypeOkta       AuthConnectionType = "okta"
	AuthConnectionTypeSamlp      AuthConnectionType = "samlp"
	AuthConnectionTypeSocial     AuthConnectionType = "social"
	AuthConnectionTypeWaad       AuthConnectionType = "waad"
)

// Defines values for AuthTokenGrantType.
const (
	UrnDevrevParamsOauthGrantTypeTokenIssue  AuthTokenGrantType = "urn:devrev:params:oauth:grant-type:token-issue"
	UrnIetfParamsOauthGrantTypeTokenExchange AuthTokenGrantType = "urn:ietf:params:oauth:grant-type:token-exchange"
)

// Defines values for AuthTokenRequestedTokenType.
const (
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeAat             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:aat"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeAatActAs        AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:aat:act-as"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeAatPublic       AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:aat:public"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeDev             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:dev"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeDevConnect      AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:dev:connect"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeGat             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:gat"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypePat             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:pat"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypePatActAs        AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:pat:act-as"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeRat             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:rat"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeRev             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:rev"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSession         AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:session"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSessionDev0     AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:session:dev0"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSessionOnetime  AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:session:onetime"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSessionRevActAs AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:session:rev:act-as"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSuper           AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:super"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSys             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:sys"
	AuthTokenRequestedTokenTypeUrnIetfParamsOauthTokenTypeJwt               AuthTokenRequestedTokenType = "urn:ietf:params:oauth:token-type:jwt"
)

// Defines values for AuthTokenStatus.
const (
	AuthTokenStatusActive  AuthTokenStatus = "active"
	AuthTokenStatusExpired AuthTokenStatus = "expired"
	AuthTokenStatusRevoked AuthTokenStatus = "revoked"
)

// Defines values for AuthTokenSubjectTokenType.
const (
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeJwtAuth0 AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:jwt:auth0"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeJwtDev   AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:jwt:dev"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeRat      AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:rat"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeRev      AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:rev"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeRevinfo  AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:revinfo"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeSession  AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:session"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeSysu     AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:sysu"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeUserinfo AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:userinfo"
	AuthTokenSubjectTokenTypeUrnIetfParamsOauthTokenTypeJwt        AuthTokenSubjectTokenType = "urn:ietf:params:oauth:token-type:jwt"
)

// Defines values for AuthTokenTokenType.
const (
	Bearer AuthTokenTokenType = "bearer"
)

// Defines values for BooleanExpressionType.
const (
	And       BooleanExpressionType = "and"
	Not       BooleanExpressionType = "not"
	Or        BooleanExpressionType = "or"
	Primitive BooleanExpressionType = "primitive"
)

// Defines values for CodeChangeSource.
const (
	AzureDevops CodeChangeSource = "azure_devops"
	Bitbucket   CodeChangeSource = "bitbucket"
	Github      CodeChangeSource = "github"
	Gitlab      CodeChangeSource = "gitlab"
)

// Defines values for CommandActionExecutorType.
const (
	CommandActionExecutorTypeRego     CommandActionExecutorType = "rego"
	CommandActionExecutorTypeWorkflow CommandActionExecutorType = "workflow"
)

// Defines values for CommandActionTemplateType.
const (
	DevrevV1 CommandActionTemplateType = "devrev_v1"
)

// Defines values for CommandStatus.
const (
	CommandStatusDisabled CommandStatus = "disabled"
	CommandStatusDraft    CommandStatus = "draft"
	CommandStatusEnabled  CommandStatus = "enabled"
)

// Defines values for CommandSurfaceObjectTypes.
const (
	CommandSurfaceObjectTypesAccount         CommandSurfaceObjectTypes = "account"
	CommandSurfaceObjectTypesAiAssistantChat CommandSurfaceObjectTypes = "ai_assistant_chat"
	CommandSurfaceObjectTypesArticle         CommandSurfaceObjectTypes = "article"
	CommandSurfaceObjectTypesConversation    CommandSurfaceObjectTypes = "conversation"
	CommandSurfaceObjectTypesCustomObject    CommandSurfaceObjectTypes = "custom_object"
	CommandSurfaceObjectTypesDm              CommandSurfaceObjectTypes = "dm"
	CommandSurfaceObjectTypesEngagement      CommandSurfaceObjectTypes = "engagement"
	CommandSurfaceObjectTypesFlow            CommandSurfaceObjectTypes = "flow"
	CommandSurfaceObjectTypesIncident        CommandSurfaceObjectTypes = "incident"
	CommandSurfaceObjectTypesIssue           CommandSurfaceObjectTypes = "issue"
	CommandSurfaceObjectTypesOpportunity     CommandSurfaceObjectTypes = "opportunity"
	CommandSurfaceObjectTypesPart            CommandSurfaceObjectTypes = "part"
	CommandSurfaceObjectTypesRevOrg          CommandSurfaceObjectTypes = "rev_org"
	CommandSurfaceObjectTypesRevUser         CommandSurfaceObjectTypes = "rev_user"
	CommandSurfaceObjectTypesSnapIn          CommandSurfaceObjectTypes = "snap_in"
	CommandSurfaceObjectTypesTicket          CommandSurfaceObjectTypes = "ticket"
)

// Defines values for CommandSurfaceSurface.
const (
	CustomerChat CommandSurfaceSurface = "customer_chat"
	Discussions  CommandSurfaceSurface = "discussions"
)

// Defines values for ConversationsCreateRequestTypeValue.
const (
	ConversationsCreateRequestTypeValueSupport ConversationsCreateRequestTypeValue = "support"
)

// Defines values for DateFilterType.
const (
	Preset DateFilterType = "preset"
	Range  DateFilterType = "range"
)

// Defines values for DateTimePresetType.
const (
	LastNDays DateTimePresetType = "last_n_days"
	NextNDays DateTimePresetType = "next_n_days"
)

// Defines values for Definedness.
const (
	Immutable Definedness = "immutable"
	Mutable   Definedness = "mutable"
	Undefined Definedness = "undefined"
)

// Defines values for DevOrgAuthConnectionsCreateRequestType.
const (
	DevOrgAuthConnectionsCreateRequestTypeGoogleApps DevOrgAuthConnectionsCreateRequestType = "google_apps"
	DevOrgAuthConnectionsCreateRequestTypeOidc       DevOrgAuthConnectionsCreateRequestType = "oidc"
	DevOrgAuthConnectionsCreateRequestTypeOkta       DevOrgAuthConnectionsCreateRequestType = "okta"
	DevOrgAuthConnectionsCreateRequestTypeSamlp      DevOrgAuthConnectionsCreateRequestType = "samlp"
	DevOrgAuthConnectionsCreateRequestTypeWaad       DevOrgAuthConnectionsCreateRequestType = "waad"
)

// Defines values for DevOrgAuthConnectionsUpdateRequestType.
const (
	GoogleApps DevOrgAuthConnectionsUpdateRequestType = "google_apps"
	None       DevOrgAuthConnectionsUpdateRequestType = "none"
	Oidc       DevOrgAuthConnectionsUpdateRequestType = "oidc"
	Okta       DevOrgAuthConnectionsUpdateRequestType = "okta"
	Samlp      DevOrgAuthConnectionsUpdateRequestType = "samlp"
	Waad       DevOrgAuthConnectionsUpdateRequestType = "waad"
)

// Defines values for DevUserJobTitle.
const (
	DevUserJobTitleCustomerSuccessManager DevUserJobTitle = "customer_success_manager"
	DevUserJobTitleCxo                    DevUserJobTitle = "cxo"
	DevUserJobTitleDesigner               DevUserJobTitle = "designer"
	DevUserJobTitleDeveloper              DevUserJobTitle = "developer"
	DevUserJobTitleHeadOfSupport          DevUserJobTitle = "head_of_support"
	DevUserJobTitleOperations             DevUserJobTitle = "operations"
	DevUserJobTitleOthers                 DevUserJobTitle = "others"
	DevUserJobTitleProductManager         DevUserJobTitle = "product_manager"
	DevUserJobTitleQa                     DevUserJobTitle = "qa"
	DevUserJobTitleRevenueLeader          DevUserJobTitle = "revenue_leader"
	DevUserJobTitleSupport                DevUserJobTitle = "support"
	DevUserJobTitleTechLead               DevUserJobTitle = "tech_lead"
)

// Defines values for DevUsersCreateRequestStateEnumValue.
const (
	DevUsersCreateRequestStateEnumValueShadow DevUsersCreateRequestStateEnumValue = "shadow"
)

// Defines values for ErrorBadRequestCustomizationValidationErrorSubtype.
const (
	BadIdType            ErrorBadRequestCustomizationValidationErrorSubtype = "bad_id_type"
	DateParseError       ErrorBadRequestCustomizationValidationErrorSubtype = "date_parse_error"
	EnumOutOfRange       ErrorBadRequestCustomizationValidationErrorSubtype = "enum_out_of_range"
	ExpressionParseError ErrorBadRequestCustomizationValidationErrorSubtype = "expression_parse_error"
	FieldDropped         ErrorBadRequestCustomizationValidationErrorSubtype = "field_dropped"
	FieldImmutable       ErrorBadRequestCustomizationValidationErrorSubtype = "field_immutable"
	FieldNotInSchema     ErrorBadRequestCustomizationValidationErrorSubtype = "field_not_in_schema"
	FieldRequired        ErrorBadRequestCustomizationValidationErrorSubtype = "field_required"
	FragmentNotFound     ErrorBadRequestCustomizationValidationErrorSubtype = "fragment_not_found"
	IdParseError         ErrorBadRequestCustomizationValidationErrorSubtype = "id_parse_error"
	IdTypeNotAllowed     ErrorBadRequestCustomizationValidationErrorSubtype = "id_type_not_allowed"
	InvalidArgument      ErrorBadRequestCustomizationValidationErrorSubtype = "invalid_argument"
	TimestampParseError  ErrorBadRequestCustomizationValidationErrorSubtype = "timestamp_parse_error"
	UnknownError         ErrorBadRequestCustomizationValidationErrorSubtype = "unknown_error"
	UnsupportedType      ErrorBadRequestCustomizationValidationErrorSubtype = "unsupported_type"
	WrongType            ErrorBadRequestCustomizationValidationErrorSubtype = "wrong_type"
)

// Defines values for ErrorBadRequestMergeWorksErrorErrorSubtype.
const (
	AlreadyMerged           ErrorBadRequestMergeWorksErrorErrorSubtype = "already_merged"
	Closed                  ErrorBadRequestMergeWorksErrorErrorSubtype = "closed"
	DifferentReporters      ErrorBadRequestMergeWorksErrorErrorSubtype = "different_reporters"
	DifferentWorkspace      ErrorBadRequestMergeWorksErrorErrorSubtype = "different_workspace"
	InvalidStageTransition  ErrorBadRequestMergeWorksErrorErrorSubtype = "invalid_stage_transition"
	Locked                  ErrorBadRequestMergeWorksErrorErrorSubtype = "locked"
	StageNotFoundForSubtype ErrorBadRequestMergeWorksErrorErrorSubtype = "stage_not_found_for_subtype"
)

// Defines values for ErrorBadRequestType.
const (
	ErrorBadRequestTypeArtifactAlreadyAttachedToAParent  ErrorBadRequestType = "artifact_already_attached_to_a_parent"
	ErrorBadRequestTypeBadRequest                        ErrorBadRequestType = "bad_request"
	ErrorBadRequestTypeCustomizationValidationError      ErrorBadRequestType = "customization_validation_error"
	ErrorBadRequestTypeInvalidApiVersion                 ErrorBadRequestType = "invalid_api_version"
	ErrorBadRequestTypeInvalidEnumValue                  ErrorBadRequestType = "invalid_enum_value"
	ErrorBadRequestTypeInvalidField                      ErrorBadRequestType = "invalid_field"
	ErrorBadRequestTypeInvalidId                         ErrorBadRequestType = "invalid_id"
	ErrorBadRequestTypeMergeWorksError                   ErrorBadRequestType = "merge_works_error"
	ErrorBadRequestTypeMissingDependency                 ErrorBadRequestType = "missing_dependency"
	ErrorBadRequestTypeMissingRequiredField              ErrorBadRequestType = "missing_required_field"
	ErrorBadRequestTypeParseError                        ErrorBadRequestType = "parse_error"
	ErrorBadRequestTypeStaleSchemaFragments              ErrorBadRequestType = "stale_schema_fragments"
	ErrorBadRequestTypeUnexpectedIdType                  ErrorBadRequestType = "unexpected_id_type"
	ErrorBadRequestTypeUnexpectedJsonType                ErrorBadRequestType = "unexpected_json_type"
	ErrorBadRequestTypeValueNotPermitted                 ErrorBadRequestType = "value_not_permitted"
	ErrorBadRequestTypeWorkflowComponentValidationErrors ErrorBadRequestType = "workflow_component_validation_errors"
)

// Defines values for ErrorBadRequestUnexpectedJsonTypeType.
const (
	ErrorBadRequestUnexpectedJsonTypeTypeArray  ErrorBadRequestUnexpectedJsonTypeType = "array"
	ErrorBadRequestUnexpectedJsonTypeTypeBool   ErrorBadRequestUnexpectedJsonTypeType = "bool"
	ErrorBadRequestUnexpectedJsonTypeTypeNull   ErrorBadRequestUnexpectedJsonTypeType = "null"
	ErrorBadRequestUnexpectedJsonTypeTypeNumber ErrorBadRequestUnexpectedJsonTypeType = "number"
	ErrorBadRequestUnexpectedJsonTypeTypeObject ErrorBadRequestUnexpectedJsonTypeType = "object"
	ErrorBadRequestUnexpectedJsonTypeTypeString ErrorBadRequestUnexpectedJsonTypeType = "string"
)

// Defines values for ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType.
const (
	ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationTypeField        ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType = "field"
	ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationTypeOperation    ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType = "operation"
	ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationTypeWorkflow     ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType = "workflow"
	ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationTypeWorkflowStep ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType = "workflow_step"
)

// Defines values for ErrorConflictType.
const (
	ErrorConflictTypeConflict ErrorConflictType = "conflict"
)

// Defines values for ErrorForbiddenType.
const (
	ErrorForbiddenTypeForbidden ErrorForbiddenType = "forbidden"
)

// Defines values for ErrorInternalServerErrorType.
const (
	InternalError ErrorInternalServerErrorType = "internal_error"
)

// Defines values for ErrorNotFoundType.
const (
	ErrorNotFoundTypeNotFound ErrorNotFoundType = "not_found"
)

// Defines values for ErrorServiceUnavailableType.
const (
	ErrorServiceUnavailableTypeServiceUnavailable ErrorServiceUnavailableType = "service_unavailable"
)

// Defines values for ErrorTooManyRequestsType.
const (
	ErrorTooManyRequestsTypeTooManyRequests ErrorTooManyRequestsType = "too_many_requests"
)

// Defines values for ErrorUnauthorizedType.
const (
	Unauthenticated ErrorUnauthorizedType = "unauthenticated"
)

// Defines values for EventAiAgentResponseAgentResponse.
const (
	EventAiAgentResponseAgentResponseError                    EventAiAgentResponseAgentResponse = "error"
	EventAiAgentResponseAgentResponseMessage                  EventAiAgentResponseAgentResponse = "message"
	EventAiAgentResponseAgentResponseMessageGenerationStarted EventAiAgentResponseAgentResponse = "message_generation_started"
	EventAiAgentResponseAgentResponseProgress                 EventAiAgentResponseAgentResponse = "progress"
	EventAiAgentResponseAgentResponseSuggestions              EventAiAgentResponseAgentResponse = "suggestions"
)

// Defines values for EventFetchedResult.
const (
	EventFetchedResultForbidden EventFetchedResult = "forbidden"
	EventFetchedResultNotFound  EventFetchedResult = "not_found"
	EventFetchedResultOk        EventFetchedResult = "ok"
)

// Defines values for EventTimelineEntryUpdatedReactionAction.
const (
	Added   EventTimelineEntryUpdatedReactionAction = "added"
	Removed EventTimelineEntryUpdatedReactionAction = "removed"
)

// Defines values for GroupIngestionSource.
const (
	Airdrop GroupIngestionSource = "airdrop"
	Scim    GroupIngestionSource = "scim"
)

// Defines values for GroupMemberType.
const (
	GroupMemberTypeDevUser GroupMemberType = "dev_user"
	GroupMemberTypeRevUser GroupMemberType = "rev_user"
)

// Defines values for GroupType.
const (
	GroupTypeDynamic GroupType = "dynamic"
	GroupTypeStatic  GroupType = "static"
)

// Defines values for IssuePriority.
const (
	IssuePriorityP0 IssuePriority = "p0"
	IssuePriorityP1 IssuePriority = "p1"
	IssuePriorityP2 IssuePriority = "p2"
	IssuePriorityP3 IssuePriority = "p3"
)

// Defines values for LinkEndpointType.
const (
	LinkEndpointTypeCapability   LinkEndpointType = "capability"
	LinkEndpointTypeConversation LinkEndpointType = "conversation"
	LinkEndpointTypeDevUser      LinkEndpointType = "dev_user"
	LinkEndpointTypeEnhancement  LinkEndpointType = "enhancement"
	LinkEndpointTypeFeature      LinkEndpointType = "feature"
	LinkEndpointTypeIssue        LinkEndpointType = "issue"
	LinkEndpointTypeProduct      LinkEndpointType = "product"
	LinkEndpointTypeRevOrg       LinkEndpointType = "rev_org"
	LinkEndpointTypeRevUser      LinkEndpointType = "rev_user"
	LinkEndpointTypeTicket       LinkEndpointType = "ticket"
)

// Defines values for LinkType.
const (
	CustomLink    LinkType = "custom_link"
	DevelopedWith LinkType = "developed_with"
	Imports       LinkType = "imports"
	IsAnalyzedBy  LinkType = "is_analyzed_by"
	IsConvertedTo LinkType = "is_converted_to"
	IsDependentOn LinkType = "is_dependent_on"
	IsDuplicateOf LinkType = "is_duplicate_of"
	IsFollowUpOf  LinkType = "is_follow_up_of"
	IsMergedInto  LinkType = "is_merged_into"
	IsParentOf    LinkType = "is_parent_of"
	IsPartOf      LinkType = "is_part_of"
	IsRelatedTo   LinkType = "is_related_to"
	Serves        LinkType = "serves"
)

// Defines values for LinksDirection.
const (
	IsSource LinksDirection = "is_source"
	IsTarget LinksDirection = "is_target"
)

// Defines values for ListMode.
const (
	After  ListMode = "after"
	Before ListMode = "before"
)

// Defines values for MeetingChannel.
const (
	AmazonConnect MeetingChannel = "amazon_connect"
	GoogleMeet    MeetingChannel = "google_meet"
	Offline       MeetingChannel = "offline"
	Other         MeetingChannel = "other"
	Teams         MeetingChannel = "teams"
	Zoom          MeetingChannel = "zoom"
)

// Defines values for MeetingState.
const (
	MeetingStateCanceled    MeetingState = "canceled"
	MeetingStateCompleted   MeetingState = "completed"
	MeetingStateNoShow      MeetingState = "no_show"
	MeetingStateOngoing     MeetingState = "ongoing"
	MeetingStateRejected    MeetingState = "rejected"
	MeetingStateRescheduled MeetingState = "rescheduled"
	MeetingStateScheduled   MeetingState = "scheduled"
	MeetingStateWaiting     MeetingState = "waiting"
)

// Defines values for MemberType.
const (
	MemberTypeDevUser MemberType = "dev_user"
	MemberTypeGroup   MemberType = "group"
	MemberTypeRevUser MemberType = "rev_user"
	MemberTypeSysUser MemberType = "sys_user"
)

// Defines values for MetricActionExecuteRequestAction.
const (
	MetricActionExecuteRequestActionComplete MetricActionExecuteRequestAction = "complete"
	MetricActionExecuteRequestActionPause    MetricActionExecuteRequestAction = "pause"
	MetricActionExecuteRequestActionRestart  MetricActionExecuteRequestAction = "restart"
	MetricActionExecuteRequestActionResume   MetricActionExecuteRequestAction = "resume"
	MetricActionExecuteRequestActionStart    MetricActionExecuteRequestAction = "start"
)

// Defines values for MetricDefinitionAppliesTo.
const (
	MetricDefinitionAppliesToConversation MetricDefinitionAppliesTo = "conversation"
	MetricDefinitionAppliesToIssue        MetricDefinitionAppliesTo = "issue"
	MetricDefinitionAppliesToTicket       MetricDefinitionAppliesTo = "ticket"
)

// Defines values for MetricDefinitionMetricType.
const (
	Time  MetricDefinitionMetricType = "time"
	Value MetricDefinitionMetricType = "value"
)

// Defines values for MetricDefinitionStatus.
const (
	MetricDefinitionStatusActive   MetricDefinitionStatus = "active"
	MetricDefinitionStatusInactive MetricDefinitionStatus = "inactive"
)

// Defines values for OrgEnvironment.
const (
	Production OrgEnvironment = "production"
	Staging    OrgEnvironment = "staging"
	Test       OrgEnvironment = "test"
)

// Defines values for OrgScheduleFragmentStatus.
const (
	OrgScheduleFragmentStatusArchived  OrgScheduleFragmentStatus = "archived"
	OrgScheduleFragmentStatusDraft     OrgScheduleFragmentStatus = "draft"
	OrgScheduleFragmentStatusPublished OrgScheduleFragmentStatus = "published"
)

// Defines values for OrgScheduleStatus.
const (
	OrgScheduleStatusArchived  OrgScheduleStatus = "archived"
	OrgScheduleStatusDraft     OrgScheduleStatus = "draft"
	OrgScheduleStatusPublished OrgScheduleStatus = "published"
)

// Defines values for OrgType.
const (
	OrgTypeRevOrg OrgType = "rev_org"
)

// Defines values for PartType.
const (
	PartTypeCapability  PartType = "capability"
	PartTypeEnhancement PartType = "enhancement"
	PartTypeFeature     PartType = "feature"
	PartTypeProduct     PartType = "product"
)

// Defines values for QuestionAnswerStatus.
const (
	QuestionAnswerStatusArchived     QuestionAnswerStatus = "archived"
	QuestionAnswerStatusDiscarded    QuestionAnswerStatus = "discarded"
	QuestionAnswerStatusDraft        QuestionAnswerStatus = "draft"
	QuestionAnswerStatusPublished    QuestionAnswerStatus = "published"
	QuestionAnswerStatusReviewNeeded QuestionAnswerStatus = "review_needed"
)

// Defines values for ReactionsUpdateRequestAction.
const (
	Add    ReactionsUpdateRequestAction = "add"
	Remove ReactionsUpdateRequestAction = "remove"
)

// Defines values for SchemaFieldDescriptorArrayTypeBaseType.
const (
	SchemaFieldDescriptorArrayTypeBaseTypeBool      SchemaFieldDescriptorArrayTypeBaseType = "bool"
	SchemaFieldDescriptorArrayTypeBaseTypeComposite SchemaFieldDescriptorArrayTypeBaseType = "composite"
	SchemaFieldDescriptorArrayTypeBaseTypeDate      SchemaFieldDescriptorArrayTypeBaseType = "date"
	SchemaFieldDescriptorArrayTypeBaseTypeDouble    SchemaFieldDescriptorArrayTypeBaseType = "double"
	SchemaFieldDescriptorArrayTypeBaseTypeEnum      SchemaFieldDescriptorArrayTypeBaseType = "enum"
	SchemaFieldDescriptorArrayTypeBaseTypeId        SchemaFieldDescriptorArrayTypeBaseType = "id"
	SchemaFieldDescriptorArrayTypeBaseTypeInt       SchemaFieldDescriptorArrayTypeBaseType = "int"
	SchemaFieldDescriptorArrayTypeBaseTypeJsonValue SchemaFieldDescriptorArrayTypeBaseType = "json_value"
	SchemaFieldDescriptorArrayTypeBaseTypeRichText  SchemaFieldDescriptorArrayTypeBaseType = "rich_text"
	SchemaFieldDescriptorArrayTypeBaseTypeStruct    SchemaFieldDescriptorArrayTypeBaseType = "struct"
	SchemaFieldDescriptorArrayTypeBaseTypeText      SchemaFieldDescriptorArrayTypeBaseType = "text"
	SchemaFieldDescriptorArrayTypeBaseTypeTimestamp SchemaFieldDescriptorArrayTypeBaseType = "timestamp"
	SchemaFieldDescriptorArrayTypeBaseTypeTokens    SchemaFieldDescriptorArrayTypeBaseType = "tokens"
	SchemaFieldDescriptorArrayTypeBaseTypeUenum     SchemaFieldDescriptorArrayTypeBaseType = "uenum"
)

// Defines values for SchemaFieldDescriptorFieldType.
const (
	Array     SchemaFieldDescriptorFieldType = "array"
	Bool      SchemaFieldDescriptorFieldType = "bool"
	Composite SchemaFieldDescriptorFieldType = "composite"
	Date      SchemaFieldDescriptorFieldType = "date"
	Double    SchemaFieldDescriptorFieldType = "double"
	Enum      SchemaFieldDescriptorFieldType = "enum"
	Id        SchemaFieldDescriptorFieldType = "id"
	Int       SchemaFieldDescriptorFieldType = "int"
	JsonValue SchemaFieldDescriptorFieldType = "json_value"
	RichText  SchemaFieldDescriptorFieldType = "rich_text"
	Struct    SchemaFieldDescriptorFieldType = "struct"
	Text      SchemaFieldDescriptorFieldType = "text"
	Timestamp SchemaFieldDescriptorFieldType = "timestamp"
	Tokens    SchemaFieldDescriptorFieldType = "tokens"
	Uenum     SchemaFieldDescriptorFieldType = "uenum"
	Unknown   SchemaFieldDescriptorFieldType = "unknown"
)

// Defines values for SlaAppliesTo.
const (
	SlaAppliesToConversation SlaAppliesTo = "conversation"
	SlaAppliesToIssue        SlaAppliesTo = "issue"
	SlaAppliesToTicket       SlaAppliesTo = "ticket"
)

// Defines values for SlaEvaluationPeriod.
const (
	Monthly   SlaEvaluationPeriod = "monthly"
	Quarterly SlaEvaluationPeriod = "quarterly"
	Weekly    SlaEvaluationPeriod = "weekly"
	Yearly    SlaEvaluationPeriod = "yearly"
)

// Defines values for SlaSelectorAppliesTo.
const (
	SlaSelectorAppliesToConversation SlaSelectorAppliesTo = "conversation"
	SlaSelectorAppliesToIssue        SlaSelectorAppliesTo = "issue"
	SlaSelectorAppliesToTicket       SlaSelectorAppliesTo = "ticket"
)

// Defines values for SlaSelectorPriority.
const (
	SlaSelectorPriorityP0 SlaSelectorPriority = "p0"
	SlaSelectorPriorityP1 SlaSelectorPriority = "p1"
	SlaSelectorPriorityP2 SlaSelectorPriority = "p2"
)

// Defines values for SlaSelectorSeverity.
const (
	SlaSelectorSeverityBlocker SlaSelectorSeverity = "blocker"
	SlaSelectorSeverityHigh    SlaSelectorSeverity = "high"
	SlaSelectorSeverityLow     SlaSelectorSeverity = "low"
	SlaSelectorSeverityMedium  SlaSelectorSeverity = "medium"
)

// Defines values for SlaStatus.
const (
	SlaStatusArchived  SlaStatus = "archived"
	SlaStatusDraft     SlaStatus = "draft"
	SlaStatusPublished SlaStatus = "published"
)

// Defines values for SlaSummaryStage.
const (
	SlaSummaryStageBreached  SlaSummaryStage = "breached"
	SlaSummaryStageCompleted SlaSummaryStage = "completed"
	SlaSummaryStagePaused    SlaSummaryStage = "paused"
	SlaSummaryStageRunning   SlaSummaryStage = "running"
	SlaSummaryStageWarning   SlaSummaryStage = "warning"
)

// Defines values for SlaTrackerAppliesToType.
const (
	SlaTrackerAppliesToTypeConversation SlaTrackerAppliesToType = "conversation"
	SlaTrackerAppliesToTypeIssue        SlaTrackerAppliesToType = "issue"
	SlaTrackerAppliesToTypeTicket       SlaTrackerAppliesToType = "ticket"
)

// Defines values for SlaType.
const (
	SlaTypeExternal SlaType = "external"
	SlaTypeInternal SlaType = "internal"
)

// Defines values for SlasFilterAppliesToOperatorType.
const (
	All SlasFilterAppliesToOperatorType = "all"
	Any SlasFilterAppliesToOperatorType = "any"
)

// Defines values for SnapKitActionRequestElementTypeValue.
const (
	Button SnapKitActionRequestElementTypeValue = "button"
	Form   SnapKitActionRequestElementTypeValue = "form"
)

// Defines values for StageValidationOptionForCreate.
const (
	AllowNonStart StageValidationOptionForCreate = "allow_non_start"
)

// Defines values for StageValidationOptionForUpdate.
const (
	AllowInvalidTransition StageValidationOptionForUpdate = "allow_invalid_transition"
)

// Defines values for SyncMetadataFilterSyncInFilterStatus.
const (
	SyncMetadataFilterSyncInFilterStatusFailed    SyncMetadataFilterSyncInFilterStatus = "failed"
	SyncMetadataFilterSyncInFilterStatusModified  SyncMetadataFilterSyncInFilterStatus = "modified"
	SyncMetadataFilterSyncInFilterStatusStaged    SyncMetadataFilterSyncInFilterStatus = "staged"
	SyncMetadataFilterSyncInFilterStatusSucceeded SyncMetadataFilterSyncInFilterStatus = "succeeded"
)

// Defines values for SyncMetadataFilterSyncOutFilterStatus.
const (
	SyncMetadataFilterSyncOutFilterStatusFailed    SyncMetadataFilterSyncOutFilterStatus = "failed"
	SyncMetadataFilterSyncOutFilterStatusModified  SyncMetadataFilterSyncOutFilterStatus = "modified"
	SyncMetadataFilterSyncOutFilterStatusSucceeded SyncMetadataFilterSyncOutFilterStatus = "succeeded"
)

// Defines values for SyncProgressState.
const (
	SyncProgressStateCompleted                          SyncProgressState = "completed"
	SyncProgressStateDeleteInProgress                   SyncProgressState = "delete_in_progress"
	SyncProgressStateDeleted                            SyncProgressState = "deleted"
	SyncProgressStateDeletionError                      SyncProgressState = "deletion_error"
	SyncProgressStateExtractAttachments                 SyncProgressState = "extract_attachments"
	SyncProgressStateExtractAttachmentsError            SyncProgressState = "extract_attachments_error"
	SyncProgressStateExtraction                         SyncProgressState = "extraction"
	SyncProgressStateExtractionError                    SyncProgressState = "extraction_error"
	SyncProgressStateLoading                            SyncProgressState = "loading"
	SyncProgressStateLoadingAttachments                 SyncProgressState = "loading_attachments"
	SyncProgressStateLoadingAttachmentsError            SyncProgressState = "loading_attachments_error"
	SyncProgressStateLoadingError                       SyncProgressState = "loading_error"
	SyncProgressStateRecipeDiscovery                    SyncProgressState = "recipe_discovery"
	SyncProgressStateRecipeDiscoveryError               SyncProgressState = "recipe_discovery_error"
	SyncProgressStateRecipeDiscoveryWaitingForUserInput SyncProgressState = "recipe_discovery_waiting_for_user_input"
	SyncProgressStateStarting                           SyncProgressState = "starting"
	SyncProgressStateTransformation                     SyncProgressState = "transformation"
	SyncProgressStateTransformationError                SyncProgressState = "transformation_error"
)

// Defines values for SyncRunMode.
const (
	Initial        SyncRunMode = "initial"
	SyncFromDevrev SyncRunMode = "sync_from_devrev"
	SyncToDevrev   SyncRunMode = "sync_to_devrev"
)

// Defines values for TicketChannels.
const (
	Email     TicketChannels = "email"
	Plug      TicketChannels = "plug"
	Slack     TicketChannels = "slack"
	Twilio    TicketChannels = "twilio"
	TwilioSms TicketChannels = "twilio_sms"
)

// Defines values for TicketSeverity.
const (
	TicketSeverityBlocker TicketSeverity = "blocker"
	TicketSeverityHigh    TicketSeverity = "high"
	TicketSeverityLow     TicketSeverity = "low"
	TicketSeverityMedium  TicketSeverity = "medium"
)

// Defines values for TimelineCommentBodyType.
const (
	TimelineCommentBodyTypeData       TimelineCommentBodyType = "data"
	TimelineCommentBodyTypeSnapKit    TimelineCommentBodyType = "snap_kit"
	TimelineCommentBodyTypeSnapWidget TimelineCommentBodyType = "snap_widget"
	TimelineCommentBodyTypeText       TimelineCommentBodyType = "text"
)

// Defines values for TimelineEntriesCreateRequestType.
const (
	TimelineEntriesCreateRequestTypeTimelineComment TimelineEntriesCreateRequestType = "timeline_comment"
)

// Defines values for TimelineEntriesUpdateRequestType.
const (
	TimelineEntriesUpdateRequestTypeTimelineComment TimelineEntriesUpdateRequestType = "timeline_comment"
)

// Defines values for TimelineEntryObjectType.
const (
	TimelineEntryObjectTypeCapability      TimelineEntryObjectType = "capability"
	TimelineEntryObjectTypeConversation    TimelineEntryObjectType = "conversation"
	TimelineEntryObjectTypeEnhancement     TimelineEntryObjectType = "enhancement"
	TimelineEntryObjectTypeFeature         TimelineEntryObjectType = "feature"
	TimelineEntryObjectTypeIssue           TimelineEntryObjectType = "issue"
	TimelineEntryObjectTypeProduct         TimelineEntryObjectType = "product"
	TimelineEntryObjectTypeRevOrg          TimelineEntryObjectType = "rev_org"
	TimelineEntryObjectTypeRevUser         TimelineEntryObjectType = "rev_user"
	TimelineEntryObjectTypeTicket          TimelineEntryObjectType = "ticket"
	TimelineEntryObjectTypeTimelineComment TimelineEntryObjectType = "timeline_comment"
)

// Defines values for TimelineEntryType.
const (
	TimelineEntryTypeTimelineComment TimelineEntryType = "timeline_comment"
)

// Defines values for TimelineEntryVisibility.
const (
	External TimelineEntryVisibility = "external"
	Internal TimelineEntryVisibility = "internal"
	Private  TimelineEntryVisibility = "private"
	Public   TimelineEntryVisibility = "public"
)

// Defines values for UserState.
const (
	UserStateActive      UserState = "active"
	UserStateDeactivated UserState = "deactivated"
	UserStateDeleted     UserState = "deleted"
	UserStateLocked      UserState = "locked"
	UserStateShadow      UserState = "shadow"
	UserStateUnassigned  UserState = "unassigned"
)

// Defines values for UserType.
const (
	UserTypeDevUser        UserType = "dev_user"
	UserTypeRevUser        UserType = "rev_user"
	UserTypeServiceAccount UserType = "service_account"
	UserTypeSysUser        UserType = "sys_user"
)

// Defines values for VistaGroupItemState.
const (
	VistaGroupItemStateActive    VistaGroupItemState = "active"
	VistaGroupItemStateCompleted VistaGroupItemState = "completed"
	VistaGroupItemStatePlanned   VistaGroupItemState = "planned"
)

// Defines values for VistaGroupItemType.
const (
	VistaGroupItemTypeCurated VistaGroupItemType = "curated"
	VistaGroupItemTypeDynamic VistaGroupItemType = "dynamic"
)

// Defines values for WebCrawlerJobState.
const (
	Aborted   WebCrawlerJobState = "aborted"
	Completed WebCrawlerJobState = "completed"
	Running   WebCrawlerJobState = "running"
	Scheduled WebCrawlerJobState = "scheduled"
	Suspended WebCrawlerJobState = "suspended"
)

// Defines values for WebCrawlerJobsControlRequestAction.
const (
	WebCrawlerJobsControlRequestActionAbort  WebCrawlerJobsControlRequestAction = "abort"
	WebCrawlerJobsControlRequestActionPause  WebCrawlerJobsControlRequestAction = "pause"
	WebCrawlerJobsControlRequestActionResume WebCrawlerJobsControlRequestAction = "resume"
)

// Defines values for WebhookEventType.
const (
	AccountCreated        WebhookEventType = "account_created"
	AccountDeleted        WebhookEventType = "account_deleted"
	AccountUpdated        WebhookEventType = "account_updated"
	AiAgentResponse       WebhookEventType = "ai_agent_response"
	ConversationCreated   WebhookEventType = "conversation_created"
	ConversationDeleted   WebhookEventType = "conversation_deleted"
	ConversationUpdated   WebhookEventType = "conversation_updated"
	DashboardCreated      WebhookEventType = "dashboard_created"
	DashboardDeleted      WebhookEventType = "dashboard_deleted"
	DashboardUpdated      WebhookEventType = "dashboard_updated"
	DevUserCreated        WebhookEventType = "dev_user_created"
	DevUserDeleted        WebhookEventType = "dev_user_deleted"
	DevUserUpdated        WebhookEventType = "dev_user_updated"
	GroupCreated          WebhookEventType = "group_created"
	GroupDeleted          WebhookEventType = "group_deleted"
	GroupMemberAdded      WebhookEventType = "group_member_added"
	GroupMemberRemoved    WebhookEventType = "group_member_removed"
	GroupUpdated          WebhookEventType = "group_updated"
	IncidentCreated       WebhookEventType = "incident_created"
	IncidentDeleted       WebhookEventType = "incident_deleted"
	IncidentUpdated       WebhookEventType = "incident_updated"
	JobCreated            WebhookEventType = "job_created"
	JobDeleted            WebhookEventType = "job_deleted"
	JobUpdated            WebhookEventType = "job_updated"
	LinkCreated           WebhookEventType = "link_created"
	LinkDeleted           WebhookEventType = "link_deleted"
	LinkUpdated           WebhookEventType = "link_updated"
	PartCreated           WebhookEventType = "part_created"
	PartDeleted           WebhookEventType = "part_deleted"
	PartUpdated           WebhookEventType = "part_updated"
	QuestionAnswerCreated WebhookEventType = "question_answer_created"
	QuestionAnswerDeleted WebhookEventType = "question_answer_deleted"
	QuestionAnswerUpdated WebhookEventType = "question_answer_updated"
	RevOrgCreated         WebhookEventType = "rev_org_created"
	RevOrgDeleted         WebhookEventType = "rev_org_deleted"
	RevOrgUpdated         WebhookEventType = "rev_org_updated"
	RevUserCreated        WebhookEventType = "rev_user_created"
	RevUserDeleted        WebhookEventType = "rev_user_deleted"
	RevUserUpdated        WebhookEventType = "rev_user_updated"
	SlaTrackerCreated     WebhookEventType = "sla_tracker_created"
	SlaTrackerDeleted     WebhookEventType = "sla_tracker_deleted"
	SlaTrackerFetched     WebhookEventType = "sla_tracker_fetched"
	SlaTrackerUpdated     WebhookEventType = "sla_tracker_updated"
	SurveyCreated         WebhookEventType = "survey_created"
	SurveyDeleted         WebhookEventType = "survey_deleted"
	SurveyResponseCreated WebhookEventType = "survey_response_created"
	SurveyResponseDeleted WebhookEventType = "survey_response_deleted"
	SurveyResponseUpdated WebhookEventType = "survey_response_updated"
	SurveyUpdated         WebhookEventType = "survey_updated"
	SyncHistoryCreated    WebhookEventType = "sync_history_created"
	SyncHistoryDeleted    WebhookEventType = "sync_history_deleted"
	SyncHistoryUpdated    WebhookEventType = "sync_history_updated"
	SyncUnitUpdated       WebhookEventType = "sync_unit_updated"
	TagCreated            WebhookEventType = "tag_created"
	TagDeleted            WebhookEventType = "tag_deleted"
	TagUpdated            WebhookEventType = "tag_updated"
	TimelineEntryCreated  WebhookEventType = "timeline_entry_created"
	TimelineEntryDeleted  WebhookEventType = "timeline_entry_deleted"
	TimelineEntryUpdated  WebhookEventType = "timeline_entry_updated"
	Verify                WebhookEventType = "verify"
	WebhookCreated        WebhookEventType = "webhook_created"
	WebhookDeleted        WebhookEventType = "webhook_deleted"
	WebhookUpdated        WebhookEventType = "webhook_updated"
	WidgetCreated         WebhookEventType = "widget_created"
	WidgetDeleted         WebhookEventType = "widget_deleted"
	WidgetUpdated         WebhookEventType = "widget_updated"
	WorkCreated           WebhookEventType = "work_created"
	WorkDeleted           WebhookEventType = "work_deleted"
	WorkFetched           WebhookEventType = "work_fetched"
	WorkUpdated           WebhookEventType = "work_updated"
)

// Defines values for WebhookStatus.
const (
	Active     WebhookStatus = "active"
	Inactive   WebhookStatus = "inactive"
	Unverified WebhookStatus = "unverified"
)

// Defines values for WebhooksUpdateAction.
const (
	Activate   WebhooksUpdateAction = "activate"
	Deactivate WebhooksUpdateAction = "deactivate"
)

// Defines values for WorkType.
const (
	WorkTypeIssue  WorkType = "issue"
	WorkTypeTicket WorkType = "ticket"
)

// AccessLevel defines model for access-level.
type AccessLevel string

// Account defines model for account.
type Account struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the corresponding Account.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Domains Company's domain names. Example - 'devrev.ai'.
	Domains *[]string `json:"domains,omitempty"`

	// ExternalRefs External refs are unique identifiers from your customer system of
	// records, stored as a list.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy List of Dev user IDs owning this Account.
	OwnedBy        []UserSummary   `json:"owned_by"`
	PrimaryAccount *AccountSummary `json:"primary_account,omitempty"`

	// Tier The Tier of the corresponding Account.
	Tier *string `json:"tier,omitempty"`

	// Websites Company's website links. Filling in this property will also fill in
	// domain. Example - 'www.devrev.ai'.
	Websites *[]string `json:"websites,omitempty"`
}

// AccountSummary defines model for account-summary.
type AccountSummary = OrgBaseSummary

// AccountsCreateRequest Request object to create a new account in the Dev organization.
type AccountsCreateRequest struct {
	// Description Description of the account.
	Description *string `json:"description,omitempty"`

	// DisplayName Name of the account.
	DisplayName string `json:"display_name"`

	// Domains List of company's domain names. Example - ['devrev.ai'].
	Domains *[]string `json:"domains,omitempty"`

	// ExternalRefs External refs are unique identifiers from your customer system of
	// records, stored as a list.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// OwnedBy List of Dev users owning this account.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// Tier The tier of the account.
	Tier *string `json:"tier,omitempty"`

	// Websites List of company websites. Example - ['www.devrev.ai',
	// 'www.marketplace.devrev.ai'].
	Websites *[]string `json:"websites,omitempty"`
}

// AccountsCreateResponseBody The response to creating a new account.
type AccountsCreateResponseBody struct {
	Account Account `json:"account"`
}

// AccountsDeleteRequest Request object to delete an account.
type AccountsDeleteRequest struct {
	// Id The ID of account to delete.
	Id string `json:"id"`
}

// AccountsDeleteResponseBody The response to deleting an account.
type AccountsDeleteResponseBody = map[string]interface{}

// AccountsExportRequest The request to export a collection of accounts.
type AccountsExportRequest struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `json:"display_name,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// First The number of accounts to return. The default is '50'.
	First        *int32          `json:"first,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// SortBy Fields to sort the accounts by and the direction to sort them in.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `json:"stage,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `json:"websites,omitempty"`
}

// AccountsExportResponseBody The response to exporting a collection of accounts.
type AccountsExportResponseBody struct {
	// Accounts The exported accounts.
	Accounts []Account `json:"accounts"`
}

// AccountsFilters defines model for accounts-filters.
type AccountsFilters struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `json:"display_name,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string       `json:"external_refs,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `json:"stage,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `json:"websites,omitempty"`
}

// AccountsGetRequest Request object to get an account's information.
type AccountsGetRequest struct {
	// Id The ID of the account to be retrieved.
	Id string `json:"id"`
}

// AccountsGetResponseBody The returned account.
type AccountsGetResponseBody struct {
	Account Account `json:"account"`
}

// AccountsListRequest List the accounts.
type AccountsListRequest struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `json:"display_name,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// Limit The maximum number of accounts to return per page. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// SortBy Fields to sort the accounts by and the direction to sort them in.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `json:"stage,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `json:"websites,omitempty"`
}

// AccountsListResponseBody The response to listing all accounts matching the filter criteria.
type AccountsListResponseBody struct {
	// Accounts List containing all the accounts
	Accounts []Account `json:"accounts"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// AccountsMergeRequest Request object to merge two accounts.
type AccountsMergeRequest struct {
	// PrimaryAccount The ID of the primary account, which will be retained post merge.
	PrimaryAccount string `json:"primary_account"`

	// SecondaryAccount The ID of the secondary account, which will be merged into the
	// primary account.
	SecondaryAccount string `json:"secondary_account"`
}

// AccountsMergeResponseBody The response to merging an account.
type AccountsMergeResponseBody = map[string]interface{}

// AccountsUpdateRequest Request to update details of the account.
type AccountsUpdateRequest struct {
	// Description Updated description of the account.
	Description *string `json:"description,omitempty"`

	// DisplayName Updated display name for the account.
	DisplayName *string `json:"display_name,omitempty"`

	// Domains Updated list of company's domain names. Example - ['devrev.ai'].
	Domains *[]string `json:"domains,omitempty"`

	// ExternalRefs Updated External Refs of account.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// Id The ID of account to update.
	Id string `json:"id"`

	// OwnedBy Updated list of the users owning this account.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// Tier Updated tier of the account.
	Tier     *string                        `json:"tier"`
	Websites *AccountsUpdateRequestWebsites `json:"websites,omitempty"`
}

// AccountsUpdateRequestWebsites defines model for accounts-update-request-websites.
type AccountsUpdateRequestWebsites struct {
	// Set Sets the websites field of the account.
	Set *[]string `json:"set,omitempty"`
}

// AccountsUpdateResponseBody Updated account object.
type AccountsUpdateResponseBody struct {
	Account Account `json:"account"`
}

// AddTagWithValue defines model for add-tag-with-value.
type AddTagWithValue struct {
	// Id The ID of the tag.
	Id string `json:"id"`

	// Value The value for the object's association with the tag. If specified,
	// the value must be one that's specified in the tag's allowed values.
	Value *string `json:"value,omitempty"`
}

// AiAgentEventExecuteError An error object providing the error message for the AI agent event
// execution.
type AiAgentEventExecuteError struct {
	// Error The error message for the AI agent event execution.
	Error string `json:"error"`
}

// AiAgentEventExecuteProgress A progress object providing the status of the AI agent event execution.
type AiAgentEventExecuteProgress struct {
	ProgressState *AiAgentEventExecuteProgressProgressState `json:"progress_state,omitempty"`

	// SkillExecuted The progress for the AI agent event execution indicating that the skill
	// has been executed.
	SkillExecuted *AiAgentEventExecuteProgressSkillExecuted `json:"skill_executed,omitempty"`

	// SkillTriggered The progress for the AI agent event execution indicating that the skill
	// has been triggered.
	SkillTriggered *AiAgentEventExecuteProgressSkillTriggered `json:"skill_triggered,omitempty"`
}

// AiAgentEventExecuteProgressProgressState defines model for AiAgentEventExecuteProgress.ProgressState.
type AiAgentEventExecuteProgressProgressState string

// AiAgentEventExecuteProgressSkillExecuted The progress for the AI agent event execution indicating that the skill
// has been executed.
type AiAgentEventExecuteProgressSkillExecuted struct {
	// Args The arguments for the skill call.
	Args *map[string]interface{} `json:"args,omitempty"`

	// Metadata The metadata of the skill call. The fields depend on the skill that
	// was executed.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Output The output of the skill call.
	Output map[string]interface{} `json:"output"`

	// SkillName The name of the skill.
	SkillName string `json:"skill_name"`
}

// AiAgentEventExecuteProgressSkillTriggered The progress for the AI agent event execution indicating that the skill
// has been triggered.
type AiAgentEventExecuteProgressSkillTriggered struct {
	// Args The arguments for the skill call.
	Args map[string]interface{} `json:"args"`

	// SkillName The name of the skill.
	SkillName string `json:"skill_name"`

	// Thought The thought explaining why the skill was called.
	Thought     *string             `json:"thought,omitempty"`
	Workflow    *WorkflowSummary    `json:"workflow,omitempty"`
	WorkflowRun *WorkflowRunSummary `json:"workflow_run,omitempty"`
}

// AiAgentEventSuggestions A list of suggestions generated for the AI agent event.
type AiAgentEventSuggestions struct {
	// Suggestions The suggestions generated for the AI agent event.
	Suggestions []AiAgentSuggestion `json:"suggestions"`
}

// AiAgentMessageGenerationStarted Additional metadata to indicate that the message generation has
// started.
type AiAgentMessageGenerationStarted struct {
	// RequestId The request ID contains an UUID to fetch the partial message
	// generation.
	RequestId string `json:"request_id"`
}

// AiAgentSuggestion A suggestion generated for the AI agent event.
type AiAgentSuggestion struct {
	// Suggestion The text of the suggestion.
	Suggestion string `json:"suggestion"`
}

// ArchetypeMetricTarget Metric with corresponding target values.
type ArchetypeMetricTarget struct {
	// BreachedAt For breached metrics the time they entered into breach. This is the
	// same as what the target date was, unless the breach happened due to
	// a different policy starting to apply.
	BreachedAt *time.Time `json:"breached_at,omitempty"`

	// CompletedAt The time at which the metric completed at.
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CompletedIn For completed metrics the time (in minutes) it took to complete
	// them. (Taking into account the schedule if any).
	CompletedIn *int32 `json:"completed_in,omitempty"`

	// InPolicy If true, the metric is part of the applied policy.
	InPolicy *bool `json:"in_policy,omitempty"`

	// IsOutOfSchedule If true, the schedule attached to this metric is out of schedule at
	// the time of the query. It is not set for metrics in *completed*
	// stage.
	IsOutOfSchedule  *bool                   `json:"is_out_of_schedule,omitempty"`
	MetricDefinition MetricDefinitionSummary `json:"metric_definition"`

	// NextScheduleTransition The next time the schedule will change its state, if such is known.
	NextScheduleTransition *time.Time          `json:"next_schedule_transition,omitempty"`
	OrgSchedule            *OrgScheduleSummary `json:"org_schedule,omitempty"`

	// RemainingTime Time in minutes that remains on a paused metric.
	RemainingTime *int32 `json:"remaining_time,omitempty"`

	// Stage Metric stage corresponding to the applicable SLA.
	Stage string `json:"stage"`

	// Status It is an indicator of whether the metric has ever been breached
	// (missed). If not, it shows whether the metric is completed, in
	// progress, or not part of the applied policy.
	Status *string `json:"status,omitempty"`

	// TargetTime Time at which the metric would breach SLA if no action taken.
	TargetTime *time.Time `json:"target_time,omitempty"`

	// WarningTargetTime Time at which the metric would reach the SLA warning limit if no
	// action taken.
	WarningTargetTime *time.Time `json:"warning_target_time,omitempty"`
}

// ArchetypeSlaSummary SLA summary for the object.
type ArchetypeSlaSummary struct {
	// ClosestToBreachMetric The name of the metric which is closest to breach.
	ClosestToBreachMetric *string             `json:"closest_to_breach_metric,omitempty"`
	OrgSchedule           *OrgScheduleSummary `json:"org_schedule,omitempty"`

	// RemainingTime The remaining time (in minutes) for the closest_to_breach_metric if
	// it is paused. A paused metric will only be closest to breach if no
	// metrics are running (running, warning and breached stage).
	RemainingTime *int32      `json:"remaining_time,omitempty"`
	SlaTracker    *SlaTracker `json:"sla_tracker,omitempty"`

	// Stage The stage of the SLA. This is the metric stage which is closest to
	// breach.
	Stage *SlaSummaryStage `json:"stage,omitempty"`

	// TargetTime The target time to avoid SLA breach. This is the target time of the
	// metric which is closest to breach.
	TargetTime *time.Time `json:"target_time,omitempty"`
}

// Article defines model for article.
type Article struct {
	// AppliesToParts Parts relevant to the article.
	AppliesToParts *[]PartSummary `json:"applies_to_parts,omitempty"`

	// ArticleType Type of the article.
	ArticleType *ArticleType `json:"article_type,omitempty"`

	// AuthoredBy Users that authored the article.
	AuthoredBy *[]UserSummary `json:"authored_by,omitempty"`
	CreatedBy  *UserSummary   `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the article.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ExtractedContent Extracted content of the article.
	ExtractedContent *[]ArtifactSummary `json:"extracted_content,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// NumDownvotes Number of downvotes on the article.
	NumDownvotes *int32 `json:"num_downvotes,omitempty"`

	// NumUpvotes Number of upvotes on the article.
	NumUpvotes *int32 `json:"num_upvotes,omitempty"`

	// OwnedBy Users that own the article.
	OwnedBy []UserSummary     `json:"owned_by"`
	Parent  *DirectorySummary `json:"parent,omitempty"`

	// Rank Rank of the article.
	Rank *string `json:"rank,omitempty"`

	// Resource Resource details.
	Resource *Resource `json:"resource,omitempty"`

	// Scope The properties of an enum value.
	Scope *EnumValue `json:"scope,omitempty"`

	// Title Title of the article.
	Title *string `json:"title,omitempty"`
}

// ArticleContentFormat Content format of the article.
type ArticleContentFormat string

// ArticleDataSourceCreate defines model for article-data-source-create.
type ArticleDataSourceCreate struct {
	// IsCustomLeafType Indicates if the leaf type is custom.
	IsCustomLeafType bool `json:"is_custom_leaf_type"`

	// IsDefault Indicates if the data source is default.
	IsDefault bool `json:"is_default"`

	// LeafType The object's type.
	LeafType string `json:"leaf_type"`

	// Object The ID of the object powering article.
	Object string `json:"object"`

	// ReferenceId The reference ID of the data source.
	ReferenceId string `json:"reference_id"`
}

// ArticleStatus Status of the article.
type ArticleStatus string

// ArticleType Type of the article.
type ArticleType string

// ArticlesCreateRequest The request to create an article.
type ArticlesCreateRequest struct {
	AccessLevel *AccessLevel `json:"access_level,omitempty"`

	// Aliases The aliases of the article.
	Aliases *[]string `json:"aliases,omitempty"`

	// AppliesToParts The parts that the article applies to.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// ArticleType Type of the article.
	ArticleType *ArticleType `json:"article_type,omitempty"`

	// AuthoredBy The authors of the article.
	AuthoredBy *[]string `json:"authored_by,omitempty"`

	// Brand The brand associated with the article.
	Brand *string `json:"brand,omitempty"`

	// ContentFormat Content format of the article.
	ContentFormat *ArticleContentFormat `json:"content_format,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// DataSources Data sources provide the backing data for the article.
	DataSources *[]ArticleDataSourceCreate `json:"data_sources,omitempty"`

	// Description Description for the article.
	Description *string `json:"description,omitempty"`

	// ExtractedContent ID of the extracted content artifact.
	ExtractedContent *[]string `json:"extracted_content,omitempty"`

	// Language Language of the article.
	Language *string `json:"language,omitempty"`

	// Notify Whether to notify the users when the article is published.
	Notify *bool `json:"notify,omitempty"`

	// OwnedBy The users that own the article.
	OwnedBy []string `json:"owned_by"`

	// Parent The parent directory of the article.
	Parent *string `json:"parent,omitempty"`

	// PublishedAt The published date of the article.
	PublishedAt *time.Time `json:"published_at,omitempty"`

	// ReleaseNotes The release notes of the article.
	ReleaseNotes *string                       `json:"release_notes,omitempty"`
	Resource     ArticlesCreateRequestResource `json:"resource"`

	// Scope The scope of the article.
	Scope *int64 `json:"scope,omitempty"`

	// SharedWith Information about the role the member receives due to the share.
	SharedWith *[]SetSharedWithMembership `json:"shared_with,omitempty"`

	// Status Status of the article.
	Status *ArticleStatus `json:"status,omitempty"`

	// Tags Tags associated with the article.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Title Name of the article.
	Title string `json:"title"`
}

// ArticlesCreateRequestResource defines model for articles-create-request-resource.
type ArticlesCreateRequestResource struct {
	// Artifacts IDs of the artifacts.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// ContentBlocks List of content blocks used in the article.
	ContentBlocks *[]string `json:"content_blocks,omitempty"`

	// PublishedVersion The latest published version.
	PublishedVersion *string `json:"published_version,omitempty"`

	// Url URL of the external article.
	Url *string `json:"url,omitempty"`
}

// ArticlesCreateResponseBody Create article response.
type ArticlesCreateResponseBody struct {
	Article Article `json:"article"`
}

// ArticlesDeleteRequest The request to delete an article.
type ArticlesDeleteRequest struct {
	// Id The ID of the article to delete.
	Id string `json:"id"`
}

// ArticlesDeleteResponseBody defines model for articles-delete-response.
type ArticlesDeleteResponseBody = map[string]interface{}

// ArticlesGetRequest The request to get an article.
type ArticlesGetRequest struct {
	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `json:"dev_org,omitempty"`

	// Id The ID of the required article.
	Id string `json:"id"`
}

// ArticlesGetResponseBody Get article response.
type ArticlesGetResponseBody struct {
	Article Article `json:"article"`
}

// ArticlesListRequest The request to list articles.
type ArticlesListRequest struct {
	// AppliesToParts Filters for articles belonging to any of the provided parts.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// ArticleType Filter for the type of articles. If this is not provided, then
	// articles that are not content blocks are returned.
	ArticleType *[]ArticleType `json:"article_type,omitempty"`

	// AuthoredBy Filters for articles authored by any of the provided users.
	AuthoredBy *[]string `json:"authored_by,omitempty"`

	// Brands Filters for articles belonging to any of the provided brands.
	Brands *[]string `json:"brands,omitempty"`

	// CreatedBy Filters for articles created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `json:"dev_org,omitempty"`

	// Limit The maximum number of articles to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedBy Filters for articles modified by any of the provided users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`

	// OwnedBy Filters for articles owned by any of the provided users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// Scope Filter for the scope of the articles.
	Scope *[]int64 `json:"scope,omitempty"`

	// SharedWith Filter for articles based on intended audience.
	SharedWith *[]SharedWithMembershipFilter `json:"shared_with,omitempty"`

	// Tags Filters for article with any of the provided tags.
	Tags *[]string `json:"tags,omitempty"`
}

// ArticlesListResponseBody List articles response.
type ArticlesListResponseBody struct {
	// Articles The article entries matching the request.
	Articles []Article `json:"articles"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Total Total number of article items for the request.
	Total int32 `json:"total"`
}

// ArticlesUpdateRequest The request to update an article.
type ArticlesUpdateRequest struct {
	AccessLevel    *AccessLevel                         `json:"access_level,omitempty"`
	Aliases        *ArticlesUpdateRequestAliases        `json:"aliases,omitempty"`
	AppliesToParts *ArticlesUpdateRequestAppliesToParts `json:"applies_to_parts,omitempty"`
	Artifacts      *ArticlesUpdateRequestArtifacts      `json:"artifacts,omitempty"`
	AuthoredBy     *ArticlesUpdateRequestAuthoredBy     `json:"authored_by,omitempty"`

	// Brand The updated brand of the article.
	Brand         *string                             `json:"brand"`
	ContentBlocks *ArticlesUpdateRequestContentBlocks `json:"content_blocks,omitempty"`

	// ContentFormat Content format of the article.
	ContentFormat *ArticleContentFormat `json:"content_format,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec                             `json:"custom_schema_spec,omitempty"`
	DataSources      *ArticlesUpdateRequestArticleDataSourceUpdate `json:"data_sources,omitempty"`

	// Description Updated description of the article object, or unchanged if not
	// provided.
	Description      *string                                `json:"description,omitempty"`
	ExtractedContent *ArticlesUpdateRequestExtractedContent `json:"extracted_content,omitempty"`

	// Id The article's ID.
	Id string `json:"id"`

	// Language Updates the language of the article.
	Language *string `json:"language,omitempty"`

	// Notify Whether to notify the users when the article is published.
	Notify  *bool                         `json:"notify,omitempty"`
	OwnedBy *ArticlesUpdateRequestOwnedBy `json:"owned_by,omitempty"`

	// Parent The updated parent directory for the article.
	Parent *string `json:"parent"`

	// PublishedVersion Updates the the latest published version.
	PublishedVersion *string `json:"published_version,omitempty"`

	// ReleaseNotes Updates the release notes of the article.
	ReleaseNotes *string                          `json:"release_notes,omitempty"`
	Reorder      *ArticlesUpdateRequestReorder    `json:"reorder,omitempty"`
	SharedWith   *ArticlesUpdateRequestSharedWith `json:"shared_with,omitempty"`

	// Status Status of the article.
	Status *ArticleStatus             `json:"status,omitempty"`
	Tags   *ArticlesUpdateRequestTags `json:"tags,omitempty"`

	// Title Updated title of the article object, or unchanged if not provided.
	Title *string `json:"title,omitempty"`

	// Url Updates the URL of the external article.
	Url *string `json:"url,omitempty"`
}

// ArticlesUpdateRequestAliases defines model for articles-update-request-aliases.
type ArticlesUpdateRequestAliases struct {
	// Set Updates the aliases of the article.
	Set []string `json:"set"`
}

// ArticlesUpdateRequestAppliesToParts defines model for articles-update-request-applies-to-parts.
type ArticlesUpdateRequestAppliesToParts struct {
	// Set Updates the parts that the article applies to.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestArticleDataSourceUpdate defines model for articles-update-request-article-data-source-update.
type ArticlesUpdateRequestArticleDataSourceUpdate struct {
	// Set Updates data sources provide the backing data for the article.
	Set *[]ArticleDataSourceCreate `json:"set,omitempty"`
}

// ArticlesUpdateRequestArtifacts defines model for articles-update-request-artifacts.
type ArticlesUpdateRequestArtifacts struct {
	// Set Updates IDs of the artifacts.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestAuthoredBy defines model for articles-update-request-authored-by.
type ArticlesUpdateRequestAuthoredBy struct {
	// Set Sets the users that authored the article.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestContentBlocks defines model for articles-update-request-content-blocks.
type ArticlesUpdateRequestContentBlocks struct {
	// Set Updates IDs of the content blocks.
	Set []string `json:"set"`
}

// ArticlesUpdateRequestExtractedContent defines model for articles-update-request-extracted-content.
type ArticlesUpdateRequestExtractedContent struct {
	// Set Update the ID of the extracted content.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestOwnedBy defines model for articles-update-request-owned-by.
type ArticlesUpdateRequestOwnedBy struct {
	// Set Sets the owner IDs to the provided user IDs. This must not be
	// empty.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestReorder defines model for articles-update-request-reorder.
type ArticlesUpdateRequestReorder struct {
	// After The article after which the reordered article is placed.
	After *string `json:"after,omitempty"`

	// Before The article before which the reordered article is placed.
	Before *string `json:"before,omitempty"`
}

// ArticlesUpdateRequestSharedWith defines model for articles-update-request-shared-with.
type ArticlesUpdateRequestSharedWith struct {
	// Set Sets the field to the provided membership list.
	Set *[]SetSharedWithMembership `json:"set,omitempty"`
}

// ArticlesUpdateRequestTags defines model for articles-update-request-tags.
type ArticlesUpdateRequestTags struct {
	// Set Sets the provided tags on the article.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// ArticlesUpdateResponseBody defines model for articles-update-response.
type ArticlesUpdateResponseBody struct {
	Article Article `json:"article"`
}

// Artifact defines model for artifact.
type Artifact struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// File Defines a file object.
	File *ArtifactFile `json:"file,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// ArtifactConfigurationSet Represents a set of configuration to be used with the artifacts object.
type ArtifactConfigurationSet string

// ArtifactFile Defines a file object.
type ArtifactFile struct {
	// Name Name of the file.
	Name *string `json:"name,omitempty"`

	// Size Size of the file in bytes.
	Size *int32 `json:"size,omitempty"`

	// Type Type of the file.
	Type *string `json:"type,omitempty"`
}

// ArtifactFileSummary Defines a file object.
type ArtifactFileSummary struct {
	// Name Name of the file.
	Name *string `json:"name,omitempty"`

	// Size Size of the file in bytes.
	Size *int32 `json:"size,omitempty"`

	// Type Type of the file.
	Type *string `json:"type,omitempty"`
}

// ArtifactSummary defines model for artifact-summary.
type ArtifactSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// File Defines a file object.
	File *ArtifactFileSummary `json:"file,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`
}

// ArtifactVersion The version of the artifact.
type ArtifactVersion struct {
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// Timestamp The timestamp at which the version was created.
	Timestamp time.Time `json:"timestamp"`

	// Version The version of the artifact.
	Version string `json:"version"`
}

// ArtifactsGetRequest The request to get an artifact's information.
type ArtifactsGetRequest struct {
	// Id The requested artifact's ID.
	Id string `json:"id"`

	// Version The version of the artifact that needs to be fetched.
	Version *string `json:"version,omitempty"`
}

// ArtifactsGetResponseBody The response to getting an artifact's information.
type ArtifactsGetResponseBody struct {
	Artifact Artifact `json:"artifact"`

	// Version The version of the artifact.
	Version ArtifactVersion `json:"version"`
}

// ArtifactsHardDeleteVersionRequest The request to permnanently delete an artifact's version.
type ArtifactsHardDeleteVersionRequest struct {
	// Id The ID of the artifact to delete the version for.
	Id string `json:"id"`

	// Version The version of the artifact that needs to be deleted.
	Version *string `json:"version,omitempty"`
}

// ArtifactsHardDeleteVersionResponseBody defines model for artifacts-hard-delete-version-response.
type ArtifactsHardDeleteVersionResponseBody = map[string]interface{}

// ArtifactsListRequest The request to list artifacts attached to an object.
type ArtifactsListRequest struct {
	// ParentId The ID of the object to filter artifacts.
	ParentId *string `json:"parent_id,omitempty"`
}

// ArtifactsListResponseBody The response to list artifacts attached to an object.
type ArtifactsListResponseBody struct {
	// Artifacts The artifact's information.
	Artifacts []Artifact `json:"artifacts"`
}

// ArtifactsLocateRequest The request to get an artifact's download URL.
type ArtifactsLocateRequest struct {
	// Id The ID of the artifact to get the URL for.
	Id string `json:"id"`

	// Version The version of the artifact that needs to be fetched.
	Version *string `json:"version,omitempty"`
}

// ArtifactsLocateResponseBody The response to getting an artifact's download URL.
type ArtifactsLocateResponseBody struct {
	// ExpiresAt The expiration timestamp of the URL.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Url The artifact's download URL.
	Url string `json:"url"`
}

// ArtifactsPrepareRequest The request to prepare a URL to upload a file.
type ArtifactsPrepareRequest struct {
	// ConfigurationSet Represents a set of configuration to be used with the artifacts object.
	ConfigurationSet *ArtifactConfigurationSet `json:"configuration_set,omitempty"`

	// FileName The name of the file that's being uploaded.
	FileName string `json:"file_name"`

	// FileType The type of file that's being uploaded.
	FileType *string `json:"file_type,omitempty"`
}

// ArtifactsPrepareResponseBody The response to preparing a URL to upload a file.
type ArtifactsPrepareResponseBody struct {
	// FormData The POST policy form data.
	FormData []ArtifactsPrepareResponseFormData `json:"form_data"`

	// Id The generated artifact's ID.
	Id string `json:"id"`

	// Url The URL that the file's data should be uploaded to.
	Url string `json:"url"`
}

// ArtifactsPrepareResponseFormData defines model for artifacts-prepare-response-form-data.
type ArtifactsPrepareResponseFormData struct {
	// Key Key of the form field.
	Key string `json:"key"`

	// Value Value corresponding to the key.
	Value string `json:"value"`
}

// ArtifactsVersionsPrepareRequest The request to prepare a new version of an artifact.
type ArtifactsVersionsPrepareRequest struct {
	// Id The ID of the artifact to prepare a new version for.
	Id string `json:"id"`
}

// ArtifactsVersionsPrepareResponseBody The response to preparing a new artifact version.
type ArtifactsVersionsPrepareResponseBody struct {
	// FormData The POST policy form data.
	FormData []ArtifactsVersionsPrepareResponseFormData `json:"form_data"`

	// Url The URL that the file's data should be uploaded to.
	Url string `json:"url"`
}

// ArtifactsVersionsPrepareResponseFormData defines model for artifacts-versions-prepare-response-form-data.
type ArtifactsVersionsPrepareResponseFormData struct {
	// Key Key of the form field.
	Key string `json:"key"`

	// Value Value corresponding to the key.
	Value string `json:"value"`
}

// Atom defines model for atom.
type Atom struct {
	Type  AtomType `json:"type"`
	union json.RawMessage
}

// AtomBase defines model for atom-base.
type AtomBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// AtomBaseSummary defines model for atom-base-summary.
type AtomBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`
}

// AtomSummary defines model for atom-summary.
type AtomSummary struct {
	Type  AtomType `json:"type"`
	union json.RawMessage
}

// AtomType defines model for atom-type.
type AtomType string

// AtomsGetRequest defines model for atoms-get-request.
type AtomsGetRequest struct {
	// Id The ID of the object to get.
	Id string `json:"id"`
}

// AtomsGetResponseBody defines model for atoms-get-response.
type AtomsGetResponseBody struct {
	Atom Atom `json:"atom"`
}

// AuthConnection Connection object that specifies the configuration for an
// authentication connection that is set up for a Dev organization.
type AuthConnection struct {
	// DisplayName Display name of the authentication connection. This name will be
	// visible to all the users when they sign in to this Dev
	// organization. For example, if the display_name is 'abclogin', then
	// it would appear on the login button as 'Log in to abclogin'.
	DisplayName string `json:"display_name"`

	// Enabled Whether the authentication connection is enabled or disabled. If
	// set to false, the authentication connection will not show up on the
	// login screen as a login option.
	Enabled bool `json:"enabled"`

	// Id ID of the authentication connection.
	Id string `json:"id"`

	// Type Defines the type for the authentication connection. The configuration
	// for each authentication connection will depend on the type value.
	Type  AuthConnectionType `json:"type"`
	union json.RawMessage
}

// AuthConnectionOptionsAzureAd Object encapsulating the configuration parameters for an Azure AD
// authentication connection.
type AuthConnectionOptionsAzureAd struct {
	// ClientId Client ID for the Azure authentication connection.
	ClientId string `json:"client_id"`

	// Domain Domain URL of the Azure authentication connection.
	Domain string `json:"domain"`
}

// AuthConnectionOptionsGoogleApps Object encapsulating the configuration parameters for a Google Apps
// authentication connection.
type AuthConnectionOptionsGoogleApps struct {
	// ClientId Client ID for the Google Apps authentication connection.
	ClientId string `json:"client_id"`

	// TenantDomain Tenant domain URL of the Google Apps authentication connection.
	TenantDomain string `json:"tenant_domain"`
}

// AuthConnectionOptionsOidc Object encapsulating the configuration parameters for an OIDC
// authentication connection.
type AuthConnectionOptionsOidc struct {
	// ClientId Client ID for the OIDC authentication connection.
	ClientId string `json:"client_id"`

	// Issuer Issuer URL of the OIDC authentication connection.
	Issuer string `json:"issuer"`
}

// AuthConnectionOptionsOkta Object encapsulating the configuration parameters for an Okta
// authentication connection.
type AuthConnectionOptionsOkta struct {
	// ClientId Client ID for the Okta authentication connection.
	ClientId string `json:"client_id"`

	// Domain Domain URL of the Okta authentication connection.
	Domain string `json:"domain"`
}

// AuthConnectionOptionsSaml Object encapsulating the configuration parameters for a SAML
// authentication connection.
type AuthConnectionOptionsSaml struct {
	// ConnectionName Connection name for the SAML authentication connection. Must match
	// the `connection` query parameter specified in the sign on URL
	// during SAML configuration in your identity provider.
	ConnectionName *string                 `json:"connection_name,omitempty"`
	FieldsMap      SamlConnectionFieldsMap `json:"fields_map"`

	// SignInEndpoint Sign In endpoint for the SAML authentication connection.
	SignInEndpoint string `json:"sign_in_endpoint"`
}

// AuthConnectionOptionsSocial defines model for auth-connection-options-social.
type AuthConnectionOptionsSocial = map[string]interface{}

// AuthConnectionToggle defines model for auth-connection-toggle.
type AuthConnectionToggle string

// AuthConnectionType Defines the type for the authentication connection. The configuration
// for each authentication connection will depend on the type value.
type AuthConnectionType string

// AuthToken defines model for auth-token.
type AuthToken struct {
	// ClientId An identifier that represents the application that requested the
	// token. Only applicable for application access tokens.
	ClientId  *string      `json:"client_id,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ExpiresAt The time at which the token expires.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IssuedAt The time at which the token was issued.
	IssuedAt   *time.Time   `json:"issued_at,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// RequestedTokenType The type of the requested token.
	RequestedTokenType *AuthTokenRequestedTokenType `json:"requested_token_type,omitempty"`

	// Scopes The scopes associated with the issued token.
	Scopes *[]string `json:"scopes,omitempty"`

	// Status The status of the token.
	Status *AuthTokenStatus `json:"status,omitempty"`

	// Subject The subject of the token.
	Subject *string `json:"subject,omitempty"`

	// TokenHint A hint that identifies the token.
	TokenHint *string `json:"token_hint,omitempty"`
}

// AuthTokenGrantType Specifies the process of obtaining a token.
type AuthTokenGrantType string

// AuthTokenRequestedTokenType The type of the requested token.
type AuthTokenRequestedTokenType string

// AuthTokenStatus The status of the token.
type AuthTokenStatus string

// AuthTokenSubjectTokenType The type of the subject token.
type AuthTokenSubjectTokenType string

// AuthTokenSummary defines model for auth-token-summary.
type AuthTokenSummary = AtomBaseSummary

// AuthTokenTokenType The type of the issued token. Bearer is the only supported token type.
type AuthTokenTokenType string

// AuthTokensAccountTraits Carries account info.
type AuthTokensAccountTraits struct {
	// DisplayName The display name of the account.
	DisplayName *string `json:"display_name,omitempty"`

	// Domains List of company's domain names on accounts. Example -
	// ['devrev.ai'].
	Domains *[]string `json:"domains,omitempty"`
}

// AuthTokensCreateRequest A request to create a new token corresponding to the requested token
// type.
type AuthTokensCreateRequest struct {
	// ActAs The unique ID of the Dev user or the service account to
	// impersonate.
	ActAs *string `json:"act_as,omitempty"`

	// Aud The expected audience values with respect to the token.
	Aud *[]string `json:"aud,omitempty"`

	// ClientId An identifier that represents the application which is requesting
	// the token. If no client_id is present in the request to generate an
	// application access token (AAT), DevRev will generate a client_id.
	// This client_id is only associated with an AAT.
	ClientId *string `json:"client_id,omitempty"`

	// ExpiresIn The expected validity lifetime of the token in number of days. In
	// practice, the value should be based on the usage of the token.
	ExpiresIn *int `json:"expires_in,omitempty"`

	// GrantType Specifies the process of obtaining a token.
	GrantType *AuthTokenGrantType `json:"grant_type,omitempty"`

	// RequestedTokenType The type of the requested token.
	RequestedTokenType *AuthTokenRequestedTokenType `json:"requested_token_type,omitempty"`

	// RevInfo Carries info corresponding to the Rev user to be provisioned and/or
	// issue a Rev session token.
	RevInfo *AuthTokensRevInfo `json:"rev_info,omitempty"`

	// Scope The requested set of scopes associated with the issued token. A
	// space-delimited list of values in which the order of values does
	// not matter.
	Scope *string `json:"scope,omitempty"`

	// SubjectToken Represents the entity that requests the token. Not required when
	// requesting an application access token (AAT).
	SubjectToken *string `json:"subject_token,omitempty"`

	// SubjectTokenType The type of the subject token.
	SubjectTokenType *AuthTokenSubjectTokenType `json:"subject_token_type,omitempty"`

	// TokenHint A hint that identifies the token.
	TokenHint *string `json:"token_hint,omitempty"`
}

// AuthTokensCreateResponseBody Response for the request to create a new token corresponding to the
// requested token type.
type AuthTokensCreateResponseBody struct {
	// AccessToken The issued JSON Web Token (JWT) corresponding to the requested
	// token type.
	AccessToken string `json:"access_token"`

	// ClientId An identifier that represents the application which is requesting
	// the token. Only present in a response corresponding to an
	// application access token (AAT).
	ClientId *string `json:"client_id,omitempty"`

	// ExpiresIn The validity lifetime of the token specified in seconds since Unix
	// epoch.
	ExpiresIn int64 `json:"expires_in"`

	// RefreshToken A token to refresh the issued token.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope The scopes associated with the issued token. A space-delimited list
	// of values in which the order of values does not matter.
	Scope *string `json:"scope,omitempty"`

	// TokenType The type of the issued token. Bearer is the only supported token type.
	TokenType AuthTokenTokenType `json:"token_type"`
}

// AuthTokensDeleteRequest The request to revoke the token.
type AuthTokensDeleteRequest struct {
	// TokenId The unique identifier for the token under a given Dev organization.
	// If no token ID is provided, then the token ID will be set from the
	// JTI claim of the token in the authorization header.
	TokenId *string `json:"token_id,omitempty"`
}

// AuthTokensGetRequest The request to get the token metadata.
type AuthTokensGetRequest struct {
	// TokenId The unique identifier of the token under a given Dev organization.
	TokenId string `json:"token_id"`
}

// AuthTokensGetResponseBody The response to get the token metadata.
type AuthTokensGetResponseBody struct {
	Token AuthToken `json:"token"`
}

// AuthTokensInfoRequest The request to get the Dev organization, user and token attributes
// extracted from the auth token.
type AuthTokensInfoRequest = map[string]interface{}

// AuthTokensInfoResponseBody The Dev organization, user and token attributes extracted from the auth
// token.
type AuthTokensInfoResponseBody struct {
	// Organization The Dev organization attributes extracted from the auth token.
	Organization AuthTokensOrgAttributes `json:"organization"`

	// Token The token attributes extracted from the auth token.
	Token AuthTokensTokenAttributes `json:"token"`

	// User The user attributes extracted from the auth token.
	User AuthTokensUserAttributes `json:"user"`
}

// AuthTokensListRequest A request to list the token metadata.
type AuthTokensListRequest struct {
	// ClientId An identifier that represents the application, which requested the
	// token. Only relevant for application access tokens.
	ClientId *string `json:"client_id,omitempty"`

	// RequestedTokenType The type of the requested token.
	RequestedTokenType *AuthTokenRequestedTokenType `json:"requested_token_type,omitempty"`

	// Subject The subject associated with the token. In the absence of this
	// parameter, the ID of the authenticated entity is treated as the
	// subject.
	Subject *string `json:"subject,omitempty"`
}

// AuthTokensListResponseBody The response to list the token metadata.
type AuthTokensListResponseBody struct {
	// Tokens The list of token metadata.
	Tokens []AuthToken `json:"tokens"`
}

// AuthTokensOrgAttributes The Dev organization attributes extracted from the auth token.
type AuthTokensOrgAttributes struct {
	// DisplayId The display ID of the Dev organization.
	DisplayId string `json:"display_id"`

	// Id The ID of the the Dev organization.
	Id string `json:"id"`

	// Slug The slug of the Dev organization.
	Slug *string `json:"slug,omitempty"`
}

// AuthTokensOrgTraits Carries Rev org info.
type AuthTokensOrgTraits struct {
	// CustomFields Application-defined custom fields of the Rev org.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Description The description of the Rev org.
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the Rev org.
	DisplayName *string `json:"display_name,omitempty"`

	// Domain The domain of the Rev org.
	// Deprecated:
	Domain *string `json:"domain,omitempty"`

	// PhoneNumbers Phone numbers of the Rev org.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`

	// Tier The tier of the Rev org.
	Tier *string `json:"tier,omitempty"`
}

// AuthTokensRevInfo Carries info corresponding to the Rev user to be provisioned and/or
// issue a Rev session token.
type AuthTokensRevInfo struct {
	// AccountRef An identifier which uniquely identifies an account.
	AccountRef *string `json:"account_ref,omitempty"`

	// AccountTraits Carries account info.
	AccountTraits *AuthTokensAccountTraits `json:"account_traits,omitempty"`

	// OrgRef An identifier which uniquely identifies a Rev org.
	// Deprecated:
	OrgRef *string `json:"org_ref,omitempty"`

	// OrgTraits Carries Rev org info.
	OrgTraits *AuthTokensOrgTraits `json:"org_traits,omitempty"`

	// UserId The unique ID of the Rev user.
	UserId *string `json:"user_id,omitempty"`

	// UserRef An identifier which uniquely identifies a Rev user.
	UserRef *string `json:"user_ref,omitempty"`

	// UserTraits Carries Rev user info.
	UserTraits *AuthTokensUserTraits `json:"user_traits,omitempty"`

	// WorkspaceRef An identifier which uniquely identifies a workspace.
	WorkspaceRef *string `json:"workspace_ref,omitempty"`

	// WorkspaceTraits Carries Rev org info.
	WorkspaceTraits *AuthTokensOrgTraits `json:"workspace_traits,omitempty"`
}

// AuthTokensSelfDeleteRequest The request to delete all the tokens created by the authenticated user,
// that match with the provided token type.
type AuthTokensSelfDeleteRequest struct {
	// RequestedTokenType The type of the requested token.
	RequestedTokenType *AuthTokenRequestedTokenType `json:"requested_token_type,omitempty"`
}

// AuthTokensTokenAttributes The token attributes extracted from the auth token.
type AuthTokensTokenAttributes struct {
	// Expiry The expiry (exp) of the token in seconds from Unix epoch.
	Expiry int64 `json:"expiry"`

	// IssuedAt The issued at (iat) time of the token in seconds from Unix epoch.
	IssuedAt int64 `json:"issued_at"`

	// Issuer The issuer ID (iss) of the token.
	Issuer string `json:"issuer"`

	// Subject The subject (sub) of the token.
	Subject string `json:"subject"`
}

// AuthTokensUpdateRequest A request to update the token metadata.
type AuthTokensUpdateRequest struct {
	// TokenHint A hint that identifies the token.
	TokenHint string `json:"token_hint"`

	// TokenId The unique identifier of the token under a given Dev organization.
	TokenId string `json:"token_id"`
}

// AuthTokensUpdateResponseBody Response for the request to update the token metadata.
type AuthTokensUpdateResponseBody struct {
	Token AuthToken `json:"token"`
}

// AuthTokensUserAttributes The user attributes extracted from the auth token.
type AuthTokensUserAttributes struct {
	// DisplayId The display ID of the user.
	DisplayId string `json:"display_id"`

	// DisplayName The display name of the user.
	DisplayName *string `json:"display_name,omitempty"`

	// Email The email address of the user.
	Email *string `json:"email,omitempty"`

	// FullName The full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id The ID of the user.
	Id   string   `json:"id"`
	Type UserType `json:"type"`
}

// AuthTokensUserTraits Carries Rev user info.
type AuthTokensUserTraits struct {
	// CustomFields Application-defined custom fields of the Rev user.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Description The description of the Rev user.
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the Rev user.
	DisplayName *string `json:"display_name,omitempty"`

	// Email The email address of the Rev user.
	Email *string `json:"email,omitempty"`

	// FullName The full name of the Rev user.
	// Deprecated:
	FullName *string `json:"full_name,omitempty"`

	// PhoneNumbers Phone numbers of the Rev user.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`
}

// BooleanExpression Boolean expression.
type BooleanExpression struct {
	Type  BooleanExpressionType `json:"type"`
	union json.RawMessage
}

// BooleanExpressionAndExpression All the expressions would be 'and'ed together.
type BooleanExpressionAndExpression struct {
	Expressions []BooleanExpression `json:"expressions"`
}

// BooleanExpressionNotExpression The expression would be negated.
type BooleanExpressionNotExpression struct {
	// Expression Boolean expression.
	Expression BooleanExpression `json:"expression"`
}

// BooleanExpressionOrExpression All the expressions would be 'or'ed together.
type BooleanExpressionOrExpression struct {
	Expressions []BooleanExpression `json:"expressions"`
}

// BooleanExpressionPrimitiveExpression The primitive expression type.
type BooleanExpressionPrimitiveExpression = map[string]interface{}

// BooleanExpressionType defines model for boolean-expression-type.
type BooleanExpressionType string

// Capability defines model for capability.
type Capability = PartBase

// CapabilitySummary defines model for capability-summary.
type CapabilitySummary = PartBaseSummary

// Chat defines model for chat.
type Chat struct {
	Type ChatType `json:"type"`
}

// ChatType defines model for chat-type.
type ChatType = string

// ChatsCreateRequest defines model for chats-create-request.
type ChatsCreateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// GetIfConflict If true and a chat already exists with unique properties that
	// conflict with the chat creation, then the existing chat is returned
	// without error, otherwise if false, a conflict error is returned.
	GetIfConflict *bool `json:"get_if_conflict,omitempty"`

	// Title The title for the chat.
	Title *string  `json:"title,omitempty"`
	Type  ChatType `json:"type"`
	union json.RawMessage
}

// ChatsCreateRequestDm defines model for chats-create-request-dm.
type ChatsCreateRequestDm struct {
	// IsDefault Whether this is the default DM for messaging the constituent users.
	// If true, then this DM is always returned when opening a DM for the
	// users. Note only one DM may be the default for a given set of
	// users. By Default, this is true.
	IsDefault *bool `json:"is_default,omitempty"`

	// Records The associated records for this DM.
	Records *[]string `json:"records,omitempty"`

	// Users The users to send direct messages to. The authenticated user must
	// be included in this list.
	Users []string `json:"users"`
}

// ChatsCreateResponseBody defines model for chats-create-response.
type ChatsCreateResponseBody struct {
	Chat Chat `json:"chat"`
}

// ChatsGetRequest defines model for chats-get-request.
type ChatsGetRequest struct {
	// Id The chat's ID.
	Id    *string   `json:"id,omitempty"`
	Type  *ChatType `json:"type,omitempty"`
	union json.RawMessage
}

// ChatsGetRequestDm defines model for chats-get-request-dm.
type ChatsGetRequestDm struct {
	// Users The users to send direct messages to. Note the authenticated user
	// must be included in this list.
	Users []string `json:"users"`
}

// ChatsGetResponseBody defines model for chats-get-response.
type ChatsGetResponseBody struct {
	Chat Chat `json:"chat"`
}

// ChatsUpdateRequest defines model for chats-update-request.
type ChatsUpdateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Id The chat's ID.
	Id string `json:"id"`

	// Title The updated title for the chat, or unchanged if not provided.
	Title *string   `json:"title,omitempty"`
	Type  *ChatType `json:"type,omitempty"`
	union json.RawMessage
}

// ChatsUpdateRequestDm defines model for chats-update-request-dm.
type ChatsUpdateRequestDm struct {
	Records *ChatsUpdateRequestDmRecords `json:"records,omitempty"`
	Users   *ChatsUpdateRequestDmUsers   `json:"users,omitempty"`
}

// ChatsUpdateRequestDmRecords defines model for chats-update-request-dm-records.
type ChatsUpdateRequestDmRecords struct {
	// Set The associated records to set for this DM.
	Set *[]string `json:"set,omitempty"`
}

// ChatsUpdateRequestDmUsers defines model for chats-update-request-dm-users.
type ChatsUpdateRequestDmUsers struct {
	// Set The updated list of users to send direct messages to. The
	// authenticated user must be included in this list.
	Set []string `json:"set"`
}

// ChatsUpdateResponseBody defines model for chats-update-response.
type ChatsUpdateResponseBody struct {
	Chat Chat `json:"chat"`
}

// CodeChange defines model for code-change.
type CodeChange struct {
	// Branch Name of the code branch in the repo.
	Branch *string `json:"branch,omitempty"`

	// ClosedDate Time at which the code change corresponding to this object reached
	// a closed or merged stage. For example, the time at which a Pull
	// Request was either closed without merging or successfully merged.
	ClosedDate *time.Time `json:"closed_date,omitempty"`

	// CommitId Commit ID of the merged commit in the target branch.
	CommitId  *string      `json:"commit_id,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Detailed description of the contents of this change.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ExternalIdentifier Unique external identifier for this change.e.g Pull Request URL.
	ExternalIdentifier *string `json:"external_identifier,omitempty"`

	// FilteredLoc Details of lines of code in this code change.
	FilteredLoc *LinesOfCode `json:"filtered_loc,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// RepoUrl URL pointing to the repo this change was on.
	RepoUrl *string `json:"repo_url,omitempty"`

	// Source Source of the code change object.
	Source *CodeChangeSource `json:"source,omitempty"`

	// TargetBranch Name of the target branch in the repo.
	TargetBranch *string `json:"target_branch,omitempty"`

	// Title Title describing in brief the contents of this change.
	Title *string `json:"title,omitempty"`

	// TotalLoc Details of lines of code in this code change.
	TotalLoc *LinesOfCode `json:"total_loc,omitempty"`
}

// CodeChangeSource Source of the code change object.
type CodeChangeSource string

// CodeChangesCreateRequest defines model for code-changes-create-request.
type CodeChangesCreateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`
}

// CodeChangesCreateResponseBody defines model for code-changes-create-response.
type CodeChangesCreateResponseBody struct {
	CodeChange CodeChange `json:"code_change"`
}

// CodeChangesDeleteRequest defines model for code-changes-delete-request.
type CodeChangesDeleteRequest struct {
	// Id ID of the code change object which is to be deleted.
	Id string `json:"id"`
}

// CodeChangesDeleteResponseBody defines model for code-changes-delete-response.
type CodeChangesDeleteResponseBody = map[string]interface{}

// CodeChangesGetRequest defines model for code-changes-get-request.
type CodeChangesGetRequest struct {
	// Id The code change object ID.
	Id string `json:"id"`
}

// CodeChangesGetResponseBody defines model for code-changes-get-response.
type CodeChangesGetResponseBody struct {
	CodeChange CodeChange `json:"code_change"`
}

// CodeChangesListRequest defines model for code-changes-list-request.
type CodeChangesListRequest struct {
	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of code change objects to return. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`
}

// CodeChangesListResponseBody defines model for code-changes-list-response.
type CodeChangesListResponseBody struct {
	// CodeChanges The list of requested code change objects.
	CodeChanges []CodeChange `json:"code_changes"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// CodeChangesUpdateRequest defines model for code-changes-update-request.
type CodeChangesUpdateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Id The ID of the code change object to be updated.
	Id string `json:"id"`
}

// CodeChangesUpdateResponseBody defines model for code-changes-update-response.
type CodeChangesUpdateResponseBody struct {
	CodeChange CodeChange `json:"code_change"`
}

// Command defines model for command.
type Command struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the command.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Display name of the command.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Name of the command.
	Name *string `json:"name,omitempty"`

	// Namespace Namespace of the command.
	Namespace *string `json:"namespace,omitempty"`

	// SharedWith The list of users, groups and audiences with whom the command is
	// shared.
	SharedWith *[]SharedWithMembership `json:"shared_with,omitempty"`

	// Status Status of the command.
	Status *CommandStatus `json:"status,omitempty"`

	// Surfaces Surfaces where this command can be invoked.
	Surfaces *[]CommandSurface `json:"surfaces,omitempty"`

	// UsageHint A user friendly description of the parameters which can be passed
	// to the command.
	UsageHint *string `json:"usage_hint,omitempty"`
}

// CommandActionExecutorType Specifies how the action is defined.
type CommandActionExecutorType string

// CommandActionTemplateType The template engine for resolving message.
type CommandActionTemplateType string

// CommandCreateRequest The request to create a command.
type CommandCreateRequest struct {
	Action *CreateCommandAction `json:"action,omitempty"`

	// Description Description of the command.
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the command.
	DisplayName *string `json:"display_name,omitempty"`

	// Name Name of the command.
	Name string `json:"name"`

	// Namespace Namespace of the command.
	Namespace string `json:"namespace"`

	// SharedWith The list of users, groups and audiences with whom the command is
	// shared.
	SharedWith *[]SetSharedWithMembership `json:"shared_with,omitempty"`

	// Source ID of the source which created this command.
	Source *string `json:"source,omitempty"`

	// Status Status of the command.
	Status *CommandStatus `json:"status,omitempty"`

	// Surfaces Surfaces where this command can be invoked.
	Surfaces *[]CreateCommandSurface `json:"surfaces,omitempty"`

	// UsageHint A user friendly description of the parameters which can be passed
	// to the command.
	UsageHint *string `json:"usage_hint,omitempty"`
}

// CommandCreateResponseBody defines model for command-create-response.
type CommandCreateResponseBody struct {
	Command Command `json:"command"`
}

// CommandGetRequest The request to get a command.
type CommandGetRequest struct {
	// Id The command's ID.
	Id string `json:"id"`
}

// CommandGetResponseBody defines model for command-get-response.
type CommandGetResponseBody struct {
	Command Command `json:"command"`
}

// CommandStatus Status of the command.
type CommandStatus string

// CommandSurface Metadata defining which surfaces this command can be executed on.
type CommandSurface struct {
	// ObjectTypes Objects types on which a command can be invoked.
	ObjectTypes *[]CommandSurfaceObjectTypes `json:"object_types,omitempty"`

	// Surface Surfaces from where this command can be invoked.
	Surface *CommandSurfaceSurface `json:"surface,omitempty"`
}

// CommandSurfaceObjectTypes Objects types on which a command can be invoked.
type CommandSurfaceObjectTypes string

// CommandSurfaceSurface Surfaces from where this command can be invoked.
type CommandSurfaceSurface string

// CommandUpdateRequest The request to update a command.
type CommandUpdateRequest struct {
	Action *UpdateCommandAction `json:"action,omitempty"`

	// Description Description of the command.
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the command.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The ID of the command to update.
	Id string `json:"id"`

	// Name Name of the command.
	Name *string `json:"name,omitempty"`

	// Namespace Namespace of the command.
	Namespace *string `json:"namespace,omitempty"`

	// SharedWith The list of users, groups and audiences with whom the command is
	// shared.
	SharedWith *[]SetSharedWithMembership `json:"shared_with,omitempty"`

	// Source ID of the source which created this command.
	Source *string `json:"source,omitempty"`

	// Status Status of the command.
	Status *CommandStatus `json:"status,omitempty"`

	// Surfaces Surfaces where this command can be invoked.
	Surfaces *[]UpdateCommandSurface `json:"surfaces,omitempty"`

	// UsageHint A user friendly description of the parameters which can be passed
	// to the command.
	UsageHint *string `json:"usage_hint,omitempty"`
}

// CommandUpdateResponseBody defines model for command-update-response.
type CommandUpdateResponseBody struct {
	Command Command `json:"command"`
}

// CommandsListRequest defines model for commands-list-request.
type CommandsListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// ExecutorType Filtering based on executor_type.
	ExecutorType *[]CommandActionExecutorType `json:"executor_type,omitempty"`

	// Limit The maximum number of commands to return per page. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Namespace Filter commands based on namespace.
	Namespace *[]string `json:"namespace,omitempty"`

	// SortBy List of fields to sort the commands items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// SourceObjectId ID of the object where command is invoked (work/part/conversation).
	SourceObjectId *string `json:"source_object_id,omitempty"`

	// Status Filter commands based on status.
	Status *[]CommandStatus `json:"status,omitempty"`
}

// CommandsListResponseBody defines model for commands-list-response.
type CommandsListResponseBody struct {
	// Commands List of commands.
	Commands []Command `json:"commands"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// Conversation defines model for conversation.
type Conversation struct {
	// Channels Channel IDs of the conversation.
	Channels  *[]ExternalCommunicationChannelSummary `json:"channels,omitempty"`
	CreatedBy *UserSummary                           `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the conversation object.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string       `json:"display_id,omitempty"`
	Group     *GroupSummary `json:"group,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Members The users in the conversation.
	Members []UserSummary `json:"members"`

	// Messages The latest messages on the conversation.
	Messages *[]TimelineEntry `json:"messages,omitempty"`

	// Metadata Metadata on conversation.
	Metadata   *ConversationMetadata `json:"metadata,omitempty"`
	ModifiedBy *UserSummary          `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy Owner IDs for the conversation.
	OwnedBy *[]UserSummary `json:"owned_by,omitempty"`

	// SlaSummary SLA summary for the object.
	SlaSummary *ArchetypeSlaSummary `json:"sla_summary,omitempty"`
	SlaTracker *SlaTrackerSummary   `json:"sla_tracker,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStage `json:"stage,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// Title Title of the conversation object.
	Title *string `json:"title,omitempty"`
}

// ConversationMetadata Metadata on conversation.
type ConversationMetadata struct {
	// UrlContext URL from which the conversation was created if the conversation was
	// created via PLuG.
	UrlContext *string `json:"url_context,omitempty"`
}

// ConversationSummary defines model for conversation-summary.
type ConversationSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Title Title of the conversation object.
	Title *string `json:"title,omitempty"`
}

// ConversationsCreateRequest The request to create a new conversation.
type ConversationsCreateRequest struct {
	// Brand The brand associated with the conversation.
	Brand *string `json:"brand,omitempty"`

	// Channels Channel IDs of the conversation.
	Channels *[]string `json:"channels,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description Description for the conversation.
	Description *string `json:"description,omitempty"`

	// Group The group that the conversation is associated with.
	Group *string `json:"group,omitempty"`

	// IsSpam Whether the conversation is spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// Members The users in the conversation.
	Members *[]string `json:"members,omitempty"`

	// Messages Initial messages on the conversation.
	Messages *[]ConversationsCreateRequestMessage `json:"messages,omitempty"`
	Metadata *ConversationsCreateRequestMetadata  `json:"metadata,omitempty"`

	// OwnedBy The users that own the conversation.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// SourceChannel Whether the conversation is from a source channel.
	SourceChannel *string `json:"source_channel,omitempty"`

	// SourceChannelV2 Source channel ID of the conversation.
	SourceChannelV2 *string `json:"source_channel_v2,omitempty"`

	// Stage Sets an object's initial stage.
	Stage *StageInit `json:"stage,omitempty"`

	// Tags Tags associated with the conversation.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Title The title for the conversation.
	Title *string                             `json:"title,omitempty"`
	Type  ConversationsCreateRequestTypeValue `json:"type"`

	// UserSessions The IDs of user sessions associated with the conversation.
	UserSessions *[]string `json:"user_sessions,omitempty"`
}

// ConversationsCreateRequestMessage defines model for conversations-create-request-message.
type ConversationsCreateRequestMessage struct {
	// Artifacts The IDs of the artifacts to the message.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Body The message's body.
	Body *string `json:"body,omitempty"`
}

// ConversationsCreateRequestMetadata defines model for conversations-create-request-metadata.
type ConversationsCreateRequestMetadata struct {
	UrlContext *string `json:"url_context,omitempty"`
}

// ConversationsCreateRequestTypeValue defines model for conversations-create-request-type-value.
type ConversationsCreateRequestTypeValue string

// ConversationsCreateResponseBody The response to creating a new conversation.
type ConversationsCreateResponseBody struct {
	Conversation Conversation `json:"conversation"`
}

// ConversationsDeleteRequest The request to delete a conversation.
type ConversationsDeleteRequest struct {
	// Id The ID of the conversation to delete.
	Id string `json:"id"`
}

// ConversationsDeleteResponseBody The response for deleting a conversation.
type ConversationsDeleteResponseBody = map[string]interface{}

// ConversationsGetRequest The request to get a conversation's information.
type ConversationsGetRequest struct {
	// Id The requested conversation's ID.
	Id string `json:"id"`
}

// ConversationsGetResponseBody The response to getting a conversation's information.
type ConversationsGetResponseBody struct {
	Conversation Conversation `json:"conversation"`
}

// ConversationsListRequest The request to get information about a list of conversations.
type ConversationsListRequest struct {
	// ActualCloseDate Provides ways to specify date ranges on objects.
	ActualCloseDate *DateFilter `json:"actual_close_date,omitempty"`

	// AppliesToParts Filters for conversations belonging to any of the provided parts.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// Brand Filters for tickets that are associated with any of the brands.
	Brand *[]string `json:"brand,omitempty"`

	// Channels Filters for conversations that are associated with any of the
	// channels.
	Channels *[]string `json:"channels,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Group Filters for conversation that belong to the given groups.
	Group *[]string `json:"group,omitempty"`

	// IsCreatorVerified Filters for conversations that are created by verified users.
	IsCreatorVerified *bool `json:"is_creator_verified,omitempty"`

	// IsFrozen Filters for conversations that are frozen.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// IsSpam Filters for conversations that are spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// Limit The maximum number of conversations to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Members Filters for conversations where these users are participants.
	Members *[]string `json:"members,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for conversations owned by any of these users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// RevOrg Filters for conversations that are associated with any of the
	// provided Rev organizations.
	// Deprecated:
	RevOrg *[]string `json:"rev_org,omitempty"`

	// RevOrgs Filters for conversations that are associated with any of the
	// provided Rev organizations.
	RevOrgs *[]string `json:"rev_orgs,omitempty"`

	// SlaSummary The filter for SLA summary.
	SlaSummary *SlaSummaryFilter `json:"sla_summary,omitempty"`

	// SourceChannel Filters for conversations with any of the provided source channels.
	SourceChannel *[]string `json:"source_channel,omitempty"`

	// SourceChannelV2 Filters for conversations that are associated with the source
	// channel.
	SourceChannelV2 *[]string `json:"source_channel_v2,omitempty"`

	// SourceChannels Filters for conversations with any of the provided source channels.
	// Deprecated:
	SourceChannels *[]string `json:"source_channels,omitempty"`

	// Stage The filter for stages.
	Stage *StageFilter `json:"stage,omitempty"`

	// State Filters for conversations with any of the provided states.
	State *[]string `json:"state,omitempty"`

	// Tags Filters for conversations with any of the provided tags.
	// Deprecated:
	Tags *[]string `json:"tags,omitempty"`

	// TagsV2 Filters for conversations with any of the provided tags with value.
	TagsV2 *[]TagWithValueFilter `json:"tags_v2,omitempty"`
}

// ConversationsListResponseBody The response to listing the conversations.
type ConversationsListResponseBody struct {
	// Conversations The list of conversations.
	Conversations []Conversation `json:"conversations"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// ConversationsUpdateRequest The request to update a conversation.
type ConversationsUpdateRequest struct {
	AppliesToParts *ConversationsUpdateRequestAppliesToParts `json:"applies_to_parts,omitempty"`

	// Brand The brand associated with the conversation.
	Brand    *string                             `json:"brand,omitempty"`
	Channels *ConversationsUpdateRequestChannels `json:"channels,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description The updated description for the conversation.
	Description *string `json:"description,omitempty"`

	// Group The group that the conversation is associated with.
	Group *string `json:"group,omitempty"`

	// Id The ID of the conversation to update.
	Id string `json:"id"`

	// IsFrozen Whether the conversation is frozen.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// IsSpam Whether the conversation is spam.
	IsSpam   *bool                               `json:"is_spam,omitempty"`
	Members  *ConversationsUpdateRequestMembers  `json:"members,omitempty"`
	Metadata *ConversationsUpdateRequestMetadata `json:"metadata,omitempty"`
	OwnedBy  *ConversationsUpdateRequestOwnedBy  `json:"owned_by,omitempty"`

	// SourceChannelV2 Source channel ID of the conversation.
	SourceChannelV2 *string `json:"source_channel_v2,omitempty"`

	// Stage Updates an object's stage.
	Stage *StageUpdate `json:"stage,omitempty"`

	// Status The updated status of the conversation.
	Status *string                         `json:"status,omitempty"`
	Tags   *ConversationsUpdateRequestTags `json:"tags,omitempty"`

	// Title The updated title of the conversation.
	Title        *string                                 `json:"title,omitempty"`
	UserSessions *ConversationsUpdateRequestUserSessions `json:"user_sessions,omitempty"`
}

// ConversationsUpdateRequestAppliesToParts defines model for conversations-update-request-applies-to-parts.
type ConversationsUpdateRequestAppliesToParts struct {
	// Set Updates the parts that the conversation applies to.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateRequestChannels defines model for conversations-update-request-channels.
type ConversationsUpdateRequestChannels struct {
	// Set Sets the channel IDs of the conversation.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateRequestMembers defines model for conversations-update-request-members.
type ConversationsUpdateRequestMembers struct {
	// Set Sets the member IDs to the provided user IDs.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateRequestMetadata defines model for conversations-update-request-metadata.
type ConversationsUpdateRequestMetadata struct {
	UrlContext *string `json:"url_context,omitempty"`
}

// ConversationsUpdateRequestOwnedBy defines model for conversations-update-request-owned-by.
type ConversationsUpdateRequestOwnedBy struct {
	// Set Sets the owner IDs to the provided user IDs.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateRequestTags defines model for conversations-update-request-tags.
type ConversationsUpdateRequestTags struct {
	// Add Adds the provided tags on the conversation.
	Add *[]AddTagWithValue `json:"add,omitempty"`

	// Remove Removes the provided tags on the conversation.
	Remove *[]RemoveTagWithValue `json:"remove,omitempty"`

	// Set Sets the tag IDs to the provided tags.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// ConversationsUpdateRequestUserSessions defines model for conversations-update-request-user-sessions.
type ConversationsUpdateRequestUserSessions struct {
	// Set The updated user sessions that the conversation is associated with.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateResponseBody The response for updating a conversation.
type ConversationsUpdateResponseBody struct {
	Conversation Conversation `json:"conversation"`
}

// CreateCommandAction defines model for create-command-action.
type CreateCommandAction struct {
	ActionDetails *CreateCommandActionDetails `json:"action_details,omitempty"`

	// Artifacts IDs of the new artifact items
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Code The raw code to execute, defined in the language specified by
	// executor
	Code *string `json:"code,omitempty"`

	// ExecutorConfig Executor specific config
	ExecutorConfig *map[string]interface{} `json:"executor_config,omitempty"`

	// ExecutorType Specifies how the action is defined.
	ExecutorType CommandActionExecutorType `json:"executor_type"`

	// Message The message to populate in discussion box, when the command is
	// selected to execute.
	Message *string `json:"message,omitempty"`

	// SnapInFunctionId Function containing logic for the command. If function ID is
	// specified the executor config is ignored and command is executed by
	// functions.
	SnapInFunctionId *string `json:"snap_in_function_id,omitempty"`

	// TemplateType The template engine for resolving message.
	TemplateType *CommandActionTemplateType `json:"template_type,omitempty"`
}

// CreateCommandActionDetails defines model for create-command-action-details.
type CreateCommandActionDetails struct {
	// ObjectUpdatePayload The payload to update the object in context upon command execution.
	ObjectUpdatePayload *map[string]interface{} `json:"object_update_payload,omitempty"`
}

// CreateCommandSurface defines model for create-command-surface.
type CreateCommandSurface struct {
	// ObjectTypes Objects types on which a command can be invoked
	ObjectTypes *[]CommandSurfaceObjectTypes `json:"object_types,omitempty"`

	// Surface Surfaces from where this command can be invoked.
	Surface CommandSurfaceSurface `json:"surface"`
}

// CreateOrgScheduleInterval defines model for create-org-schedule-interval.
type CreateOrgScheduleInterval struct {
	// From Date (inclusive) on which the interval begins.
	From time.Time `json:"from"`

	// IsExcluded If true, no organization schedule is looked up for these days and
	// they are marked as holidays.
	IsExcluded *bool `json:"is_excluded,omitempty"`

	// Name The name of the period, for example the event or holiday it
	// represents.
	Name string `json:"name"`

	// To Date (exclusive) on which the interval ends. If omitted, it is a
	// single day interval.
	To *time.Time `json:"to,omitempty"`
}

// CreateWeeklyOrgScheduleInterval defines model for create-weekly-org-schedule-interval.
type CreateWeeklyOrgScheduleInterval struct {
	// From Duration in minutes of the week when the interval starts. 0 is
	// Sunday midnight, when Sunday ends and Monday begins.
	From int64 `json:"from"`

	// To Duration in minutes of the week when the interval ends (must be
	// larger than 'from'). 0 is Sunday midnight, when Sunday ends and
	// Monday begins.
	To int64 `json:"to"`
}

// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
// request must have the corresponding schema specified; omission results
// in a Bad Request error. If a custom schema is not included in the
// specifier, it remains unchanged. For surfaces with human interactors,
// it is recommended to provide tenant_fragment: true and
// validate_required_fields: true.
type CustomSchemaSpec struct {
	// Apps List of apps.
	Apps *[]string `json:"apps,omitempty"`

	// Subtype Name of the subtype.
	Subtype *string `json:"subtype,omitempty"`

	// TenantFragment Whether the tenant schema is requested.
	TenantFragment *bool `json:"tenant_fragment,omitempty"`

	// ValidateRequiredFields Whether to enforce required fields validation.
	ValidateRequiredFields *bool `json:"validate_required_fields,omitempty"`
}

// Dashboard defines model for dashboard.
type Dashboard = AtomBase

// DateFilter Provides ways to specify date ranges on objects.
type DateFilter struct {
	// Type Type of date filter.
	Type  DateFilterType `json:"type"`
	union json.RawMessage
}

// DateFilterType Type of date filter.
type DateFilterType string

// DateTimeFilter defines model for date-time-filter.
type DateTimeFilter struct {
	// After Filters for objects created after the provided timestamp
	// (inclusive).
	After *time.Time `json:"after,omitempty"`

	// Before Filters for objects created before the provided timestamp
	// (inclusive).
	Before *time.Time `json:"before,omitempty"`
}

// DateTimePreset Provides preset types for date filter.
type DateTimePreset struct {
	// PresetType Type of date preset.
	PresetType DateTimePresetType `json:"preset_type"`
	union      json.RawMessage
}

// DateTimePresetLastNDays defines model for date-time-preset-last-n-days.
type DateTimePresetLastNDays struct {
	// Days The range starts from the current timestamp and continues for the
	// past n days.
	Days int `json:"days"`
}

// DateTimePresetNextNDays defines model for date-time-preset-next-n-days.
type DateTimePresetNextNDays struct {
	// Days The range starts from the current timestamp and continues for the
	// next n days.
	Days int `json:"days"`
}

// DateTimePresetType Type of date preset.
type DateTimePresetType string

// Definedness Indicates whether this evaluation can change in the future.
type Definedness string

// DevOrg defines model for dev-org.
type DevOrg = OrgBase

// DevOrgAuthConnectionsCreateRequest Request to create a new enterprise authentication connection.
type DevOrgAuthConnectionsCreateRequest struct {
	// DisplayName Display name of the authentication connection. This name will be
	// visible to all the users when they sign in to this Dev
	// organization. For example, if the display_name is 'abclogin', then
	// it would appear on the login button as 'Log in to abclogin'.
	DisplayName *string `json:"display_name,omitempty"`

	// Type Defines the type for the authentication connection. Different types of
	// authentication connections have different configuration parameters.
	Type  DevOrgAuthConnectionsCreateRequestType `json:"type"`
	union json.RawMessage
}

// DevOrgAuthConnectionsCreateRequestAzureAdOptions Object encapsulating the configuration parameters for an Azure AD
// authentication connection.
type DevOrgAuthConnectionsCreateRequestAzureAdOptions struct {
	// ClientId Client ID for the Azure authentication connection.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret for the Azure authentication connection.
	ClientSecret string `json:"client_secret"`

	// Domain Domain URL of the Azure authentication connection.
	Domain string `json:"domain"`
}

// DevOrgAuthConnectionsCreateRequestGoogleAppsOptions Object encapsulating the configuration parameters for a Google Apps
// authentication connection.
type DevOrgAuthConnectionsCreateRequestGoogleAppsOptions struct {
	// ClientId Client ID for the Google Apps authentication connection.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret for the Google Apps authentication connection.
	ClientSecret string `json:"client_secret"`

	// TenantDomain Tenant domain URL of the Google Apps authentication connection.
	TenantDomain string `json:"tenant_domain"`
}

// DevOrgAuthConnectionsCreateRequestOidcOptions Object encapsulating the configuration parameters for an OIDC
// authentication connection.
type DevOrgAuthConnectionsCreateRequestOidcOptions struct {
	// ClientId Client ID for the OIDC authentication connection.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret for the OIDC authentication connection.
	ClientSecret string `json:"client_secret"`

	// Issuer Issuer URL of the OIDC authentication connection.
	Issuer string `json:"issuer"`
}

// DevOrgAuthConnectionsCreateRequestOktaOptions Object encapsulating the configuration parameters for an Okta
// authentication connection.
type DevOrgAuthConnectionsCreateRequestOktaOptions struct {
	// ClientId Client ID for the Okta authentication connection.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret for the Okta authentication connection.
	ClientSecret string `json:"client_secret"`

	// Domain Domain URL of the Okta authentication connection.
	Domain string `json:"domain"`
}

// DevOrgAuthConnectionsCreateRequestSamlOptions Object encapsulating the configuration parameters for a SAML
// authentication connection.
type DevOrgAuthConnectionsCreateRequestSamlOptions struct {
	// ConnectionName Connection name for the SAML authentication connection. Must match
	// the `connection` query parameter specified in the sign on URL
	// during SAML configuration in your identity provider.
	ConnectionName *string                  `json:"connection_name,omitempty"`
	FieldsMap      *SamlConnectionFieldsMap `json:"fields_map,omitempty"`

	// SignInEndpoint Sign In endpoint for the SAML authentication connection.
	SignInEndpoint string `json:"sign_in_endpoint"`

	// SigningCert Signing certificate for the SAML authentication connection.
	SigningCert string `json:"signing_cert"`
}

// DevOrgAuthConnectionsCreateRequestType Defines the type for the authentication connection. Different types of
// authentication connections have different configuration parameters.
type DevOrgAuthConnectionsCreateRequestType string

// DevOrgAuthConnectionsCreateResponseBody Response for the request to create a new enterprise authentication
// connection.
type DevOrgAuthConnectionsCreateResponseBody struct {
	// AuthConnection Connection object that specifies the configuration for an
	// authentication connection that is set up for a Dev organization.
	AuthConnection AuthConnection `json:"auth_connection"`
}

// DevOrgAuthConnectionsDeleteRequest Request to delete an enterprise authentication connection for a Dev
// organization. A default connection and a connection which is currently
// enabled cannot be deleted.
type DevOrgAuthConnectionsDeleteRequest struct {
	// Id ID of the authentication connection to be deleted.
	Id string `json:"id"`
}

// DevOrgAuthConnectionsGetRequest Request to get configuration details of organization's authentication
// Connection.
type DevOrgAuthConnectionsGetRequest struct {
	// Id ID of the authentication connection.
	Id string `json:"id"`
}

// DevOrgAuthConnectionsGetResponseBody Response object encapsulating the configuration details of an
// authentication connection.
type DevOrgAuthConnectionsGetResponseBody struct {
	// AuthConnection Connection object that specifies the configuration for an
	// authentication connection that is set up for a Dev organization.
	AuthConnection AuthConnection `json:"auth_connection"`
}

// DevOrgAuthConnectionsListResponseBody Response object for the request to list all the social and enterprise
// authentication connections configured for a Dev organization.
type DevOrgAuthConnectionsListResponseBody struct {
	// AuthConnections List of all the authentication connections currently configured for
	// a Dev organization.
	AuthConnections []AuthConnection `json:"auth_connections"`
}

// DevOrgAuthConnectionsToggleRequest Request to enable or disable an authentication connection for a Dev
// organization.
type DevOrgAuthConnectionsToggleRequest struct {
	// Id ID of the authentication connection to be toggled.
	Id     string                `json:"id"`
	Toggle *AuthConnectionToggle `json:"toggle,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequest Request to update an enterprise authentication connection for a Dev
// organization.
type DevOrgAuthConnectionsUpdateRequest struct {
	// DisplayName New display name of the authentication connection. This name will
	// be visible to all the users when they sign in to this Dev
	// organization. For example, if the display_name is 'abclogin', then
	// it would appear on the login button as 'Log in to abclogin'.
	DisplayName *string `json:"display_name,omitempty"`

	// Id ID of the authentication connection which is to be updated.
	Id string `json:"id"`

	// Type Specifies the type for the authentication connection. Different types
	// of authentication connections have different configuration parameters
	// that can be updated.
	Type  *DevOrgAuthConnectionsUpdateRequestType `json:"type,omitempty"`
	union json.RawMessage
}

// DevOrgAuthConnectionsUpdateRequestAzureAdOptions Object encapsulating the configuration parameters for an Azure AD
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestAzureAdOptions struct {
	// ClientId Client ID for the Azure authentication connection.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for the Azure authentication connection.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Domain Domain URL of the Azure authentication connection.
	Domain *string `json:"domain,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions Object encapsulating the configuration parameters for a Google Apps
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions struct {
	// ClientId Client ID for the Google Apps authentication connection.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for the Google Apps authentication connection.
	ClientSecret *string `json:"client_secret,omitempty"`

	// TenantDomain Tenant domain URL of the Google Apps authentication connection.
	TenantDomain *string `json:"tenant_domain,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestOidcOptions Object encapsulating the configuration parameters for an OIDC
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestOidcOptions struct {
	// ClientId Client ID for the OIDC authentication connection.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for the OIDC authentication connection.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Issuer Issuer URL of the OIDC authentication connection.
	Issuer *string `json:"issuer,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestOktaOptions Object encapsulating the configuration parameters for an Okta
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestOktaOptions struct {
	// ClientId Client ID for the Okta authentication connection.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for the Okta authentication connection.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Domain Domain URL of the Okta authentication connection.
	Domain *string `json:"domain,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestSamlOptions Object encapsulating the configuration parameters for a SAML
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestSamlOptions struct {
	FieldsMap *SamlConnectionFieldsMap `json:"fields_map,omitempty"`

	// SignInEndpoint Sign In endpoint for the SAML authentication connection.
	SignInEndpoint *string `json:"sign_in_endpoint,omitempty"`

	// SigningCert Signing certificate for the SAML authentication connection.
	SigningCert *string `json:"signing_cert,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestType Specifies the type for the authentication connection. Different types
// of authentication connections have different configuration parameters
// that can be updated.
type DevOrgAuthConnectionsUpdateRequestType string

// DevOrgAuthConnectionsUpdateResponseBody Response for the request to update an enterprise authentication
// connection.
type DevOrgAuthConnectionsUpdateResponseBody struct {
	// AuthConnection Connection object that specifies the configuration for an
	// authentication connection that is set up for a Dev organization.
	AuthConnection AuthConnection `json:"auth_connection"`
}

// DevOrgsGetRequest A request to get a Dev organization's information.
type DevOrgsGetRequest = map[string]interface{}

// DevOrgsGetResponseBody The response to get a Dev organization's information.
type DevOrgsGetResponseBody struct {
	DevOrg DevOrg `json:"dev_org"`
}

// DevUser defines model for dev-user.
type DevUser struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// ExperienceStartDate Start date of the user's employment.
	ExperienceStartDate *time.Time `json:"experience_start_date,omitempty"`

	// ExternalIdentities IDs of the Dev User outside the DevRev SOR.
	ExternalIdentities *[]ExternalIdentity `json:"external_identities,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// JobHistory Job history of the user.
	JobHistory *[]JobHistoryItem `json:"job_history,omitempty"`
	ModifiedBy *UserSummary      `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// PhoneNumbers Phone numbers of the user.
	PhoneNumbers    *[]string    `json:"phone_numbers,omitempty"`
	PrimaryIdentity *UserSummary `json:"primary_identity,omitempty"`

	// Skills Array of skills of the user.
	Skills *[]UserSkill `json:"skills,omitempty"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`
}

// DevUserExternalIdentityFilter defines model for dev-user-external-identity-filter.
type DevUserExternalIdentityFilter struct {
	// Id Unique ID of the user in the external source.
	Id *string `json:"id,omitempty"`

	// Issuer Issuer of the external identity of the user.
	Issuer *string `json:"issuer,omitempty"`
}

// DevUserJobTitle Job title of the Dev User.
type DevUserJobTitle string

// DevUserSummary defines model for dev-user-summary.
type DevUserSummary = UserBaseSummary

// DevUsersActivateRequest A request to activate the Dev user.
type DevUsersActivateRequest struct {
	// Groups IDs of the groups assigned to user during activation.
	Groups *[]string `json:"groups,omitempty"`

	// Id The ID for the Dev user.
	Id string `json:"id"`
}

// DevUsersActivateResponseBody The response to activate the Dev user.
type DevUsersActivateResponseBody struct {
	// InviteSent Whether an invitation has been sent to the Dev user.
	InviteSent bool `json:"invite_sent"`
}

// DevUsersCreateRequest Request object to create a new Dev user for a Dev organization.
type DevUsersCreateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Email Email of the Dev user.
	Email string `json:"email"`

	// FullName Full name of the Dev user.
	FullName *string `json:"full_name,omitempty"`

	// ReportsTo The ID of the user that the user reports to.
	ReportsTo *string                             `json:"reports_to,omitempty"`
	State     DevUsersCreateRequestStateEnumValue `json:"state"`
}

// DevUsersCreateRequestStateEnumValue defines model for dev-users-create-request-state-enum-value.
type DevUsersCreateRequestStateEnumValue string

// DevUsersCreateResponseBody Response object for request to create a new Dev user for a Dev
// organization.
type DevUsersCreateResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersDeactivateRequest A request to deactivate the Dev user.
type DevUsersDeactivateRequest struct {
	// Id The ID for the Dev user.
	Id string `json:"id"`
}

// DevUsersDeactivateResponseBody The response to deactivate the Dev user.
type DevUsersDeactivateResponseBody = map[string]interface{}

// DevUsersGetRequest A request to get a Dev user's information.
type DevUsersGetRequest struct {
	// Id User ID of the requested Dev user.
	Id string `json:"id"`
}

// DevUsersGetResponseBody The response to getting the information for the Dev user.
type DevUsersGetResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersIdentitiesLinkRequest Request to link external identity to a Dev user.
type DevUsersIdentitiesLinkRequest struct {
	// DevUser The ID of the Dev user to link the external identity to.
	DevUser string `json:"dev_user"`

	// DisplayName Display name of the Dev user in the external source.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Unique ID of the Dev user in the external source.
	Id string `json:"id"`

	// Issuer Issuer of the external identity of the Dev user.
	Issuer string `json:"issuer"`
}

// DevUsersIdentitiesLinkResponseBody Response for the request to link an external identity to a Dev user.
type DevUsersIdentitiesLinkResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersIdentitiesUnlinkRequest Request to unlink an external identity from a Dev user.
type DevUsersIdentitiesUnlinkRequest struct {
	// DevUser The ID of the Dev user to unlink the external identity from.
	DevUser string `json:"dev_user"`

	// Issuer Issuer that needs to be unlinked from a Dev user.
	Issuer string `json:"issuer"`
}

// DevUsersIdentitiesUnlinkResponseBody Response for the request to unlink an external identity from a Dev
// user.
type DevUsersIdentitiesUnlinkResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersListRequest A request to get the list of Dev user's information.
type DevUsersListRequest struct {
	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Email Filters Dev users based on email addresses.
	Email *[]string `json:"email,omitempty"`

	// ExternalIdentity Filters Dev users based on external identity.
	ExternalIdentity *[]DevUserExternalIdentityFilter `json:"external_identity,omitempty"`

	// Limit The maximum number of Dev users to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// SortBy Fields to sort the Dev users by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// State Filters Dev users based on state.
	State *[]UserState `json:"state,omitempty"`
}

// DevUsersListResponseBody The response to listing the Dev users.
type DevUsersListResponseBody struct {
	// DevUsers The list of Dev users.
	DevUsers []DevUser `json:"dev_users"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// DevUsersMergeRequest Request object for merging Dev users.
type DevUsersMergeRequest struct {
	// PrimaryUser The unique ID of the primary user.
	PrimaryUser string `json:"primary_user"`

	// SecondaryUser The unique ID of the secondary user.
	SecondaryUser string `json:"secondary_user"`
}

// DevUsersMergeResponseBody Response object for request to merge Dev users.
type DevUsersMergeResponseBody = map[string]interface{}

// DevUsersSelfRequest A request to get the authenticated user's information.
type DevUsersSelfRequest = map[string]interface{}

// DevUsersSelfResponseBody The response to getting the information for the authenticated user.
type DevUsersSelfResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersSelfUpdateRequest A request to update the user's information for the authenticated Dev
// user.
type DevUsersSelfUpdateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// DisplayName The updated display name of the Dev user.
	DisplayName *string `json:"display_name,omitempty"`

	// ExperienceStartDate Start date of Dev user's experience.
	ExperienceStartDate *time.Time `json:"experience_start_date,omitempty"`

	// FullName The updated full name of the Dev user.
	FullName *string `json:"full_name,omitempty"`

	// JobHistory Job history of the Dev user.
	JobHistory *[]DevUsersUpdateJobHistoryItem `json:"job_history,omitempty"`

	// JobTitle Job title of the Dev User.
	JobTitle *DevUserJobTitle `json:"job_title,omitempty"`
}

// DevUsersUpdateJobHistoryItem defines model for dev-users-update-job-history-item.
type DevUsersUpdateJobHistoryItem struct {
	// EmploymentStatus Enum for the employment status of the user.
	EmploymentStatus *int64 `json:"employment_status,omitempty"`

	// EndDate End date of the job.
	EndDate *time.Time `json:"end_date,omitempty"`

	// IsCurrent Is this the current active job for the user.
	IsCurrent *bool `json:"is_current,omitempty"`

	// Location The job location for the user.
	Location *string `json:"location,omitempty"`

	// StartDate Start date of the job.
	StartDate *time.Time `json:"start_date,omitempty"`

	// Title The job title for the user.
	Title *string `json:"title,omitempty"`
}

// DevUsersUpdateRequest A request to update the user's information corresponding to the
// provided Dev user.
type DevUsersUpdateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// DisplayName The updated display name of the Dev user.
	DisplayName *string `json:"display_name,omitempty"`

	// ExperienceStartDate Start date of Dev user's experience.
	ExperienceStartDate *time.Time `json:"experience_start_date,omitempty"`

	// FullName The updated full name of the Dev user.
	FullName *string `json:"full_name,omitempty"`

	// Id The ID for the Dev user to be updated.
	Id string `json:"id"`

	// JobHistory Job history of the Dev user.
	JobHistory *[]DevUsersUpdateJobHistoryItem `json:"job_history,omitempty"`

	// JobTitle Job title of the Dev User.
	JobTitle *DevUserJobTitle `json:"job_title,omitempty"`
}

// DevUsersUpdateResponseBody The response to update a Dev user.
type DevUsersUpdateResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DirectoriesCountRequest defines model for directories-count-request.
type DirectoriesCountRequest struct {
	// CreatedBy Filters for directories created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// ModifiedBy Filters for directories modified by any of the provided users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`
}

// DirectoriesCountResponseBody defines model for directories-count-response.
type DirectoriesCountResponseBody struct {
	// Count The total number of directories matching the filter.
	Count int32 `json:"count"`
}

// DirectoriesCreateRequest The request to create a directory.
type DirectoriesCreateRequest struct {
	// Description Description for the directory.
	Description *string `json:"description,omitempty"`

	// Icon Icon for the directory.
	Icon *string `json:"icon,omitempty"`

	// Language Language of the directory.
	Language *string `json:"language,omitempty"`

	// Parent Parent directory of the directory.
	Parent *string `json:"parent,omitempty"`

	// Published Whether the directory is published.
	Published *bool `json:"published,omitempty"`

	// Tags Tags associated with the directory.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Thumbnail ID of the thumbnail artifact.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title Title of the directory.
	Title string `json:"title"`
}

// DirectoriesCreateResponseBody Create directory response.
type DirectoriesCreateResponseBody struct {
	Directory Directory `json:"directory"`
}

// DirectoriesDeleteRequest The request to delete a directory.
type DirectoriesDeleteRequest struct {
	// Id The ID of the directory to delete.
	Id string `json:"id"`
}

// DirectoriesDeleteResponseBody defines model for directories-delete-response.
type DirectoriesDeleteResponseBody = map[string]interface{}

// DirectoriesGetRequest The request to get a directory.
type DirectoriesGetRequest struct {
	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `json:"dev_org,omitempty"`

	// Id The ID of the requested directory.
	Id string `json:"id"`
}

// DirectoriesGetResponseBody Get directory response.
type DirectoriesGetResponseBody struct {
	Directory Directory `json:"directory"`
}

// DirectoriesListRequest The request to list directories.
type DirectoriesListRequest struct {
	// CreatedBy Filters for directories created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `json:"dev_org,omitempty"`

	// Limit The maximum number of directories to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedBy Filters for directories modified by any of the provided users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`
}

// DirectoriesListResponseBody List directory response.
type DirectoriesListResponseBody struct {
	// Directories The list of directories.
	Directories []Directory `json:"directories"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// DirectoriesUpdateRequest The request to update a directory.
type DirectoriesUpdateRequest struct {
	// Description The updated description for the directory.
	Description *string `json:"description,omitempty"`

	// Icon The updated icon for the directory.
	Icon *string `json:"icon,omitempty"`

	// Id The ID of the directory to update.
	Id string `json:"id"`

	// Parent The updated parent directory for the directory.
	Parent *string `json:"parent"`

	// Published Whether the directory is published.
	Published *bool                            `json:"published,omitempty"`
	Reorder   *DirectoriesUpdateRequestReorder `json:"reorder,omitempty"`
	Tags      *DirectoriesUpdateRequestTags    `json:"tags,omitempty"`

	// Thumbnail The updated thumbnail for the directory.
	Thumbnail *string `json:"thumbnail"`

	// Title The updated title for the directory.
	Title *string `json:"title,omitempty"`
}

// DirectoriesUpdateRequestReorder defines model for directories-update-request-reorder.
type DirectoriesUpdateRequestReorder struct {
	// After The directory after which the reordered directory is placed.
	After *string `json:"after,omitempty"`

	// Before The directory before which the reordered directory is placed.
	Before *string `json:"before,omitempty"`
}

// DirectoriesUpdateRequestTags defines model for directories-update-request-tags.
type DirectoriesUpdateRequestTags struct {
	// Set Sets the provided tags on the directory.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// DirectoriesUpdateResponseBody Update directory response.
type DirectoriesUpdateResponseBody struct {
	Directory Directory `json:"directory"`
}

// Directory defines model for directory.
type Directory struct {
	Body      *ArtifactSummary `json:"body,omitempty"`
	CreatedBy *UserSummary     `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the directory.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Icon Icon of the directory.
	Icon *string `json:"icon,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time        `json:"modified_date,omitempty"`
	Parent       *DirectorySummary `json:"parent,omitempty"`

	// Published Whether the directory is published.
	Published *bool `json:"published,omitempty"`

	// Rank Rank of the directory.
	Rank *string `json:"rank,omitempty"`

	// Tags Tags associated with the directory.
	Tags      *[]TagWithValue  `json:"tags,omitempty"`
	Thumbnail *ArtifactSummary `json:"thumbnail,omitempty"`

	// Title Title of the directory.
	Title *string `json:"title,omitempty"`
}

// DirectorySummary defines model for directory-summary.
type DirectorySummary = AtomBaseSummary

// DynamicGroupInfo Information to define dynamic groups.
type DynamicGroupInfo = map[string]interface{}

// Empty defines model for empty.
type Empty = map[string]interface{}

// Enhancement defines model for enhancement.
type Enhancement struct {
	// ActualCloseDate Actual close date for the object.
	ActualCloseDate *time.Time `json:"actual_close_date,omitempty"`

	// ActualStartDate Actual start date for the object.
	ActualStartDate *time.Time `json:"actual_start_date,omitempty"`

	// Artifacts The attached artifacts.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`
	CreatedBy *UserSummary       `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the part.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Name of the part.
	Name string `json:"name"`

	// OwnedBy The users that own the part.
	OwnedBy []UserSummary `json:"owned_by"`

	// StageV2 Describes the current stage of a object.
	StageV2 *Stage `json:"stage_v2,omitempty"`

	// StateV2 State of the object based upon the stage.
	StateV2 *string `json:"state_v2,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Target close date for the object.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// TargetStartDate Target start date for the object.
	TargetStartDate *time.Time `json:"target_start_date,omitempty"`
}

// EnhancementSummary defines model for enhancement-summary.
type EnhancementSummary = PartBaseSummary

// EnumValue The properties of an enum value.
type EnumValue struct {
	// Id The unique ID of the enum value.
	Id int64 `json:"id"`

	// Label The display label of the enum value.
	Label string `json:"label"`

	// Ordinal Used for determining the relative order of the enum value.
	Ordinal int64 `json:"ordinal"`

	// Value The actual value of the enum value.
	Value *interface{} `json:"value,omitempty"`
}

// EnumValueSummary The properties of an enum value.
type EnumValueSummary struct {
	// Id The unique ID of the enum value.
	Id int64 `json:"id"`

	// Label The display label of the enum value.
	Label string `json:"label"`

	// Ordinal Used for determining the relative order of the enum value.
	Ordinal int64 `json:"ordinal"`
}

// Error defines model for error.
type Error struct {
	// Message Information about the error.
	Message string `json:"message"`

	// Status The corresponding HTTP status code.
	Status int32 `json:"status"`

	// Type The error type.
	Type *string `json:"type,omitempty"`
}

// ErrorBadRequest defines model for error-bad-request.
type ErrorBadRequest struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string             `json:"message,omitempty"`
	Type    ErrorBadRequestType `json:"type"`
	union   json.RawMessage
}

// ErrorBadRequestArtifactAlreadyAttachedToAParent defines model for error-bad-request-artifact-already-attached-to-a-parent.
type ErrorBadRequestArtifactAlreadyAttachedToAParent struct {
	// ExistingParent The existing parent attached to the artifact.
	ExistingParent string `json:"existing_parent"`

	// IsSame Whether the existing parent is the same as the new parent.
	IsSame bool `json:"is_same"`
}

// ErrorBadRequestBadRequest defines model for error-bad-request-bad-request.
type ErrorBadRequestBadRequest = map[string]interface{}

// ErrorBadRequestCustomizationValidationError Describes an error encountered during customization validation.
type ErrorBadRequestCustomizationValidationError struct {
	// FieldName The name of the invalid field.
	FieldName *string `json:"field_name,omitempty"`

	// Reason The reason given for the error.
	Reason  *string                                            `json:"reason,omitempty"`
	Subtype ErrorBadRequestCustomizationValidationErrorSubtype `json:"subtype"`
	union   json.RawMessage
}

// ErrorBadRequestCustomizationValidationErrorBadIdType defines model for error-bad-request-customization-validation-error-bad-id-type.
type ErrorBadRequestCustomizationValidationErrorBadIdType = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorDateParseError defines model for error-bad-request-customization-validation-error-date-parse-error.
type ErrorBadRequestCustomizationValidationErrorDateParseError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorEnumOutOfRange defines model for error-bad-request-customization-validation-error-enum-out-of-range.
type ErrorBadRequestCustomizationValidationErrorEnumOutOfRange = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorExpressionParseError defines model for error-bad-request-customization-validation-error-expression-parse-error.
type ErrorBadRequestCustomizationValidationErrorExpressionParseError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFieldDropped defines model for error-bad-request-customization-validation-error-field-dropped.
type ErrorBadRequestCustomizationValidationErrorFieldDropped = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFieldImmutable defines model for error-bad-request-customization-validation-error-field-immutable.
type ErrorBadRequestCustomizationValidationErrorFieldImmutable = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFieldNotInSchema defines model for error-bad-request-customization-validation-error-field-not-in-schema.
type ErrorBadRequestCustomizationValidationErrorFieldNotInSchema = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFieldRequired defines model for error-bad-request-customization-validation-error-field-required.
type ErrorBadRequestCustomizationValidationErrorFieldRequired = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFragmentNotFound defines model for error-bad-request-customization-validation-error-fragment-not-found.
type ErrorBadRequestCustomizationValidationErrorFragmentNotFound = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorIdParseError defines model for error-bad-request-customization-validation-error-id-parse-error.
type ErrorBadRequestCustomizationValidationErrorIdParseError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed defines model for error-bad-request-customization-validation-error-id-type-not-allowed.
type ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorInvalidArgument defines model for error-bad-request-customization-validation-error-invalid-argument.
type ErrorBadRequestCustomizationValidationErrorInvalidArgument = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorSubtype defines model for error-bad-request-customization-validation-error-subtype.
type ErrorBadRequestCustomizationValidationErrorSubtype string

// ErrorBadRequestCustomizationValidationErrorTimestampParseError defines model for error-bad-request-customization-validation-error-timestamp-parse-error.
type ErrorBadRequestCustomizationValidationErrorTimestampParseError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorUnknownError defines model for error-bad-request-customization-validation-error-unknown-error.
type ErrorBadRequestCustomizationValidationErrorUnknownError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorUnsupportedType defines model for error-bad-request-customization-validation-error-unsupported-type.
type ErrorBadRequestCustomizationValidationErrorUnsupportedType = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorWrongType defines model for error-bad-request-customization-validation-error-wrong-type.
type ErrorBadRequestCustomizationValidationErrorWrongType = map[string]interface{}

// ErrorBadRequestInvalidApiVersion defines model for error-bad-request-invalid-api-version.
type ErrorBadRequestInvalidApiVersion struct {
	// Value The provided API version.
	Value string `json:"value"`
}

// ErrorBadRequestInvalidEnumValue defines model for error-bad-request-invalid-enum-value.
type ErrorBadRequestInvalidEnumValue struct {
	// AllowedValues The allowed values for the field.
	AllowedValues []string `json:"allowed_values"`

	// FieldName The field whose enum value is invalid.
	FieldName string `json:"field_name"`

	// Value The value that was received.
	Value string `json:"value"`
}

// ErrorBadRequestInvalidField defines model for error-bad-request-invalid-field.
type ErrorBadRequestInvalidField struct {
	// FieldName The field name that's invalid.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestInvalidId defines model for error-bad-request-invalid-id.
type ErrorBadRequestInvalidId struct {
	// FieldName The field whose ID is invalid.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestMergeWorksError defines model for error-bad-request-merge-works-error.
type ErrorBadRequestMergeWorksError struct {
	// Errors The errors encountered during the validation of the merge.
	Errors *[]ErrorBadRequestMergeWorksErrorError `json:"errors,omitempty"`
}

// ErrorBadRequestMergeWorksErrorError defines model for error-bad-request-merge-works-error-error.
type ErrorBadRequestMergeWorksErrorError struct {
	AlreadyMerged *ErrorBadRequestMergeWorksErrorErrorAlreadyMerged `json:"already_merged,omitempty"`
	Closed        *ErrorBadRequestMergeWorksErrorErrorClosed        `json:"closed,omitempty"`

	// Details The details of the error.
	Details                 string                                                      `json:"details"`
	DifferentReporters      *ErrorBadRequestMergeWorksErrorErrorDifferentReporters      `json:"different_reporters,omitempty"`
	DifferentWorkspace      *ErrorBadRequestMergeWorksErrorErrorDifferentWorkspace      `json:"different_workspace,omitempty"`
	InvalidStageTransition  *ErrorBadRequestMergeWorksErrorErrorInvalidStageTransition  `json:"invalid_stage_transition,omitempty"`
	Locked                  *ErrorBadRequestMergeWorksErrorErrorLocked                  `json:"locked,omitempty"`
	StageNotFoundForSubtype *ErrorBadRequestMergeWorksErrorErrorStageNotFoundForSubtype `json:"stage_not_found_for_subtype,omitempty"`
	Subtype                 *ErrorBadRequestMergeWorksErrorErrorSubtype                 `json:"subtype,omitempty"`

	// Work The ID of the work which failed the validation.
	Work string `json:"work"`
}

// ErrorBadRequestMergeWorksErrorErrorSubtype defines model for ErrorBadRequestMergeWorksErrorError.Subtype.
type ErrorBadRequestMergeWorksErrorErrorSubtype string

// ErrorBadRequestMergeWorksErrorErrorAlreadyMerged defines model for error-bad-request-merge-works-error-error-already-merged.
type ErrorBadRequestMergeWorksErrorErrorAlreadyMerged struct {
	// MergedInto ID of the work into which the work was merged.
	MergedInto string `json:"merged_into"`
}

// ErrorBadRequestMergeWorksErrorErrorClosed defines model for error-bad-request-merge-works-error-error-closed.
type ErrorBadRequestMergeWorksErrorErrorClosed = map[string]interface{}

// ErrorBadRequestMergeWorksErrorErrorDifferentReporters defines model for error-bad-request-merge-works-error-error-different-reporters.
type ErrorBadRequestMergeWorksErrorErrorDifferentReporters struct {
	// PrimaryReporters The reporters of the primary work.
	PrimaryReporters *[]string `json:"primary_reporters,omitempty"`

	// SecondaryReporters The reporters of the secondary work.
	SecondaryReporters *[]string `json:"secondary_reporters,omitempty"`
}

// ErrorBadRequestMergeWorksErrorErrorDifferentWorkspace defines model for error-bad-request-merge-works-error-error-different-workspace.
type ErrorBadRequestMergeWorksErrorErrorDifferentWorkspace struct {
	// PrimaryWorkspace The workspace of the primary work.
	PrimaryWorkspace *string `json:"primary_workspace,omitempty"`

	// SecondaryWorkspace The workspace of the secondary work.
	SecondaryWorkspace *string `json:"secondary_workspace,omitempty"`
}

// ErrorBadRequestMergeWorksErrorErrorInvalidStageTransition defines model for error-bad-request-merge-works-error-error-invalid-stage-transition.
type ErrorBadRequestMergeWorksErrorErrorInvalidStageTransition struct {
	// CurrentStage The current stage of the work.
	CurrentStage string `json:"current_stage"`

	// RequestedStage The stage to which the transition isn't allowed.
	RequestedStage string `json:"requested_stage"`
}

// ErrorBadRequestMergeWorksErrorErrorLocked defines model for error-bad-request-merge-works-error-error-locked.
type ErrorBadRequestMergeWorksErrorErrorLocked = map[string]interface{}

// ErrorBadRequestMergeWorksErrorErrorStageNotFoundForSubtype defines model for error-bad-request-merge-works-error-error-stage-not-found-for-subtype.
type ErrorBadRequestMergeWorksErrorErrorStageNotFoundForSubtype struct {
	// Subtype The subtype of the work for which stage is not configured.
	Subtype *string `json:"subtype,omitempty"`
}

// ErrorBadRequestMissingDependency defines model for error-bad-request-missing-dependency.
type ErrorBadRequestMissingDependency struct {
	// Dependencies The dependent fields.
	Dependencies *[]ErrorBadRequestMissingDependencyDependency `json:"dependencies,omitempty"`

	// DependentFieldName The field on which the value depends.
	DependentFieldName *string `json:"dependent_field_name,omitempty"`

	// DependentFieldValue The value which needs to be set of the dependent field.
	DependentFieldValue *string `json:"dependent_field_value,omitempty"`

	// ProvidedFieldName The field whose value was received.
	ProvidedFieldName *string `json:"provided_field_name,omitempty"`

	// ProvidedFieldValue The value that was received.
	ProvidedFieldValue *string `json:"provided_field_value,omitempty"`
}

// ErrorBadRequestMissingDependencyDependency defines model for error-bad-request-missing-dependency-dependency.
type ErrorBadRequestMissingDependencyDependency struct {
	// FieldName The dependent field name.
	FieldName string `json:"field_name"`

	// FieldValue The dependent field value.
	FieldValue string `json:"field_value"`
}

// ErrorBadRequestMissingRequiredField defines model for error-bad-request-missing-required-field.
type ErrorBadRequestMissingRequiredField struct {
	// FieldName The missing field's name.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestParseError defines model for error-bad-request-parse-error.
type ErrorBadRequestParseError = map[string]interface{}

// ErrorBadRequestStaleSchemaFragments Error indicating that the request contained one or more stale schema
// fragments, which are schema fragments that have been replaced by a
// newer version and are therefore considered deprecated schema fragments.
// The caller should refresh and use the latest schema fragments in their
// request.
type ErrorBadRequestStaleSchemaFragments = map[string]interface{}

// ErrorBadRequestType defines model for error-bad-request-type.
type ErrorBadRequestType string

// ErrorBadRequestUnexpectedIdType defines model for error-bad-request-unexpected-id-type.
type ErrorBadRequestUnexpectedIdType struct {
	// FieldName The field whose ID type is unexpected.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestUnexpectedJsonType defines model for error-bad-request-unexpected-json-type.
type ErrorBadRequestUnexpectedJsonType struct {
	Actual   ErrorBadRequestUnexpectedJsonTypeType `json:"actual"`
	Expected ErrorBadRequestUnexpectedJsonTypeType `json:"expected"`

	// FieldName The field name that's invalid.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestUnexpectedJsonTypeType defines model for error-bad-request-unexpected-json-type-type.
type ErrorBadRequestUnexpectedJsonTypeType string

// ErrorBadRequestValueNotPermitted defines model for error-bad-request-value-not-permitted.
type ErrorBadRequestValueNotPermitted struct {
	// AllowedValues The allowed values for the field.
	AllowedValues *[]string `json:"allowed_values,omitempty"`

	// FieldName The field whose value is not permitted.
	FieldName string `json:"field_name"`

	// Reason The reason the value isn't permitted.
	Reason *string `json:"reason,omitempty"`
}

// ErrorBadRequestWorkflowComponentValidationError Error indicating that one or more workflow components failed
// validation.
type ErrorBadRequestWorkflowComponentValidationError struct {
	// Code Error code uniquely identifying the validation issue.
	Code string `json:"code"`

	// Field Represents a field with a violation.
	Field    *ErrorBadRequestWorkflowComponentValidationErrorField                                   `json:"field,omitempty"`
	Location *ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType `json:"location,omitempty"`

	// Message Human-readable message describing the issue.
	Message string `json:"message"`

	// Operation Represents an operation with a violation.
	Operation *ErrorBadRequestWorkflowComponentValidationErrorOperation `json:"operation,omitempty"`

	// Workflow Represents a workflow with a violation.
	Workflow *ErrorBadRequestWorkflowComponentValidationErrorWorkflow `json:"workflow,omitempty"`

	// WorkflowStep Represents a workflow step with a violation.
	WorkflowStep *ErrorBadRequestWorkflowComponentValidationErrorWorkflowStep `json:"workflow_step,omitempty"`
}

// ErrorBadRequestWorkflowComponentValidationErrorField Represents a field with a violation.
type ErrorBadRequestWorkflowComponentValidationErrorField struct {
	// FieldPath Path to the field with dot notation.
	FieldPath string `json:"field_path"`

	// ParentId The parent object containing the field.
	ParentId string `json:"parent_id"`
}

// ErrorBadRequestWorkflowComponentValidationErrorOperation Represents an operation with a violation.
type ErrorBadRequestWorkflowComponentValidationErrorOperation struct {
	// Id The ID of the operation with the error.
	Id string `json:"id"`
}

// ErrorBadRequestWorkflowComponentValidationErrorWorkflow Represents a workflow with a violation.
type ErrorBadRequestWorkflowComponentValidationErrorWorkflow struct {
	// Id The ID of the workflow with the error.
	Id string `json:"id"`
}

// ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType defines model for error-bad-request-workflow-component-validation-error-workflow-component-validation-location-type.
type ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType string

// ErrorBadRequestWorkflowComponentValidationErrorWorkflowStep Represents a workflow step with a violation.
type ErrorBadRequestWorkflowComponentValidationErrorWorkflowStep struct {
	// Id The ID of the workflow step with the error.
	Id string `json:"id"`
}

// ErrorBadRequestWorkflowComponentValidationErrors defines model for error-bad-request-workflow-component-validation-errors.
type ErrorBadRequestWorkflowComponentValidationErrors struct {
	// Errors Nested validation errors.
	Errors *[]ErrorBadRequestWorkflowComponentValidationError `json:"errors,omitempty"`
}

// ErrorBase defines model for error-base.
type ErrorBase struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string `json:"message,omitempty"`
}

// ErrorConflict defines model for error-conflict.
type ErrorConflict struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string           `json:"message,omitempty"`
	Type    ErrorConflictType `json:"type"`
	union   json.RawMessage
}

// ErrorConflictConflict defines model for error-conflict-conflict.
type ErrorConflictConflict = map[string]interface{}

// ErrorConflictType defines model for error-conflict-type.
type ErrorConflictType string

// ErrorForbidden defines model for error-forbidden.
type ErrorForbidden struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string            `json:"message,omitempty"`
	Type    ErrorForbiddenType `json:"type"`
	union   json.RawMessage
}

// ErrorForbiddenForbidden defines model for error-forbidden-forbidden.
type ErrorForbiddenForbidden = map[string]interface{}

// ErrorForbiddenType defines model for error-forbidden-type.
type ErrorForbiddenType string

// ErrorInternalServerError defines model for error-internal-server-error.
type ErrorInternalServerError struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string `json:"message,omitempty"`

	// ReferenceId A unique ID that's generated for the error that can be used for
	// inquiry.
	ReferenceId *string                      `json:"reference_id,omitempty"`
	Type        ErrorInternalServerErrorType `json:"type"`
	union       json.RawMessage
}

// ErrorInternalServerErrorInternalError defines model for error-internal-server-error-internal-error.
type ErrorInternalServerErrorInternalError = map[string]interface{}

// ErrorInternalServerErrorType defines model for error-internal-server-error-type.
type ErrorInternalServerErrorType string

// ErrorNotFound defines model for error-not-found.
type ErrorNotFound struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string           `json:"message,omitempty"`
	Type    ErrorNotFoundType `json:"type"`
	union   json.RawMessage
}

// ErrorNotFoundNotFound defines model for error-not-found-not-found.
type ErrorNotFoundNotFound = map[string]interface{}

// ErrorNotFoundType defines model for error-not-found-type.
type ErrorNotFoundType string

// ErrorServiceUnavailable defines model for error-service-unavailable.
type ErrorServiceUnavailable struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string                     `json:"message,omitempty"`
	Type    ErrorServiceUnavailableType `json:"type"`
	union   json.RawMessage
}

// ErrorServiceUnavailableServiceUnavailable defines model for error-service-unavailable-service-unavailable.
type ErrorServiceUnavailableServiceUnavailable = map[string]interface{}

// ErrorServiceUnavailableType defines model for error-service-unavailable-type.
type ErrorServiceUnavailableType string

// ErrorTooManyRequests defines model for error-too-many-requests.
type ErrorTooManyRequests struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string `json:"message,omitempty"`

	// RetryAfter The number of seconds after which the client should retry.
	RetryAfter *int64                   `json:"retry_after,omitempty"`
	Type       ErrorTooManyRequestsType `json:"type"`
	union      json.RawMessage
}

// ErrorTooManyRequestsTooManyRequests defines model for error-too-many-requests-too-many-requests.
type ErrorTooManyRequestsTooManyRequests = map[string]interface{}

// ErrorTooManyRequestsType defines model for error-too-many-requests-type.
type ErrorTooManyRequestsType string

// ErrorUnauthorized defines model for error-unauthorized.
type ErrorUnauthorized struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string               `json:"message,omitempty"`
	Type    ErrorUnauthorizedType `json:"type"`
	union   json.RawMessage
}

// ErrorUnauthorizedType defines model for error-unauthorized-type.
type ErrorUnauthorizedType string

// ErrorUnauthorizedUnauthenticated defines model for error-unauthorized-unauthenticated.
type ErrorUnauthorizedUnauthenticated = map[string]interface{}

// EventAccountCreated defines model for event-account-created.
type EventAccountCreated struct {
	Account Account `json:"account"`
}

// EventAccountDeleted defines model for event-account-deleted.
type EventAccountDeleted struct {
	// Id The ID of the account that was deleted.
	Id         string   `json:"id"`
	OldAccount *Account `json:"old_account,omitempty"`
}

// EventAccountUpdated defines model for event-account-updated.
type EventAccountUpdated struct {
	Account    Account  `json:"account"`
	OldAccount *Account `json:"old_account,omitempty"`
}

// EventAiAgentResponseBody defines model for event-ai-agent-response.
type EventAiAgentResponseBody struct {
	// Agent The ID of the AI agent that consumed the event.
	Agent         string                             `json:"agent"`
	AgentResponse *EventAiAgentResponseAgentResponse `json:"agent_response,omitempty"`

	// ClientMetadata The metadata given by client to be passed to the event source.
	ClientMetadata *map[string]interface{} `json:"client_metadata,omitempty"`

	// Error An error object providing the error message for the AI agent event
	// execution.
	Error *AiAgentEventExecuteError `json:"error,omitempty"`

	// Message The final response of asynchronous agent events execution.
	Message *string `json:"message,omitempty"`

	// MessageGenerationStarted Additional metadata to indicate that the message generation has
	// started.
	MessageGenerationStarted *AiAgentMessageGenerationStarted `json:"message_generation_started,omitempty"`

	// Progress A progress object providing the status of the AI agent event execution.
	Progress *AiAgentEventExecuteProgress `json:"progress,omitempty"`

	// Session The agent session ID to track the asynchronous execution of this
	// session.
	Session string `json:"session"`

	// SessionObject An identifier of the session with the AI agent.
	SessionObject string `json:"session_object"`

	// Suggestions A list of suggestions generated for the AI agent event.
	Suggestions *AiAgentEventSuggestions `json:"suggestions,omitempty"`
}

// EventAiAgentResponseAgentResponse defines model for EventAiAgentResponse.AgentResponse.
type EventAiAgentResponseAgentResponse string

// EventConversationCreated defines model for event-conversation-created.
type EventConversationCreated struct {
	Conversation Conversation `json:"conversation"`
}

// EventConversationDeleted defines model for event-conversation-deleted.
type EventConversationDeleted struct {
	// Id The ID of the conversation that was deleted.
	Id              string        `json:"id"`
	OldConversation *Conversation `json:"old_conversation,omitempty"`
}

// EventConversationUpdated defines model for event-conversation-updated.
type EventConversationUpdated struct {
	Conversation    Conversation  `json:"conversation"`
	OldConversation *Conversation `json:"old_conversation,omitempty"`
}

// EventDashboardCreated defines model for event-dashboard-created.
type EventDashboardCreated struct {
	Dashboard Dashboard `json:"dashboard"`
}

// EventDashboardDeleted defines model for event-dashboard-deleted.
type EventDashboardDeleted struct {
	// Id The ID of the dashboard that was deleted.
	Id           string     `json:"id"`
	OldDashboard *Dashboard `json:"old_dashboard,omitempty"`
}

// EventDashboardUpdated defines model for event-dashboard-updated.
type EventDashboardUpdated struct {
	Dashboard    Dashboard  `json:"dashboard"`
	OldDashboard *Dashboard `json:"old_dashboard,omitempty"`
}

// EventDevUserCreated defines model for event-dev-user-created.
type EventDevUserCreated struct {
	DevUser DevUser `json:"dev_user"`
}

// EventDevUserDeleted defines model for event-dev-user-deleted.
type EventDevUserDeleted struct {
	// Id The ID of the Dev user that was deleted.
	Id         string   `json:"id"`
	OldDevUser *DevUser `json:"old_dev_user,omitempty"`
}

// EventDevUserUpdated defines model for event-dev-user-updated.
type EventDevUserUpdated struct {
	DevUser    DevUser  `json:"dev_user"`
	OldDevUser *DevUser `json:"old_dev_user,omitempty"`
}

// EventFetchedResult defines model for event-fetched-result.
type EventFetchedResult string

// EventGroupCreated defines model for event-group-created.
type EventGroupCreated struct {
	Group Group `json:"group"`
}

// EventGroupDeleted defines model for event-group-deleted.
type EventGroupDeleted struct {
	// Id The ID of the group that was deleted.
	Id       string `json:"id"`
	OldGroup *Group `json:"old_group,omitempty"`
}

// EventGroupMemberAdded defines model for event-group-member-added.
type EventGroupMemberAdded struct {
	Group  GroupSummary `json:"group"`
	Member UserSummary  `json:"member"`
}

// EventGroupMemberRemoved defines model for event-group-member-removed.
type EventGroupMemberRemoved struct {
	Group  GroupSummary `json:"group"`
	Member UserSummary  `json:"member"`
}

// EventGroupUpdated defines model for event-group-updated.
type EventGroupUpdated struct {
	Group    Group  `json:"group"`
	OldGroup *Group `json:"old_group,omitempty"`
}

// EventIncidentCreated defines model for event-incident-created.
type EventIncidentCreated struct {
	Incident Incident `json:"incident"`
}

// EventIncidentDeleted defines model for event-incident-deleted.
type EventIncidentDeleted struct {
	// Id The ID of the incident that was deleted.
	Id          string    `json:"id"`
	OldIncident *Incident `json:"old_incident,omitempty"`
}

// EventIncidentUpdated defines model for event-incident-updated.
type EventIncidentUpdated struct {
	Incident    Incident  `json:"incident"`
	OldIncident *Incident `json:"old_incident,omitempty"`
}

// EventLinkCreated defines model for event-link-created.
type EventLinkCreated struct {
	Link Link `json:"link"`
}

// EventLinkDeleted defines model for event-link-deleted.
type EventLinkDeleted struct {
	// Id The ID of the link that was deleted.
	Id string `json:"id"`
}

// EventLinkUpdated defines model for event-link-updated.
type EventLinkUpdated struct {
	Link    Link  `json:"link"`
	OldLink *Link `json:"old_link,omitempty"`
}

// EventPartCreated defines model for event-part-created.
type EventPartCreated struct {
	Part Part `json:"part"`
}

// EventPartDeleted defines model for event-part-deleted.
type EventPartDeleted struct {
	// Id The ID of the part that was deleted.
	Id      string `json:"id"`
	OldPart *Part  `json:"old_part,omitempty"`
}

// EventPartUpdated defines model for event-part-updated.
type EventPartUpdated struct {
	OldPart *Part `json:"old_part,omitempty"`
	Part    Part  `json:"part"`
}

// EventQuestionAnswerCreated defines model for event-question-answer-created.
type EventQuestionAnswerCreated struct {
	QuestionAnswer QuestionAnswer `json:"question_answer"`
}

// EventQuestionAnswerDeleted defines model for event-question-answer-deleted.
type EventQuestionAnswerDeleted struct {
	// Id The ID of the question-answer that was deleted.
	Id                string          `json:"id"`
	OldQuestionAnswer *QuestionAnswer `json:"old_question_answer,omitempty"`
}

// EventQuestionAnswerUpdated defines model for event-question-answer-updated.
type EventQuestionAnswerUpdated struct {
	OldQuestionAnswer *QuestionAnswer `json:"old_question_answer,omitempty"`
	QuestionAnswer    QuestionAnswer  `json:"question_answer"`
}

// EventRevOrgCreated defines model for event-rev-org-created.
type EventRevOrgCreated struct {
	RevOrg RevOrg `json:"rev_org"`
}

// EventRevOrgDeleted defines model for event-rev-org-deleted.
type EventRevOrgDeleted struct {
	// Id The ID of the Rev organization that was deleted.
	Id        string  `json:"id"`
	OldRevOrg *RevOrg `json:"old_rev_org,omitempty"`
}

// EventRevOrgUpdated defines model for event-rev-org-updated.
type EventRevOrgUpdated struct {
	OldRevOrg *RevOrg `json:"old_rev_org,omitempty"`
	RevOrg    RevOrg  `json:"rev_org"`
}

// EventRevUserCreated defines model for event-rev-user-created.
type EventRevUserCreated struct {
	RevUser RevUser `json:"rev_user"`
}

// EventRevUserDeleted defines model for event-rev-user-deleted.
type EventRevUserDeleted struct {
	// Id The ID of the Rev user that was deleted.
	Id         string   `json:"id"`
	OldRevUser *RevUser `json:"old_rev_user,omitempty"`
}

// EventRevUserUpdated defines model for event-rev-user-updated.
type EventRevUserUpdated struct {
	OldRevUser *RevUser `json:"old_rev_user,omitempty"`
	RevUser    RevUser  `json:"rev_user"`
}

// EventSlaTrackerCreated defines model for event-sla-tracker-created.
type EventSlaTrackerCreated struct {
	SlaTracker SlaTracker `json:"sla_tracker"`
}

// EventSlaTrackerDeleted defines model for event-sla-tracker-deleted.
type EventSlaTrackerDeleted struct {
	// Id The ID of the SLA tracker that was deleted.
	Id            string      `json:"id"`
	OldSlaTracker *SlaTracker `json:"old_sla_tracker,omitempty"`
}

// EventSlaTrackerFetched defines model for event-sla-tracker-fetched.
type EventSlaTrackerFetched struct {
	// Id The ID of the SLA tracker that was fetched.
	Id     string             `json:"id"`
	Result EventFetchedResult `json:"result"`
	union  json.RawMessage
}

// EventSlaTrackerFetchedOk defines model for event-sla-tracker-fetched-ok.
type EventSlaTrackerFetchedOk struct {
	SlaTracker *SlaTracker `json:"sla_tracker,omitempty"`
}

// EventSlaTrackerUpdated defines model for event-sla-tracker-updated.
type EventSlaTrackerUpdated struct {
	OldSlaTracker *SlaTracker `json:"old_sla_tracker,omitempty"`
	SlaTracker    SlaTracker  `json:"sla_tracker"`
}

// EventSurveyCreated defines model for event-survey-created.
type EventSurveyCreated struct {
	Survey Survey `json:"survey"`
}

// EventSurveyDeleted defines model for event-survey-deleted.
type EventSurveyDeleted struct {
	// Id The ID of the survey that was deleted.
	Id        string  `json:"id"`
	OldSurvey *Survey `json:"old_survey,omitempty"`
}

// EventSurveyResponseCreated defines model for event-survey-response-created.
type EventSurveyResponseCreated struct {
	SurveyResponse SurveyResponse `json:"survey_response"`
}

// EventSurveyResponseDeleted defines model for event-survey-response-deleted.
type EventSurveyResponseDeleted struct {
	// Id The ID of the survey response that was deleted.
	Id                string          `json:"id"`
	OldSurveyResponse *SurveyResponse `json:"old_survey_response,omitempty"`
}

// EventSurveyResponseUpdated defines model for event-survey-response-updated.
type EventSurveyResponseUpdated struct {
	OldSurveyResponse *SurveyResponse `json:"old_survey_response,omitempty"`
	SurveyResponse    SurveyResponse  `json:"survey_response"`
}

// EventSurveyUpdated defines model for event-survey-updated.
type EventSurveyUpdated struct {
	OldSurvey *Survey `json:"old_survey,omitempty"`
	Survey    Survey  `json:"survey"`
}

// EventSyncHistoryCreated defines model for event-sync-history-created.
type EventSyncHistoryCreated struct {
	SyncHistory SyncHistory `json:"sync_history"`
}

// EventSyncHistoryDeleted defines model for event-sync-history-deleted.
type EventSyncHistoryDeleted struct {
	// Id The ID of the sync history that was deleted.
	Id string `json:"id"`
}

// EventSyncHistoryUpdated defines model for event-sync-history-updated.
type EventSyncHistoryUpdated struct {
	OldSyncHistory *SyncHistory `json:"old_sync_history,omitempty"`
	SyncHistory    SyncHistory  `json:"sync_history"`
}

// EventTagCreated defines model for event-tag-created.
type EventTagCreated struct {
	Tag Tag `json:"tag"`
}

// EventTagDeleted defines model for event-tag-deleted.
type EventTagDeleted struct {
	// Id The ID of the tag that was deleted.
	Id     string `json:"id"`
	OldTag *Tag   `json:"old_tag,omitempty"`
}

// EventTagUpdated defines model for event-tag-updated.
type EventTagUpdated struct {
	OldTag *Tag `json:"old_tag,omitempty"`
	Tag    Tag  `json:"tag"`
}

// EventTimelineEntryCreated defines model for event-timeline-entry-created.
type EventTimelineEntryCreated struct {
	Entry TimelineEntry `json:"entry"`
}

// EventTimelineEntryDeleted defines model for event-timeline-entry-deleted.
type EventTimelineEntryDeleted struct {
	// Id The ID of the timeline entry that was deleted.
	Id       string         `json:"id"`
	OldEntry *TimelineEntry `json:"old_entry,omitempty"`
}

// EventTimelineEntryUpdated defines model for event-timeline-entry-updated.
type EventTimelineEntryUpdated struct {
	Entry    TimelineEntry  `json:"entry"`
	OldEntry *TimelineEntry `json:"old_entry,omitempty"`

	// Reactions The reactions that were performed.
	Reactions *[]EventTimelineEntryUpdatedReaction `json:"reactions,omitempty"`
}

// EventTimelineEntryUpdatedReaction defines model for event-timeline-entry-updated-reaction.
type EventTimelineEntryUpdatedReaction struct {
	Action EventTimelineEntryUpdatedReactionAction `json:"action"`

	// Emoji The emoji for the reaction.
	Emoji   string       `json:"emoji"`
	Reactor *UserSummary `json:"reactor,omitempty"`
}

// EventTimelineEntryUpdatedReactionAction defines model for event-timeline-entry-updated-reaction-action.
type EventTimelineEntryUpdatedReactionAction string

// EventWebhookCreated defines model for event-webhook-created.
type EventWebhookCreated struct {
	Webhook Webhook `json:"webhook"`
}

// EventWebhookDeleted defines model for event-webhook-deleted.
type EventWebhookDeleted struct {
	// Id The ID of the webhook that was deleted.
	Id string `json:"id"`
}

// EventWebhookUpdated defines model for event-webhook-updated.
type EventWebhookUpdated struct {
	Webhook Webhook `json:"webhook"`
}

// EventWidgetCreated defines model for event-widget-created.
type EventWidgetCreated struct {
	Widget Widget `json:"widget"`
}

// EventWidgetDeleted defines model for event-widget-deleted.
type EventWidgetDeleted struct {
	// Id The ID of the widget that was deleted.
	Id        string  `json:"id"`
	OldWidget *Widget `json:"old_widget,omitempty"`
}

// EventWidgetUpdated defines model for event-widget-updated.
type EventWidgetUpdated struct {
	OldWidget *Widget `json:"old_widget,omitempty"`
	Widget    Widget  `json:"widget"`
}

// EventWorkCreated defines model for event-work-created.
type EventWorkCreated struct {
	Work Work `json:"work"`
}

// EventWorkDeleted defines model for event-work-deleted.
type EventWorkDeleted struct {
	// Id The ID of the work that was deleted.
	Id      string `json:"id"`
	OldWork *Work  `json:"old_work,omitempty"`
}

// EventWorkFetched defines model for event-work-fetched.
type EventWorkFetched struct {
	// Id The ID of the work that was fetched.
	Id     string             `json:"id"`
	Result EventFetchedResult `json:"result"`
	union  json.RawMessage
}

// EventWorkFetchedOk defines model for event-work-fetched-ok.
type EventWorkFetchedOk struct {
	Work *Work `json:"work,omitempty"`
}

// EventWorkUpdated defines model for event-work-updated.
type EventWorkUpdated struct {
	OldWork *Work `json:"old_work,omitempty"`
	Work    Work  `json:"work"`
}

// ExternalCommunicationChannelSummary defines model for external-communication-channel-summary.
type ExternalCommunicationChannelSummary = AtomBaseSummary

// ExternalIdentity External identity of a user.
type ExternalIdentity struct {
	// DisplayName Display name of the user in the external source.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Unique ID of the user in the external source.
	Id *string `json:"id,omitempty"`

	// IsVerified Whether the external identity is verified or not.
	IsVerified *bool `json:"is_verified,omitempty"`

	// Issuer Issuer of the external identity of the user.
	Issuer *string `json:"issuer,omitempty"`
}

// Feature defines model for feature.
type Feature = PartBase

// FeatureSummary defines model for feature-summary.
type FeatureSummary = PartBaseSummary

// FieldDescriptor Set of field attributes.
type FieldDescriptor = map[string]interface{}

// Group defines model for group.
type Group = AtomBase

// GroupIngestionSource Creation source of the group.
type GroupIngestionSource string

// GroupMemberType Type of the members in the group.
type GroupMemberType string

// GroupMembersAddRequest A request to add a new member to a group.
type GroupMembersAddRequest struct {
	// Group ID of the group where the member is being added.
	Group string `json:"group"`

	// Member ID of the member to be added.
	Member string `json:"member"`

	// MemberRevOrg Rev org of the rev user to be added. This should be specified only
	// if the member is a rev user
	MemberRevOrg *string `json:"member_rev_org,omitempty"`
}

// GroupMembersAddResponseBody defines model for group-members-add-response.
type GroupMembersAddResponseBody = map[string]interface{}

// GroupMembersListRequest A request to list group members.
type GroupMembersListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Group ID of the group for which to list members.
	Group string `json:"group"`

	// Limit The maximum number of members to return. If not set, then the
	// default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`
}

// GroupMembersListResponseBody List of group members.
type GroupMembersListResponseBody struct {
	// Members List of members.
	Members []GroupMembersListResponseMember `json:"members"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// GroupMembersListResponseMember A group member.
type GroupMembersListResponseMember struct {
	Member       MemberSummary  `json:"member"`
	MemberRevOrg *RevOrgSummary `json:"member_rev_org,omitempty"`
}

// GroupMembersRemoveRequest A request to remove a group member.
type GroupMembersRemoveRequest struct {
	// Group ID of the group where the member is being removed.
	Group string `json:"group"`

	// Member ID of the member to be removed.
	Member string `json:"member"`

	// MemberRevOrg Rev org of the rev user to be removed. This should be specified
	// only if the member is a rev user
	MemberRevOrg *string `json:"member_rev_org,omitempty"`
}

// GroupMembersRemoveResponseBody defines model for group-members-remove-response.
type GroupMembersRemoveResponseBody = map[string]interface{}

// GroupSummary defines model for group-summary.
type GroupSummary = AtomBaseSummary

// GroupType Type of the group.
type GroupType string

// GroupsCreateRequest A request to create a new group.
type GroupsCreateRequest struct {
	// Description Description of the group.
	Description string `json:"description"`

	// DynamicGroupInfo Information to define dynamic groups.
	DynamicGroupInfo *DynamicGroupInfo `json:"dynamic_group_info,omitempty"`

	// MemberType Type of the members in the group.
	MemberType *GroupMemberType `json:"member_type,omitempty"`

	// Name Unique name of the group.
	Name string `json:"name"`

	// Owner Owner of the group.
	Owner *string `json:"owner,omitempty"`

	// Type Type of the group.
	Type *GroupType `json:"type,omitempty"`
}

// GroupsCreateResponseBody The response to group creation.
type GroupsCreateResponseBody struct {
	Group Group `json:"group"`
}

// GroupsGetRequest A request to get information about a group.
type GroupsGetRequest struct {
	// Id The ID of the group to get.
	Id string `json:"id"`
}

// GroupsGetResponseBody The response to getting the group.
type GroupsGetResponseBody struct {
	Group Group `json:"group"`
}

// GroupsListRequest A request to get information about a list of groups.
type GroupsListRequest struct {
	// CreatedBy Filters the groups on the basis of creator.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// GroupType Filters the groups based on the group type.
	GroupType *[]GroupType `json:"group_type,omitempty"`

	// IngestionSource Filter groups by ingestion source(s).
	IngestionSource *[]GroupIngestionSource `json:"ingestion_source,omitempty"`

	// IsDefault Whether to fetch default or custom groups.
	IsDefault *bool `json:"is_default,omitempty"`

	// Limit The maximum number of groups to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// MemberType Filters the groups on basis of member type.
	MemberType *[]GroupMemberType `json:"member_type,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Name Filters the groups on the basis of group name.
	Name *[]string `json:"name,omitempty"`

	// SortBy Comma-separated fields to sort the groups by.
	SortBy       *[]string           `json:"sort_by,omitempty"`
	SyncMetadata *SyncMetadataFilter `json:"sync_metadata,omitempty"`
}

// GroupsListResponseBody The response to listing the groups.
type GroupsListResponseBody struct {
	// Groups The list of groups.
	Groups []Group `json:"groups"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// GroupsUpdateRequest A request to update a group.
type GroupsUpdateRequest struct {
	// Description The updated group's description.
	Description      *string                              `json:"description,omitempty"`
	DynamicGroupInfo *GroupsUpdateRequestDynamicGroupInfo `json:"dynamic_group_info,omitempty"`

	// Id The ID of the group to update.
	Id string `json:"id"`

	// Name The updated group's name.
	Name *string `json:"name,omitempty"`

	// Owner The updated group's owner.
	Owner *string `json:"owner"`
}

// GroupsUpdateRequestDynamicGroupInfo defines model for groups-update-request-dynamic-group-info.
type GroupsUpdateRequestDynamicGroupInfo struct {
	// MembershipExpression Boolean expression.
	MembershipExpression BooleanExpression `json:"membership_expression"`
}

// GroupsUpdateResponseBody The response to group update.
type GroupsUpdateResponseBody struct {
	Group Group `json:"group"`
}

// ImpactedCustomerDetails Details of the impact due to the incident.
type ImpactedCustomerDetails struct {
	// Count The properties of an enum value.
	Count *EnumValue `json:"count,omitempty"`

	// CustomerIds List of customers impacted due to the incident.
	CustomerIds *[]AccountSummary `json:"customer_ids,omitempty"`
}

// Incident defines model for incident.
type Incident struct {
	// AcknowledgedDate Timestamp when the incident was acknowledged.
	AcknowledgedDate *time.Time `json:"acknowledged_date,omitempty"`

	// AppliesToParts Parts to which the incident is applicable to.
	AppliesToParts *[]PartSummary `json:"applies_to_parts,omitempty"`

	// Artifacts Artifacts attached to the incident.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body Body of the incident.
	Body      *string      `json:"body,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IdentifiedDate Time when the incident was identified/reported.
	IdentifiedDate *time.Time `json:"identified_date,omitempty"`

	// Impact Details of the impact due to the incident.
	Impact *ImpactedCustomerDetails `json:"impact,omitempty"`

	// MitigatedDate Timestamp when the incident was mitigated.
	MitigatedDate *time.Time   `json:"mitigated_date,omitempty"`
	ModifiedBy    *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy The users that own the incident.
	OwnedBy *[]UserSummary `json:"owned_by,omitempty"`

	// ReportedBy The properties of an enum value.
	ReportedBy *EnumValue `json:"reported_by,omitempty"`

	// Severity The properties of an enum value.
	Severity *EnumValue `json:"severity,omitempty"`

	// Source The properties of an enum value.
	Source *EnumValue `json:"source,omitempty"`

	// Stage Describes the current stage of a object.
	Stage *Stage `json:"stage,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the incident is expected to be resolved.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the incident.
	Title string `json:"title"`
}

// InstantEvaluation defines model for instant-evaluation.
type InstantEvaluation struct {
	// At The time instant evaluated.
	At time.Time `json:"at"`

	// Definedness Indicates whether this evaluation can change in the future.
	Definedness Definedness `json:"definedness"`

	// IsActive Active state of the organization schedule at the time instant.
	IsActive *bool `json:"is_active,omitempty"`

	// NextTransition Next instant at which the active state of the organization schedule
	// changes, for example, if the schedule is currently off, the next
	// instant at which it will be on.
	NextTransition *time.Time `json:"next_transition,omitempty"`
}

// Issue defines model for issue.
type Issue struct {
	AppliesToPart *PartSummary `json:"applies_to_part,omitempty"`

	// Artifacts The artifacts attached to the work item.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body Body of the work object.
	Body      *string      `json:"body,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DevelopedWith Parts associated based on git events.
	DevelopedWith *[]PartSummary `json:"developed_with,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *IssuePriority `json:"priority,omitempty"`

	// PriorityV2 The properties of an enum value.
	PriorityV2 *EnumValue `json:"priority_v2,omitempty"`

	// ReportedBy Users that reported the work.
	ReportedBy *[]UserSummary `json:"reported_by,omitempty"`

	// SlaSummary SLA summary for the object.
	SlaSummary *ArchetypeSlaSummary `json:"sla_summary,omitempty"`
	SlaTracker *SlaTrackerSummary   `json:"sla_tracker,omitempty"`

	// Sprint Vista group item.
	Sprint *VistaGroupItemSummary `json:"sprint,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStage `json:"stage,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// TargetStartDate Target start date for the object.
	TargetStartDate *time.Time `json:"target_start_date,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// IssuePriority Priority of the work based upon impact and criticality.
type IssuePriority string

// IssueSummary defines model for issue-summary.
type IssueSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *IssuePriority `json:"priority,omitempty"`

	// PriorityV2 The properties of an enum value.
	PriorityV2 *EnumValueSummary `json:"priority_v2,omitempty"`

	// Sprint Vista group item.
	Sprint *VistaGroupItemSummary `json:"sprint,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStageSummary `json:"stage,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// JobHistoryItem Defines a job history line item.
type JobHistoryItem struct {
	// EmploymentStatus The properties of an enum value.
	EmploymentStatus *EnumValue `json:"employment_status,omitempty"`

	// EndDate The end date of the job, or not specified if current.
	EndDate *time.Time `json:"end_date,omitempty"`

	// IsCurrent Is this the current active job for the user.
	IsCurrent *bool `json:"is_current,omitempty"`

	// Location The job location for the user.
	Location *string `json:"location,omitempty"`

	// StartDate The start date of the job.
	StartDate *time.Time `json:"start_date,omitempty"`

	// Title The job title for the user.
	Title *string `json:"title,omitempty"`
}

// KeyringsCreateCallbackRequest defines model for keyrings-create-callback-request.
type KeyringsCreateCallbackRequest struct {
	// Code Code to exchange for an access token.
	Code string `json:"code"`

	// State State value given to the authorization request.
	State string `json:"state"`
}

// LegacyStage Describes the current stage of a work item.
type LegacyStage struct {
	// Name Current stage name of the work item.
	Name string `json:"name"`
}

// LegacyStageSummary Describes the current stage of a work item.
type LegacyStageSummary struct {
	// Name Current stage name of the work item.
	Name string `json:"name"`
}

// LinesOfCode Details of lines of code in this code change.
type LinesOfCode struct {
	// FileCount Count of files involved in this code change.
	FileCount *int64 `json:"file_count,omitempty"`

	// LinesAdded Number of new lines added in this code change.
	LinesAdded *int64 `json:"lines_added,omitempty"`

	// LinesDeleted Number of lines deleted in this code change.
	LinesDeleted *int64 `json:"lines_deleted,omitempty"`

	// LinesModified Number of lines modified in this code change.
	LinesModified *int64 `json:"lines_modified,omitempty"`
}

// Link defines model for link.
type Link struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// LinkType Type of link used to define the relationship.
	LinkType   LinkType     `json:"link_type"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time          `json:"modified_date,omitempty"`
	Source       LinkEndpointSummary `json:"source"`
	Target       LinkEndpointSummary `json:"target"`
}

// LinkEndpointSummary defines model for link-endpoint-summary.
type LinkEndpointSummary struct {
	Type  LinkEndpointType `json:"type"`
	union json.RawMessage
}

// LinkEndpointType defines model for link-endpoint-type.
type LinkEndpointType string

// LinkSummary defines model for link-summary.
type LinkSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// LinkType Type of link used to define the relationship.
	LinkType LinkType            `json:"link_type"`
	Source   LinkEndpointSummary `json:"source"`
	Target   LinkEndpointSummary `json:"target"`
}

// LinkType Type of link used to define the relationship.
type LinkType string

// LinksCreateRequest The request to create a new link.
type LinksCreateRequest struct {
	// CustomLinkType The ID of the custom link type.
	CustomLinkType *string `json:"custom_link_type,omitempty"`

	// LinkType Type of link used to define the relationship.
	LinkType LinkType `json:"link_type"`

	// Source The ID of the source object.
	Source string `json:"source"`

	// Target The ID of the target object.
	Target string `json:"target"`
}

// LinksCreateResponseBody The response to creating a new link.
type LinksCreateResponseBody struct {
	Link Link `json:"link"`
}

// LinksDeleteRequest The request to delete a link.
type LinksDeleteRequest struct {
	// Id The ID of the link to delete.
	Id string `json:"id"`
}

// LinksDeleteResponseBody The response for deleting a link.
type LinksDeleteResponseBody = map[string]interface{}

// LinksDirection The direction of link, which can either be outbound such that the
// object is the source of the link, otherwise inbound where the object is
// the target of the link.
type LinksDirection string

// LinksGetRequest The request to get a link's information.
type LinksGetRequest struct {
	// Id The requested link's ID.
	Id string `json:"id"`
}

// LinksGetResponseBody The response to getting a link's information.
type LinksGetResponseBody struct {
	Link Link `json:"link"`
}

// LinksListRequest The request to get information about a list of links.
type LinksListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Direction The direction of link, which can either be outbound such that the
	// object is the source of the link, otherwise inbound where the object is
	// the target of the link.
	Direction *LinksDirection `json:"direction,omitempty"`

	// Limit The maximum number of links to return. If not set, then the default
	// is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// LinkType The link type(s) to filter for, otherwise if not present, all link
	// types are included.
	LinkType *[]LinkType `json:"link_type,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Object The ID of the object to list the links for.
	Object string `json:"object"`

	// ObjectTypes The object types to filter for, otherwise if not present, all
	// object types are included.
	ObjectTypes *[]LinkEndpointType `json:"object_types,omitempty"`

	// Types The link types to filter for, otherwise if not present, all link
	// types are included.
	// Deprecated:
	Types *[]LinkType `json:"types,omitempty"`
}

// LinksListResponseBody The response to listing the links.
type LinksListResponseBody struct {
	// Links The list of links.
	Links []Link `json:"links"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// LinksReplaceRequest The request to replace a link.
type LinksReplaceRequest struct {
	// Id The ID of the link to be replaced.
	Id string `json:"id"`

	// LinkType Type of link used to define the relationship.
	LinkType LinkType `json:"link_type"`

	// Source The ID of the source object.
	Source string `json:"source"`

	// Target The ID of the target object.
	Target string `json:"target"`
}

// LinksReplaceResponseBody The response to replacing a link.
type LinksReplaceResponseBody struct {
	Link Link `json:"link"`
}

// ListMode The iteration mode to use. If "after", then entries after the provided
// cursor will be returned, or if no cursor is provided, then from the
// beginning. If "before", then entries before the provided cursor will be
// returned, or if no cursor is provided, then from the end. Entries will
// always be returned in the specified sort-by order.
type ListMode string

// Meeting defines model for meeting.
type Meeting = AtomBase

// MeetingChannel The channel of meeting.
type MeetingChannel string

// MeetingState The state of meeting.
type MeetingState string

// MeetingsCountRequest defines model for meetings-count-request.
type MeetingsCountRequest struct {
	// Channel Filters for meeting on specified channels.
	Channel *[]MeetingChannel `json:"channel,omitempty"`

	// CreatedBy Filters for meetings created by the specified user(s).
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// EndedDate Provides ways to specify date ranges on objects.
	EndedDate *DateFilter `json:"ended_date,omitempty"`

	// ExternalRef Filters for meetings with the provided external_ref(s).
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// Links Filters for links associated with the meeting.
	Links *[]MeetingsFilterLinkSummaryFilter `json:"links,omitempty"`

	// Members Filter for meeting on specified Member Ids.
	Members *[]string `json:"members,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// Organizer Filter for meeting on specified organizers.
	Organizer *[]string `json:"organizer,omitempty"`

	// Parent Filters for meetings with the provided parent.
	// Deprecated:
	Parent *[]string `json:"parent,omitempty"`

	// ScheduledDate Provides ways to specify date ranges on objects.
	ScheduledDate *DateFilter `json:"scheduled_date,omitempty"`

	// State Filters for meeting on specified state or outcomes.
	State *[]MeetingState `json:"state,omitempty"`
}

// MeetingsCountResponseBody defines model for meetings-count-response.
type MeetingsCountResponseBody struct {
	// Count The number of meetings matching the filter.
	Count int64 `json:"count"`
}

// MeetingsCreateRequest defines model for meetings-create-request.
type MeetingsCreateRequest struct {
	// Channel The channel of meeting.
	Channel MeetingChannel `json:"channel"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description The description of the meeting.
	Description *string `json:"description,omitempty"`

	// EndedDate Time at which meeting ended.
	EndedDate *time.Time `json:"ended_date,omitempty"`

	// ExternalRef External reference for the meeting.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalUrl External URL for the meeting.
	ExternalUrl *string `json:"external_url,omitempty"`

	// Members IDs of the users that were part of the meeting.
	Members []string `json:"members"`

	// Organizer The ID of the user who organized the meeting. If not provided, the
	// creator is set as the organizer.
	Organizer *string `json:"organizer,omitempty"`

	// Parent The parent object ID in which the meeting was created.
	// Deprecated:
	Parent *string `json:"parent,omitempty"`

	// RecordingUrl The recording URL of the meeting.
	RecordingUrl *string `json:"recording_url,omitempty"`

	// ScheduledDate The date and time when the meeting was scheduled.
	ScheduledDate *time.Time `json:"scheduled_date,omitempty"`

	// State The state of meeting.
	State MeetingState `json:"state"`

	// Tags Tags associated with the meeting.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Title The title of the meeting.
	Title string `json:"title"`
}

// MeetingsCreateResponseBody defines model for meetings-create-response.
type MeetingsCreateResponseBody struct {
	Meeting Meeting `json:"meeting"`
}

// MeetingsDeleteRequest defines model for meetings-delete-request.
type MeetingsDeleteRequest struct {
	// Id The meeting's ID.
	Id string `json:"id"`
}

// MeetingsDeleteResponseBody defines model for meetings-delete-response.
type MeetingsDeleteResponseBody = map[string]interface{}

// MeetingsFilterLinkSummaryFilter The filter for the link summary.
type MeetingsFilterLinkSummaryFilter struct {
	// LinkType Filters for link type in links associated with the meeting.
	LinkType *string `json:"link_type,omitempty"`

	// Target Filters for target id in links associated with the meeting.
	Target *string `json:"target,omitempty"`

	// TargetObjectType Filters for target object type in links associated with the
	// meeting.
	TargetObjectType *string `json:"target_object_type,omitempty"`
}

// MeetingsGetRequest defines model for meetings-get-request.
type MeetingsGetRequest struct {
	// Id The meeting's ID.
	Id string `json:"id"`
}

// MeetingsGetResponseBody defines model for meetings-get-response.
type MeetingsGetResponseBody struct {
	Meeting Meeting `json:"meeting"`
}

// MeetingsListRequest defines model for meetings-list-request.
type MeetingsListRequest struct {
	// Channel Filters for meeting on specified channels.
	Channel *[]MeetingChannel `json:"channel,omitempty"`

	// CreatedBy Filters for meetings created by the specified user(s).
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// EndedDate Provides ways to specify date ranges on objects.
	EndedDate *DateFilter `json:"ended_date,omitempty"`

	// ExternalRef Filters for meetings with the provided external_ref(s).
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// Limit The maximum number of meetings to return.
	Limit *int32 `json:"limit,omitempty"`

	// Links Filters for links associated with the meeting.
	Links *[]MeetingsFilterLinkSummaryFilter `json:"links,omitempty"`

	// Members Filter for meeting on specified Member Ids.
	Members *[]string `json:"members,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// Organizer Filter for meeting on specified organizers.
	Organizer *[]string `json:"organizer,omitempty"`

	// Parent Filters for meetings with the provided parent.
	// Deprecated:
	Parent *[]string `json:"parent,omitempty"`

	// ScheduledDate Provides ways to specify date ranges on objects.
	ScheduledDate *DateFilter `json:"scheduled_date,omitempty"`

	// SortBy Fields to sort the meetings by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// State Filters for meeting on specified state or outcomes.
	State *[]MeetingState `json:"state,omitempty"`
}

// MeetingsListResponseBody defines model for meetings-list-response.
type MeetingsListResponseBody struct {
	// Meetings The list of meetings.
	Meetings []Meeting `json:"meetings"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// MeetingsUpdateRequest defines model for meetings-update-request.
type MeetingsUpdateRequest struct {
	// Channel The channel of meeting.
	Channel *MeetingChannel `json:"channel,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description The description of the meeting.
	Description *string `json:"description,omitempty"`

	// EndedDate Updates the date and time when the meeting ended.
	EndedDate *time.Time `json:"ended_date"`

	// ExternalRef External Reference for the meeting.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalUrl External URL for the meeting.
	ExternalUrl *string `json:"external_url,omitempty"`

	// Id The meetings ID.
	Id      string                        `json:"id"`
	Members *MeetingsUpdateRequestMembers `json:"members,omitempty"`

	// Organizer The ID of the user who organized the meeting.
	Organizer *string `json:"organizer,omitempty"`

	// Recording The ID of the meeting's recording artifact.
	Recording *string `json:"recording"`

	// RecordingUrl The recording URL of the meeting.
	RecordingUrl *string `json:"recording_url,omitempty"`

	// ScheduledDate Updates the date and time when the meeting was scheduled.
	ScheduledDate *time.Time `json:"scheduled_date"`

	// State The state of meeting.
	State *MeetingState              `json:"state,omitempty"`
	Tags  *MeetingsUpdateRequestTags `json:"tags,omitempty"`

	// Title The title of the meeting.
	Title *string `json:"title,omitempty"`

	// Transcript The ID of the artifact for the transcript of the meeting.
	Transcript *string `json:"transcript,omitempty"`
}

// MeetingsUpdateRequestMembers defines model for meetings-update-request-members.
type MeetingsUpdateRequestMembers struct {
	// Set Sets the members to the provided user IDs. This must not be empty.
	Set *[]string `json:"set,omitempty"`
}

// MeetingsUpdateRequestTags defines model for meetings-update-request-tags.
type MeetingsUpdateRequestTags struct {
	// Set Sets the provided tags on the meeting item.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// MeetingsUpdateResponseBody defines model for meetings-update-response.
type MeetingsUpdateResponseBody struct {
	Meeting Meeting `json:"meeting"`
}

// MemberSummary defines model for member-summary.
type MemberSummary struct {
	Type  MemberType `json:"type"`
	union json.RawMessage
}

// MemberType defines model for member-type.
type MemberType string

// MetricActionExecuteRequest defines model for metric-action-execute-request.
type MetricActionExecuteRequest struct {
	Action MetricActionExecuteRequestAction `json:"action"`

	// EventDate Timestamp of the event.
	EventDate time.Time `json:"event_date"`

	// Metric The metric's ID for which the metric action is to be executed.
	Metric string `json:"metric"`

	// Object The underlying object's ID on which the metric action is to be
	// executed.
	Object string `json:"object"`
}

// MetricActionExecuteRequestAction defines model for metric-action-execute-request-action.
type MetricActionExecuteRequestAction string

// MetricActionExecuteResponseBody defines model for metric-action-execute-response.
type MetricActionExecuteResponseBody = map[string]interface{}

// MetricDefinition defines model for metric-definition.
type MetricDefinition struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Human readable name of the metric.
	Name *string `json:"name,omitempty"`
}

// MetricDefinitionAppliesTo The list of item types on which the metric might be applied.
type MetricDefinitionAppliesTo string

// MetricDefinitionMetricType The type of the metric. 'time' metrics track the time spent in some
// state, supporting operations like 'start', 'stop', 'pause', 'resume'.
// 'value' metrics track a value, supporting operations like 'set',
// 'increment', 'decrement'.
type MetricDefinitionMetricType string

// MetricDefinitionStatus The status of the metric. 'active' metrics can be used to create new
// SLAs, while 'inactive' metrics can not be used in new SLAs. Metrics can
// be updated between 'active' and 'inactive' states.
type MetricDefinitionStatus string

// MetricDefinitionSummary defines model for metric-definition-summary.
type MetricDefinitionSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Human readable name of the metric.
	Name *string `json:"name,omitempty"`
}

// MetricDefinitionsCreateRequest defines model for metric-definitions-create-request.
type MetricDefinitionsCreateRequest struct {
	// AppliesTo The list of object types on which the metric can be applied.
	AppliesTo []MetricDefinitionAppliesTo `json:"applies_to"`

	// Description Description of the purpose and operation of the metric.
	Description *string `json:"description,omitempty"`

	// Name A unique human readable name of the metric.
	Name string `json:"name"`
}

// MetricDefinitionsCreateResponseBody defines model for metric-definitions-create-response.
type MetricDefinitionsCreateResponseBody struct {
	MetricDefinition MetricDefinition `json:"metric_definition"`
}

// MetricDefinitionsDeleteRequest defines model for metric-definitions-delete-request.
type MetricDefinitionsDeleteRequest struct {
	// Id The ID of the metric definition to be deleted.
	Id string `json:"id"`
}

// MetricDefinitionsDeleteResponseBody The response to deleting a metric definition.
type MetricDefinitionsDeleteResponseBody = map[string]interface{}

// MetricDefinitionsGetRequest defines model for metric-definitions-get-request.
type MetricDefinitionsGetRequest struct {
	// Id The ID of the metric definition to get.
	Id *string `json:"id,omitempty"`

	// Name The unique human readable name of the metric.
	Name *string `json:"name,omitempty"`
}

// MetricDefinitionsGetResponseBody defines model for metric-definitions-get-response.
type MetricDefinitionsGetResponseBody struct {
	MetricDefinition MetricDefinition `json:"metric_definition"`
}

// MetricDefinitionsListRequest defines model for metric-definitions-list-request.
type MetricDefinitionsListRequest struct {
	// AppliesToType The type of objects the metric definition applies to.
	AppliesToType *[]MetricDefinitionAppliesTo `json:"applies_to_type,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// IncludeCustomMetrics Whether to include custom metrics in the response. If not set, then
	// custom metrics are excluded.
	IncludeCustomMetrics *bool `json:"include_custom_metrics,omitempty"`

	// Limit The maximum number of records to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// SortBy Fields to sort the records by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Status The status of the metric definition.
	Status *[]MetricDefinitionStatus `json:"status,omitempty"`

	// Type The type of metric definitions sought.
	Type *[]MetricDefinitionMetricType `json:"type,omitempty"`
}

// MetricDefinitionsListResponseBody defines model for metric-definitions-list-response.
type MetricDefinitionsListResponseBody struct {
	// MetricDefinitions The list of metric definitions.
	MetricDefinitions []MetricDefinition `json:"metric_definitions"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// MetricDefinitionsUpdateRequest defines model for metric-definitions-update-request.
type MetricDefinitionsUpdateRequest struct {
	// Description The updated description of the purpose and operation of the metric.
	Description *string `json:"description,omitempty"`

	// Id The ID of the metric definition to update.
	Id string `json:"id"`

	// Name The updated unique human readable name of the metric.
	Name *string `json:"name,omitempty"`

	// Status The status of the metric. 'active' metrics can be used to create new
	// SLAs, while 'inactive' metrics can not be used in new SLAs. Metrics can
	// be updated between 'active' and 'inactive' states.
	Status *MetricDefinitionStatus `json:"status,omitempty"`
}

// MetricDefinitionsUpdateResponseBody defines model for metric-definitions-update-response.
type MetricDefinitionsUpdateResponseBody struct {
	MetricDefinition MetricDefinition `json:"metric_definition"`
}

// MetricTracker defines model for metric-tracker.
type MetricTracker struct {
	Type MetricTrackerType `json:"type"`
}

// MetricTrackerType defines model for metric-tracker-type.
type MetricTrackerType = string

// MetricTrackersGetRequest defines model for metric-trackers-get-request.
type MetricTrackersGetRequest struct {
	// Metric The ID of the metric that is being tracked.
	Metric string `json:"metric"`

	// Object The ID of the underlying object on which the metric is being
	// tracked.
	Object string `json:"object"`
}

// MetricTrackersGetResponseBody defines model for metric-trackers-get-response.
type MetricTrackersGetResponseBody struct {
	MetricTracker MetricTracker `json:"metric_tracker"`
}

// OrgBase defines model for org-base.
type OrgBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// OrgBaseSummary defines model for org-base-summary.
type OrgBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`
}

// OrgEnvironment The environment of the Org. Defaults to 'production' if not specified.
type OrgEnvironment string

// OrgSchedule defines model for org-schedule.
type OrgSchedule struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DefaultWeeklyOrgSchedule The schedule for each week.
	DefaultWeeklyOrgSchedule *WeeklyOrgSchedule `json:"default_weekly_org_schedule,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// MinValidDays The schedule must be valid and well-defined for at least this many
	// days in the future, otherwise a warning notification is generated.
	// Default is 0 if not specified.
	MinValidDays *int32       `json:"min_valid_days,omitempty"`
	ModifiedBy   *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Human-readable name.
	Name *string `json:"name,omitempty"`

	// OrgScheduleFragments The list of schedule fragments. It must be an ordered list of
	// contiguous fragments (the next starting when the previous one
	// ends), updates in a published schedule are only allowed to add new
	// ones to the future.
	OrgScheduleFragments *[]OrgScheduleFragmentOverview `json:"org_schedule_fragments,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleStatus `json:"status"`

	// Timezone Timezone in which this is defined. Only organization schedules in
	// the same timezone can be directly combined.
	Timezone *string `json:"timezone,omitempty"`

	// ValidUntil Derived field indicating when a valid organization schedule will
	// become invalid. If omitted, the schedule is already invalid. A
	// schedule is valid if it has a weekly schedule for all named periods
	// for all its schedule fragments, and if it has a schedule fragment
	// for the time period in question.
	ValidUntil *time.Time `json:"valid_until,omitempty"`

	// WeeklyOrgSchedules If the organization schedule fragment specifies that the given day
	// belongs to a named period, a weekly schedule from this list with
	// the matching name will be selected.
	WeeklyOrgSchedules *[]WeeklyOrgSchedule `json:"weekly_org_schedules,omitempty"`
}

// OrgScheduleFragment defines model for org-schedule-fragment.
type OrgScheduleFragment struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// From The date (inclusive) on which the organization schedule fragment
	// begins.
	From *time.Time `json:"from,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Intervals Periods during which the schedule is considered to be 'off' or to
	// be in some specific named period.
	Intervals  *[]OrgScheduleInterval `json:"intervals,omitempty"`
	ModifiedBy *UserSummary           `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Human-readable name, indicating the purpose of the schedule.
	Name *string `json:"name,omitempty"`

	// RegionCodes CLDR region code of the countries/regions it is meant to be valid
	// for. Does not drive logic, serves only for easier filtering and
	// organization.
	RegionCodes *[]string `json:"region_codes,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleFragmentStatus `json:"status"`

	// To The date (exclusive) on which the organization schedule fragment's
	// validity ends.
	To *time.Time `json:"to,omitempty"`
}

// OrgScheduleFragmentOverview The representation of the organization schedule fragment embedded
// inside a organization schedule, used to quickly look up the schedule
// fragment for the right period.
type OrgScheduleFragmentOverview = map[string]interface{}

// OrgScheduleFragmentStatus Status determines how an item can be used. In 'draft' status an item
// can be edited but can't be used. When 'published' the item can longer
// be edited but can be used. 'Archived' is read-only.
type OrgScheduleFragmentStatus string

// OrgScheduleFragmentsCreateRequest defines model for org-schedule-fragments-create-request.
type OrgScheduleFragmentsCreateRequest struct {
	// From Date (inclusive) on which the organization schedule fragment
	// begins.
	From time.Time `json:"from"`

	// Intervals The intervals that comprise the schedule fragment.
	Intervals []CreateOrgScheduleInterval `json:"intervals"`

	// Name Name of the organization schedule fragment.
	Name string `json:"name"`

	// RegionCodes CLDR region code of the countries/regions it is meant to be valid
	// for. Does not drive logic, serves only for easier filtering and
	// organization.
	RegionCodes *[]string `json:"region_codes,omitempty"`

	// To Date (exclusive) on which the organization schedule fragment's
	// validity ends.
	To time.Time `json:"to"`
}

// OrgScheduleFragmentsCreateResponseBody defines model for org-schedule-fragments-create-response.
type OrgScheduleFragmentsCreateResponseBody struct {
	OrgScheduleFragment OrgScheduleFragment `json:"org_schedule_fragment"`
}

// OrgScheduleFragmentsGetRequest defines model for org-schedule-fragments-get-request.
type OrgScheduleFragmentsGetRequest struct {
	// Id Organization schedule Fragment ID.
	Id string `json:"id"`
}

// OrgScheduleFragmentsGetResponseBody defines model for org-schedule-fragments-get-response.
type OrgScheduleFragmentsGetResponseBody struct {
	OrgScheduleFragment OrgScheduleFragment `json:"org_schedule_fragment"`
}

// OrgScheduleFragmentsTransitionRequest defines model for org-schedule-fragments-transition-request.
type OrgScheduleFragmentsTransitionRequest struct {
	// Id Organization schedule Fragment ID.
	Id string `json:"id"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleFragmentStatus `json:"status"`
}

// OrgScheduleFragmentsTransitionResponseBody defines model for org-schedule-fragments-transition-response.
type OrgScheduleFragmentsTransitionResponseBody struct {
	OrgScheduleFragment OrgScheduleFragment `json:"org_schedule_fragment"`
}

// OrgScheduleInterval An optionally named period on day granularity.
type OrgScheduleInterval = map[string]interface{}

// OrgScheduleStatus Status determines how an item can be used. In 'draft' status an item
// can be edited but can't be used. When 'published' the item can longer
// be edited but can be used. 'Archived' is read-only.
type OrgScheduleStatus string

// OrgScheduleSummary defines model for org-schedule-summary.
type OrgScheduleSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Human-readable name.
	Name *string `json:"name,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleStatus `json:"status"`

	// Timezone Timezone in which this is defined. Only organization schedules in
	// the same timezone can be directly combined.
	Timezone *string `json:"timezone,omitempty"`

	// ValidUntil Derived field indicating when a valid organization schedule will
	// become invalid. If omitted, the schedule is already invalid. A
	// schedule is valid if it has a weekly schedule for all named periods
	// for all its schedule fragments, and if it has a schedule fragment
	// for the time period in question.
	ValidUntil *time.Time `json:"valid_until,omitempty"`
}

// OrgSchedulesCreateRequest defines model for org-schedules-create-request.
type OrgSchedulesCreateRequest struct {
	DefaultWeeklyOrgSchedule *SetWeeklyOrgSchedule `json:"default_weekly_org_schedule,omitempty"`

	// MinValidDays Organization schedule must be valid for at least this many days in
	// the future. Meaning organization schedule fragments must cover this
	// period. 0 if omitted.
	MinValidDays *int64 `json:"min_valid_days,omitempty"`

	// Name Human-readable name.
	Name string `json:"name"`

	// OrgScheduleFragments List of organization schedule fragments with no overlaps or gaps.
	OrgScheduleFragments *[]SetOrgScheduleFragmentSummary `json:"org_schedule_fragments,omitempty"`

	// Timezone Timezone in which the organization schedule applies. Expected to be
	// a valid IANA time zone name such as America/New_York.
	Timezone string `json:"timezone"`

	// WeeklyOrgSchedules If this day belongs to a named period according to the currently
	// active organization schedule fragment, a weekly organization
	// schedule from this list with the corresponding name will apply.
	WeeklyOrgSchedules *[]SetWeeklyOrgSchedule `json:"weekly_org_schedules,omitempty"`
}

// OrgSchedulesCreateResponseBody defines model for org-schedules-create-response.
type OrgSchedulesCreateResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSchedulesEvaluateRequest defines model for org-schedules-evaluate-request.
type OrgSchedulesEvaluateRequest struct {
	// Id Organization schedule ID.
	Id string `json:"id"`

	// Instants Time instants to evaluate the organization schedule for.
	Instants []time.Time `json:"instants"`
}

// OrgSchedulesEvaluateResponseBody defines model for org-schedules-evaluate-response.
type OrgSchedulesEvaluateResponseBody struct {
	// InstantEvaluations The evaluations for the given time instants in the requested order.
	InstantEvaluations []InstantEvaluation `json:"instant_evaluations"`
}

// OrgSchedulesGetRequest defines model for org-schedules-get-request.
type OrgSchedulesGetRequest struct {
	// Id Organization schedule ID.
	Id string `json:"id"`
}

// OrgSchedulesGetResponseBody defines model for org-schedules-get-response.
type OrgSchedulesGetResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSchedulesListRequest defines model for org-schedules-list-request.
type OrgSchedulesListRequest struct {
	// CreatedById Creator ID the filter matches.
	CreatedById *[]string `json:"created_by_id,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit Max number of organization schedules returned in a page. Default is
	// 50.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Status The organization schedule statuses the filter matches.
	Status *[]OrgScheduleStatus `json:"status,omitempty"`

	// ValidUntil Provides ways to specify date ranges on objects.
	ValidUntil *DateFilter `json:"valid_until,omitempty"`
}

// OrgSchedulesListResponseBody defines model for org-schedules-list-response.
type OrgSchedulesListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// OrgSchedules The list of organization schedules.
	OrgSchedules []OrgSchedule `json:"org_schedules"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// OrgSchedulesSetFutureRequest defines model for org-schedules-set-future-request.
type OrgSchedulesSetFutureRequest struct {
	// Id Organization schedule ID.
	Id string `json:"id"`

	// OrgScheduleFragmentId Organization schedule Fragment ID.
	OrgScheduleFragmentId string `json:"org_schedule_fragment_id"`
}

// OrgSchedulesSetFutureResponseBody defines model for org-schedules-set-future-response.
type OrgSchedulesSetFutureResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSchedulesTransitionRequest defines model for org-schedules-transition-request.
type OrgSchedulesTransitionRequest struct {
	// Id Organization schedule ID.
	Id string `json:"id"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleStatus `json:"status"`
}

// OrgSchedulesTransitionResponseBody defines model for org-schedules-transition-response.
type OrgSchedulesTransitionResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSchedulesUpdateRequest defines model for org-schedules-update-request.
type OrgSchedulesUpdateRequest struct {
	DefaultWeeklyOrgSchedule *SetWeeklyOrgSchedule `json:"default_weekly_org_schedule,omitempty"`

	// Id Organization schedule ID.
	Id string `json:"id"`

	// MinValidDays Organization schedule must be valid for at least this many days in
	// the future. Meaning organization schedule fragments must cover this
	// period. 0 if omitted.
	MinValidDays *int64 `json:"min_valid_days,omitempty"`

	// Name Human-readable name.
	Name *string `json:"name,omitempty"`

	// OrgScheduleFragments List of organization schedule fragments with no overlaps or gaps.
	OrgScheduleFragments *[]SetOrgScheduleFragmentSummary `json:"org_schedule_fragments,omitempty"`

	// Timezone Timezone in which the organization schedule applies. Expected to be
	// a valid IANA time zone name such as America/New_York.
	Timezone *string `json:"timezone,omitempty"`

	// WeeklyOrgSchedules If this day belongs to a named period according to the currently
	// active organization schedule fragment, a weekly organization
	// schedule from this list with the corresponding name will apply.
	WeeklyOrgSchedules *[]SetWeeklyOrgSchedule `json:"weekly_org_schedules,omitempty"`
}

// OrgSchedulesUpdateResponseBody defines model for org-schedules-update-response.
type OrgSchedulesUpdateResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSummary defines model for org-summary.
type OrgSummary struct {
	Type  OrgType `json:"type"`
	union json.RawMessage
}

// OrgType defines model for org-type.
type OrgType string

// ParentPartFilter The filter for specifying parent part.
type ParentPartFilter struct {
	// Level Number of levels to fetch the part hierarchy up to.
	Level *int32 `json:"level,omitempty"`

	// Parts Part IDs to fetch the hierarchy for.
	Parts []string `json:"parts"`
}

// Part defines model for part.
type Part struct {
	Type  PartType `json:"type"`
	union json.RawMessage
}

// PartBase defines model for part-base.
type PartBase struct {
	// Artifacts The attached artifacts.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`
	CreatedBy *UserSummary       `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the part.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Name of the part.
	Name string `json:"name"`

	// OwnedBy The users that own the part.
	OwnedBy []UserSummary `json:"owned_by"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`
}

// PartBaseSummary defines model for part-base-summary.
type PartBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Name of the part.
	Name string `json:"name"`

	// OwnedBy The users that own the part.
	OwnedBy []UserSummary `json:"owned_by"`
}

// PartSummary defines model for part-summary.
type PartSummary struct {
	Type  PartType `json:"type"`
	union json.RawMessage
}

// PartType defines model for part-type.
type PartType string

// PartsCreateRequest defines model for parts-create-request.
type PartsCreateRequest struct {
	// Artifacts The IDs of the artifacts.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Description Description of the part.
	Description *string `json:"description,omitempty"`

	// Name Name of the part.
	Name string `json:"name"`

	// OwnedBy The users that own the part.
	OwnedBy []string `json:"owned_by"`

	// Tags Tags associated with the part.
	Tags  *[]SetTagWithValue `json:"tags,omitempty"`
	Type  PartType           `json:"type"`
	union json.RawMessage
}

// PartsCreateRequestCapability defines model for parts-create-request-capability.
type PartsCreateRequestCapability struct {
	// ParentPart ID of the parent product for the capability.
	ParentPart []string `json:"parent_part"`
}

// PartsCreateRequestEnhancement defines model for parts-create-request-enhancement.
type PartsCreateRequestEnhancement struct {
	// ParentPart ID of the parent part on which the enhancement is to be created.
	ParentPart []string `json:"parent_part"`

	// TargetCloseDate Target close date by which enhancement is expected to be closed.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// TargetStartDate Target start date by which enhancement is expected to be started.
	// Example Date Format: 2000-11-01T01:01:01Z
	TargetStartDate *time.Time `json:"target_start_date,omitempty"`
}

// PartsCreateRequestFeature defines model for parts-create-request-feature.
type PartsCreateRequestFeature struct {
	// ParentPart ID of the parent capability/feature for the feature.
	ParentPart []string `json:"parent_part"`
}

// PartsCreateRequestProduct defines model for parts-create-request-product.
type PartsCreateRequestProduct = map[string]interface{}

// PartsCreateResponseBody defines model for parts-create-response.
type PartsCreateResponseBody struct {
	Part Part `json:"part"`
}

// PartsDeleteRequest defines model for parts-delete-request.
type PartsDeleteRequest struct {
	// Id The ID of the part to delete.
	Id string `json:"id"`
}

// PartsDeleteResponseBody defines model for parts-delete-response.
type PartsDeleteResponseBody = map[string]interface{}

// PartsGetRequest defines model for parts-get-request.
type PartsGetRequest struct {
	// Id The ID of the part to retrieve.
	Id string `json:"id"`
}

// PartsGetResponseBody defines model for parts-get-response.
type PartsGetResponseBody struct {
	Part Part `json:"part"`
}

// PartsListRequest defines model for parts-list-request.
type PartsListRequest struct {
	// CreatedBy Filters for parts created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of parts to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedBy Filters for parts modified by any of these users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`

	// Name Filters for parts of the provided name(s).
	Name *[]string `json:"name,omitempty"`

	// OwnedBy Filters for parts owned by any of these users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// ParentPart The filter for specifying parent part.
	ParentPart *ParentPartFilter `json:"parent_part,omitempty"`

	// Tags Filters for part with any of the provided tags.
	Tags *[]string `json:"tags,omitempty"`

	// Type Filters for parts of the provided type(s).
	Type *[]PartType `json:"type,omitempty"`
}

// PartsListResponseBody defines model for parts-list-response.
type PartsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// Parts The list of parts.
	Parts []Part `json:"parts"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// PartsUpdateRequest defines model for parts-update-request.
type PartsUpdateRequest struct {
	Artifacts *PartsUpdateRequestArtifacts `json:"artifacts,omitempty"`

	// Description The updated description of the part.
	Description *string `json:"description,omitempty"`

	// Id The ID of the part to update.
	Id string `json:"id"`

	// Name The updated name of the part.
	Name    *string                    `json:"name,omitempty"`
	OwnedBy *PartsUpdateRequestOwnedBy `json:"owned_by,omitempty"`
	Tags    *PartsUpdateRequestTags    `json:"tags,omitempty"`
	Type    *PartType                  `json:"type,omitempty"`
	union   json.RawMessage
}

// PartsUpdateRequestArtifacts defines model for parts-update-request-artifacts.
type PartsUpdateRequestArtifacts struct {
	// Set Sets the artifacts to the provided IDs.
	Set *[]string `json:"set,omitempty"`
}

// PartsUpdateRequestCapability defines model for parts-update-request-capability.
type PartsUpdateRequestCapability = map[string]interface{}

// PartsUpdateRequestEnhancement defines model for parts-update-request-enhancement.
type PartsUpdateRequestEnhancement struct {
	// TargetCloseDate Updates the target close date of the enhancement.
	TargetCloseDate *time.Time `json:"target_close_date"`

	// TargetStartDate Updates the target start date of the enhancement. Example Date
	// Format: 2000-11-01T01:01:01Z
	TargetStartDate *time.Time `json:"target_start_date"`
}

// PartsUpdateRequestFeature defines model for parts-update-request-feature.
type PartsUpdateRequestFeature = map[string]interface{}

// PartsUpdateRequestOwnedBy defines model for parts-update-request-owned-by.
type PartsUpdateRequestOwnedBy struct {
	// Set Sets the owner IDs to the provided user IDs. This must not be
	// empty.
	Set *[]string `json:"set,omitempty"`
}

// PartsUpdateRequestProduct defines model for parts-update-request-product.
type PartsUpdateRequestProduct = map[string]interface{}

// PartsUpdateRequestTags defines model for parts-update-request-tags.
type PartsUpdateRequestTags struct {
	// Set Sets the tags to the provided tags.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// PartsUpdateResponseBody defines model for parts-update-response.
type PartsUpdateResponseBody struct {
	Part Part `json:"part"`
}

// Product defines model for product.
type Product = PartBase

// ProductSummary defines model for product-summary.
type ProductSummary = PartBaseSummary

// QuestionAnswer defines model for question-answer.
type QuestionAnswer struct {
	// Answer The Answer.
	Answer *string `json:"answer,omitempty"`

	// AppliesToParts Details of the parts relevant to the question_answer.
	AppliesToParts *[]PartSummary `json:"applies_to_parts,omitempty"`
	CreatedBy      *UserSummary   `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Question The Question.
	Question *string `json:"question,omitempty"`

	// Sources Details of the sources from which the question answer was
	// generated.
	Sources *[]AtomSummary `json:"sources,omitempty"`

	// Status Status of the question answer.
	Status *QuestionAnswerStatus `json:"status,omitempty"`

	// SuggestedAnswer An alternative answer suggested by the Q/A generation algorithm.
	SuggestedAnswer *string `json:"suggested_answer,omitempty"`

	// SuggestedForDeletion Whether the Q/A was marked for deletion by the Q/A generation
	// algorithm.
	SuggestedForDeletion *bool `json:"suggested_for_deletion,omitempty"`

	// Topic The topic to which the QA belongs.
	Topic *string `json:"topic,omitempty"`

	// Verified Whether the Q/A was verified.
	Verified *bool `json:"verified,omitempty"`
}

// QuestionAnswerStatus Status of the question answer.
type QuestionAnswerStatus string

// ReactionsListRequest defines model for reactions-list-request.
type ReactionsListRequest struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided,
	// then iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Emoji The emoji to list the reactors for. This can be the short name of
	// the emoji (e.g. "joy"), or the code point (e.g. "1f602").
	Emoji string `json:"emoji"`

	// Limit The maximum number of reactors to return.
	Limit *int32 `json:"limit,omitempty"`

	// Object The ID of the object to list reactors for.
	Object string `json:"object"`
}

// ReactionsListResponseBody defines model for reactions-list-response.
type ReactionsListResponseBody struct {
	// NextCursor The cursor that should be used to iterate the next sequence of
	// results, otherwise if not set, then no elements exist after.
	NextCursor *string `json:"next_cursor,omitempty"`

	// Reactors The users that have reacted.
	Reactors []UserSummary `json:"reactors"`
}

// ReactionsUpdateRequest defines model for reactions-update-request.
type ReactionsUpdateRequest struct {
	Action ReactionsUpdateRequestAction `json:"action"`

	// Emoji The emoji for the reaction. This can be the short name of the emoji
	// (e.g. "joy"), or the code point (e.g. "1f602").
	Emoji string `json:"emoji"`

	// Object The object to update the reaction for.
	Object string `json:"object"`
}

// ReactionsUpdateRequestAction defines model for reactions-update-request-action.
type ReactionsUpdateRequestAction string

// ReactionsUpdateResponseBody defines model for reactions-update-response.
type ReactionsUpdateResponseBody = map[string]interface{}

// RemoveTagWithValue defines model for remove-tag-with-value.
type RemoveTagWithValue struct {
	// Id The ID of the tag.
	Id string `json:"id"`
}

// RemovedSlaMetricHistory Information about removed metrics.
type RemovedSlaMetricHistory = map[string]interface{}

// Resource Resource details.
type Resource struct {
	// Artifacts Artifacts of the resource (relevant only for type artifact).
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Url URL of the resource (relevant only for type url).
	Url *string `json:"url,omitempty"`
}

// RevOrg defines model for rev-org.
type RevOrg struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the Rev organization.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Domain Company's domain name. Example - 'devrev.ai'.
	// Deprecated:
	Domain *string `json:"domain,omitempty"`

	// ExternalRef External ref is a unique identifier for the Rev (customer)
	// organization from your primary customer system of records. If none
	// is specified, a system-generated identifier will be assigned to the
	// organization.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate  *time.Time  `json:"modified_date,omitempty"`
	PrimaryRevOrg *OrgSummary `json:"primary_rev_org,omitempty"`
}

// RevOrgSummary defines model for rev-org-summary.
type RevOrgSummary = OrgBaseSummary

// RevOrgsCreateRequest Request object to create a new Rev organization in the Dev
// organization.
type RevOrgsCreateRequest struct {
	// Account Account Id to associate with this Rev organization.
	Account string `json:"account"`

	// Description Description of the Rev organization.
	Description *string `json:"description,omitempty"`

	// DisplayName Name of the Rev organization.
	DisplayName string `json:"display_name"`

	// Domain Company's domain name. Example - 'devrev.ai'.
	// Deprecated:
	Domain *string `json:"domain,omitempty"`

	// Environment The environment of the Org. Defaults to 'production' if not specified.
	Environment *OrgEnvironment `json:"environment,omitempty"`

	// ExternalRef External ref is a custom unique identifier which is a reference to
	// an unique id for this organization's data in some system of
	// records.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Tier The tier of the RevOrg.
	Tier *string `json:"tier,omitempty"`
}

// RevOrgsCreateResponseBody Response object for request to create a new Rev organization.
type RevOrgsCreateResponseBody struct {
	RevOrg RevOrg `json:"rev_org"`
}

// RevOrgsDeleteRequest Request object to delete a Rev organization.
type RevOrgsDeleteRequest struct {
	// Id The ID of Rev organization to delete.
	Id string `json:"id"`
}

// RevOrgsDeleteResponseBody The response to deleting a Rev organization.
type RevOrgsDeleteResponseBody = map[string]interface{}

// RevOrgsGetRequest Request object to get Rev organization's information.
type RevOrgsGetRequest struct {
	// Account The ID of account for which default Rev organization is to be
	// fetched.
	Account *string `json:"account,omitempty"`

	// Id The ID of the required Rev organization.
	Id *string `json:"id,omitempty"`
}

// RevOrgsGetResponseBody The response to getting a Rev organization's information.
type RevOrgsGetResponseBody struct {
	RevOrg RevOrg `json:"rev_org"`
}

// RevOrgsListRequest A request to get the list of Rev organizations for the authenticated
// user's Dev organization.
type RevOrgsListRequest struct {
	// CreatedBy Filters by creator.
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// DisplayName Array of display names of Rev orgs to be filtered.
	DisplayName *[]string `json:"display_name,omitempty"`

	// ExternalRef List of external refs to filter Rev organizations for.
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// Limit The maximum number of Rev organizations to be retrieved per page.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// SortBy Fields to sort the Rev organizations by and the direction to sort
	// them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// RevOrgsListResponseBody The response to getting a list of Rev organizations' information.
type RevOrgsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// RevOrgs List with all of the Rev organizations' information.
	RevOrgs []RevOrg `json:"rev_orgs"`
}

// RevOrgsUpdateRequest Request object to update information of the Rev organization.
type RevOrgsUpdateRequest struct {
	// Description Description of the Rev organization.
	Description *string `json:"description,omitempty"`

	// DisplayName Customer chosen name for the Rev organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Domain Company's domain name. Example - 'devrev.ai'.
	// Deprecated:
	Domain *string `json:"domain,omitempty"`

	// Environment The environment of the Org. Defaults to 'production' if not specified.
	Environment *OrgEnvironment `json:"environment,omitempty"`

	// ExternalRef External ref is a custom unique identifier which is a reference to
	// an unique id for this organization's data in some system of
	// records.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Id The ID of Rev organization to update.
	Id string `json:"id"`

	// Tier The tier of the RevOrg.
	Tier *string `json:"tier,omitempty"`
}

// RevOrgsUpdateResponseBody Response object to updating Rev organization's information.
type RevOrgsUpdateResponseBody struct {
	RevOrg RevOrg `json:"rev_org"`
}

// RevUser defines model for rev-user.
type RevUser struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the Rev user.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// ExternalRef External ref is a mutable unique identifier for a user within the
	// Rev organization from your primary customer record. If none is
	// available, a good alternative is the email address/phone number
	// which could uniquely identify the user. If none is specified, a
	// system-generated identifier will be assigned to the user.
	ExternalRef *string `json:"external_ref,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// PhoneNumbers Phone numbers of the user.
	PhoneNumbers    *[]string    `json:"phone_numbers,omitempty"`
	PrimaryIdentity *UserSummary `json:"primary_identity,omitempty"`
	RevOrg          *OrgSummary  `json:"rev_org,omitempty"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`
}

// RevUserSummary defines model for rev-user-summary.
type RevUserSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// ExternalRef External ref is a mutable unique identifier for a user within the
	// Rev organization from your primary customer record. If none is
	// available, a good alternative is the email address/phone number
	// which could uniquely identify the user. If none is specified, a
	// system-generated identifier will be assigned to the user.
	ExternalRef *string `json:"external_ref,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id     string      `json:"id"`
	RevOrg *OrgSummary `json:"rev_org,omitempty"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`
}

// RevUsersCreateRequest Request object to create a new Rev user for a Rev organization.
type RevUsersCreateRequest struct {
	// CustomSchemaFragments The schema fragment IDs associated with the Rev user.
	// Deprecated:
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description Description of the Rev user.
	Description *string `json:"description,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName *string `json:"display_name,omitempty"`

	// DisplayPicture Artifact ID of a Rev user's display picture.
	DisplayPicture *string `json:"display_picture,omitempty"`

	// Email Email address of the Rev user.
	Email *string `json:"email,omitempty"`

	// ExternalRef External ref is a mutable unique identifier for a user within the
	// Dev organization from your primary customer record. If none is
	// available, a good alternative is the email address/phone number
	// which could uniquely identify the user. If none is specified, a
	// system-generated identifier will be assigned to the user.
	ExternalRef *string `json:"external_ref,omitempty"`

	// PhoneNumbers Phone numbers, in E.164 format, of the Rev user.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`

	// RevOrg The ID of the Rev organization to which the created Rev user is
	// associated.
	RevOrg *string `json:"rev_org,omitempty"`
}

// RevUsersCreateResponseBody Response object for creating a new Rev user for Rev organization.
type RevUsersCreateResponseBody struct {
	RevUser RevUser `json:"rev_user"`
}

// RevUsersDeleteRequest Request object to delete a Rev user.
type RevUsersDeleteRequest struct {
	// Id The ID of Rev user to delete.
	Id string `json:"id"`
}

// RevUsersDeleteResponseBody The response to deleting a Rev user of a Rev organization.
type RevUsersDeleteResponseBody = map[string]interface{}

// RevUsersGetRequest Request object to get a Rev user.
type RevUsersGetRequest struct {
	// Id The ID of Rev user to be retrieved.
	Id string `json:"id"`
}

// RevUsersGetResponseBody The returned Rev user.
type RevUsersGetResponseBody struct {
	RevUser RevUser `json:"rev_user"`
}

// RevUsersListRequest Gets the list of Rev users belonging to the authenticated user's Dev
// organization which the user is also authorized to access.
type RevUsersListRequest struct {
	// Associations Filters for Rev users with specified associations
	// (account/workspace).
	Associations *[]string `json:"associations,omitempty"`

	// CreatedBy Filters for Rev users that were created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Email List of emails of Rev users to be filtered.
	Email *[]string `json:"email,omitempty"`

	// ExternalRef List of external refs to filter Rev users for.
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// IsVerified Value of is_verified field to filter the Rev users.
	IsVerified *bool `json:"is_verified,omitempty"`

	// Limit The maximum number of Rev users to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// PhoneNumbers List of phone numbers, in E.164 format, to filter Rev users on.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`

	// RevOrg List of IDs of Rev organizations to be filtered.
	RevOrg *[]string `json:"rev_org,omitempty"`

	// SortBy Fields to sort the Rev users by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// RevUsersListResponseBody The response to listing all Rev users matching the filter criteria.
type RevUsersListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// RevUsers List containing all the Rev users.
	RevUsers []RevUser `json:"rev_users"`
}

// RevUsersMergeRequest Request to merge two Rev users, retaining the primary user.
type RevUsersMergeRequest struct {
	// PrimaryUser The ID of the primary Rev user, which will be retained.
	PrimaryUser string `json:"primary_user"`

	// SecondaryUser The ID of the secondary Rev user, which will be merged into the
	// Primary Rev user.
	SecondaryUser string `json:"secondary_user"`
}

// RevUsersMergeResponseBody Acknowledgment response indicating that the merge request has been
// received for processing asynchronously.
type RevUsersMergeResponseBody = map[string]interface{}

// RevUsersScanRequest Scans the list of Rev users.
type RevUsersScanRequest struct {
	// Associations Filters for Rev users with specified associations
	// (account/workspace).
	Associations *[]string `json:"associations,omitempty"`

	// CreatedBy Filters for Rev users that were created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration, otherwise the beginning if not
	// provided.
	Cursor *string `json:"cursor,omitempty"`

	// Email List of emails of Rev users to be filtered.
	Email *[]string `json:"email,omitempty"`

	// ExternalRef List of external refs to filter Rev users for.
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// IsVerified Value of is_verified field to filter the Rev users.
	IsVerified   *bool           `json:"is_verified,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// PhoneNumbers List of phone numbers, in E.164 format, to filter Rev users on.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`

	// RevOrg List of IDs of Rev organizations to be filtered.
	RevOrg *[]string `json:"rev_org,omitempty"`
}

// RevUsersScanResponseBody The response to scanning Rev users.
type RevUsersScanResponseBody struct {
	// NextCursor The cursor that should be used to resume iteration, otherwise if
	// not provided, then iteration has completed.
	NextCursor *string `json:"next_cursor,omitempty"`

	// RevUsers The iterated Rev users.
	RevUsers []RevUser `json:"rev_users"`
}

// RevUsersUpdateRequest Request to update details of a Rev user.
type RevUsersUpdateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields          *map[string]interface{}                     `json:"custom_fields,omitempty"`
	CustomSchemaFragments *RevUsersUpdateRequestCustomSchemaFragments `json:"custom_schema_fragments,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description Updated description of the Rev user.
	Description *string `json:"description,omitempty"`

	// DisplayName Updated display name of the Rev user.
	DisplayName *string `json:"display_name,omitempty"`

	// DisplayPicture Artifact ID of a Rev user's updated display picture.
	DisplayPicture *string `json:"display_picture"`

	// Email Updated email address of the Rev user.
	Email *string `json:"email,omitempty"`

	// ExternalRef Updated external ref value of the Rev user.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Id The ID of Rev user to update.
	Id string `json:"id"`

	// PhoneNumbers The phone numbers, in E.164 format, of the Rev user.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`
}

// RevUsersUpdateRequestCustomSchemaFragments defines model for rev-users-update-request-custom-schema-fragments.
type RevUsersUpdateRequestCustomSchemaFragments struct {
	// Set Sets the IDs to the provided schema fragment IDs.
	Set *[]string `json:"set,omitempty"`
}

// RevUsersUpdateResponseBody Updated Rev user object.
type RevUsersUpdateResponseBody struct {
	RevUser RevUser `json:"rev_user"`
}

// RoleSummary defines model for role-summary.
type RoleSummary = AtomBaseSummary

// SamlConnectionFieldsMap defines model for saml-connection-fields-map.
type SamlConnectionFieldsMap struct {
	// Email Claims in the SAML assertion returned by the identity provider that
	// map to the email address of the user.
	Email *string `json:"email,omitempty"`

	// UserId Claims in the SAML assertion returned by the identity provider that
	// map to the user ID of the user.
	UserId *string `json:"user_id,omitempty"`
}

// SchemaBoolFieldDescriptor defines model for schema-bool-field-descriptor.
type SchemaBoolFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *bool `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaBoolListFieldDescriptor defines model for schema-bool-list-field-descriptor.
type SchemaBoolListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]bool `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaCompositeFieldDescriptor defines model for schema-composite-field-descriptor.
type SchemaCompositeFieldDescriptor struct {
	// CompositeType Composite type. Required when field type is composite.
	CompositeType *string `json:"composite_type,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaCompositeListFieldDescriptor defines model for schema-composite-list-field-descriptor.
type SchemaCompositeListFieldDescriptor struct {
	// CompositeType Composite type. Required when field type is composite.
	CompositeType *string `json:"composite_type,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaDateFieldDescriptor defines model for schema-date-field-descriptor.
type SchemaDateFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaDateListFieldDescriptor defines model for schema-date-list-field-descriptor.
type SchemaDateListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaDoubleFieldDescriptor defines model for schema-double-field-descriptor.
type SchemaDoubleFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *float64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaDoubleListFieldDescriptor defines model for schema-double-list-field-descriptor.
type SchemaDoubleListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]float64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaEnumFieldDescriptor defines model for schema-enum-field-descriptor.
type SchemaEnumFieldDescriptor struct {
	// AllowedValues Allowed values for the field.
	AllowedValues []string `json:"allowed_values"`

	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsOverridable Whether the enum is overridable.
	IsOverridable *bool `json:"is_overridable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// TranslatedValues Translations for allowed_values field.
	TranslatedValues *map[string]string `json:"translated_values,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaEnumListFieldDescriptor defines model for schema-enum-list-field-descriptor.
type SchemaEnumListFieldDescriptor struct {
	// AllowedValues Allowed values for the field.
	AllowedValues []string `json:"allowed_values"`

	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsOverridable Whether the enum is overridable.
	IsOverridable *bool `json:"is_overridable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// TranslatedValues Translations for allowed_values field.
	TranslatedValues *map[string]string `json:"translated_values,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaFieldDescriptor Set of field attributes.
type SchemaFieldDescriptor struct {
	FieldType SchemaFieldDescriptorFieldType `json:"field_type"`
	union     json.RawMessage
}

// SchemaFieldDescriptorArrayType defines model for schema-field-descriptor-array-type.
type SchemaFieldDescriptorArrayType struct {
	BaseType SchemaFieldDescriptorArrayTypeBaseType `json:"base_type"`

	// EqItems The exact array length.
	EqItems *int64 `json:"eq_items,omitempty"`

	// MaxItems The maximum array length.
	MaxItems *int64 `json:"max_items,omitempty"`

	// MinItems The minimum array length.
	MinItems *int64 `json:"min_items,omitempty"`
	union    json.RawMessage
}

// SchemaFieldDescriptorArrayTypeBaseType defines model for schema-field-descriptor-array-type-base-type.
type SchemaFieldDescriptorArrayTypeBaseType string

// SchemaFieldDescriptorBase defines model for schema-field-descriptor-base.
type SchemaFieldDescriptorBase struct {
	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaFieldDescriptorFieldType defines model for schema-field-descriptor-field-type.
type SchemaFieldDescriptorFieldType string

// SchemaFieldMfzMetadata The schema of MFZ specific fields.
type SchemaFieldMfzMetadata = map[string]interface{}

// SchemaFieldOasisMetadata The schema of oasis specific fields.
type SchemaFieldOasisMetadata = map[string]interface{}

// SchemaFieldUenumValue A unified enum value.
type SchemaFieldUenumValue = map[string]interface{}

// SchemaFieldUiMetadata The schema of ui specific fields.
type SchemaFieldUiMetadata = map[string]interface{}

// SchemaIdFieldDescriptor defines model for schema-id-field-descriptor.
type SchemaIdFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IdType Object ID types. Required when field type is ID.
	IdType *[]string `json:"id_type,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaIdListFieldDescriptor defines model for schema-id-list-field-descriptor.
type SchemaIdListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IdType Object ID types. Required when field type is ID.
	IdType *[]string `json:"id_type,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaIntFieldDescriptor defines model for schema-int-field-descriptor.
type SchemaIntFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *int64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// Gt The minimum value for the integer (exclusive).
	Gt *int64 `json:"gt,omitempty"`

	// Gte The minimum value for the integer (inclusive).
	Gte *int64 `json:"gte,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Lt The maximum value for the integer (exclusive).
	Lt *int64 `json:"lt,omitempty"`

	// Lte The maximum value for the integer (inclusive).
	Lte *int64 `json:"lte,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaIntListFieldDescriptor defines model for schema-int-list-field-descriptor.
type SchemaIntListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]int64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// Gt The minimum value for the integer (exclusive).
	Gt *int64 `json:"gt,omitempty"`

	// Gte The minimum value for the integer (inclusive).
	Gte *int64 `json:"gte,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Lt The maximum value for the integer (exclusive).
	Lt *int64 `json:"lt,omitempty"`

	// Lte The maximum value for the integer (inclusive).
	Lte *int64 `json:"lte,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaJsonValueFieldDescriptor defines model for schema-json-value-field-descriptor.
type SchemaJsonValueFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *interface{} `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaJsonValueListFieldDescriptor defines model for schema-json-value-list-field-descriptor.
type SchemaJsonValueListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]interface{} `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaRichTextFieldDescriptor defines model for schema-rich-text-field-descriptor.
type SchemaRichTextFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaRichTextListFieldDescriptor defines model for schema-rich-text-list-field-descriptor.
type SchemaRichTextListFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaStructFieldDescriptor defines model for schema-struct-field-descriptor.
type SchemaStructFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *map[string]interface{} `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaStructListFieldDescriptor defines model for schema-struct-list-field-descriptor.
type SchemaStructListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]map[string]interface{} `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTextFieldDescriptor defines model for schema-text-field-descriptor.
type SchemaTextFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTextListFieldDescriptor defines model for schema-text-list-field-descriptor.
type SchemaTextListFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTimestampFieldDescriptor defines model for schema-timestamp-field-descriptor.
type SchemaTimestampFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTimestampListFieldDescriptor defines model for schema-timestamp-list-field-descriptor.
type SchemaTimestampListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTokensFieldDescriptor defines model for schema-tokens-field-descriptor.
type SchemaTokensFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTokensListFieldDescriptor defines model for schema-tokens-list-field-descriptor.
type SchemaTokensListFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaUenumFieldDescriptor defines model for schema-uenum-field-descriptor.
type SchemaUenumFieldDescriptor struct {
	// AllowedValues Allowed values for the field.
	AllowedValues []SchemaFieldUenumValue `json:"allowed_values"`

	// DefaultValue Default value.
	DefaultValue *int64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaUenumListFieldDescriptor defines model for schema-uenum-list-field-descriptor.
type SchemaUenumListFieldDescriptor struct {
	// AllowedValues Allowed values for the field.
	AllowedValues []SchemaFieldUenumValue `json:"allowed_values"`

	// DefaultValue Default value.
	DefaultValue *[]int64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaUnknownFieldDescriptor defines model for schema-unknown-field-descriptor.
type SchemaUnknownFieldDescriptor = SchemaFieldDescriptorBase

// ServiceAccount defines model for service-account.
type ServiceAccount = UserBase

// ServiceAccountSummary defines model for service-account-summary.
type ServiceAccountSummary = UserBaseSummary

// ServiceAccountsCreateRequest The request object to create a new service account.
type ServiceAccountsCreateRequest struct {
	// DisplayName The service account's display name. A unique, human readable name
	// to identify a service account.
	DisplayName string `json:"display_name"`

	// GenKeyring Indicates whether to generate a keyring along with the new service
	// account. The default is false.
	GenKeyring *bool `json:"gen_keyring,omitempty"`
}

// ServiceAccountsCreateResponseBody The response object to the corresponding create service account
// request.
type ServiceAccountsCreateResponseBody struct {
	ServiceAccount ServiceAccount `json:"service_account"`
}

// ServiceAccountsGetRequest The request object to get a service account's information.
type ServiceAccountsGetRequest struct {
	// Id The ID of the requested service account.
	Id string `json:"id"`
}

// ServiceAccountsGetResponseBody The response object that carries the service account's information
// corresponding to the request.
type ServiceAccountsGetResponseBody struct {
	ServiceAccount ServiceAccount `json:"service_account"`
}

// SetIssueSelector defines model for set-issue-selector.
type SetIssueSelector struct {
	// CustomFields Custom fields on the issue with their fully qualified names and the
	// associated with their exact allowed values. The SLA policy applies
	// to issues where all named custom fields have exactly the specified
	// values.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Owners The SLA policy applies to the issues of these owners.
	Owners *[]string `json:"owners,omitempty"`

	// Parts The SLA policy applies to the issues of these parts.
	Parts *[]string `json:"parts,omitempty"`

	// RevOrgs The SLA policy applies to the issues of these revorgs.
	RevOrgs *[]string `json:"rev_orgs,omitempty"`

	// StageName The SLA policy applies to issues with these stages.
	StageName *[]string `json:"stage_name,omitempty"`

	// Subtype The issue subtype for which the SLA policy applies.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags The SLA policy applies to issues with these tags. If empty, the tag
	// filter isn't applied.
	Tags *[]string `json:"tags,omitempty"`
}

// SetOrgScheduleFragmentSummary defines model for set-org-schedule-fragment-summary.
type SetOrgScheduleFragmentSummary struct {
	// Id Organization schedule fragment ID.
	Id string `json:"id"`
}

// SetSharedWithMembership Information about the role the member receives due to the share.
type SetSharedWithMembership struct {
	// Member ID of the member the object is shared with.
	Member *string `json:"member,omitempty"`

	// Role ID of the role that describes what privileges the membership
	// entails.
	Role *string `json:"role,omitempty"`
}

// SetSlaPolicy defines model for set-sla-policy.
type SetSlaPolicy struct {
	// Metrics Metrics to apply to the selected items.
	Metrics *[]SetSupportMetricTarget `json:"metrics,omitempty"`

	// Name Human-readable name.
	Name     string         `json:"name"`
	Selector SetSlaSelector `json:"selector"`
}

// SetSlaSelector defines model for set-sla-selector.
type SetSlaSelector struct {
	// AppliesTo The item type for which the SLA policy applies.
	AppliesTo SlaSelectorAppliesTo `json:"applies_to"`

	// CustomFields Custom fields with their fully qualified names and associated with
	// their exact allowed values. The SLA policy applies to records where
	// all named custom fields have exactly the specified values. If the
	// value is null, the field must have null value or not be present.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Groups The SLA policy applies to the tickets or conversations of these
	// groups.
	Groups        *[]string         `json:"groups,omitempty"`
	IssueSelector *SetIssueSelector `json:"issue_selector,omitempty"`

	// Owners The SLA policy applies to the tickets or conversations of these
	// owners.
	Owners *[]string `json:"owners,omitempty"`

	// Parts The SLA policy applies to the tickets of these parts.
	Parts *[]string `json:"parts,omitempty"`

	// Priority The SLA policy applies to conversations with these priorities.
	Priority *[]SlaSelectorPriority `json:"priority,omitempty"`

	// Severity The SLA policy applies to tickets with these severities.
	Severity *[]SlaSelectorSeverity `json:"severity,omitempty"`

	// SourceChannel The SLA policy applies to conversations with these sources.
	SourceChannel *[]string `json:"source_channel,omitempty"`

	// Subtype The SLA policy applies to tickets with these subtypes.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags The SLA policy applies to items with these tags.
	Tags *[]string `json:"tags,omitempty"`

	// TicketSourceChannel The SLA policy applies to tickets with these source channels.
	TicketSourceChannel *[]string `json:"ticket_source_channel,omitempty"`
}

// SetSupportMetricTarget defines model for set-support-metric-target.
type SetSupportMetricTarget struct {
	// Metric The metric to apply.
	Metric string `json:"metric"`

	// OrgScheduleId The organization schedule controlling this metrics calculation.
	// Time based metrics don't consume time while their schedule is off.
	OrgScheduleId *string `json:"org_schedule_id,omitempty"`

	// Performance The percentage of instances for which this metric's target must not
	// be breached, in order to avoid breaching the overall SLA policy.
	Performance *float64 `json:"performance,omitempty"`

	// Target The target value to be achieved, for example the time in which to
	// do something, or the maximum allowed number of message pairs. The
	// units and interpretation of the value is controlled by the
	// properties of the referenced metric.
	Target int32 `json:"target"`

	// WarningTarget The threshold in the same units as target where the metric is
	// considered to be 'at risk'.
	WarningTarget *int32 `json:"warning_target,omitempty"`
}

// SetTagWithValue defines model for set-tag-with-value.
type SetTagWithValue struct {
	// Id The ID of the tag.
	Id string `json:"id"`

	// Value The value for the object's association with the tag. If specified,
	// the value must be one that's specified in the tag's allowed values.
	Value *string `json:"value,omitempty"`
}

// SetWeeklyOrgSchedule defines model for set-weekly-org-schedule.
type SetWeeklyOrgSchedule struct {
	// Intervals The 'on' intervals of the week.
	Intervals []CreateWeeklyOrgScheduleInterval `json:"intervals"`

	// PeriodName The name of the period during which the organization schedule
	// applies.
	PeriodName string `json:"period_name"`
}

// SharedWithMembership Information about the role the member receives due to the share.
type SharedWithMembership struct {
	Member *MemberSummary `json:"member,omitempty"`
	Role   *RoleSummary   `json:"role,omitempty"`
}

// SharedWithMembershipFilter Filter on target item based on intended audience.
type SharedWithMembershipFilter struct {
	// Member ID of the group/member with whom the item is shared.
	Member *string `json:"member,omitempty"`

	// Role Role ID of the group/member with whom the item is shared.
	Role *string `json:"role,omitempty"`
}

// Sla defines model for sla.
type Sla struct {
	// AccountFilter A set of account attributes that must be satisfied for the SLA to
	// apply. AND applies between each field.
	AccountFilter *map[string]interface{} `json:"account_filter,omitempty"`

	// Compensation Describes the compensation to be provided in case of SLA breach. It is
	// not 'self-executing', it is the responsibility of the organization
	// providing the SLA to actually transfer the promised credit, resource or
	// other payment.
	Compensation *SlaCompensation `json:"compensation,omitempty"`
	CreatedBy    *UserSummary     `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the purpose and capabilities of the SLA.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// EvaluationPeriod Specifies the frequency of when the contractually-meaningful evaluation
	// of the SLA happens. The organization for their own information might
	// evaluate the various metrics contained in the policy as often as we can
	// make it feasible for them, but only the evaluation at the end of the
	// evaluation period triggers a compensation and needs to be shared with
	// the customer.
	EvaluationPeriod *SlaEvaluationPeriod `json:"evaluation_period,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Human-readable name.
	Name string `json:"name"`

	// Policies The policies encompassed by this SLA, ordered in decreasing
	// priority.
	Policies *[]SlaPolicy `json:"policies,omitempty"`

	// SlaType Type of the SLA.
	SlaType *SlaType `json:"sla_type,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status SlaStatus `json:"status"`
}

// SlaAppliesTo The object types on which the SLA applies. An external SLA can apply to
// multiple object types, but an internal SLA can apply to only one object
// type.
type SlaAppliesTo string

// SlaAssignResult defines model for sla-assign-result.
type SlaAssignResult struct {
	Error  *Error        `json:"error,omitempty"`
	RevOrg RevOrgSummary `json:"rev_org"`
}

// SlaCompensation Describes the compensation to be provided in case of SLA breach. It is
// not 'self-executing', it is the responsibility of the organization
// providing the SLA to actually transfer the promised credit, resource or
// other payment.
type SlaCompensation = map[string]interface{}

// SlaEvaluationPeriod Specifies the frequency of when the contractually-meaningful evaluation
// of the SLA happens. The organization for their own information might
// evaluate the various metrics contained in the policy as often as we can
// make it feasible for them, but only the evaluation at the end of the
// evaluation period triggers a compensation and needs to be shared with
// the customer.
type SlaEvaluationPeriod string

// SlaPolicy A policy that represents a promise to your revs.
type SlaPolicy = map[string]interface{}

// SlaSelectorAppliesTo The item type for which the SLA policy applies.
type SlaSelectorAppliesTo string

// SlaSelectorPriority The SLA policy applies to conversations with these priorities.
type SlaSelectorPriority string

// SlaSelectorSeverity The SLA policy applies to tickets with these severities.
type SlaSelectorSeverity string

// SlaStatus Status determines how an item can be used. In 'draft' status an item
// can be edited but can't be used. When 'published' the item can longer
// be edited but can be used. 'Archived' is read-only.
type SlaStatus string

// SlaSummary defines model for sla-summary.
type SlaSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Human-readable name.
	Name string `json:"name"`

	// SlaType Type of the SLA.
	SlaType *SlaType `json:"sla_type,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status SlaStatus `json:"status"`
}

// SlaSummaryFilter The filter for SLA summary.
type SlaSummaryFilter struct {
	// Stage Filters for records with any of the provided SLA stages.
	Stage *[]SlaSummaryStage `json:"stage,omitempty"`

	// TargetTime Provides ways to specify date ranges on objects.
	TargetTime *DateFilter `json:"target_time,omitempty"`
}

// SlaSummaryStage The stage of the SLA. This is the metric stage which is closest to
// breach.
type SlaSummaryStage string

// SlaTracker defines model for sla-tracker.
type SlaTracker struct {
	// AppliesToId Details of the object on which the SLA is being tracked.
	AppliesToId *string `json:"applies_to_id,omitempty"`

	// AppliesToType The type of the object on which the SLA is being tracked.
	AppliesToType *SlaTrackerAppliesToType `json:"applies_to_type,omitempty"`
	CreatedBy     *UserSummary             `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// MetricTargetSummaries Summary of the metrics target being tracked in the SLA tracker.
	MetricTargetSummaries []ArchetypeMetricTarget `json:"metric_target_summaries"`
	ModifiedBy            *UserSummary            `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// RemovedSlaMetricHistory Information about removed metrics.
	RemovedSlaMetricHistory *[]RemovedSlaMetricHistory `json:"removed_sla_metric_history,omitempty"`
	Sla                     *SlaSummary                `json:"sla,omitempty"`

	// SlaPolicyId Details of the applicable SLA policy. Can be omitted if no sla
	// applies, or if no policy of the sla applies at the moment.
	SlaPolicyId *string `json:"sla_policy_id,omitempty"`

	// Stage SLA stage of the object being tracked.
	Stage *string `json:"stage,omitempty"`

	// Status It is an indicator of whether the SLA has ever been breached
	// (missed). If not, it shows whether the SLA is completed, in
	// progress, or nil - if no policy is applied.
	Status *string `json:"status,omitempty"`
}

// SlaTrackerAppliesToType The type of the object on which the SLA is being tracked.
type SlaTrackerAppliesToType string

// SlaTrackerSummary defines model for sla-tracker-summary.
type SlaTrackerSummary struct {
	// AppliesToType The type of the object on which the SLA is being tracked.
	AppliesToType *SlaTrackerAppliesToType `json:"applies_to_type,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`
}

// SlaTrackersGetRequest defines model for sla-trackers-get-request.
type SlaTrackersGetRequest struct {
	// Id The ID of the SLA tracker to get.
	Id string `json:"id"`
}

// SlaTrackersGetResponseBody defines model for sla-trackers-get-response.
type SlaTrackersGetResponseBody struct {
	SlaTracker SlaTracker `json:"sla_tracker"`
}

// SlaTrackersListRequest defines model for sla-trackers-list-request.
type SlaTrackersListRequest struct {
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of SLA trackers to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// SortBy Fields to sort the SLA Trackers by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stage The SLA tracker stages the filter matches.
	Stage *[]string `json:"stage,omitempty"`

	// Status The SLA tracker statuses the filter matches.
	Status *[]string `json:"status,omitempty"`
}

// SlaTrackersListResponseBody defines model for sla-trackers-list-response.
type SlaTrackersListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// SlaTrackers The list of SLA trackers.
	SlaTrackers []SlaTracker `json:"sla_trackers"`
}

// SlaType Type of the SLA.
type SlaType string

// SlasAssignRequest defines model for slas-assign-request.
type SlasAssignRequest struct {
	// Id The SLA which would be assigned to the Rev organizations. If
	// omitted, the SLA of all the rev organizations referenced will be
	// unset.
	Id *string `json:"id,omitempty"`

	// RevOrgs The Rev organizations to apply the SLA to.
	RevOrgs []string `json:"rev_orgs"`
}

// SlasAssignResponseBody defines model for slas-assign-response.
type SlasAssignResponseBody struct {
	// Results The list of outcomes for each Rev organization.
	Results []SlaAssignResult `json:"results"`
}

// SlasCreateRequest defines model for slas-create-request.
type SlasCreateRequest struct {
	AccountSelector *AccountsFilters `json:"account_selector,omitempty"`

	// AppliesTo The object types this SLA can apply to.
	AppliesTo *[]SlaAppliesTo `json:"applies_to,omitempty"`

	// Description Description of the purpose and capabilities of the SLA.
	Description *string `json:"description,omitempty"`

	// EvaluationPeriod Specifies the frequency of when the contractually-meaningful evaluation
	// of the SLA happens. The organization for their own information might
	// evaluate the various metrics contained in the policy as often as we can
	// make it feasible for them, but only the evaluation at the end of the
	// evaluation period triggers a compensation and needs to be shared with
	// the customer.
	EvaluationPeriod *SlaEvaluationPeriod `json:"evaluation_period,omitempty"`

	// Name Human-readable name.
	Name string `json:"name"`

	// Policies The policies encompassed by this SLA, ordered in decreasing
	// priority.
	Policies *[]SetSlaPolicy `json:"policies,omitempty"`

	// SlaType Type of the SLA.
	SlaType *SlaType `json:"sla_type,omitempty"`
}

// SlasCreateResponseBody defines model for slas-create-response.
type SlasCreateResponseBody struct {
	Sla Sla `json:"sla"`
}

// SlasFilterAppliesToOperatorType defines model for slas-filter-applies-to-operator-type.
type SlasFilterAppliesToOperatorType string

// SlasGetRequest defines model for slas-get-request.
type SlasGetRequest struct {
	// Id The ID of the SLA to get.
	Id string `json:"id"`
}

// SlasGetResponseBody defines model for slas-get-response.
type SlasGetResponseBody struct {
	Sla Sla `json:"sla"`
}

// SlasListRequest defines model for slas-list-request.
type SlasListRequest struct {
	// AppliesTo The object types the SLA applies to.
	AppliesTo   *[]SlaAppliesTo                  `json:"applies_to,omitempty"`
	AppliesToOp *SlasFilterAppliesToOperatorType `json:"applies_to_op,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of SLAs to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// SlaType The SLA types the filter matches.
	SlaType *[]SlaType `json:"sla_type,omitempty"`

	// SortBy Fields to sort the SLAs by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Status The SLA statuses the filter matches.
	Status *[]SlaStatus `json:"status,omitempty"`
}

// SlasListResponseBody defines model for slas-list-response.
type SlasListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Slas The list of SLAs.
	Slas []Sla `json:"slas"`
}

// SlasTransitionRequest defines model for slas-transition-request.
type SlasTransitionRequest struct {
	// Id The updated SLA.
	Id string `json:"id"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status SlaStatus `json:"status"`
}

// SlasTransitionResponseBody defines model for slas-transition-response.
type SlasTransitionResponseBody struct {
	Sla Sla `json:"sla"`
}

// SlasUpdateRequest defines model for slas-update-request.
type SlasUpdateRequest struct {
	AccountSelector *AccountsFilters `json:"account_selector,omitempty"`

	// Description Description of the purpose and capabilities of the SLA.
	Description *string `json:"description,omitempty"`

	// EvaluationPeriod Specifies the frequency of when the contractually-meaningful evaluation
	// of the SLA happens. The organization for their own information might
	// evaluate the various metrics contained in the policy as often as we can
	// make it feasible for them, but only the evaluation at the end of the
	// evaluation period triggers a compensation and needs to be shared with
	// the customer.
	EvaluationPeriod *SlaEvaluationPeriod `json:"evaluation_period,omitempty"`

	// Id The SLA's ID.
	Id string `json:"id"`

	// Name Human-readable name.
	Name *string `json:"name,omitempty"`

	// Policies The policies encompassed by this SLA, ordered in decreasing
	// priority, the whole array will be overwritten by the contents of
	// this array.
	Policies *[]SetSlaPolicy `json:"policies,omitempty"`
}

// SlasUpdateResponseBody defines model for slas-update-response.
type SlasUpdateResponseBody struct {
	Sla Sla `json:"sla"`
}

// SnapKitActionExecuteDeferredRequest defines model for snap-kit-action-execute-deferred-request.
type SnapKitActionExecuteDeferredRequest struct {
	// Actions List of actions triggered in the request.
	Actions []SnapKitActionRequest `json:"actions"`

	// Id ID of the deferred snap-kit action to be executed.
	Id string `json:"id"`
}

// SnapKitActionExecuteDeferredResponseBody defines model for snap-kit-action-execute-deferred-response.
type SnapKitActionExecuteDeferredResponseBody = map[string]interface{}

// SnapKitActionRequest defines model for snap-kit-action-request.
type SnapKitActionRequest struct {
	// ActionId Id of the interactive element specified by developer in a snap-kit
	// object.
	ActionId string `json:"action_id"`

	// ActionType Action interaction type.
	ActionType *string `json:"action_type,omitempty"`

	// BlockId Id of the block within the surface which is the container for the
	// interactive element.
	BlockId *string `json:"block_id,omitempty"`

	// Timestamp Timestamp when the action was originated.
	Timestamp time.Time                            `json:"timestamp"`
	Type      SnapKitActionRequestElementTypeValue `json:"type"`
	union     json.RawMessage
}

// SnapKitActionRequestButton defines model for snap-kit-action-request-button.
type SnapKitActionRequestButton struct {
	// Value Value for the button interactive element.
	Value string `json:"value"`
}

// SnapKitActionRequestElementTypeValue defines model for snap-kit-action-request-element-type-value.
type SnapKitActionRequestElementTypeValue string

// SnapKitActionRequestForm defines model for snap-kit-action-request-form.
type SnapKitActionRequestForm struct {
	// Value Value for the form interactive element.
	Value map[string]interface{} `json:"value"`
}

// SnapWidget defines model for snap-widget.
type SnapWidget struct {
	Type SnapWidgetType `json:"type"`
}

// SnapWidgetType defines model for snap-widget-type.
type SnapWidgetType = string

// SnapWidgetsCreateRequest defines model for snap-widgets-create-request.
type SnapWidgetsCreateRequest struct {
	// SharedWith Sets the members that the snap widget is shared with.
	SharedWith *[]SetSharedWithMembership   `json:"shared_with,omitempty"`
	Type       SnapWidgetsCreateRequestType `json:"type"`
}

// SnapWidgetsCreateRequestType defines model for snap-widgets-create-request-type.
type SnapWidgetsCreateRequestType = string

// SnapWidgetsCreateResponseBody defines model for snap-widgets-create-response.
type SnapWidgetsCreateResponseBody struct {
	SnapWidget SnapWidget `json:"snap_widget"`
}

// Stage Describes the current stage of a object.
type Stage = map[string]interface{}

// StageFilter The filter for stages.
type StageFilter struct {
	// Name Filters for records in the provided stage(s) by name.
	Name *[]string `json:"name,omitempty"`
}

// StageInit Sets an object's initial stage.
type StageInit struct {
	// Name The name of the stage.
	Name *string `json:"name,omitempty"`
}

// StageUpdate Updates an object's stage.
type StageUpdate struct {
	// Name The updated name of the stage, otherwise unchanged if not set.
	Name *string `json:"name,omitempty"`
}

// StageValidationOptionForCreate Type of stage validation options when creating an object.
type StageValidationOptionForCreate string

// StageValidationOptionForUpdate Type of state validation options when updating the stage of an object.
type StageValidationOptionForUpdate string

// StagedInfoFilter defines model for staged-info-filter.
type StagedInfoFilter struct {
	// IsStaged Filters for issues that are staged.
	IsStaged *bool `json:"is_staged,omitempty"`
}

// Survey defines model for survey.
type Survey struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the survey.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Header Header of the survey.
	Header *string `json:"header,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IntroductoryText Text posted when introducing the survey to the responder.
	IntroductoryText *string      `json:"introductory_text,omitempty"`
	ModifiedBy       *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Survey name associated with schema. This name would be unique per
	// dev org.
	Name *string `json:"name,omitempty"`

	// ResponseText Text posted after the response is collected.
	ResponseText *string `json:"response_text,omitempty"`

	// Schema List of all fields in the schema.
	Schema *[]SchemaFieldDescriptor `json:"schema,omitempty"`

	// SchemaWithMetadata List of all the fields and their respective metadata in the schema.
	SchemaWithMetadata *[]SurveyFieldWithMetadata `json:"schema_with_metadata,omitempty"`

	// Title Title of the survey.
	Title *string `json:"title,omitempty"`
}

// SurveyAggregationFilter The filter for survey aggregation.
type SurveyAggregationFilter = map[string]interface{}

// SurveyFieldWithMetadata Field descriptors with additional metadata for surveys.
type SurveyFieldWithMetadata struct {
	// Field Set of field attributes.
	Field *SchemaFieldDescriptor `json:"field,omitempty"`

	// Metadata Additional metadata for the input field.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Question The question linked to the input field.
	Question *string `json:"question,omitempty"`
}

// SurveyResponse defines model for survey-response.
type SurveyResponse struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DispatchId The unique ID associated with the dispatched survey.
	DispatchId *string `json:"dispatch_id,omitempty"`

	// DispatchedChannels Source channels on which the survey is sent. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "plug",
	//     "ordinal": 1,
	//     "overridable": false
	//   },
	//   {
	//     "id": 2,
	//     "label": "portal",
	//     "ordinal": 2,
	//     "overridable": false
	//   },
	//   {
	//     "id": 3,
	//     "label": "email",
	//     "ordinal": 3,
	//     "overridable": false
	//   },
	//   {
	//     "id": 4,
	//     "label": "slack",
	//     "ordinal": 4,
	//     "overridable": false
	//   }
	// ```
	DispatchedChannels *[]EnumValue `json:"dispatched_channels,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Object The ID of the object for which survey is taken.
	Object    *string      `json:"object,omitempty"`
	Recipient *UserSummary `json:"recipient,omitempty"`

	// Response Response for the survey.
	Response *map[string]interface{} `json:"response,omitempty"`

	// ResponseChannel The properties of an enum value.
	ResponseChannel *EnumValue `json:"response_channel,omitempty"`

	// Stage The properties of an enum value.
	Stage *EnumValue `json:"stage,omitempty"`

	// Survey The ID of the survey for which response is taken.
	Survey *string `json:"survey,omitempty"`
}

// SurveysCreateRequest defines model for surveys-create-request.
type SurveysCreateRequest struct {
	// Description Description about the survey.
	Description *string `json:"description,omitempty"`

	// Header Header of the survey.
	Header *string `json:"header,omitempty"`

	// IntroductoryText Text posted when introducing the survey to the responder.
	IntroductoryText *string `json:"introductory_text,omitempty"`

	// Name The survey's name.
	Name string `json:"name"`

	// ResponseText Text posted after the response is collected.
	ResponseText *string `json:"response_text,omitempty"`

	// Schema Schema for the survey.
	Schema *[]FieldDescriptor `json:"schema,omitempty"`

	// SchemaWithMetadata The schema with metadata for the survey.
	SchemaWithMetadata *[]SurveyFieldWithMetadata `json:"schema_with_metadata,omitempty"`

	// Title Title of the survey.
	Title *string `json:"title,omitempty"`
}

// SurveysCreateResponseBody defines model for surveys-create-response.
type SurveysCreateResponseBody struct {
	Survey Survey `json:"survey"`
}

// SurveysDeleteRequest defines model for surveys-delete-request.
type SurveysDeleteRequest struct {
	// Id ID of the survey being deleted.
	Id string `json:"id"`
}

// SurveysDeleteResponseBody defines model for surveys-delete-response.
type SurveysDeleteResponseBody = map[string]interface{}

// SurveysGetRequest defines model for surveys-get-request.
type SurveysGetRequest struct {
	// Id The ID of the survey to get.
	Id string `json:"id"`
}

// SurveysGetResponseBody defines model for surveys-get-response.
type SurveysGetResponseBody struct {
	Survey Survey `json:"survey"`
}

// SurveysListRequest defines model for surveys-list-request.
type SurveysListRequest struct {
	// CreatedBy Filters for surveys created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of surveys to return. If not set, then the
	// default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// Name Filters for surveys by name(s).
	Name *[]string `json:"name,omitempty"`

	// SortBy Fields to sort the surveys by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// SurveysListResponseBody defines model for surveys-list-response.
type SurveysListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Surveys The list of the surveys.
	Surveys []Survey `json:"surveys"`
}

// SurveysResponsesListRequest defines model for surveys-responses-list-request.
type SurveysResponsesListRequest struct {
	// CreatedBy Filters for survey responses created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// DispatchIds Filters for survey responses associated with these unique IDs.
	DispatchIds *[]string `json:"dispatch_ids,omitempty"`

	// Limit The maximum number of survey responses to return. If not set, then
	// the default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// Objects Filters for survey responses created for the objects.
	Objects *[]string `json:"objects,omitempty"`

	// Recipient Filters for survey responses dispatched to any of these users.
	Recipient *[]string `json:"recipient,omitempty"`

	// SortBy Fields to sort the survey responses by and the direction to sort
	// them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stages Filters for survey response stages.
	Stages *[]int64 `json:"stages,omitempty"`

	// Surveys Filters for survey responses for the provided survey IDs.
	Surveys *[]string `json:"surveys,omitempty"`
}

// SurveysResponsesListResponseBody defines model for surveys-responses-list-response.
type SurveysResponsesListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// SurveyResponses The list of the survey responses.
	SurveyResponses []SurveyResponse `json:"survey_responses"`
}

// SurveysResponsesUpdateRequest defines model for surveys-responses-update-request.
type SurveysResponsesUpdateRequest struct {
	// DispatchId The unique ID associated with the dispatched survey.
	DispatchId string `json:"dispatch_id"`

	// Response Survey response submitted for the object.
	Response *map[string]interface{} `json:"response,omitempty"`

	// ResponseChannel The source channel ordinal which recorded the survey response.
	ResponseChannel *int64 `json:"response_channel,omitempty"`

	// ResponseScore The response score for the survey. Only applicable for CSAT and
	// NPS.
	ResponseScore *int32 `json:"response_score,omitempty"`

	// Stage The stage ordinal of the survey response object.
	Stage *int64 `json:"stage,omitempty"`
}

// SurveysResponsesUpdateResponseBody defines model for surveys-responses-update-response.
type SurveysResponsesUpdateResponseBody = map[string]interface{}

// SurveysSendRequest defines model for surveys-send-request.
type SurveysSendRequest struct {
	Email SurveysSendRequestEmail `json:"email"`
}

// SurveysSendRequestEmail defines model for surveys-send-request-email.
type SurveysSendRequestEmail struct {
	// Body Message body for a survey email.
	Body string `json:"body"`

	// Recipients Recipients list for a survey email.
	Recipients []string `json:"recipients"`

	// Sender Sender email address from which an email is sent.
	Sender string `json:"sender"`

	// Subject Subject for an email where survey is sent.
	Subject string `json:"subject"`
}

// SurveysSendResponseBody defines model for surveys-send-response.
type SurveysSendResponseBody = map[string]interface{}

// SurveysSubmitRequest defines model for surveys-submit-request.
type SurveysSubmitRequest struct {
	// DispatchId The unique ID associated with the dispatched survey.
	DispatchId *string `json:"dispatch_id,omitempty"`

	// DispatchedChannels The ordinals of the source channels on which the survey is sent.
	DispatchedChannels *[]int64 `json:"dispatched_channels,omitempty"`

	// Object The ID of the object this survey is on (e.g. ticket, conversation,
	// etc).
	Object string `json:"object"`

	// Recipient The unique ID associated with the recipient of the survey.
	Recipient *string `json:"recipient,omitempty"`

	// Response Survey response submitted for the object.
	Response *map[string]interface{} `json:"response,omitempty"`

	// ResponseScore The response score for the survey. Only applicable for CSAT and
	// NPS.
	ResponseScore *int32 `json:"response_score,omitempty"`

	// SourceChannel The source channel from which survey response is submitted.
	SourceChannel *string `json:"source_channel,omitempty"`

	// Stage The stage ordinal of the survey response object.
	Stage *int64 `json:"stage,omitempty"`

	// Survey The ID of the survey to submit the response to.
	Survey string `json:"survey"`
}

// SurveysSubmitResponseBody defines model for surveys-submit-response.
type SurveysSubmitResponseBody = map[string]interface{}

// SurveysUpdateRequest defines model for surveys-update-request.
type SurveysUpdateRequest struct {
	// Description The updated description about the survey.
	Description *string `json:"description,omitempty"`

	// Header Header of the survey.
	Header *string `json:"header,omitempty"`

	// Id The ID of the survey to update.
	Id string `json:"id"`

	// IntroductoryText The updated text posted when introducing the survey to the
	// responder.
	IntroductoryText *string `json:"introductory_text,omitempty"`

	// Name The survey's updated name.
	Name *string `json:"name,omitempty"`

	// ResponseText Text posted after the response is collected.
	ResponseText *string `json:"response_text,omitempty"`

	// SchemaWithMetadata The updated schema with metadata for the survey.
	SchemaWithMetadata *[]SurveyFieldWithMetadata `json:"schema_with_metadata,omitempty"`

	// Survey The ID of the survey to update.
	// Deprecated:
	Survey *string `json:"survey,omitempty"`

	// Title Title of the survey.
	Title *string `json:"title,omitempty"`
}

// SurveysUpdateResponseBody defines model for surveys-update-response.
type SurveysUpdateResponseBody struct {
	Survey Survey `json:"survey"`
}

// SyncHistory defines model for sync-history.
type SyncHistory struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// SyncRun Object for holding run-specific data.
	SyncRun *SyncRun `json:"sync_run,omitempty"`

	// SyncUnit SyncUnit ID associated with this historical entry.
	SyncUnit *string `json:"sync_unit,omitempty"`
}

// SyncMetadataFilter defines model for sync-metadata-filter.
type SyncMetadataFilter struct {
	// ExternalReference Filters for issues with this specific external reference.
	ExternalReference *[]string                        `json:"external_reference,omitempty"`
	LastSyncIn        *SyncMetadataFilterSyncInFilter  `json:"last_sync_in,omitempty"`
	LastSyncOut       *SyncMetadataFilterSyncOutFilter `json:"last_sync_out,omitempty"`

	// OriginSystem Filters for issues synced from this specific origin system.
	OriginSystem *[]string `json:"origin_system,omitempty"`
}

// SyncMetadataFilterSyncInFilter defines model for sync-metadata-filter-sync-in-filter.
type SyncMetadataFilterSyncInFilter struct {
	// Status Filters for works with selected sync statuses.
	Status *[]SyncMetadataFilterSyncInFilterStatus `json:"status,omitempty"`

	// SyncDate Provides ways to specify date ranges on objects.
	SyncDate *DateFilter `json:"sync_date,omitempty"`

	// SyncHistory Filters for works modified with selected sync history.
	SyncHistory *[]string `json:"sync_history,omitempty"`

	// SyncUnit Filters for works modified with selected sync units.
	SyncUnit *[]string `json:"sync_unit,omitempty"`
}

// SyncMetadataFilterSyncInFilterStatus defines model for sync-metadata-filter-sync-in-filter-status.
type SyncMetadataFilterSyncInFilterStatus string

// SyncMetadataFilterSyncOutFilter defines model for sync-metadata-filter-sync-out-filter.
type SyncMetadataFilterSyncOutFilter struct {
	// Status Filters for works with selected sync statuses.
	Status *[]SyncMetadataFilterSyncOutFilterStatus `json:"status,omitempty"`

	// SyncDate Provides ways to specify date ranges on objects.
	SyncDate *DateFilter `json:"sync_date,omitempty"`

	// SyncHistory Filters for works modified with selected sync history.
	SyncHistory *[]string `json:"sync_history,omitempty"`

	// SyncUnit Filters for works modified with selected sync units.
	SyncUnit *[]string `json:"sync_unit,omitempty"`
}

// SyncMetadataFilterSyncOutFilterStatus defines model for sync-metadata-filter-sync-out-filter-status.
type SyncMetadataFilterSyncOutFilterStatus string

// SyncProgress Progress.
type SyncProgress struct {
	// State The state of a sync progress.
	State *SyncProgressState `json:"state,omitempty"`
}

// SyncProgressState The state of a sync progress.
type SyncProgressState string

// SyncRun Object for holding run-specific data.
type SyncRun struct {
	// EndedAt The time when a sync was ended.
	EndedAt *time.Time `json:"ended_at,omitempty"`

	// Mode The direction/mode of a sync run.
	Mode *SyncRunMode `json:"mode,omitempty"`

	// Progress Progress.
	Progress *SyncProgress `json:"progress,omitempty"`

	// StartedAt The time when a sync was started.
	StartedAt *time.Time `json:"started_at,omitempty"`
}

// SyncRunMode The direction/mode of a sync run.
type SyncRunMode string

// SysUser defines model for sys-user.
type SysUser = UserBase

// SysUserSummary defines model for sys-user-summary.
type SysUserSummary = UserBaseSummary

// SysUsersListRequest A request to get the list of system user's information.
type SysUsersListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of system users to return. Value can range from
	// '1' to '100', with a default of '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// SortBy Fields to sort the system users by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// SysUsersListResponseBody The response to listing the system users.
type SysUsersListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// SysUsers The list of system users.
	SysUsers []SysUser `json:"sys_users"`
}

// SysUsersUpdateRequest Request to update information of the system user.
type SysUsersUpdateRequest struct {
	// DisplayName Updated display name for the system user.
	DisplayName *string `json:"display_name,omitempty"`

	// DisplayPicture Artifact ID of the system user's new display picture.
	DisplayPicture *string `json:"display_picture"`

	// FullName Updated full name for the system user.
	FullName *string `json:"full_name,omitempty"`

	// Id The ID of system user to update.
	Id string `json:"id"`
}

// SysUsersUpdateResponseBody Updated Sys user object.
type SysUsersUpdateResponseBody struct {
	SysUser SysUser `json:"sys_user"`
}

// Tag defines model for tag.
type Tag struct {
	// AllowedValues The allowed values for the tag, where a value is provided when a
	// tag is associated with an object. If empty, then no value should be
	// provided when the association is made.
	AllowedValues *[]string    `json:"allowed_values,omitempty"`
	CreatedBy     *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description An informative description for the tag that should provide context
	// on the tag's purpose and usage.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name The name of the tag, which denotes the logical concept by which all
	// tagged objects will be associated. The name is guaranteed to be
	// unique.
	Name string `json:"name"`
}

// TagSummary defines model for tag-summary.
type TagSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name The name of the tag, which denotes the logical concept by which all
	// tagged objects will be associated. The name is guaranteed to be
	// unique.
	Name string `json:"name"`
}

// TagWithValue defines model for tag-with-value.
type TagWithValue struct {
	Tag TagSummary `json:"tag"`

	// Value The value for the object's association with the tag.
	Value *string `json:"value,omitempty"`
}

// TagWithValueFilter defines model for tag-with-value-filter.
type TagWithValueFilter struct {
	// Id The ID of the tag.
	Id *string `json:"id,omitempty"`

	// Value The value for the object's association with the tag. If specified,
	// the value must be one that's specified in the tag's allowed values.
	Value *string `json:"value,omitempty"`
}

// TagsCreateRequest The request to create a new tag.
type TagsCreateRequest struct {
	// AllowedValues The allowed values for the tag, or empty if no values are
	// permitted.
	AllowedValues *[]string `json:"allowed_values,omitempty"`

	// Description The description for the tag.
	Description *string `json:"description,omitempty"`

	// Name The name for the tag, which must be unique across all tags.
	Name string `json:"name"`
}

// TagsCreateResponseBody The response to creating a new tag.
type TagsCreateResponseBody struct {
	Tag Tag `json:"tag"`
}

// TagsDeleteRequest The request to delete a tag.
type TagsDeleteRequest struct {
	// Id The ID of the tag to delete.
	Id string `json:"id"`
}

// TagsDeleteResponseBody The response for deleting a tag.
type TagsDeleteResponseBody = map[string]interface{}

// TagsGetRequest The request to get a tag's information.
type TagsGetRequest struct {
	// Id The requested tag's ID.
	Id string `json:"id"`
}

// TagsGetResponseBody The response to getting a tag's information.
type TagsGetResponseBody struct {
	Tag Tag `json:"tag"`
}

// TagsListRequest The request to get information about a list of tags.
type TagsListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of tags to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Name Filters for tags with the provided names.
	Name *[]string `json:"name,omitempty"`

	// SortBy Fields to sort tags by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// TagsListResponseBody The response to listing the tags.
type TagsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Tags The list of tags.
	Tags []Tag `json:"tags"`
}

// TagsUpdateAllowedValues Specifies an update to a tag's allowed values.
type TagsUpdateAllowedValues struct {
	// Set Sets the allowed values for the tag.
	Set *[]string `json:"set,omitempty"`
}

// TagsUpdateRequest The request to update a tag.
type TagsUpdateRequest struct {
	// AllowedValues Specifies an update to a tag's allowed values.
	AllowedValues *TagsUpdateAllowedValues `json:"allowed_values,omitempty"`

	// Description The updated description of the tag.
	Description *string `json:"description,omitempty"`

	// Id The ID of the tag to update.
	Id string `json:"id"`

	// Name The updated name of the tag. The name must be unique across all
	// tags.
	Name *string `json:"name,omitempty"`
}

// TagsUpdateResponseBody The response for updating a tag.
type TagsUpdateResponseBody struct {
	Tag Tag `json:"tag"`
}

// Ticket defines model for ticket.
type Ticket struct {
	Account       *AccountSummary `json:"account,omitempty"`
	AppliesToPart *PartSummary    `json:"applies_to_part,omitempty"`

	// Artifacts The artifacts attached to the work item.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body Body of the work object.
	Body *string `json:"body,omitempty"`

	// Channels Channels of the ticket.
	Channels *[]TicketChannels `json:"channels,omitempty"`

	// ChannelsV2 Channel IDs of the ticket.
	ChannelsV2 *[]ExternalCommunicationChannelSummary `json:"channels_v2,omitempty"`
	CreatedBy  *UserSummary                           `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string       `json:"display_id,omitempty"`
	Group     *GroupSummary `json:"group,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// NeedsResponse Whether the ticket needs a response.
	NeedsResponse *bool `json:"needs_response,omitempty"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// ReportedBy Users that reported the work.
	ReportedBy *[]UserSummary `json:"reported_by,omitempty"`
	RevOrg     *OrgSummary    `json:"rev_org,omitempty"`

	// Sentiment The properties of an enum value.
	Sentiment *EnumValue `json:"sentiment,omitempty"`

	// SentimentModifiedDate Timestamp when the sentiment was last modified.
	SentimentModifiedDate *time.Time `json:"sentiment_modified_date,omitempty"`

	// SentimentSummary Summary justifying the sentiment.
	SentimentSummary *string `json:"sentiment_summary,omitempty"`

	// Severity Severity of the ticket.
	Severity *TicketSeverity `json:"severity,omitempty"`

	// SlaSummary SLA summary for the object.
	SlaSummary *ArchetypeSlaSummary `json:"sla_summary,omitempty"`
	SlaTracker *SlaTrackerSummary   `json:"sla_tracker,omitempty"`

	// SourceChannel Source channel of the ticket.
	SourceChannel   *string                              `json:"source_channel,omitempty"`
	SourceChannelV2 *ExternalCommunicationChannelSummary `json:"source_channel_v2,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStage `json:"stage,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`

	// Visibility The properties of an enum value.
	Visibility *EnumValue `json:"visibility,omitempty"`
}

// TicketChannels Channels of the ticket.
type TicketChannels string

// TicketSeverity Severity of the ticket.
type TicketSeverity string

// TicketSummary defines model for ticket-summary.
type TicketSummary struct {
	Account *AccountSummary `json:"account,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`
	RevOrg  *OrgSummary   `json:"rev_org,omitempty"`

	// Severity Severity of the ticket.
	Severity *TicketSeverity `json:"severity,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStageSummary `json:"stage,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// TimelineComment defines model for timeline-comment.
type TimelineComment struct {
	// Artifacts The artifacts for the comment.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body The comment's body. If the comment has been deleted, then no body
	// will appear in the response.
	Body *string `json:"body,omitempty"`

	// BodyType The type of the body to use for the comment.
	BodyType  *TimelineCommentBodyType `json:"body_type,omitempty"`
	CreatedBy *UserSummary             `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Object The object that the Timeline entry belongs to.
	Object string `json:"object"`

	// ObjectDisplayId The display ID of the object that the Timeline entry belongs to.
	ObjectDisplayId string `json:"object_display_id"`

	// ObjectType The type of object that the Timeline entry belongs to.
	ObjectType *TimelineEntryObjectType `json:"object_type,omitempty"`

	// References Summary information about objects that are referenced in the
	// comment.
	References *[]AtomSummary `json:"references,omitempty"`

	// SnapKitBody Snap Kit Body of the comment.
	SnapKitBody *TimelineSnapKitBody `json:"snap_kit_body,omitempty"`

	// SnapWidgetBody The snap widget body of the comment.
	SnapWidgetBody *[]SnapWidget `json:"snap_widget_body,omitempty"`

	// Visibility The visibility of the entry. If 'private', then the entry is only
	// visible to the creator, 'internal' is visible with the Dev
	// organization, 'external' is visible to the Dev organzation and Rev
	// users, and 'public' is visible to all. If not set, then the default
	// visibility is 'external'.
	Visibility *TimelineEntryVisibility `json:"visibility,omitempty"`
}

// TimelineCommentBodyType The type of the body to use for the comment.
type TimelineCommentBodyType string

// TimelineCommentSummary defines model for timeline-comment-summary.
type TimelineCommentSummary = TimelineEntryBaseSummary

// TimelineEntriesCreateRequest The request to create a timeline entry for an object.
type TimelineEntriesCreateRequest struct {
	// ExpiresAt If set, then the entry is ephemeral and will be deleted after the
	// provided time. The minimum value should be at least a minute more
	// than the current timestamp.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Object The ID of the object to create the timeline entry for.
	Object string `json:"object"`

	// PrivateTo If the visibility of the entry is private, this specifies the users
	// that the entry is private to. Note the creator is always implicitly
	// included in this list.
	PrivateTo *[]string                        `json:"private_to,omitempty"`
	Type      TimelineEntriesCreateRequestType `json:"type"`

	// Visibility The visibility of the entry. If 'private', then the entry is only
	// visible to the creator, 'internal' is visible with the Dev
	// organization, 'external' is visible to the Dev organzation and Rev
	// users, and 'public' is visible to all. If not set, then the default
	// visibility is 'external'.
	Visibility *TimelineEntryVisibility `json:"visibility,omitempty"`
	union      json.RawMessage
}

// TimelineEntriesCreateRequestTimelineComment defines model for timeline-entries-create-request-timeline-comment.
type TimelineEntriesCreateRequestTimelineComment struct {
	// Artifacts The IDs of the artifacts attached to the comment.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Body The comment's body.
	Body *string `json:"body,omitempty"`

	// BodyType The type of the body to use for the comment.
	BodyType *TimelineCommentBodyType `json:"body_type,omitempty"`

	// SnapKitBody Snap Kit Body of the comment.
	SnapKitBody *TimelineSnapKitBody `json:"snap_kit_body,omitempty"`
}

// TimelineEntriesCreateRequestType defines model for timeline-entries-create-request-type.
type TimelineEntriesCreateRequestType string

// TimelineEntriesCreateResponseBody The response to creating a timeline entry for an object.
type TimelineEntriesCreateResponseBody struct {
	TimelineEntry TimelineEntry `json:"timeline_entry"`
}

// TimelineEntriesDeleteRequest The request to delete a timeline entry from an object.
type TimelineEntriesDeleteRequest struct {
	// Id The ID of the timeline entry to delete.
	Id string `json:"id"`
}

// TimelineEntriesDeleteResponseBody The response to deleting a timeline entry from an object.
type TimelineEntriesDeleteResponseBody = map[string]interface{}

// TimelineEntriesGetRequest The request to get a timeline entry.
type TimelineEntriesGetRequest struct {
	// Id The ID of the timeline entry to get.
	Id string `json:"id"`
}

// TimelineEntriesGetResponseBody The request to getting a timeline entry.
type TimelineEntriesGetResponseBody struct {
	TimelineEntry TimelineEntry `json:"timeline_entry"`
}

// TimelineEntriesListRequest The request to list timeline entries for an object.
type TimelineEntriesListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of entries to return. If not set, then this
	// defaults to `50`.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Object The ID of the object to list timeline entries for.
	Object string `json:"object"`

	// Visibility The visibility of the timeline entries to filter for. Note this is
	// a strict filter, such that only entries with the exact visibilities
	// specified will be returned.
	Visibility *[]TimelineEntryVisibility `json:"visibility,omitempty"`
}

// TimelineEntriesListResponseBody The response to listing timeline entries for an object.
type TimelineEntriesListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// TimelineEntries The timeline entries for the object.
	TimelineEntries []TimelineEntry `json:"timeline_entries"`
}

// TimelineEntriesUpdateRequest The request to update a timeline entry.
type TimelineEntriesUpdateRequest struct {
	// Id The ID of the timeline entry to update.
	Id    string                           `json:"id"`
	Type  TimelineEntriesUpdateRequestType `json:"type"`
	union json.RawMessage
}

// TimelineEntriesUpdateRequestTimelineComment defines model for timeline-entries-update-request-timeline-comment.
type TimelineEntriesUpdateRequestTimelineComment struct {
	Artifacts *TimelineEntriesUpdateRequestTimelineCommentArtifacts `json:"artifacts,omitempty"`

	// Body The updated comment's body.
	Body *string `json:"body,omitempty"`

	// BodyType The type of the body to use for the comment.
	BodyType *TimelineCommentBodyType `json:"body_type,omitempty"`

	// SnapKitBody Snap Kit Body of the comment.
	SnapKitBody *TimelineSnapKitBody `json:"snap_kit_body,omitempty"`
}

// TimelineEntriesUpdateRequestTimelineCommentArtifacts defines model for timeline-entries-update-request-timeline-comment-artifacts.
type TimelineEntriesUpdateRequestTimelineCommentArtifacts struct {
	// Add Adds the provided artifacts to the comment. An artifact cannot be
	// added more than once, i.e. nothing is done if the artifact is
	// already attached. Mutually exclusive with `set`.
	Add *[]string `json:"add,omitempty"`

	// Remove Removes the provided artifacts from the comment. If an artifact is
	// not present, then it's ignored. Mututally exclusive with `set`.
	Remove *[]string `json:"remove,omitempty"`

	// Set Sets the field to the provided artifacts.
	Set *[]string `json:"set,omitempty"`
}

// TimelineEntriesUpdateRequestType defines model for timeline-entries-update-request-type.
type TimelineEntriesUpdateRequestType string

// TimelineEntriesUpdateResponseBody The response to updating a timeline entry.
type TimelineEntriesUpdateResponseBody struct {
	TimelineEntry TimelineEntry `json:"timeline_entry"`
}

// TimelineEntry defines model for timeline-entry.
type TimelineEntry struct {
	Type  TimelineEntryType `json:"type"`
	union json.RawMessage
}

// TimelineEntryBase defines model for timeline-entry-base.
type TimelineEntryBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Object The object that the Timeline entry belongs to.
	Object string `json:"object"`

	// ObjectDisplayId The display ID of the object that the Timeline entry belongs to.
	ObjectDisplayId string `json:"object_display_id"`

	// ObjectType The type of object that the Timeline entry belongs to.
	ObjectType *TimelineEntryObjectType `json:"object_type,omitempty"`

	// Visibility The visibility of the entry. If 'private', then the entry is only
	// visible to the creator, 'internal' is visible with the Dev
	// organization, 'external' is visible to the Dev organzation and Rev
	// users, and 'public' is visible to all. If not set, then the default
	// visibility is 'external'.
	Visibility *TimelineEntryVisibility `json:"visibility,omitempty"`
}

// TimelineEntryBaseSummary defines model for timeline-entry-base-summary.
type TimelineEntryBaseSummary = AtomBaseSummary

// TimelineEntryObjectType The type of object that the Timeline entry belongs to.
type TimelineEntryObjectType string

// TimelineEntryType defines model for timeline-entry-type.
type TimelineEntryType string

// TimelineEntryVisibility The visibility of the entry. If 'private', then the entry is only
// visible to the creator, 'internal' is visible with the Dev
// organization, 'external' is visible to the Dev organzation and Rev
// users, and 'public' is visible to all. If not set, then the default
// visibility is 'external'.
type TimelineEntryVisibility string

// TimelineSnapKitBody Snap Kit Body of the comment.
type TimelineSnapKitBody struct {
	// Body The JSON body of the SnapKit.
	Body *map[string]interface{} `json:"body,omitempty"`

	// SnapInActionName The name of an action defined in the SnapIn. The combination of
	// snap_in_id and snap_in_action_name uniquely identifies the
	// interaction object which is to be called when actions on a snapkit
	// element is taken.
	SnapInActionName *string `json:"snap_in_action_name,omitempty"`

	// SnapInId ID of the snap-in which created the SnapKit.
	SnapInId *string `json:"snap_in_id,omitempty"`
}

// UpdateCommandAction defines model for update-command-action.
type UpdateCommandAction struct {
	ActionDetails *UpdateCommandActionDetails `json:"action_details,omitempty"`

	// Artifacts IDs of the new artifact items
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Code The raw code to execute, defined in the language specified by
	// executor
	Code *string `json:"code,omitempty"`

	// ExecutorConfig Executor specific config
	ExecutorConfig *map[string]interface{} `json:"executor_config,omitempty"`

	// Message The message to populate in discussion box, when the command is
	// selected to execute.
	Message *string `json:"message,omitempty"`

	// SnapInFunctionId Function containing logic for the command. If function ID is
	// specified the executor config is ignored and command is executed by
	// functions.
	SnapInFunctionId *string `json:"snap_in_function_id,omitempty"`

	// TemplateType The template engine for resolving message.
	TemplateType *CommandActionTemplateType `json:"template_type,omitempty"`
}

// UpdateCommandActionDetails defines model for update-command-action-details.
type UpdateCommandActionDetails struct {
	// ObjectUpdatePayload The payload to update the object in context upon command execution.
	ObjectUpdatePayload *map[string]interface{} `json:"object_update_payload,omitempty"`
}

// UpdateCommandSurface defines model for update-command-surface.
type UpdateCommandSurface struct {
	// ObjectTypes Objects types on which a command can be invoked
	ObjectTypes *[]CommandSurfaceObjectTypes `json:"object_types,omitempty"`

	// Surface Surfaces from where this command can be invoked.
	Surface *CommandSurfaceSurface `json:"surface,omitempty"`
}

// UserBase defines model for user-base.
type UserBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// PhoneNumbers Phone numbers of the user.
	PhoneNumbers    *[]string    `json:"phone_numbers,omitempty"`
	PrimaryIdentity *UserSummary `json:"primary_identity,omitempty"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`
}

// UserBaseSummary defines model for user-base-summary.
type UserBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`
}

// UserSkill Skill associated with the user.
type UserSkill struct {
	// Name Name of the skill.
	Name *string `json:"name,omitempty"`
}

// UserState State of the user.
type UserState string

// UserSummary defines model for user-summary.
type UserSummary struct {
	Type  UserType `json:"type"`
	union json.RawMessage
}

// UserType defines model for user-type.
type UserType string

// VistaGroupItemState Defines the state of the group item.
type VistaGroupItemState string

// VistaGroupItemSummary Vista group item.
type VistaGroupItemSummary struct {
	// EndDate Timestamp when the vista ends.
	EndDate *time.Time `json:"end_date,omitempty"`

	// Id ID of the group item in don v2 format.
	Id string `json:"id"`

	// Name Name of the group.
	Name string `json:"name"`

	// StartDate Timestamp when the vista starts.
	StartDate *time.Time `json:"start_date,omitempty"`

	// State Defines the state of the group item.
	State *VistaGroupItemState `json:"state,omitempty"`

	// Type Type of the group object.
	Type VistaGroupItemType `json:"type"`
}

// VistaGroupItemType Type of the group object.
type VistaGroupItemType string

// WebCrawlerJob defines model for web-crawler-job.
type WebCrawlerJob struct {
	// AcceptRegexs URL patterns to accept (an empty value means accept all URLs)
	// subject to explicit rejects (if any).
	AcceptRegexs *[]string    `json:"accept_regexs,omitempty"`
	CreatedBy    *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the web crawler job.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DomainNames Domain names to crawl URLs for. If this field is not set, it is
	// inferred based on the domain names in the seed set of URLs.
	DomainNames *[]string `json:"domain_names,omitempty"`

	// Frequency Number of days between re-sync job runs.
	Frequency *int32 `json:"frequency,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// MaxDepth Specifies the maximum recursion depth from the seed URL that we
	// will crawl. If this value is -1, there is no limit on recursion
	// depth.
	MaxDepth   *int32       `json:"max_depth,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// NoParent Specifies whether we should never ascend to the parent directory
	// when crawling from a seed set URL.
	NoParent *bool `json:"no_parent,omitempty"`

	// NotifyOnComplete Whether to notify via email.
	NotifyOnComplete *bool `json:"notify_on_complete,omitempty"`

	// NumBytes Number of bytes stored.
	NumBytes *int32 `json:"num_bytes,omitempty"`

	// NumTimeoutUrls Number of URLs that timed out.
	NumTimeoutUrls *int32 `json:"num_timeout_urls,omitempty"`

	// NumUrlsScraped Number of URLs whose webpage are scraped.
	NumUrlsScraped *int32 `json:"num_urls_scraped,omitempty"`

	// RejectRegexs URL patterns to reject (an empty value means no explicit
	// rejections).
	RejectRegexs *[]string `json:"reject_regexs,omitempty"`

	// SitemapIndexUrls Sitemap index URLs. The URLs in the referenced sitemaps add to the
	// seed set of URLs to crawl from.
	SitemapIndexUrls *[]string `json:"sitemap_index_urls,omitempty"`

	// SitemapUrls Sitemap URLs. The URLs in the sitemap add to the seed set of URLs
	// to crawl from.
	SitemapUrls *[]string `json:"sitemap_urls,omitempty"`

	// State State of the web crawler job.
	State *WebCrawlerJobState `json:"state,omitempty"`

	// Urls URLs to add to the seed set of URLs to crawl from.
	Urls *[]string `json:"urls,omitempty"`

	// UserAgent User agent to use for crawling websites in this job.
	UserAgent *string `json:"user_agent,omitempty"`
}

// WebCrawlerJobState State of the web crawler job.
type WebCrawlerJobState string

// WebCrawlerJobsControlRequest The request to resume a web crawler job.
type WebCrawlerJobsControlRequest struct {
	Action WebCrawlerJobsControlRequestAction `json:"action"`

	// Id The ID of the job.
	Id string `json:"id"`
}

// WebCrawlerJobsControlRequestAction defines model for web-crawler-jobs-control-request-action.
type WebCrawlerJobsControlRequestAction string

// WebCrawlerJobsControlResponseBody The response to resume a web crawler job.
type WebCrawlerJobsControlResponseBody struct {
	WebCrawlerJob WebCrawlerJob `json:"web_crawler_job"`
}

// WebCrawlerJobsCreateRequest The request to create a web crawler job which will create webpages as
// artifacts.
type WebCrawlerJobsCreateRequest struct {
	// AcceptRegex The regex a URL must satisfy to be crawled.
	// Deprecated:
	AcceptRegex *string `json:"accept_regex,omitempty"`

	// AcceptRegexes The list of regexes a URL must satisfy to be crawled.
	AcceptRegexes *[]string `json:"accept_regexes,omitempty"`

	// AppliesToParts The parts to which created webpage/articles during this crawler job
	// will be linked to.
	AppliesToParts []string `json:"applies_to_parts"`

	// Description The description of the job.
	Description *string `json:"description,omitempty"`

	// DomainNames The list of allowed domain names to crawl.
	DomainNames *[]string `json:"domain_names,omitempty"`

	// Frequency Number of days between re-sync job runs. If 0, the job will run
	// only once.
	Frequency *int32 `json:"frequency,omitempty"`

	// MaxDepth The maximum depth to crawl.
	MaxDepth *int32 `json:"max_depth,omitempty"`

	// NotifyOnComplete Whether to notify the user when the job is complete. Default is
	// true.
	NotifyOnComplete *bool `json:"notify_on_complete,omitempty"`

	// RejectRegex The regex which if satisfied by a URL results in rejection of the
	// URL. If a URL matches both accept and reject regexes, it is
	// rejected.
	// Deprecated:
	RejectRegex *string `json:"reject_regex,omitempty"`

	// RejectRegexes The list of regexes which if satisfied by a URL results in
	// rejection of the URL. If a URL matches both accept and reject
	// regexes, it is rejected.
	RejectRegexes *[]string `json:"reject_regexes,omitempty"`

	// SitemapIndexUrls The list of sitemap index URLs to crawl.
	SitemapIndexUrls *[]string `json:"sitemap_index_urls,omitempty"`

	// SitemapUrls The list of sitemap URLs to crawl.
	SitemapUrls *[]string `json:"sitemap_urls,omitempty"`

	// Urls The list of URLs to crawl.
	Urls *[]string `json:"urls,omitempty"`

	// UserAgent User agent to use for crawling websites in this job.
	UserAgent *string `json:"user_agent,omitempty"`
}

// WebCrawlerJobsCreateResponseBody The response to create a web crawler job.
type WebCrawlerJobsCreateResponseBody struct {
	WebCrawlerJob WebCrawlerJob `json:"web_crawler_job"`
}

// WebCrawlerJobsGetRequest The request to get a web crawler job.
type WebCrawlerJobsGetRequest struct {
	// Id The ID of the job.
	Id string `json:"id"`
}

// WebCrawlerJobsGetResponseBody The response to get a web crawler job.
type WebCrawlerJobsGetResponseBody struct {
	WebCrawlerJob WebCrawlerJob `json:"web_crawler_job"`
}

// WebCrawlerJobsListRequest The request to list web crawler jobs.
type WebCrawlerJobsListRequest struct {
	// CreatedBy Filters for web crawler jobs created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of web crawler jobs to return. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`
}

// WebCrawlerJobsListResponseBody The response to list web crawler jobs.
type WebCrawlerJobsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// WebCrawlerJobs The list of jobs.
	WebCrawlerJobs []WebCrawlerJob `json:"web_crawler_jobs"`
}

// Webhook defines model for webhook.
type Webhook struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// EventTypes The event types that the webhook will receive.
	EventTypes *[]WebhookEventType `json:"event_types,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Secret The secret to use for verifying webhook events.
	Secret []byte `json:"secret"`

	// Status The status of the webhook.
	Status WebhookStatus `json:"status"`

	// Url The URL of the webhook endpoint.
	Url string `json:"url"`
}

// WebhookEventRequest defines model for webhook-event-request.
type WebhookEventRequest struct {
	AccountCreated           *EventAccountCreated      `json:"account_created,omitempty"`
	AccountDeleted           *EventAccountDeleted      `json:"account_deleted,omitempty"`
	AccountUpdated           *EventAccountUpdated      `json:"account_updated,omitempty"`
	EventAiAgentResponseBody *EventAiAgentResponseBody `json:"ai_agent_response,omitempty"`
	ConversationCreated      *EventConversationCreated `json:"conversation_created,omitempty"`
	ConversationDeleted      *EventConversationDeleted `json:"conversation_deleted,omitempty"`
	ConversationUpdated      *EventConversationUpdated `json:"conversation_updated,omitempty"`
	DashboardCreated         *EventDashboardCreated    `json:"dashboard_created,omitempty"`
	DashboardDeleted         *EventDashboardDeleted    `json:"dashboard_deleted,omitempty"`
	DashboardUpdated         *EventDashboardUpdated    `json:"dashboard_updated,omitempty"`
	DevUserCreated           *EventDevUserCreated      `json:"dev_user_created,omitempty"`
	DevUserDeleted           *EventDevUserDeleted      `json:"dev_user_deleted,omitempty"`
	DevUserUpdated           *EventDevUserUpdated      `json:"dev_user_updated,omitempty"`
	GroupCreated             *EventGroupCreated        `json:"group_created,omitempty"`
	GroupDeleted             *EventGroupDeleted        `json:"group_deleted,omitempty"`
	GroupMemberAdded         *EventGroupMemberAdded    `json:"group_member_added,omitempty"`
	GroupMemberRemoved       *EventGroupMemberRemoved  `json:"group_member_removed,omitempty"`
	GroupUpdated             *EventGroupUpdated        `json:"group_updated,omitempty"`

	// Id The event's ID.
	Id                    string                      `json:"id"`
	IncidentCreated       *EventIncidentCreated       `json:"incident_created,omitempty"`
	IncidentDeleted       *EventIncidentDeleted       `json:"incident_deleted,omitempty"`
	IncidentUpdated       *EventIncidentUpdated       `json:"incident_updated,omitempty"`
	LinkCreated           *EventLinkCreated           `json:"link_created,omitempty"`
	LinkDeleted           *EventLinkDeleted           `json:"link_deleted,omitempty"`
	LinkUpdated           *EventLinkUpdated           `json:"link_updated,omitempty"`
	PartCreated           *EventPartCreated           `json:"part_created,omitempty"`
	PartDeleted           *EventPartDeleted           `json:"part_deleted,omitempty"`
	PartUpdated           *EventPartUpdated           `json:"part_updated,omitempty"`
	QuestionAnswerCreated *EventQuestionAnswerCreated `json:"question_answer_created,omitempty"`
	QuestionAnswerDeleted *EventQuestionAnswerDeleted `json:"question_answer_deleted,omitempty"`
	QuestionAnswerUpdated *EventQuestionAnswerUpdated `json:"question_answer_updated,omitempty"`
	RevOrgCreated         *EventRevOrgCreated         `json:"rev_org_created,omitempty"`
	RevOrgDeleted         *EventRevOrgDeleted         `json:"rev_org_deleted,omitempty"`
	RevOrgUpdated         *EventRevOrgUpdated         `json:"rev_org_updated,omitempty"`
	RevUserCreated        *EventRevUserCreated        `json:"rev_user_created,omitempty"`
	RevUserDeleted        *EventRevUserDeleted        `json:"rev_user_deleted,omitempty"`
	RevUserUpdated        *EventRevUserUpdated        `json:"rev_user_updated,omitempty"`
	SlaTrackerCreated     *EventSlaTrackerCreated     `json:"sla_tracker_created,omitempty"`
	SlaTrackerDeleted     *EventSlaTrackerDeleted     `json:"sla_tracker_deleted,omitempty"`
	SlaTrackerFetched     *EventSlaTrackerFetched     `json:"sla_tracker_fetched,omitempty"`
	SlaTrackerUpdated     *EventSlaTrackerUpdated     `json:"sla_tracker_updated,omitempty"`
	SurveyCreated         *EventSurveyCreated         `json:"survey_created,omitempty"`
	SurveyDeleted         *EventSurveyDeleted         `json:"survey_deleted,omitempty"`
	SurveyResponseCreated *EventSurveyResponseCreated `json:"survey_response_created,omitempty"`
	SurveyResponseDeleted *EventSurveyResponseDeleted `json:"survey_response_deleted,omitempty"`
	SurveyResponseUpdated *EventSurveyResponseUpdated `json:"survey_response_updated,omitempty"`
	SurveyUpdated         *EventSurveyUpdated         `json:"survey_updated,omitempty"`
	SyncHistoryCreated    *EventSyncHistoryCreated    `json:"sync_history_created,omitempty"`
	SyncHistoryDeleted    *EventSyncHistoryDeleted    `json:"sync_history_deleted,omitempty"`
	SyncHistoryUpdated    *EventSyncHistoryUpdated    `json:"sync_history_updated,omitempty"`
	TagCreated            *EventTagCreated            `json:"tag_created,omitempty"`
	TagDeleted            *EventTagDeleted            `json:"tag_deleted,omitempty"`
	TagUpdated            *EventTagUpdated            `json:"tag_updated,omitempty"`
	TimelineEntryCreated  *EventTimelineEntryCreated  `json:"timeline_entry_created,omitempty"`
	TimelineEntryDeleted  *EventTimelineEntryDeleted  `json:"timeline_entry_deleted,omitempty"`
	TimelineEntryUpdated  *EventTimelineEntryUpdated  `json:"timeline_entry_updated,omitempty"`

	// Timestamp Timestamp of the webhook's invocation for the event. Note this
	// should be used to protect against replay attacks, where the event
	// should only be processed if the timestamp isn't stale by several
	// seconds.
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Type The event types that the webhook will receive.
	Type           *WebhookEventType    `json:"type,omitempty"`
	Verify         *WebhookEventVerify  `json:"verify,omitempty"`
	WebhookCreated *EventWebhookCreated `json:"webhook_created,omitempty"`
	WebhookDeleted *EventWebhookDeleted `json:"webhook_deleted,omitempty"`

	// WebhookId ID of the webhook for the event.
	WebhookId      string               `json:"webhook_id"`
	WebhookUpdated *EventWebhookUpdated `json:"webhook_updated,omitempty"`
	WidgetCreated  *EventWidgetCreated  `json:"widget_created,omitempty"`
	WidgetDeleted  *EventWidgetDeleted  `json:"widget_deleted,omitempty"`
	WidgetUpdated  *EventWidgetUpdated  `json:"widget_updated,omitempty"`
	WorkCreated    *EventWorkCreated    `json:"work_created,omitempty"`
	WorkDeleted    *EventWorkDeleted    `json:"work_deleted,omitempty"`
	WorkFetched    *EventWorkFetched    `json:"work_fetched,omitempty"`
	WorkUpdated    *EventWorkUpdated    `json:"work_updated,omitempty"`
}

// WebhookEventResponseBody defines model for webhook-event-response.
type WebhookEventResponseBody struct {
	// Challenge The challenge from the "verify" request, otherwise this should not
	// be set for other request types.
	Challenge *[]byte `json:"challenge,omitempty"`
}

// WebhookEventType The event types that the webhook will receive.
type WebhookEventType string

// WebhookEventVerify defines model for webhook-event-verify.
type WebhookEventVerify struct {
	// Challenge The challenge that must be echoed in the response.
	Challenge []byte `json:"challenge"`
}

// WebhookStatus The status of the webhook.
type WebhookStatus string

// WebhookSummary defines model for webhook-summary.
type WebhookSummary = AtomBaseSummary

// WebhooksCreateRequest The request to create a new webhook.
type WebhooksCreateRequest struct {
	// EventTypes The event types that the webhook endpoint will receive.
	EventTypes *[]WebhookEventType `json:"event_types,omitempty"`

	// Secret The secret to use when verifying webhook events. If provided, the
	// secret must be between 8 and 32 bytes (inclusive). If not set, a
	// secret will be automatically generated and provided in the
	// response.
	Secret *[]byte `json:"secret,omitempty"`

	// Url The URL of the webhook endpoint.
	Url string `json:"url"`
}

// WebhooksCreateResponseBody The response to creating a new webhook.
type WebhooksCreateResponseBody struct {
	Webhook Webhook `json:"webhook"`
}

// WebhooksDeleteRequest The request to delete a webhook.
type WebhooksDeleteRequest struct {
	// Id ID for the webhook.
	Id string `json:"id"`
}

// WebhooksDeleteResponseBody The response to deleting the webhook.
type WebhooksDeleteResponseBody = map[string]interface{}

// WebhooksGetRequest The request to get a webhook's information.
type WebhooksGetRequest struct {
	// Id ID for the webhook.
	Id string `json:"id"`
}

// WebhooksGetResponseBody The response to getting the information for the webhook.
type WebhooksGetResponseBody struct {
	Webhook Webhook `json:"webhook"`
}

// WebhooksListRequest The request to list the webhooks.
type WebhooksListRequest = map[string]interface{}

// WebhooksListResponseBody The response to listing the webhooks.
type WebhooksListResponseBody struct {
	// Webhooks The list of webhooks.
	Webhooks []Webhook `json:"webhooks"`
}

// WebhooksUpdateAction The action to update the webhook's status.
type WebhooksUpdateAction string

// WebhooksUpdateRequest The request to update a webhook.
type WebhooksUpdateRequest struct {
	// Action The action to update the webhook's status.
	Action     *WebhooksUpdateAction            `json:"action,omitempty"`
	EventTypes *WebhooksUpdateRequestEventTypes `json:"event_types,omitempty"`

	// Id ID for the webhook.
	Id string `json:"id"`

	// Secret If provided, updates the secret that's used when verifying webhook
	// events, which must be between 8 and 32 bytes (inclusive). Otherwise
	// if empty, then a new secret is generated. If the webhook is active,
	// then its status will transition to the 'unverified' state and it
	// won't receive any object events until successfully verified.
	Secret *[]byte `json:"secret,omitempty"`

	// Url The webhook's updated URL. If the webhook is active, then the
	// webhook's status will transition to the 'unverified' state and it
	// won't receive any object events until successfully verified.
	Url *string `json:"url,omitempty"`
}

// WebhooksUpdateRequestEventTypes defines model for webhooks-update-request-event-types.
type WebhooksUpdateRequestEventTypes struct {
	// Add The event types to add. If a provided event type is already set for
	// the webhook, then nothing is done. Note this is mutually exclusive
	// with 'set'.
	Add *[]WebhookEventType `json:"add,omitempty"`

	// Remove The event types to remove. If a provided event type isn't set for
	// the webhook, then nothing is done. Note this is mutually exclusive
	// with 'set'.
	Remove *[]WebhookEventType `json:"remove,omitempty"`

	// Set The updated event types, which will replace the webhook's current
	// event types. Note this is mutually exclusive with 'add' and
	// 'remove'.
	Set *[]WebhookEventType `json:"set,omitempty"`
}

// WebhooksUpdateResponseBody The response to updating the webhook.
type WebhooksUpdateResponseBody struct {
	Webhook Webhook `json:"webhook"`
}

// WeeklyOrgSchedule The schedule for each week.
type WeeklyOrgSchedule = map[string]interface{}

// Widget defines model for widget.
type Widget = AtomBase

// Work defines model for work.
type Work struct {
	Type  WorkType `json:"type"`
	union json.RawMessage
}

// WorkBase defines model for work-base.
type WorkBase struct {
	AppliesToPart *PartSummary `json:"applies_to_part,omitempty"`

	// Artifacts The artifacts attached to the work item.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body Body of the work object.
	Body      *string      `json:"body,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// ReportedBy Users that reported the work.
	ReportedBy *[]UserSummary `json:"reported_by,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStage `json:"stage,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// WorkBaseSummary defines model for work-base-summary.
type WorkBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStageSummary `json:"stage,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// WorkType defines model for work-type.
type WorkType string

// WorkflowRunSummary defines model for workflow-run-summary.
type WorkflowRunSummary = AtomBaseSummary

// WorkflowSummary defines model for workflow-summary.
type WorkflowSummary = AtomBaseSummary

// WorksCreateRequest defines model for works-create-request.
type WorksCreateRequest struct {
	// AppliesToPart The [part](https://devrev.ai/docs/product/parts) that the work
	// applies to. Specifying a part is required when creating tickets and
	// issues.
	AppliesToPart string `json:"applies_to_part"`

	// Artifacts The IDs of the artifacts to associate with the work item.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Body Body of the work object.
	Body *string `json:"body,omitempty"`

	// OwnedBy The users that own the work.
	OwnedBy []string `json:"owned_by"`

	// ReportedBy The users that reported the work.
	ReportedBy *[]string `json:"reported_by,omitempty"`

	// Stage Sets an object's initial stage.
	Stage *StageInit `json:"stage,omitempty"`

	// StageValidationOptions The type of stage validations options when creating a work item.
	StageValidationOptions *[]StageValidationOptionForCreate `json:"stage_validation_options,omitempty"`

	// Tags Tags associated with the work item.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp for when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the work object.
	Title string   `json:"title"`
	Type  WorkType `json:"type"`
	union json.RawMessage
}

// WorksCreateRequestIssue defines model for works-create-request-issue.
type WorksCreateRequestIssue struct {
	// DevelopedWith The IDs of the parts associated with issue.
	DevelopedWith *[]string `json:"developed_with,omitempty"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *IssuePriority `json:"priority,omitempty"`

	// PriorityV2 Priority enum id of the work based upon impact and criticality. The
	// allowed ids can be extended by the user. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "P0",
	//     "ordinal": 1,
	//     "overridable": true
	//   },
	//   {
	//     "id": 2,
	//     "label": "P1",
	//     "ordinal": 2,
	//     "overridable": true
	//   },
	//   {
	//     "id": 3,
	//     "label": "P2",
	//     "ordinal": 3,
	//     "overridable": true
	//   },
	//   {
	//     "id": 4,
	//     "label": "P3",
	//     "ordinal": 4,
	//     "overridable": true
	//   }
	// ```
	PriorityV2 *int64 `json:"priority_v2,omitempty"`

	// Sprint The sprint that the issue belongs to.
	Sprint *string `json:"sprint,omitempty"`

	// TargetStartDate Timestamp for when the work is expected to start.
	TargetStartDate *time.Time `json:"target_start_date,omitempty"`
}

// WorksCreateRequestTicket defines model for works-create-request-ticket.
type WorksCreateRequestTicket struct {
	// Account The account that the ticket is associated with.
	Account *string `json:"account,omitempty"`

	// Channels Channels of the ticket.
	Channels *[]TicketChannels `json:"channels,omitempty"`

	// ChannelsV2 Channel IDs of the ticket.
	ChannelsV2 *[]string `json:"channels_v2,omitempty"`

	// Group The group that the ticket is associated with.
	Group *string `json:"group,omitempty"`

	// IsSpam Whether the ticket is spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// NeedsResponse Whether the ticket needs a response.
	NeedsResponse *bool `json:"needs_response,omitempty"`

	// RevOrg The Rev organization that the ticket is associated with.
	RevOrg *string `json:"rev_org,omitempty"`

	// Severity Severity of the ticket.
	Severity *TicketSeverity `json:"severity,omitempty"`

	// SourceChannel The source channel of the ticket.
	SourceChannel *string `json:"source_channel,omitempty"`

	// SourceChannelV2 Source channel ID of the ticket.
	SourceChannelV2 *string `json:"source_channel_v2,omitempty"`
}

// WorksCreateResponseBody defines model for works-create-response.
type WorksCreateResponseBody struct {
	Work Work `json:"work"`
}

// WorksDeleteRequest defines model for works-delete-request.
type WorksDeleteRequest struct {
	// Id The work's ID.
	Id string `json:"id"`
}

// WorksDeleteResponseBody defines model for works-delete-response.
type WorksDeleteResponseBody = map[string]interface{}

// WorksExportRequest defines model for works-export-request.
type WorksExportRequest struct {
	// ActualCloseDate Provides ways to specify date ranges on objects.
	ActualCloseDate *DateFilter `json:"actual_close_date,omitempty"`

	// AppliesToPart Filters for work belonging to any of the provided parts.
	AppliesToPart *[]string `json:"applies_to_part,omitempty"`

	// CreatedBy Filters for work created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// First The number of work items to return. The default is '50', the
	// maximum is '5000'.
	First *int32            `json:"first,omitempty"`
	Issue *WorksFilterIssue `json:"issue,omitempty"`

	// ModifiedBy Filters for work modified by any of these users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for work owned by any of these users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// ReportedBy Filters for work reported by any of these users.
	ReportedBy *[]string `json:"reported_by,omitempty"`

	// Stage The filter for stages.
	Stage      *StageFilter      `json:"stage,omitempty"`
	StagedInfo *StagedInfoFilter `json:"staged_info,omitempty"`

	// State Filters for work with any of the provided states.
	State        *[]string           `json:"state,omitempty"`
	SyncMetadata *SyncMetadataFilter `json:"sync_metadata,omitempty"`

	// Tags Filters for work with any of the provided tags.
	Tags *[]string `json:"tags,omitempty"`

	// TargetCloseDate Provides ways to specify date ranges on objects.
	TargetCloseDate *DateFilter        `json:"target_close_date,omitempty"`
	Ticket          *WorksFilterTicket `json:"ticket,omitempty"`

	// Type Filters for work of the provided types.
	Type *[]WorkType `json:"type,omitempty"`
}

// WorksExportResponseBody defines model for works-export-response.
type WorksExportResponseBody struct {
	// Works The resulting collection of work items.
	Works []Work `json:"works"`
}

// WorksFilterIssue defines model for works-filter-issue.
type WorksFilterIssue struct {
	// Accounts Filters for issues with any of the provided accounts.
	Accounts *[]string `json:"accounts,omitempty"`

	// ActualStartDate Provides ways to specify date ranges on objects.
	ActualStartDate *DateFilter `json:"actual_start_date,omitempty"`

	// Priority Filters for issues with any of the provided priorities.
	Priority *[]IssuePriority `json:"priority,omitempty"`

	// PriorityV2 Filters for issues with any of the provided priority enum ids.
	PriorityV2 *[]int64 `json:"priority_v2,omitempty"`

	// RevOrgs Filters for issues with any of the provided Rev organizations.
	RevOrgs *[]string `json:"rev_orgs,omitempty"`

	// SlaSummary The filter for SLA summary.
	SlaSummary *SlaSummaryFilter `json:"sla_summary,omitempty"`

	// Sprint Filters for issues with any of the sprint.
	Sprint *[]string `json:"sprint,omitempty"`

	// TargetStartDate Provides ways to specify date ranges on objects.
	TargetStartDate *DateFilter `json:"target_start_date,omitempty"`
}

// WorksFilterTicket defines model for works-filter-ticket.
type WorksFilterTicket struct {
	// Brand Filters for tickets that are associated with any of the brands.
	Brand *[]string `json:"brand,omitempty"`

	// Channels Filters for tickets with any of the provided channels.
	Channels *[]TicketChannels `json:"channels,omitempty"`

	// ChannelsV2 Filters for tickets that are associated with any of the channels.
	ChannelsV2 *[]string `json:"channels_v2,omitempty"`

	// Group Filters for tickets belonging to specific groups.
	Group *[]string `json:"group,omitempty"`

	// IsFrozen Filters for frozen tickets.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// IsSpam Filters for tickets that are spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// NeedsResponse Filters for tickets that need response.
	NeedsResponse *bool `json:"needs_response,omitempty"`

	// RevOrg Filters for tickets that are associated with any of the provided
	// Rev organizations.
	RevOrg *[]string `json:"rev_org,omitempty"`

	// Severity Filters for tickets with any of the provided severities.
	Severity *[]TicketSeverity `json:"severity,omitempty"`

	// SlaSummary The filter for SLA summary.
	SlaSummary *SlaSummaryFilter `json:"sla_summary,omitempty"`

	// SourceChannel Filters for tickets with any of the provided source channels.
	SourceChannel *[]string `json:"source_channel,omitempty"`

	// SourceChannelV2 Filters for tickets that are associated with any of the source
	// channels.
	SourceChannelV2 *[]string `json:"source_channel_v2,omitempty"`

	// Surveys The filter for survey aggregation.
	Surveys *SurveyAggregationFilter `json:"surveys,omitempty"`
}

// WorksGetRequest defines model for works-get-request.
type WorksGetRequest struct {
	// Id The work's ID.
	Id string `json:"id"`
}

// WorksGetResponseBody defines model for works-get-response.
type WorksGetResponseBody struct {
	Work Work `json:"work"`
}

// WorksListRequest defines model for works-list-request.
type WorksListRequest struct {
	// ActualCloseDate Provides ways to specify date ranges on objects.
	ActualCloseDate *DateFilter `json:"actual_close_date,omitempty"`

	// AppliesToPart Filters for work belonging to any of the provided parts.
	AppliesToPart *[]string `json:"applies_to_part,omitempty"`

	// CreatedBy Filters for work created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string           `json:"cursor,omitempty"`
	Issue  *WorksFilterIssue `json:"issue,omitempty"`

	// Limit The maximum number of works to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedBy Filters for work modified by any of these users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for work owned by any of these users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// ReportedBy Filters for work reported by any of these users.
	ReportedBy *[]string `json:"reported_by,omitempty"`

	// SortBy Fields to sort the works by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stage The filter for stages.
	Stage      *StageFilter      `json:"stage,omitempty"`
	StagedInfo *StagedInfoFilter `json:"staged_info,omitempty"`

	// State Filters for work with any of the provided states.
	State        *[]string           `json:"state,omitempty"`
	SyncMetadata *SyncMetadataFilter `json:"sync_metadata,omitempty"`

	// Tags Filters for work with any of the provided tags.
	Tags *[]string `json:"tags,omitempty"`

	// TargetCloseDate Provides ways to specify date ranges on objects.
	TargetCloseDate *DateFilter        `json:"target_close_date,omitempty"`
	Ticket          *WorksFilterTicket `json:"ticket,omitempty"`

	// Type Filters for work of the provided types.
	Type *[]WorkType `json:"type,omitempty"`
}

// WorksListResponseBody defines model for works-list-response.
type WorksListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Works The list of works.
	Works []Work `json:"works"`
}

// WorksUpdateRequest defines model for works-update-request.
type WorksUpdateRequest struct {
	// AppliesToPart Updates the part that the work item applies to.
	AppliesToPart *string                      `json:"applies_to_part,omitempty"`
	Artifacts     *WorksUpdateRequestArtifacts `json:"artifacts,omitempty"`

	// Body Updated body of the work object, or unchanged if not provided.
	Body *string `json:"body,omitempty"`

	// Id The work's ID.
	Id         string                        `json:"id"`
	OwnedBy    *WorksUpdateRequestOwnedBy    `json:"owned_by,omitempty"`
	ReportedBy *WorksUpdateRequestReportedBy `json:"reported_by,omitempty"`

	// Stage Updates an object's stage.
	Stage *StageUpdate `json:"stage,omitempty"`

	// StageValidationOptions The type of stage validations options when updating the stage or
	// the stage diagram of an object.
	StageValidationOptions *[]StageValidationOptionForUpdate   `json:"stage_validation_options,omitempty"`
	StagedInfo             *WorksUpdateRequestStagedInfoUpdate `json:"staged_info,omitempty"`
	Tags                   *WorksUpdateRequestTags             `json:"tags,omitempty"`

	// TargetCloseDate Updates the timestamp for when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date"`

	// Title Updated title of the work object, or unchanged if not provided.
	Title *string   `json:"title,omitempty"`
	Type  *WorkType `json:"type,omitempty"`
	union json.RawMessage
}

// WorksUpdateRequestArtifacts defines model for works-update-request-artifacts.
type WorksUpdateRequestArtifacts struct {
	// Add Adds the provided artifacts (if not already present) to the field.
	Add *[]string `json:"add,omitempty"`

	// Remove Removes the provided artifacts (if they exist) from the field.
	Remove *[]string `json:"remove,omitempty"`

	// Set Sets the field to the provided artifacts.
	Set *[]string `json:"set,omitempty"`
}

// WorksUpdateRequestIssue defines model for works-update-request-issue.
type WorksUpdateRequestIssue struct {
	DevelopedWith *WorksUpdateRequestIssueDevelopedWith `json:"developed_with,omitempty"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *IssuePriority `json:"priority,omitempty"`

	// PriorityV2 Priority enum id of the work based upon impact and criticality. The
	// allowed ids can be extended by the user. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "P0",
	//     "ordinal": 1,
	//     "overridable": true
	//   },
	//   {
	//     "id": 2,
	//     "label": "P1",
	//     "ordinal": 2,
	//     "overridable": true
	//   },
	//   {
	//     "id": 3,
	//     "label": "P2",
	//     "ordinal": 3,
	//     "overridable": true
	//   },
	//   {
	//     "id": 4,
	//     "label": "P3",
	//     "ordinal": 4,
	//     "overridable": true
	//   }
	// ```
	PriorityV2 *int64 `json:"priority_v2,omitempty"`

	// Sprint Updates the sprint that the issue belongs to.
	Sprint *string `json:"sprint"`

	// TargetStartDate Updates the timestamp for when the work is expected to start.
	TargetStartDate *time.Time `json:"target_start_date"`
}

// WorksUpdateRequestIssueDevelopedWith defines model for works-update-request-issue-developed-with.
type WorksUpdateRequestIssueDevelopedWith struct {
	// Set Sets the IDs of the parts associated with issue.
	Set *[]string `json:"set,omitempty"`
}

// WorksUpdateRequestOwnedBy defines model for works-update-request-owned-by.
type WorksUpdateRequestOwnedBy struct {
	// Set Sets the owner IDs to the provided user IDs. This must not be
	// empty.
	Set *[]string `json:"set,omitempty"`
}

// WorksUpdateRequestReportedBy defines model for works-update-request-reported-by.
type WorksUpdateRequestReportedBy struct {
	// Set Sets the users that reported the work to the provided user IDs.
	Set *[]string `json:"set,omitempty"`
}

// WorksUpdateRequestStagedInfoUpdate defines model for works-update-request-staged-info-update.
type WorksUpdateRequestStagedInfoUpdate struct {
	// SyncInUnresolvedFields Updates the sync in unresolved fields of the staged work.
	SyncInUnresolvedFields *[]WorksUpdateRequestStagedInfoUpdateUnresolvedField `json:"sync_in_unresolved_fields,omitempty"`

	// SyncOutUnresolvedFields Updates the sync out unresolved fields of the staged work.
	SyncOutUnresolvedFields *[]WorksUpdateRequestStagedInfoUpdateUnresolvedField `json:"sync_out_unresolved_fields,omitempty"`

	// UnresolvedFields Updates the unresolved fields of the staged work.
	UnresolvedFields *[]string `json:"unresolved_fields,omitempty"`
}

// WorksUpdateRequestStagedInfoUpdateUnresolvedField defines model for works-update-request-staged-info-update-unresolved-field.
type WorksUpdateRequestStagedInfoUpdateUnresolvedField struct {
	// DevrevFieldName DevRev field name of the object's attribute.
	DevrevFieldName *string `json:"devrev_field_name,omitempty"`

	// ExternalDisplayName External field name as seen by the end user.
	ExternalDisplayName *string `json:"external_display_name,omitempty"`

	// ExternalFieldName Api name of the external object's field.
	ExternalFieldName *string `json:"external_field_name,omitempty"`
}

// WorksUpdateRequestTags defines model for works-update-request-tags.
type WorksUpdateRequestTags struct {
	// Set Sets the provided tags on the work item.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// WorksUpdateRequestTicket defines model for works-update-request-ticket.
type WorksUpdateRequestTicket struct {
	// Account Updates the account that the ticket is associated with.
	Account  *string                           `json:"account"`
	Channels *WorksUpdateRequestTicketChannels `json:"channels,omitempty"`

	// ChannelsV2 Updates channel IDs of the ticket.
	ChannelsV2 *[]string `json:"channels_v2,omitempty"`

	// Group Updates the group that the ticket is associated with.
	Group *string `json:"group"`

	// IsArchived Whether the ticket is archived.
	IsArchived *bool `json:"is_archived,omitempty"`

	// IsFrozen Whether the ticket is frozen.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// IsSpam Updates whether the ticket is spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// NeedsResponse Updates whether the ticket needs a response.
	NeedsResponse *bool `json:"needs_response,omitempty"`

	// RevOrg Updates the Rev organization that the ticket is associated with.
	RevOrg *string `json:"rev_org"`

	// Sentiment The enum ID for the sentiment of the ticket. The allowed ids can be
	// extended by the user. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "Delighted",
	//     "ordinal": 1,
	//     "overridable": true
	//   },
	//   {
	//     "id": 2,
	//     "label": "Happy",
	//     "ordinal": 2,
	//     "overridable": true
	//   },
	//   {
	//     "id": 3,
	//     "label": "Neutral",
	//     "ordinal": 3,
	//     "overridable": true
	//   },
	//   {
	//     "id": 4,
	//     "label": "Unhappy",
	//     "ordinal": 4,
	//     "overridable": true
	//   },
	//   {
	//     "id": 5,
	//     "label": "Frustrated",
	//     "ordinal": 5,
	//     "overridable": true
	//   }
	// ```
	Sentiment *int64 `json:"sentiment,omitempty"`

	// SentimentModifiedDate Timestamp at which sentiment was last modified.
	SentimentModifiedDate *time.Time `json:"sentiment_modified_date,omitempty"`

	// SentimentSummary Summary justifying the current sentiment.
	SentimentSummary *string `json:"sentiment_summary,omitempty"`

	// Severity Severity of the ticket.
	Severity *TicketSeverity `json:"severity,omitempty"`

	// SourceChannelV2 Updates the source channel of the ticket.
	SourceChannelV2 *string `json:"source_channel_v2"`
}

// WorksUpdateRequestTicketChannels defines model for works-update-request-ticket-channels.
type WorksUpdateRequestTicketChannels struct {
	// Set Sets the channels to the provided channels.
	Set *[]TicketChannels `json:"set,omitempty"`
}

// WorksUpdateResponseBody defines model for works-update-response.
type WorksUpdateResponseBody struct {
	Work Work `json:"work"`
}

// BadRequest Describes a error due to a bad request by the client.
type BadRequest = ErrorBadRequest

// Conflict defines model for conflict.
type Conflict = ErrorConflict

// Forbidden defines model for forbidden.
type Forbidden = ErrorForbidden

// InternalServerError defines model for internal-server-error.
type InternalServerError = ErrorInternalServerError

// NotFound defines model for not-found.
type NotFound = ErrorNotFound

// ServiceUnavailable defines model for service-unavailable.
type ServiceUnavailable = ErrorServiceUnavailable

// TooManyRequests defines model for too-many-requests.
type TooManyRequests = ErrorTooManyRequests

// Unauthorized defines model for unauthorized.
type Unauthorized = ErrorUnauthorized

// AccountsExportParams defines parameters for AccountsExport.
type AccountsExportParams struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `form:"display_name,omitempty" json:"display_name,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string `form:"external_refs,omitempty" json:"external_refs,omitempty"`

	// First The number of accounts to return. The default is '50'.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// SortBy Fields to sort the accounts by and the direction to sort them in.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `form:"stage,omitempty" json:"stage,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `form:"tier,omitempty" json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `form:"websites,omitempty" json:"websites,omitempty"`
}

// AccountsGetParams defines parameters for AccountsGet.
type AccountsGetParams struct {
	// Id The ID of the account to be retrieved.
	Id string `form:"id" json:"id"`
}

// AccountsListParams defines parameters for AccountsList.
type AccountsListParams struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `form:"display_name,omitempty" json:"display_name,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string `form:"external_refs,omitempty" json:"external_refs,omitempty"`

	// Limit The maximum number of accounts to return per page. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// SortBy Fields to sort the accounts by and the direction to sort them in.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `form:"stage,omitempty" json:"stage,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `form:"tier,omitempty" json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `form:"websites,omitempty" json:"websites,omitempty"`
}

// GetArticleParams defines parameters for GetArticle.
type GetArticleParams struct {
	// Id The ID of the required article.
	Id string `form:"id" json:"id"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `form:"dev_org,omitempty" json:"dev_org,omitempty"`
}

// ListArticlesParams defines parameters for ListArticles.
type ListArticlesParams struct {
	// AppliesToParts Filters for articles belonging to any of the provided parts.
	AppliesToParts *[]string `form:"applies_to_parts,omitempty" json:"applies_to_parts,omitempty"`

	// ArticleType Filter for the type of articles. If this is not provided, then
	// articles that are not content blocks are returned.
	ArticleType *[]ArticleType `form:"article_type,omitempty" json:"article_type,omitempty"`

	// AuthoredBy Filters for articles authored by any of the provided users.
	AuthoredBy *[]string `form:"authored_by,omitempty" json:"authored_by,omitempty"`

	// Brands Filters for articles belonging to any of the provided brands.
	Brands *[]string `form:"brands,omitempty" json:"brands,omitempty"`

	// CreatedBy Filters for articles created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `form:"dev_org,omitempty" json:"dev_org,omitempty"`

	// Limit The maximum number of articles to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedBy Filters for articles modified by any of the provided users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`

	// OwnedBy Filters for articles owned by any of the provided users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// Scope Filter for the scope of the articles.
	Scope *[]int64 `form:"scope,omitempty" json:"scope,omitempty"`

	// SharedWithMember ID of the group/member with whom the item is shared.
	SharedWithMember *string `form:"shared_with.member,omitempty" json:"shared_with.member,omitempty"`

	// SharedWithRole Role ID of the group/member with whom the item is shared.
	SharedWithRole *string `form:"shared_with.role,omitempty" json:"shared_with.role,omitempty"`

	// Tags Filters for article with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ArtifactsGetParams defines parameters for ArtifactsGet.
type ArtifactsGetParams struct {
	// Id The requested artifact's ID.
	Id string `form:"id" json:"id"`

	// Version The version of the artifact that needs to be fetched.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// ArtifactsListParams defines parameters for ArtifactsList.
type ArtifactsListParams struct {
	// ParentId The ID of the object to filter artifacts.
	ParentId *string `form:"parent_id,omitempty" json:"parent_id,omitempty"`
}

// ArtifactsLocateParams defines parameters for ArtifactsLocate.
type ArtifactsLocateParams struct {
	// Id The ID of the artifact to get the URL for.
	Id string `form:"id" json:"id"`

	// Version The version of the artifact that needs to be fetched.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// AtomsGetParams defines parameters for AtomsGet.
type AtomsGetParams struct {
	// Id The ID of the object to get.
	Id string `form:"id" json:"id"`
}

// AuthTokensGetParams defines parameters for AuthTokensGet.
type AuthTokensGetParams struct {
	// TokenId The unique identifier of the token under a given Dev organization.
	TokenId string `form:"token_id" json:"token_id"`
}

// AuthTokensListParams defines parameters for AuthTokensList.
type AuthTokensListParams struct {
	// ClientId An identifier that represents the application, which requested the
	// token. Only relevant for application access tokens.
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`

	// RequestedTokenType The type of the requested token. If no value is specified, the
	// response will include tokens of all the types.
	RequestedTokenType *AuthTokenRequestedTokenType `form:"requested_token_type,omitempty" json:"requested_token_type,omitempty"`

	// Subject The subject associated with the token. In the absence of this
	// parameter, the ID of the authenticated entity is treated as the
	// subject.
	Subject *string `form:"subject,omitempty" json:"subject,omitempty"`
}

// ChatsGetParams defines parameters for ChatsGet.
type ChatsGetParams struct {
	// Id The chat's ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// CodeChangesGetParams defines parameters for CodeChangesGet.
type CodeChangesGetParams struct {
	// Id The code change object ID.
	Id string `form:"id" json:"id"`
}

// CodeChangesListParams defines parameters for CodeChangesList.
type CodeChangesListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of code change objects to return. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`
}

// CommandsGetParams defines parameters for CommandsGet.
type CommandsGetParams struct {
	// Id The command's ID.
	Id string `form:"id" json:"id"`
}

// CommandsListParams defines parameters for CommandsList.
type CommandsListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// ExecutorType Filtering based on executor_type.
	ExecutorType *[]CommandActionExecutorType `form:"executor_type,omitempty" json:"executor_type,omitempty"`

	// Limit The maximum number of commands to return per page. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Namespace Filter commands based on namespace.
	Namespace *[]string `form:"namespace,omitempty" json:"namespace,omitempty"`

	// SortBy List of fields to sort the commands items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SourceObjectId ID of the object where command is invoked (work/part/conversation).
	SourceObjectId *string `form:"source_object_id,omitempty" json:"source_object_id,omitempty"`

	// Status Filter commands based on status.
	Status *[]CommandStatus `form:"status,omitempty" json:"status,omitempty"`
}

// ConversationsGetParams defines parameters for ConversationsGet.
type ConversationsGetParams struct {
	// Id The requested conversation's ID.
	Id string `form:"id" json:"id"`
}

// ConversationsListParams defines parameters for ConversationsList.
type ConversationsListParams struct {
	// AppliesToParts Filters for conversations belonging to any of the provided parts.
	AppliesToParts *[]string `form:"applies_to_parts,omitempty" json:"applies_to_parts,omitempty"`

	// Brand Filters for tickets that are associated with any of the brands.
	Brand *[]string `form:"brand,omitempty" json:"brand,omitempty"`

	// Channels Filters for conversations that are associated with any of the
	// channels.
	Channels *[]string `form:"channels,omitempty" json:"channels,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Group Filters for conversation that belong to the given groups.
	Group *[]string `form:"group,omitempty" json:"group,omitempty"`

	// IsCreatorVerified Filters for conversations that are created by verified users.
	IsCreatorVerified *bool `form:"is_creator_verified,omitempty" json:"is_creator_verified,omitempty"`

	// IsFrozen Filters for conversations that are frozen.
	IsFrozen *bool `form:"is_frozen,omitempty" json:"is_frozen,omitempty"`

	// IsSpam Filters for conversations that are spam.
	IsSpam *bool `form:"is_spam,omitempty" json:"is_spam,omitempty"`

	// Limit The maximum number of conversations to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Members Filters for conversations where these users are participants.
	Members *[]string `form:"members,omitempty" json:"members,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// OwnedBy Filters for conversations owned by any of these users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// RevOrg Filters for conversations that are associated with any of the
	// provided Rev organizations.
	RevOrg *[]string `form:"rev_org,omitempty" json:"rev_org,omitempty"`

	// RevOrgs Filters for conversations that are associated with any of the
	// provided Rev organizations.
	RevOrgs *[]string `form:"rev_orgs,omitempty" json:"rev_orgs,omitempty"`

	// SlaSummaryStage Filters for records with any of the provided SLA stages.
	SlaSummaryStage *[]SlaSummaryStage `form:"sla_summary.stage,omitempty" json:"sla_summary.stage,omitempty"`

	// SourceChannel Filters for conversations with any of the provided source channels.
	SourceChannel *[]string `form:"source_channel,omitempty" json:"source_channel,omitempty"`

	// SourceChannelV2 Filters for conversations that are associated with the source
	// channel.
	SourceChannelV2 *[]string `form:"source_channel_v2,omitempty" json:"source_channel_v2,omitempty"`

	// SourceChannels Filters for conversations with any of the provided source channels.
	SourceChannels *[]string `form:"source_channels,omitempty" json:"source_channels,omitempty"`

	// StageName Filters for records in the provided stage(s) by name.
	StageName *[]string `form:"stage.name,omitempty" json:"stage.name,omitempty"`

	// State Filters for conversations with any of the provided states.
	State *[]string `form:"state,omitempty" json:"state,omitempty"`

	// Tags Filters for conversations with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// TagsV2Id The ID of the tag.
	TagsV2Id *string `form:"tags_v2.id,omitempty" json:"tags_v2.id,omitempty"`

	// TagsV2Value The value for the object's association with the tag. If specified,
	// the value must be one that's specified in the tag's allowed values.
	TagsV2Value *string `form:"tags_v2.value,omitempty" json:"tags_v2.value,omitempty"`
}

// DevOrgAuthConnectionsGetParams defines parameters for DevOrgAuthConnectionsGet.
type DevOrgAuthConnectionsGetParams struct {
	// Id ID of the authentication connection.
	Id string `form:"id" json:"id"`
}

// DevUsersGetParams defines parameters for DevUsersGet.
type DevUsersGetParams struct {
	// Id User ID of the requested Dev user.
	Id string `form:"id" json:"id"`
}

// DevUsersListParams defines parameters for DevUsersList.
type DevUsersListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Email Filters Dev users based on email addresses.
	Email *[]string `form:"email,omitempty" json:"email,omitempty"`

	// ExternalIdentityId Unique ID of the user in the external source.
	ExternalIdentityId *string `form:"external_identity.id,omitempty" json:"external_identity.id,omitempty"`

	// ExternalIdentityIssuer Issuer of the external identity of the user.
	ExternalIdentityIssuer *string `form:"external_identity.issuer,omitempty" json:"external_identity.issuer,omitempty"`

	// Limit The maximum number of Dev users to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// SortBy Fields to sort the Dev users by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// State Filters Dev users based on state.
	State *[]UserState `form:"state,omitempty" json:"state,omitempty"`
}

// DirectoriesCountParams defines parameters for DirectoriesCount.
type DirectoriesCountParams struct {
	// CreatedBy Filters for directories created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// ModifiedBy Filters for directories modified by any of the provided users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`
}

// DirectoriesGetParams defines parameters for DirectoriesGet.
type DirectoriesGetParams struct {
	// Id The ID of the requested directory.
	Id string `form:"id" json:"id"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `form:"dev_org,omitempty" json:"dev_org,omitempty"`
}

// DirectoriesListParams defines parameters for DirectoriesList.
type DirectoriesListParams struct {
	// CreatedBy Filters for directories created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `form:"dev_org,omitempty" json:"dev_org,omitempty"`

	// Limit The maximum number of directories to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedBy Filters for directories modified by any of the provided users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`
}

// GroupsGetParams defines parameters for GroupsGet.
type GroupsGetParams struct {
	// Id The ID of the group to get.
	Id string `form:"id" json:"id"`
}

// GroupsListParams defines parameters for GroupsList.
type GroupsListParams struct {
	// CreatedBy Filters the groups on the basis of creator.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// GroupType Filters the groups based on the group type.
	GroupType *[]GroupType `form:"group_type,omitempty" json:"group_type,omitempty"`

	// IngestionSource Filter groups by ingestion source(s).
	IngestionSource *[]GroupIngestionSource `form:"ingestion_source,omitempty" json:"ingestion_source,omitempty"`

	// IsDefault Whether to fetch default or custom groups.
	IsDefault *bool `form:"is_default,omitempty" json:"is_default,omitempty"`

	// Limit The maximum number of groups to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberType Filters the groups on basis of member type.
	MemberType *[]GroupMemberType `form:"member_type,omitempty" json:"member_type,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Name Filters the groups on the basis of group name.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// SortBy Comma-separated fields to sort the groups by.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncMetadataExternalReference Filters for issues with this specific external reference.
	SyncMetadataExternalReference *[]string `form:"sync_metadata.external_reference,omitempty" json:"sync_metadata.external_reference,omitempty"`

	// SyncMetadataLastSyncInStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncInStatus *[]SyncMetadataFilterSyncInFilterStatus `form:"sync_metadata.last_sync_in.status,omitempty" json:"sync_metadata.last_sync_in.status,omitempty"`

	// SyncMetadataLastSyncInSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncInSyncHistory *[]string `form:"sync_metadata.last_sync_in.sync_history,omitempty" json:"sync_metadata.last_sync_in.sync_history,omitempty"`

	// SyncMetadataLastSyncInSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncInSyncUnit *[]string `form:"sync_metadata.last_sync_in.sync_unit,omitempty" json:"sync_metadata.last_sync_in.sync_unit,omitempty"`

	// SyncMetadataLastSyncOutStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncOutStatus *[]SyncMetadataFilterSyncOutFilterStatus `form:"sync_metadata.last_sync_out.status,omitempty" json:"sync_metadata.last_sync_out.status,omitempty"`

	// SyncMetadataLastSyncOutSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncOutSyncHistory *[]string `form:"sync_metadata.last_sync_out.sync_history,omitempty" json:"sync_metadata.last_sync_out.sync_history,omitempty"`

	// SyncMetadataLastSyncOutSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncOutSyncUnit *[]string `form:"sync_metadata.last_sync_out.sync_unit,omitempty" json:"sync_metadata.last_sync_out.sync_unit,omitempty"`

	// SyncMetadataOriginSystem Filters for issues synced from this specific origin system.
	SyncMetadataOriginSystem *[]string `form:"sync_metadata.origin_system,omitempty" json:"sync_metadata.origin_system,omitempty"`
}

// GroupMembersListParams defines parameters for GroupMembersList.
type GroupMembersListParams struct {
	// Group ID of the group for which to list members.
	Group string `form:"group" json:"group"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of members to return. If not set, then the default
	// is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`
}

// KeyringsCreateCallbackParams defines parameters for KeyringsCreateCallback.
type KeyringsCreateCallbackParams struct {
	// Code Code to exchange for an access token.
	Code string `form:"code" json:"code"`

	// State State value given to the authorization request.
	State string `form:"state" json:"state"`
}

// LinksGetParams defines parameters for LinksGet.
type LinksGetParams struct {
	// Id The requested link's ID.
	Id string `form:"id" json:"id"`
}

// LinksListParams defines parameters for LinksList.
type LinksListParams struct {
	// Object The ID of the object to list the links for.
	Object string `form:"object" json:"object"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Direction The direction of the links to list, otherwise if not present, then
	// links in both directions (source and target) are included.
	Direction *LinksDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// Limit The maximum number of links to return. If not set, then the default
	// is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkType The link type(s) to filter for, otherwise if not present, all link
	// types are included.
	LinkType *[]LinkType `form:"link_type,omitempty" json:"link_type,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ObjectTypes The object types to filter for, otherwise if not present, all object
	// types are included.
	ObjectTypes *[]LinkEndpointType `form:"object_types,omitempty" json:"object_types,omitempty"`

	// Types The link types to filter for, otherwise if not present, all link
	// types are included.
	Types *[]LinkType `form:"types,omitempty" json:"types,omitempty"`
}

// MeetingsCountParams defines parameters for MeetingsCount.
type MeetingsCountParams struct {
	// Channel Filters for meeting on specified channels.
	Channel *[]MeetingChannel `form:"channel,omitempty" json:"channel,omitempty"`

	// CreatedBy Filters for meetings created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// ExternalRef Filters for meetings with the provided external_ref(s).
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// LinksLinkType Filters for link type in links associated with the meeting.
	LinksLinkType *string `form:"links.link_type,omitempty" json:"links.link_type,omitempty"`

	// LinksTarget Filters for target id in links associated with the meeting.
	LinksTarget *string `form:"links.target,omitempty" json:"links.target,omitempty"`

	// LinksTargetObjectType Filters for target object type in links associated with the meeting.
	LinksTargetObjectType *string `form:"links.target_object_type,omitempty" json:"links.target_object_type,omitempty"`

	// Members Filter for meeting on specified Member Ids.
	Members *[]string `form:"members,omitempty" json:"members,omitempty"`

	// Organizer Filter for meeting on specified organizers.
	Organizer *[]string `form:"organizer,omitempty" json:"organizer,omitempty"`

	// Parent Filters for meetings with the provided parent.
	Parent *[]string `form:"parent,omitempty" json:"parent,omitempty"`

	// State Filters for meeting on specified state or outcomes.
	State *[]MeetingState `form:"state,omitempty" json:"state,omitempty"`
}

// MeetingsGetParams defines parameters for MeetingsGet.
type MeetingsGetParams struct {
	// Id The meeting's ID.
	Id string `form:"id" json:"id"`
}

// MeetingsListParams defines parameters for MeetingsList.
type MeetingsListParams struct {
	// Channel Filters for meeting on specified channels.
	Channel *[]MeetingChannel `form:"channel,omitempty" json:"channel,omitempty"`

	// CreatedBy Filters for meetings created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// ExternalRef Filters for meetings with the provided external_ref(s).
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// Limit The maximum number of meetings to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// LinksLinkType Filters for link type in links associated with the meeting.
	LinksLinkType *string `form:"links.link_type,omitempty" json:"links.link_type,omitempty"`

	// LinksTarget Filters for target id in links associated with the meeting.
	LinksTarget *string `form:"links.target,omitempty" json:"links.target,omitempty"`

	// LinksTargetObjectType Filters for target object type in links associated with the meeting.
	LinksTargetObjectType *string `form:"links.target_object_type,omitempty" json:"links.target_object_type,omitempty"`

	// Members Filter for meeting on specified Member Ids.
	Members *[]string `form:"members,omitempty" json:"members,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Organizer Filter for meeting on specified organizers.
	Organizer *[]string `form:"organizer,omitempty" json:"organizer,omitempty"`

	// Parent Filters for meetings with the provided parent.
	Parent *[]string `form:"parent,omitempty" json:"parent,omitempty"`

	// SortBy Fields to sort the meetings by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// State Filters for meeting on specified state or outcomes.
	State *[]MeetingState `form:"state,omitempty" json:"state,omitempty"`
}

// MetricDefinitionsGetParams defines parameters for MetricDefinitionsGet.
type MetricDefinitionsGetParams struct {
	// Id The ID of the metric definition to get.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name The unique human readable name of the metric.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// MetricDefinitionsListParams defines parameters for MetricDefinitionsList.
type MetricDefinitionsListParams struct {
	// AppliesToType The type of objects the metric definition applies to.
	AppliesToType *[]MetricDefinitionAppliesTo `form:"applies_to_type,omitempty" json:"applies_to_type,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// IncludeCustomMetrics Whether to include custom metrics in the response. If not set, then
	// custom metrics are excluded.
	IncludeCustomMetrics *bool `form:"include_custom_metrics,omitempty" json:"include_custom_metrics,omitempty"`

	// Limit The maximum number of records to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// SortBy Fields to sort the records by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Status The status of the metric definition.
	Status *[]MetricDefinitionStatus `form:"status,omitempty" json:"status,omitempty"`

	// Type The type of metric definitions sought.
	Type *[]MetricDefinitionMetricType `form:"type,omitempty" json:"type,omitempty"`
}

// MetricTrackersGetParams defines parameters for MetricTrackersGet.
type MetricTrackersGetParams struct {
	// Metric The ID of the metric that is being tracked.
	Metric string `form:"metric" json:"metric"`

	// Object The ID of the underlying object on which the metric is being tracked.
	Object string `form:"object" json:"object"`
}

// OrgScheduleFragmentsGetParams defines parameters for OrgScheduleFragmentsGet.
type OrgScheduleFragmentsGetParams struct {
	// Id Organization schedule Fragment ID.
	Id string `form:"id" json:"id"`
}

// OrgSchedulesEvaluateParams defines parameters for OrgSchedulesEvaluate.
type OrgSchedulesEvaluateParams struct {
	// Id Organization schedule ID.
	Id string `form:"id" json:"id"`

	// Instants Time instants to evaluate the organization schedule for.
	Instants []time.Time `form:"instants" json:"instants"`
}

// OrgSchedulesGetParams defines parameters for OrgSchedulesGet.
type OrgSchedulesGetParams struct {
	// Id Organization schedule ID.
	Id string `form:"id" json:"id"`
}

// OrgSchedulesListParams defines parameters for OrgSchedulesList.
type OrgSchedulesListParams struct {
	// CreatedById Creator ID the filter matches.
	CreatedById *[]string `form:"created_by_id,omitempty" json:"created_by_id,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Max number of organization schedules returned in a page. Default is
	// 50.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Status The organization schedule statuses the filter matches.
	Status *[]OrgScheduleStatus `form:"status,omitempty" json:"status,omitempty"`
}

// PartsGetParams defines parameters for PartsGet.
type PartsGetParams struct {
	// Id The ID of the part to retrieve.
	Id string `form:"id" json:"id"`
}

// PartsListParams defines parameters for PartsList.
type PartsListParams struct {
	// CreatedBy Filters for parts created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of parts to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedBy Filters for parts modified by any of these users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`

	// Name Filters for parts of the provided name(s).
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// OwnedBy Filters for parts owned by any of these users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// ParentPartLevel Number of levels to fetch the part hierarchy up to.
	ParentPartLevel *int32 `form:"parent_part.level,omitempty" json:"parent_part.level,omitempty"`

	// ParentPartParts Part IDs to fetch the hierarchy for. Required if any parent_part.*
	// fields are provided.
	ParentPartParts *[]string `form:"parent_part.parts,omitempty" json:"parent_part.parts,omitempty"`

	// Tags Filters for part with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Type Filters for parts of the provided type(s).
	Type *[]PartType `form:"type,omitempty" json:"type,omitempty"`
}

// ReactionsListParams defines parameters for ReactionsList.
type ReactionsListParams struct {
	// Emoji The emoji to list the reactors for. This can be the short name of the
	// emoji (e.g. "joy"), or the code point (e.g. "1f602").
	Emoji string `form:"emoji" json:"emoji"`

	// Object The ID of the object to list reactors for.
	Object string `form:"object" json:"object"`

	// Cursor The cursor to resume iteration from, otherwise if not provided, then
	// iteration starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of reactors to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// RevOrgsGetParams defines parameters for RevOrgsGet.
type RevOrgsGetParams struct {
	// Account The ID of account for which default Rev organization is to be
	// fetched.
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Id The ID of the required Rev organization.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// RevOrgsListParams defines parameters for RevOrgsList.
type RevOrgsListParams struct {
	// CreatedBy Filters by creator.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// DisplayName Array of display names of Rev orgs to be filtered.
	DisplayName *[]string `form:"display_name,omitempty" json:"display_name,omitempty"`

	// ExternalRef List of external refs to filter Rev organizations for.
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// Limit The maximum number of Rev organizations to be retrieved per page.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// SortBy Fields to sort the Rev organizations by and the direction to sort
	// them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// RevUsersGetParams defines parameters for RevUsersGet.
type RevUsersGetParams struct {
	// Id The ID of Rev user to be retrieved.
	Id string `form:"id" json:"id"`
}

// RevUsersListParams defines parameters for RevUsersList.
type RevUsersListParams struct {
	// Associations Filters for Rev users with specified associations
	// (account/workspace).
	Associations *[]string `form:"associations,omitempty" json:"associations,omitempty"`

	// CreatedBy Filters for Rev users that were created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Email List of emails of Rev users to be filtered.
	Email *[]string `form:"email,omitempty" json:"email,omitempty"`

	// ExternalRef List of external refs to filter Rev users for.
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// IsVerified Value of is_verified field to filter the Rev users.
	IsVerified *bool `form:"is_verified,omitempty" json:"is_verified,omitempty"`

	// Limit The maximum number of Rev users to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// PhoneNumbers List of phone numbers, in E.164 format, to filter Rev users on.
	PhoneNumbers *[]string `form:"phone_numbers,omitempty" json:"phone_numbers,omitempty"`

	// RevOrg List of IDs of Rev organizations to be filtered.
	RevOrg *[]string `form:"rev_org,omitempty" json:"rev_org,omitempty"`

	// SortBy Fields to sort the Rev users by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// RevUsersScanParams defines parameters for RevUsersScan.
type RevUsersScanParams struct {
	// Associations Filters for Rev users with specified associations
	// (account/workspace).
	Associations *[]string `form:"associations,omitempty" json:"associations,omitempty"`

	// CreatedBy Filters for Rev users that were created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration, otherwise the beginning if not
	// provided.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Email List of emails of Rev users to be filtered.
	Email *[]string `form:"email,omitempty" json:"email,omitempty"`

	// ExternalRef List of external refs to filter Rev users for.
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// IsVerified Value of is_verified field to filter the Rev users.
	IsVerified *bool `form:"is_verified,omitempty" json:"is_verified,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// PhoneNumbers List of phone numbers, in E.164 format, to filter Rev users on.
	PhoneNumbers *[]string `form:"phone_numbers,omitempty" json:"phone_numbers,omitempty"`

	// RevOrg List of IDs of Rev organizations to be filtered.
	RevOrg *[]string `form:"rev_org,omitempty" json:"rev_org,omitempty"`
}

// ServiceAccountsGetParams defines parameters for ServiceAccountsGet.
type ServiceAccountsGetParams struct {
	// Id The ID of the requested service account.
	Id string `form:"id" json:"id"`
}

// SlaTrackersGetParams defines parameters for SlaTrackersGet.
type SlaTrackersGetParams struct {
	// Id The ID of the SLA tracker to get.
	Id string `form:"id" json:"id"`
}

// SlaTrackersListParams defines parameters for SlaTrackersList.
type SlaTrackersListParams struct {
	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of SLA trackers to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// SortBy Fields to sort the SLA Trackers by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Stage The SLA tracker stages the filter matches.
	Stage *[]string `form:"stage,omitempty" json:"stage,omitempty"`

	// Status The SLA tracker statuses the filter matches.
	Status *[]string `form:"status,omitempty" json:"status,omitempty"`
}

// SlasGetParams defines parameters for SlasGet.
type SlasGetParams struct {
	// Id The ID of the SLA to get.
	Id string `form:"id" json:"id"`
}

// SlasListParams defines parameters for SlasList.
type SlasListParams struct {
	// AppliesTo The object types the SLA applies to.
	AppliesTo *[]SlaAppliesTo `form:"applies_to,omitempty" json:"applies_to,omitempty"`

	// AppliesToOp The Filter operator to be applied on the applies to object types
	// filter.
	AppliesToOp *SlasFilterAppliesToOperatorType `form:"applies_to_op,omitempty" json:"applies_to_op,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of SLAs to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// SlaType The SLA types the filter matches.
	SlaType *[]SlaType `form:"sla_type,omitempty" json:"sla_type,omitempty"`

	// SortBy Fields to sort the SLAs by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Status The SLA statuses the filter matches.
	Status *[]SlaStatus `form:"status,omitempty" json:"status,omitempty"`
}

// SurveysGetParams defines parameters for SurveysGet.
type SurveysGetParams struct {
	// Id The ID of the survey to get.
	Id string `form:"id" json:"id"`
}

// SurveysListParams defines parameters for SurveysList.
type SurveysListParams struct {
	// CreatedBy Filters for surveys created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of surveys to return. If not set, then the default
	// is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Name Filters for surveys by name(s).
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// SortBy Fields to sort the surveys by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// SurveysResponsesListParams defines parameters for SurveysResponsesList.
type SurveysResponsesListParams struct {
	// CreatedBy Filters for survey responses created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// DispatchIds Filters for survey responses associated with these unique IDs.
	DispatchIds *[]string `form:"dispatch_ids,omitempty" json:"dispatch_ids,omitempty"`

	// Limit The maximum number of survey responses to return. If not set, then
	// the default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Objects Filters for survey responses created for the objects.
	Objects *[]string `form:"objects,omitempty" json:"objects,omitempty"`

	// Recipient Filters for survey responses dispatched to any of these users.
	Recipient *[]string `form:"recipient,omitempty" json:"recipient,omitempty"`

	// SortBy Fields to sort the survey responses by and the direction to sort
	// them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Stages Filters for survey response stages.
	Stages *[]int64 `form:"stages,omitempty" json:"stages,omitempty"`

	// Surveys Filters for survey responses for the provided survey IDs.
	Surveys *[]string `form:"surveys,omitempty" json:"surveys,omitempty"`
}

// SysUsersListParams defines parameters for SysUsersList.
type SysUsersListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of system users to return. Value can range from
	// '1' to '100', with a default of '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// SortBy Fields to sort the system users by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// TagsGetParams defines parameters for TagsGet.
type TagsGetParams struct {
	// Id The requested tag's ID.
	Id string `form:"id" json:"id"`
}

// TagsListParams defines parameters for TagsList.
type TagsListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of tags to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Name Filters for tags with the provided names.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// SortBy Fields to sort tags by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// TimelineEntriesGetParams defines parameters for TimelineEntriesGet.
type TimelineEntriesGetParams struct {
	// Id The ID of the timeline entry to get.
	Id string `form:"id" json:"id"`
}

// TimelineEntriesListParams defines parameters for TimelineEntriesList.
type TimelineEntriesListParams struct {
	// Object The ID of the object to list timeline entries for.
	Object string `form:"object" json:"object"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of entries to return. If not set, then this
	// defaults to `50`.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Visibility The visibility of the timeline entries to filter for. Note this is a
	// strict filter, such that only entries with the exact visibilities
	// specified will be returned.
	Visibility *[]TimelineEntryVisibility `form:"visibility,omitempty" json:"visibility,omitempty"`
}

// GetWebCrawlerJobParams defines parameters for GetWebCrawlerJob.
type GetWebCrawlerJobParams struct {
	// Id The ID of the job.
	Id string `form:"id" json:"id"`
}

// ListWebCrawlerJobsParams defines parameters for ListWebCrawlerJobs.
type ListWebCrawlerJobsParams struct {
	// CreatedBy Filters for web crawler jobs created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of web crawler jobs to return. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`
}

// WebhooksGetParams defines parameters for WebhooksGet.
type WebhooksGetParams struct {
	// Id ID for the webhook.
	Id string `form:"id" json:"id"`
}

// WorksExportParams defines parameters for WorksExport.
type WorksExportParams struct {
	// AppliesToPart Filters for work belonging to any of the provided parts.
	AppliesToPart *[]string `form:"applies_to_part,omitempty" json:"applies_to_part,omitempty"`

	// CreatedBy Filters for work created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// First The number of work items to return. The default is '50', the maximum
	// is '5000'.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// IssueAccounts Filters for issues with any of the provided accounts.
	IssueAccounts *[]string `form:"issue.accounts,omitempty" json:"issue.accounts,omitempty"`

	// IssuePriority Filters for issues with any of the provided priorities.
	IssuePriority *[]IssuePriority `form:"issue.priority,omitempty" json:"issue.priority,omitempty"`

	// IssuePriorityV2 Filters for issues with any of the provided priority enum ids.
	IssuePriorityV2 *[]int64 `form:"issue.priority_v2,omitempty" json:"issue.priority_v2,omitempty"`

	// IssueRevOrgs Filters for issues with any of the provided Rev organizations.
	IssueRevOrgs *[]string `form:"issue.rev_orgs,omitempty" json:"issue.rev_orgs,omitempty"`

	// IssueSlaSummaryStage Filters for records with any of the provided SLA stages.
	IssueSlaSummaryStage *[]SlaSummaryStage `form:"issue.sla_summary.stage,omitempty" json:"issue.sla_summary.stage,omitempty"`

	// IssueSprint Filters for issues with any of the sprint.
	IssueSprint *[]string `form:"issue.sprint,omitempty" json:"issue.sprint,omitempty"`

	// ModifiedBy Filters for work modified by any of these users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`

	// OwnedBy Filters for work owned by any of these users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// ReportedBy Filters for work reported by any of these users.
	ReportedBy *[]string `form:"reported_by,omitempty" json:"reported_by,omitempty"`

	// StageName Filters for records in the provided stage(s) by name.
	StageName *[]string `form:"stage.name,omitempty" json:"stage.name,omitempty"`

	// StagedInfoIsStaged Filters for issues that are staged.
	StagedInfoIsStaged *bool `form:"staged_info.is_staged,omitempty" json:"staged_info.is_staged,omitempty"`

	// State Filters for work with any of the provided states.
	State *[]string `form:"state,omitempty" json:"state,omitempty"`

	// SyncMetadataExternalReference Filters for issues with this specific external reference.
	SyncMetadataExternalReference *[]string `form:"sync_metadata.external_reference,omitempty" json:"sync_metadata.external_reference,omitempty"`

	// SyncMetadataLastSyncInStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncInStatus *[]SyncMetadataFilterSyncInFilterStatus `form:"sync_metadata.last_sync_in.status,omitempty" json:"sync_metadata.last_sync_in.status,omitempty"`

	// SyncMetadataLastSyncInSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncInSyncHistory *[]string `form:"sync_metadata.last_sync_in.sync_history,omitempty" json:"sync_metadata.last_sync_in.sync_history,omitempty"`

	// SyncMetadataLastSyncInSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncInSyncUnit *[]string `form:"sync_metadata.last_sync_in.sync_unit,omitempty" json:"sync_metadata.last_sync_in.sync_unit,omitempty"`

	// SyncMetadataLastSyncOutStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncOutStatus *[]SyncMetadataFilterSyncOutFilterStatus `form:"sync_metadata.last_sync_out.status,omitempty" json:"sync_metadata.last_sync_out.status,omitempty"`

	// SyncMetadataLastSyncOutSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncOutSyncHistory *[]string `form:"sync_metadata.last_sync_out.sync_history,omitempty" json:"sync_metadata.last_sync_out.sync_history,omitempty"`

	// SyncMetadataLastSyncOutSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncOutSyncUnit *[]string `form:"sync_metadata.last_sync_out.sync_unit,omitempty" json:"sync_metadata.last_sync_out.sync_unit,omitempty"`

	// SyncMetadataOriginSystem Filters for issues synced from this specific origin system.
	SyncMetadataOriginSystem *[]string `form:"sync_metadata.origin_system,omitempty" json:"sync_metadata.origin_system,omitempty"`

	// Tags Filters for work with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// TicketBrand Filters for tickets that are associated with any of the brands.
	TicketBrand *[]string `form:"ticket.brand,omitempty" json:"ticket.brand,omitempty"`

	// TicketChannels Filters for tickets with any of the provided channels.
	TicketChannels *[]TicketChannels `form:"ticket.channels,omitempty" json:"ticket.channels,omitempty"`

	// TicketChannelsV2 Filters for tickets that are associated with any of the channels.
	TicketChannelsV2 *[]string `form:"ticket.channels_v2,omitempty" json:"ticket.channels_v2,omitempty"`

	// TicketGroup Filters for tickets belonging to specific groups.
	TicketGroup *[]string `form:"ticket.group,omitempty" json:"ticket.group,omitempty"`

	// TicketIsFrozen Filters for frozen tickets.
	TicketIsFrozen *bool `form:"ticket.is_frozen,omitempty" json:"ticket.is_frozen,omitempty"`

	// TicketIsSpam Filters for tickets that are spam.
	TicketIsSpam *bool `form:"ticket.is_spam,omitempty" json:"ticket.is_spam,omitempty"`

	// TicketNeedsResponse Filters for tickets that need response.
	TicketNeedsResponse *bool `form:"ticket.needs_response,omitempty" json:"ticket.needs_response,omitempty"`

	// TicketRevOrg Filters for tickets that are associated with any of the provided Rev
	// organizations.
	TicketRevOrg *[]string `form:"ticket.rev_org,omitempty" json:"ticket.rev_org,omitempty"`

	// TicketSeverity Filters for tickets with any of the provided severities.
	TicketSeverity *[]TicketSeverity `form:"ticket.severity,omitempty" json:"ticket.severity,omitempty"`

	// TicketSlaSummaryStage Filters for records with any of the provided SLA stages.
	TicketSlaSummaryStage *[]SlaSummaryStage `form:"ticket.sla_summary.stage,omitempty" json:"ticket.sla_summary.stage,omitempty"`

	// TicketSourceChannel Filters for tickets with any of the provided source channels.
	TicketSourceChannel *[]string `form:"ticket.source_channel,omitempty" json:"ticket.source_channel,omitempty"`

	// TicketSourceChannelV2 Filters for tickets that are associated with any of the source
	// channels.
	TicketSourceChannelV2 *[]string `form:"ticket.source_channel_v2,omitempty" json:"ticket.source_channel_v2,omitempty"`

	// Type Filters for work of the provided types.
	Type *[]WorkType `form:"type,omitempty" json:"type,omitempty"`
}

// WorksGetParams defines parameters for WorksGet.
type WorksGetParams struct {
	// Id The work's ID.
	Id string `form:"id" json:"id"`
}

// WorksListParams defines parameters for WorksList.
type WorksListParams struct {
	// AppliesToPart Filters for work belonging to any of the provided parts.
	AppliesToPart *[]string `form:"applies_to_part,omitempty" json:"applies_to_part,omitempty"`

	// CreatedBy Filters for work created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// IssueAccounts Filters for issues with any of the provided accounts.
	IssueAccounts *[]string `form:"issue.accounts,omitempty" json:"issue.accounts,omitempty"`

	// IssuePriority Filters for issues with any of the provided priorities.
	IssuePriority *[]IssuePriority `form:"issue.priority,omitempty" json:"issue.priority,omitempty"`

	// IssuePriorityV2 Filters for issues with any of the provided priority enum ids.
	IssuePriorityV2 *[]int64 `form:"issue.priority_v2,omitempty" json:"issue.priority_v2,omitempty"`

	// IssueRevOrgs Filters for issues with any of the provided Rev organizations.
	IssueRevOrgs *[]string `form:"issue.rev_orgs,omitempty" json:"issue.rev_orgs,omitempty"`

	// IssueSlaSummaryStage Filters for records with any of the provided SLA stages.
	IssueSlaSummaryStage *[]SlaSummaryStage `form:"issue.sla_summary.stage,omitempty" json:"issue.sla_summary.stage,omitempty"`

	// IssueSprint Filters for issues with any of the sprint.
	IssueSprint *[]string `form:"issue.sprint,omitempty" json:"issue.sprint,omitempty"`

	// Limit The maximum number of works to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedBy Filters for work modified by any of these users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`

	// OwnedBy Filters for work owned by any of these users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// ReportedBy Filters for work reported by any of these users.
	ReportedBy *[]string `form:"reported_by,omitempty" json:"reported_by,omitempty"`

	// SortBy Fields to sort the works by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// StageName Filters for records in the provided stage(s) by name.
	StageName *[]string `form:"stage.name,omitempty" json:"stage.name,omitempty"`

	// StagedInfoIsStaged Filters for issues that are staged.
	StagedInfoIsStaged *bool `form:"staged_info.is_staged,omitempty" json:"staged_info.is_staged,omitempty"`

	// State Filters for work with any of the provided states.
	State *[]string `form:"state,omitempty" json:"state,omitempty"`

	// SyncMetadataExternalReference Filters for issues with this specific external reference.
	SyncMetadataExternalReference *[]string `form:"sync_metadata.external_reference,omitempty" json:"sync_metadata.external_reference,omitempty"`

	// SyncMetadataLastSyncInStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncInStatus *[]SyncMetadataFilterSyncInFilterStatus `form:"sync_metadata.last_sync_in.status,omitempty" json:"sync_metadata.last_sync_in.status,omitempty"`

	// SyncMetadataLastSyncInSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncInSyncHistory *[]string `form:"sync_metadata.last_sync_in.sync_history,omitempty" json:"sync_metadata.last_sync_in.sync_history,omitempty"`

	// SyncMetadataLastSyncInSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncInSyncUnit *[]string `form:"sync_metadata.last_sync_in.sync_unit,omitempty" json:"sync_metadata.last_sync_in.sync_unit,omitempty"`

	// SyncMetadataLastSyncOutStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncOutStatus *[]SyncMetadataFilterSyncOutFilterStatus `form:"sync_metadata.last_sync_out.status,omitempty" json:"sync_metadata.last_sync_out.status,omitempty"`

	// SyncMetadataLastSyncOutSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncOutSyncHistory *[]string `form:"sync_metadata.last_sync_out.sync_history,omitempty" json:"sync_metadata.last_sync_out.sync_history,omitempty"`

	// SyncMetadataLastSyncOutSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncOutSyncUnit *[]string `form:"sync_metadata.last_sync_out.sync_unit,omitempty" json:"sync_metadata.last_sync_out.sync_unit,omitempty"`

	// SyncMetadataOriginSystem Filters for issues synced from this specific origin system.
	SyncMetadataOriginSystem *[]string `form:"sync_metadata.origin_system,omitempty" json:"sync_metadata.origin_system,omitempty"`

	// Tags Filters for work with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// TicketBrand Filters for tickets that are associated with any of the brands.
	TicketBrand *[]string `form:"ticket.brand,omitempty" json:"ticket.brand,omitempty"`

	// TicketChannels Filters for tickets with any of the provided channels.
	TicketChannels *[]TicketChannels `form:"ticket.channels,omitempty" json:"ticket.channels,omitempty"`

	// TicketChannelsV2 Filters for tickets that are associated with any of the channels.
	TicketChannelsV2 *[]string `form:"ticket.channels_v2,omitempty" json:"ticket.channels_v2,omitempty"`

	// TicketGroup Filters for tickets belonging to specific groups.
	TicketGroup *[]string `form:"ticket.group,omitempty" json:"ticket.group,omitempty"`

	// TicketIsFrozen Filters for frozen tickets.
	TicketIsFrozen *bool `form:"ticket.is_frozen,omitempty" json:"ticket.is_frozen,omitempty"`

	// TicketIsSpam Filters for tickets that are spam.
	TicketIsSpam *bool `form:"ticket.is_spam,omitempty" json:"ticket.is_spam,omitempty"`

	// TicketNeedsResponse Filters for tickets that need response.
	TicketNeedsResponse *bool `form:"ticket.needs_response,omitempty" json:"ticket.needs_response,omitempty"`

	// TicketRevOrg Filters for tickets that are associated with any of the provided Rev
	// organizations.
	TicketRevOrg *[]string `form:"ticket.rev_org,omitempty" json:"ticket.rev_org,omitempty"`

	// TicketSeverity Filters for tickets with any of the provided severities.
	TicketSeverity *[]TicketSeverity `form:"ticket.severity,omitempty" json:"ticket.severity,omitempty"`

	// TicketSlaSummaryStage Filters for records with any of the provided SLA stages.
	TicketSlaSummaryStage *[]SlaSummaryStage `form:"ticket.sla_summary.stage,omitempty" json:"ticket.sla_summary.stage,omitempty"`

	// TicketSourceChannel Filters for tickets with any of the provided source channels.
	TicketSourceChannel *[]string `form:"ticket.source_channel,omitempty" json:"ticket.source_channel,omitempty"`

	// TicketSourceChannelV2 Filters for tickets that are associated with any of the source
	// channels.
	TicketSourceChannelV2 *[]string `form:"ticket.source_channel_v2,omitempty" json:"ticket.source_channel_v2,omitempty"`

	// Type Filters for work of the provided types.
	Type *[]WorkType `form:"type,omitempty" json:"type,omitempty"`
}

// AccountsCreateJSONRequestBody defines body for AccountsCreate for application/json ContentType.
type AccountsCreateJSONRequestBody = AccountsCreateRequest

// AccountsDeleteJSONRequestBody defines body for AccountsDelete for application/json ContentType.
type AccountsDeleteJSONRequestBody = AccountsDeleteRequest

// AccountsExportPostJSONRequestBody defines body for AccountsExportPost for application/json ContentType.
type AccountsExportPostJSONRequestBody = AccountsExportRequest

// AccountsGetPostJSONRequestBody defines body for AccountsGetPost for application/json ContentType.
type AccountsGetPostJSONRequestBody = AccountsGetRequest

// AccountsListPostJSONRequestBody defines body for AccountsListPost for application/json ContentType.
type AccountsListPostJSONRequestBody = AccountsListRequest

// AccountsMergeJSONRequestBody defines body for AccountsMerge for application/json ContentType.
type AccountsMergeJSONRequestBody = AccountsMergeRequest

// AccountsUpdateJSONRequestBody defines body for AccountsUpdate for application/json ContentType.
type AccountsUpdateJSONRequestBody = AccountsUpdateRequest

// CreateArticleJSONRequestBody defines body for CreateArticle for application/json ContentType.
type CreateArticleJSONRequestBody = ArticlesCreateRequest

// DeleteArticleJSONRequestBody defines body for DeleteArticle for application/json ContentType.
type DeleteArticleJSONRequestBody = ArticlesDeleteRequest

// GetArticlePostJSONRequestBody defines body for GetArticlePost for application/json ContentType.
type GetArticlePostJSONRequestBody = ArticlesGetRequest

// ListArticlesPostJSONRequestBody defines body for ListArticlesPost for application/json ContentType.
type ListArticlesPostJSONRequestBody = ArticlesListRequest

// UpdateArticleJSONRequestBody defines body for UpdateArticle for application/json ContentType.
type UpdateArticleJSONRequestBody = ArticlesUpdateRequest

// ArtifactsGetPostJSONRequestBody defines body for ArtifactsGetPost for application/json ContentType.
type ArtifactsGetPostJSONRequestBody = ArtifactsGetRequest

// ArtifactsListPostJSONRequestBody defines body for ArtifactsListPost for application/json ContentType.
type ArtifactsListPostJSONRequestBody = ArtifactsListRequest

// ArtifactsLocatePostJSONRequestBody defines body for ArtifactsLocatePost for application/json ContentType.
type ArtifactsLocatePostJSONRequestBody = ArtifactsLocateRequest

// ArtifactsPrepareJSONRequestBody defines body for ArtifactsPrepare for application/json ContentType.
type ArtifactsPrepareJSONRequestBody = ArtifactsPrepareRequest

// ArtifactsHardDeleteVersionJSONRequestBody defines body for ArtifactsHardDeleteVersion for application/json ContentType.
type ArtifactsHardDeleteVersionJSONRequestBody = ArtifactsHardDeleteVersionRequest

// ArtifactsVersionsPrepareJSONRequestBody defines body for ArtifactsVersionsPrepare for application/json ContentType.
type ArtifactsVersionsPrepareJSONRequestBody = ArtifactsVersionsPrepareRequest

// AtomsGetPostJSONRequestBody defines body for AtomsGetPost for application/json ContentType.
type AtomsGetPostJSONRequestBody = AtomsGetRequest

// AuthTokensCreateJSONRequestBody defines body for AuthTokensCreate for application/json ContentType.
type AuthTokensCreateJSONRequestBody = AuthTokensCreateRequest

// AuthTokensDeleteJSONRequestBody defines body for AuthTokensDelete for application/json ContentType.
type AuthTokensDeleteJSONRequestBody = AuthTokensDeleteRequest

// AuthTokensGetPostJSONRequestBody defines body for AuthTokensGetPost for application/json ContentType.
type AuthTokensGetPostJSONRequestBody = AuthTokensGetRequest

// AuthTokensInfoPostJSONRequestBody defines body for AuthTokensInfoPost for application/json ContentType.
type AuthTokensInfoPostJSONRequestBody = AuthTokensInfoRequest

// AuthTokensListPostJSONRequestBody defines body for AuthTokensListPost for application/json ContentType.
type AuthTokensListPostJSONRequestBody = AuthTokensListRequest

// AuthTokensSelfDeleteJSONRequestBody defines body for AuthTokensSelfDelete for application/json ContentType.
type AuthTokensSelfDeleteJSONRequestBody = AuthTokensSelfDeleteRequest

// AuthTokensUpdateJSONRequestBody defines body for AuthTokensUpdate for application/json ContentType.
type AuthTokensUpdateJSONRequestBody = AuthTokensUpdateRequest

// ChatsCreateJSONRequestBody defines body for ChatsCreate for application/json ContentType.
type ChatsCreateJSONRequestBody = ChatsCreateRequest

// ChatsGetPostJSONRequestBody defines body for ChatsGetPost for application/json ContentType.
type ChatsGetPostJSONRequestBody = ChatsGetRequest

// ChatsUpdateJSONRequestBody defines body for ChatsUpdate for application/json ContentType.
type ChatsUpdateJSONRequestBody = ChatsUpdateRequest

// CodeChangesCreateJSONRequestBody defines body for CodeChangesCreate for application/json ContentType.
type CodeChangesCreateJSONRequestBody = CodeChangesCreateRequest

// CodeChangesDeleteJSONRequestBody defines body for CodeChangesDelete for application/json ContentType.
type CodeChangesDeleteJSONRequestBody = CodeChangesDeleteRequest

// CodeChangesGetPostJSONRequestBody defines body for CodeChangesGetPost for application/json ContentType.
type CodeChangesGetPostJSONRequestBody = CodeChangesGetRequest

// CodeChangesListPostJSONRequestBody defines body for CodeChangesListPost for application/json ContentType.
type CodeChangesListPostJSONRequestBody = CodeChangesListRequest

// CodeChangesUpdateJSONRequestBody defines body for CodeChangesUpdate for application/json ContentType.
type CodeChangesUpdateJSONRequestBody = CodeChangesUpdateRequest

// CommandsCreateJSONRequestBody defines body for CommandsCreate for application/json ContentType.
type CommandsCreateJSONRequestBody = CommandCreateRequest

// CommandsGetPostJSONRequestBody defines body for CommandsGetPost for application/json ContentType.
type CommandsGetPostJSONRequestBody = CommandGetRequest

// CommandsListPostJSONRequestBody defines body for CommandsListPost for application/json ContentType.
type CommandsListPostJSONRequestBody = CommandsListRequest

// CommandsUpdateJSONRequestBody defines body for CommandsUpdate for application/json ContentType.
type CommandsUpdateJSONRequestBody = CommandUpdateRequest

// ConversationsCreateJSONRequestBody defines body for ConversationsCreate for application/json ContentType.
type ConversationsCreateJSONRequestBody = ConversationsCreateRequest

// ConversationsDeleteJSONRequestBody defines body for ConversationsDelete for application/json ContentType.
type ConversationsDeleteJSONRequestBody = ConversationsDeleteRequest

// ConversationsGetPostJSONRequestBody defines body for ConversationsGetPost for application/json ContentType.
type ConversationsGetPostJSONRequestBody = ConversationsGetRequest

// ConversationsListPostJSONRequestBody defines body for ConversationsListPost for application/json ContentType.
type ConversationsListPostJSONRequestBody = ConversationsListRequest

// ConversationsUpdateJSONRequestBody defines body for ConversationsUpdate for application/json ContentType.
type ConversationsUpdateJSONRequestBody = ConversationsUpdateRequest

// DevOrgAuthConnectionsCreateJSONRequestBody defines body for DevOrgAuthConnectionsCreate for application/json ContentType.
type DevOrgAuthConnectionsCreateJSONRequestBody = DevOrgAuthConnectionsCreateRequest

// DevOrgAuthConnectionsDeleteJSONRequestBody defines body for DevOrgAuthConnectionsDelete for application/json ContentType.
type DevOrgAuthConnectionsDeleteJSONRequestBody = DevOrgAuthConnectionsDeleteRequest

// DevOrgAuthConnectionsGetPostJSONRequestBody defines body for DevOrgAuthConnectionsGetPost for application/json ContentType.
type DevOrgAuthConnectionsGetPostJSONRequestBody = DevOrgAuthConnectionsGetRequest

// DevOrgAuthConnectionsListPostJSONRequestBody defines body for DevOrgAuthConnectionsListPost for application/json ContentType.
type DevOrgAuthConnectionsListPostJSONRequestBody = Empty

// DevOrgAuthConnectionsToggleJSONRequestBody defines body for DevOrgAuthConnectionsToggle for application/json ContentType.
type DevOrgAuthConnectionsToggleJSONRequestBody = DevOrgAuthConnectionsToggleRequest

// DevOrgAuthConnectionsUpdateJSONRequestBody defines body for DevOrgAuthConnectionsUpdate for application/json ContentType.
type DevOrgAuthConnectionsUpdateJSONRequestBody = DevOrgAuthConnectionsUpdateRequest

// DevOrgsGetPostJSONRequestBody defines body for DevOrgsGetPost for application/json ContentType.
type DevOrgsGetPostJSONRequestBody = DevOrgsGetRequest

// DevUsersActivateJSONRequestBody defines body for DevUsersActivate for application/json ContentType.
type DevUsersActivateJSONRequestBody = DevUsersActivateRequest

// DevUsersCreateJSONRequestBody defines body for DevUsersCreate for application/json ContentType.
type DevUsersCreateJSONRequestBody = DevUsersCreateRequest

// DevUsersDeactivateJSONRequestBody defines body for DevUsersDeactivate for application/json ContentType.
type DevUsersDeactivateJSONRequestBody = DevUsersDeactivateRequest

// DevUsersGetPostJSONRequestBody defines body for DevUsersGetPost for application/json ContentType.
type DevUsersGetPostJSONRequestBody = DevUsersGetRequest

// DevUsersIdentitiesLinkJSONRequestBody defines body for DevUsersIdentitiesLink for application/json ContentType.
type DevUsersIdentitiesLinkJSONRequestBody = DevUsersIdentitiesLinkRequest

// DevUsersIdentitiesUnlinkJSONRequestBody defines body for DevUsersIdentitiesUnlink for application/json ContentType.
type DevUsersIdentitiesUnlinkJSONRequestBody = DevUsersIdentitiesUnlinkRequest

// DevUsersListPostJSONRequestBody defines body for DevUsersListPost for application/json ContentType.
type DevUsersListPostJSONRequestBody = DevUsersListRequest

// DevUsersMergeJSONRequestBody defines body for DevUsersMerge for application/json ContentType.
type DevUsersMergeJSONRequestBody = DevUsersMergeRequest

// DevUsersSelfPostJSONRequestBody defines body for DevUsersSelfPost for application/json ContentType.
type DevUsersSelfPostJSONRequestBody = DevUsersSelfRequest

// DevUsersSelfUpdateJSONRequestBody defines body for DevUsersSelfUpdate for application/json ContentType.
type DevUsersSelfUpdateJSONRequestBody = DevUsersSelfUpdateRequest

// DevUsersUpdateJSONRequestBody defines body for DevUsersUpdate for application/json ContentType.
type DevUsersUpdateJSONRequestBody = DevUsersUpdateRequest

// DirectoriesCountPostJSONRequestBody defines body for DirectoriesCountPost for application/json ContentType.
type DirectoriesCountPostJSONRequestBody = DirectoriesCountRequest

// DirectoriesCreateJSONRequestBody defines body for DirectoriesCreate for application/json ContentType.
type DirectoriesCreateJSONRequestBody = DirectoriesCreateRequest

// DirectoriesDeleteJSONRequestBody defines body for DirectoriesDelete for application/json ContentType.
type DirectoriesDeleteJSONRequestBody = DirectoriesDeleteRequest

// DirectoriesGetPostJSONRequestBody defines body for DirectoriesGetPost for application/json ContentType.
type DirectoriesGetPostJSONRequestBody = DirectoriesGetRequest

// DirectoriesListPostJSONRequestBody defines body for DirectoriesListPost for application/json ContentType.
type DirectoriesListPostJSONRequestBody = DirectoriesListRequest

// DirectoriesUpdateJSONRequestBody defines body for DirectoriesUpdate for application/json ContentType.
type DirectoriesUpdateJSONRequestBody = DirectoriesUpdateRequest

// GroupsCreateJSONRequestBody defines body for GroupsCreate for application/json ContentType.
type GroupsCreateJSONRequestBody = GroupsCreateRequest

// GroupsGetPostJSONRequestBody defines body for GroupsGetPost for application/json ContentType.
type GroupsGetPostJSONRequestBody = GroupsGetRequest

// GroupsListPostJSONRequestBody defines body for GroupsListPost for application/json ContentType.
type GroupsListPostJSONRequestBody = GroupsListRequest

// GroupMembersAddJSONRequestBody defines body for GroupMembersAdd for application/json ContentType.
type GroupMembersAddJSONRequestBody = GroupMembersAddRequest

// GroupMembersListPostJSONRequestBody defines body for GroupMembersListPost for application/json ContentType.
type GroupMembersListPostJSONRequestBody = GroupMembersListRequest

// GroupMembersRemoveJSONRequestBody defines body for GroupMembersRemove for application/json ContentType.
type GroupMembersRemoveJSONRequestBody = GroupMembersRemoveRequest

// GroupsUpdateJSONRequestBody defines body for GroupsUpdate for application/json ContentType.
type GroupsUpdateJSONRequestBody = GroupsUpdateRequest

// KeyringsCreateCallbackPostJSONRequestBody defines body for KeyringsCreateCallbackPost for application/json ContentType.
type KeyringsCreateCallbackPostJSONRequestBody = KeyringsCreateCallbackRequest

// LinksCreateJSONRequestBody defines body for LinksCreate for application/json ContentType.
type LinksCreateJSONRequestBody = LinksCreateRequest

// LinksDeleteJSONRequestBody defines body for LinksDelete for application/json ContentType.
type LinksDeleteJSONRequestBody = LinksDeleteRequest

// LinksGetPostJSONRequestBody defines body for LinksGetPost for application/json ContentType.
type LinksGetPostJSONRequestBody = LinksGetRequest

// LinksListPostJSONRequestBody defines body for LinksListPost for application/json ContentType.
type LinksListPostJSONRequestBody = LinksListRequest

// LinksReplaceJSONRequestBody defines body for LinksReplace for application/json ContentType.
type LinksReplaceJSONRequestBody = LinksReplaceRequest

// MeetingsCountPostJSONRequestBody defines body for MeetingsCountPost for application/json ContentType.
type MeetingsCountPostJSONRequestBody = MeetingsCountRequest

// MeetingsCreateJSONRequestBody defines body for MeetingsCreate for application/json ContentType.
type MeetingsCreateJSONRequestBody = MeetingsCreateRequest

// MeetingsDeleteJSONRequestBody defines body for MeetingsDelete for application/json ContentType.
type MeetingsDeleteJSONRequestBody = MeetingsDeleteRequest

// MeetingsGetPostJSONRequestBody defines body for MeetingsGetPost for application/json ContentType.
type MeetingsGetPostJSONRequestBody = MeetingsGetRequest

// MeetingsListPostJSONRequestBody defines body for MeetingsListPost for application/json ContentType.
type MeetingsListPostJSONRequestBody = MeetingsListRequest

// MeetingsUpdateJSONRequestBody defines body for MeetingsUpdate for application/json ContentType.
type MeetingsUpdateJSONRequestBody = MeetingsUpdateRequest

// MetricActionExecuteJSONRequestBody defines body for MetricActionExecute for application/json ContentType.
type MetricActionExecuteJSONRequestBody = MetricActionExecuteRequest

// MetricDefinitionsCreateJSONRequestBody defines body for MetricDefinitionsCreate for application/json ContentType.
type MetricDefinitionsCreateJSONRequestBody = MetricDefinitionsCreateRequest

// MetricDefinitionsDeleteJSONRequestBody defines body for MetricDefinitionsDelete for application/json ContentType.
type MetricDefinitionsDeleteJSONRequestBody = MetricDefinitionsDeleteRequest

// MetricDefinitionsGetPostJSONRequestBody defines body for MetricDefinitionsGetPost for application/json ContentType.
type MetricDefinitionsGetPostJSONRequestBody = MetricDefinitionsGetRequest

// MetricDefinitionsListPostJSONRequestBody defines body for MetricDefinitionsListPost for application/json ContentType.
type MetricDefinitionsListPostJSONRequestBody = MetricDefinitionsListRequest

// MetricDefinitionsUpdateJSONRequestBody defines body for MetricDefinitionsUpdate for application/json ContentType.
type MetricDefinitionsUpdateJSONRequestBody = MetricDefinitionsUpdateRequest

// MetricTrackersGetPostJSONRequestBody defines body for MetricTrackersGetPost for application/json ContentType.
type MetricTrackersGetPostJSONRequestBody = MetricTrackersGetRequest

// OrgScheduleFragmentsCreateJSONRequestBody defines body for OrgScheduleFragmentsCreate for application/json ContentType.
type OrgScheduleFragmentsCreateJSONRequestBody = OrgScheduleFragmentsCreateRequest

// OrgScheduleFragmentsGetPostJSONRequestBody defines body for OrgScheduleFragmentsGetPost for application/json ContentType.
type OrgScheduleFragmentsGetPostJSONRequestBody = OrgScheduleFragmentsGetRequest

// OrgScheduleFragmentsTransitionJSONRequestBody defines body for OrgScheduleFragmentsTransition for application/json ContentType.
type OrgScheduleFragmentsTransitionJSONRequestBody = OrgScheduleFragmentsTransitionRequest

// OrgSchedulesCreateJSONRequestBody defines body for OrgSchedulesCreate for application/json ContentType.
type OrgSchedulesCreateJSONRequestBody = OrgSchedulesCreateRequest

// OrgSchedulesEvaluatePostJSONRequestBody defines body for OrgSchedulesEvaluatePost for application/json ContentType.
type OrgSchedulesEvaluatePostJSONRequestBody = OrgSchedulesEvaluateRequest

// OrgSchedulesGetPostJSONRequestBody defines body for OrgSchedulesGetPost for application/json ContentType.
type OrgSchedulesGetPostJSONRequestBody = OrgSchedulesGetRequest

// OrgSchedulesListPostJSONRequestBody defines body for OrgSchedulesListPost for application/json ContentType.
type OrgSchedulesListPostJSONRequestBody = OrgSchedulesListRequest

// OrgSchedulesSetFutureJSONRequestBody defines body for OrgSchedulesSetFuture for application/json ContentType.
type OrgSchedulesSetFutureJSONRequestBody = OrgSchedulesSetFutureRequest

// OrgSchedulesTransitionJSONRequestBody defines body for OrgSchedulesTransition for application/json ContentType.
type OrgSchedulesTransitionJSONRequestBody = OrgSchedulesTransitionRequest

// OrgSchedulesUpdateJSONRequestBody defines body for OrgSchedulesUpdate for application/json ContentType.
type OrgSchedulesUpdateJSONRequestBody = OrgSchedulesUpdateRequest

// PartsCreateJSONRequestBody defines body for PartsCreate for application/json ContentType.
type PartsCreateJSONRequestBody = PartsCreateRequest

// PartsDeleteJSONRequestBody defines body for PartsDelete for application/json ContentType.
type PartsDeleteJSONRequestBody = PartsDeleteRequest

// PartsGetPostJSONRequestBody defines body for PartsGetPost for application/json ContentType.
type PartsGetPostJSONRequestBody = PartsGetRequest

// PartsListPostJSONRequestBody defines body for PartsListPost for application/json ContentType.
type PartsListPostJSONRequestBody = PartsListRequest

// PartsUpdateJSONRequestBody defines body for PartsUpdate for application/json ContentType.
type PartsUpdateJSONRequestBody = PartsUpdateRequest

// ReactionsListPostJSONRequestBody defines body for ReactionsListPost for application/json ContentType.
type ReactionsListPostJSONRequestBody = ReactionsListRequest

// ReactionsUpdateJSONRequestBody defines body for ReactionsUpdate for application/json ContentType.
type ReactionsUpdateJSONRequestBody = ReactionsUpdateRequest

// RevOrgsCreateJSONRequestBody defines body for RevOrgsCreate for application/json ContentType.
type RevOrgsCreateJSONRequestBody = RevOrgsCreateRequest

// RevOrgsDeleteJSONRequestBody defines body for RevOrgsDelete for application/json ContentType.
type RevOrgsDeleteJSONRequestBody = RevOrgsDeleteRequest

// RevOrgsGetPostJSONRequestBody defines body for RevOrgsGetPost for application/json ContentType.
type RevOrgsGetPostJSONRequestBody = RevOrgsGetRequest

// RevOrgsListPostJSONRequestBody defines body for RevOrgsListPost for application/json ContentType.
type RevOrgsListPostJSONRequestBody = RevOrgsListRequest

// RevOrgsUpdateJSONRequestBody defines body for RevOrgsUpdate for application/json ContentType.
type RevOrgsUpdateJSONRequestBody = RevOrgsUpdateRequest

// RevUsersCreateJSONRequestBody defines body for RevUsersCreate for application/json ContentType.
type RevUsersCreateJSONRequestBody = RevUsersCreateRequest

// RevUsersDeleteJSONRequestBody defines body for RevUsersDelete for application/json ContentType.
type RevUsersDeleteJSONRequestBody = RevUsersDeleteRequest

// RevUsersGetPostJSONRequestBody defines body for RevUsersGetPost for application/json ContentType.
type RevUsersGetPostJSONRequestBody = RevUsersGetRequest

// RevUsersListPostJSONRequestBody defines body for RevUsersListPost for application/json ContentType.
type RevUsersListPostJSONRequestBody = RevUsersListRequest

// RevUsersMergeJSONRequestBody defines body for RevUsersMerge for application/json ContentType.
type RevUsersMergeJSONRequestBody = RevUsersMergeRequest

// RevUsersScanPostJSONRequestBody defines body for RevUsersScanPost for application/json ContentType.
type RevUsersScanPostJSONRequestBody = RevUsersScanRequest

// RevUsersUpdateJSONRequestBody defines body for RevUsersUpdate for application/json ContentType.
type RevUsersUpdateJSONRequestBody = RevUsersUpdateRequest

// ServiceAccountsCreateJSONRequestBody defines body for ServiceAccountsCreate for application/json ContentType.
type ServiceAccountsCreateJSONRequestBody = ServiceAccountsCreateRequest

// ServiceAccountsGetPostJSONRequestBody defines body for ServiceAccountsGetPost for application/json ContentType.
type ServiceAccountsGetPostJSONRequestBody = ServiceAccountsGetRequest

// SlaTrackersGetPostJSONRequestBody defines body for SlaTrackersGetPost for application/json ContentType.
type SlaTrackersGetPostJSONRequestBody = SlaTrackersGetRequest

// SlaTrackersListPostJSONRequestBody defines body for SlaTrackersListPost for application/json ContentType.
type SlaTrackersListPostJSONRequestBody = SlaTrackersListRequest

// SlasAssignJSONRequestBody defines body for SlasAssign for application/json ContentType.
type SlasAssignJSONRequestBody = SlasAssignRequest

// SlasCreateJSONRequestBody defines body for SlasCreate for application/json ContentType.
type SlasCreateJSONRequestBody = SlasCreateRequest

// SlasGetPostJSONRequestBody defines body for SlasGetPost for application/json ContentType.
type SlasGetPostJSONRequestBody = SlasGetRequest

// SlasListPostJSONRequestBody defines body for SlasListPost for application/json ContentType.
type SlasListPostJSONRequestBody = SlasListRequest

// SlasTransitionJSONRequestBody defines body for SlasTransition for application/json ContentType.
type SlasTransitionJSONRequestBody = SlasTransitionRequest

// SlasUpdateJSONRequestBody defines body for SlasUpdate for application/json ContentType.
type SlasUpdateJSONRequestBody = SlasUpdateRequest

// SnapKitActionExecuteDeferredJSONRequestBody defines body for SnapKitActionExecuteDeferred for application/json ContentType.
type SnapKitActionExecuteDeferredJSONRequestBody = SnapKitActionExecuteDeferredRequest

// SnapWidgetsCreateJSONRequestBody defines body for SnapWidgetsCreate for application/json ContentType.
type SnapWidgetsCreateJSONRequestBody = SnapWidgetsCreateRequest

// SurveysCreateJSONRequestBody defines body for SurveysCreate for application/json ContentType.
type SurveysCreateJSONRequestBody = SurveysCreateRequest

// SurveysDeleteJSONRequestBody defines body for SurveysDelete for application/json ContentType.
type SurveysDeleteJSONRequestBody = SurveysDeleteRequest

// SurveysGetPostJSONRequestBody defines body for SurveysGetPost for application/json ContentType.
type SurveysGetPostJSONRequestBody = SurveysGetRequest

// SurveysListPostJSONRequestBody defines body for SurveysListPost for application/json ContentType.
type SurveysListPostJSONRequestBody = SurveysListRequest

// SurveysResponsesListPostJSONRequestBody defines body for SurveysResponsesListPost for application/json ContentType.
type SurveysResponsesListPostJSONRequestBody = SurveysResponsesListRequest

// SurveysResponsesUpdateJSONRequestBody defines body for SurveysResponsesUpdate for application/json ContentType.
type SurveysResponsesUpdateJSONRequestBody = SurveysResponsesUpdateRequest

// SurveysSendJSONRequestBody defines body for SurveysSend for application/json ContentType.
type SurveysSendJSONRequestBody = SurveysSendRequest

// SurveysSubmitJSONRequestBody defines body for SurveysSubmit for application/json ContentType.
type SurveysSubmitJSONRequestBody = SurveysSubmitRequest

// SurveysUpdateJSONRequestBody defines body for SurveysUpdate for application/json ContentType.
type SurveysUpdateJSONRequestBody = SurveysUpdateRequest

// SysUsersListPostJSONRequestBody defines body for SysUsersListPost for application/json ContentType.
type SysUsersListPostJSONRequestBody = SysUsersListRequest

// SysUsersUpdateJSONRequestBody defines body for SysUsersUpdate for application/json ContentType.
type SysUsersUpdateJSONRequestBody = SysUsersUpdateRequest

// TagsCreateJSONRequestBody defines body for TagsCreate for application/json ContentType.
type TagsCreateJSONRequestBody = TagsCreateRequest

// TagsDeleteJSONRequestBody defines body for TagsDelete for application/json ContentType.
type TagsDeleteJSONRequestBody = TagsDeleteRequest

// TagsGetPostJSONRequestBody defines body for TagsGetPost for application/json ContentType.
type TagsGetPostJSONRequestBody = TagsGetRequest

// TagsListPostJSONRequestBody defines body for TagsListPost for application/json ContentType.
type TagsListPostJSONRequestBody = TagsListRequest

// TagsUpdateJSONRequestBody defines body for TagsUpdate for application/json ContentType.
type TagsUpdateJSONRequestBody = TagsUpdateRequest

// TimelineEntriesCreateJSONRequestBody defines body for TimelineEntriesCreate for application/json ContentType.
type TimelineEntriesCreateJSONRequestBody = TimelineEntriesCreateRequest

// TimelineEntriesDeleteJSONRequestBody defines body for TimelineEntriesDelete for application/json ContentType.
type TimelineEntriesDeleteJSONRequestBody = TimelineEntriesDeleteRequest

// TimelineEntriesGetPostJSONRequestBody defines body for TimelineEntriesGetPost for application/json ContentType.
type TimelineEntriesGetPostJSONRequestBody = TimelineEntriesGetRequest

// TimelineEntriesListPostJSONRequestBody defines body for TimelineEntriesListPost for application/json ContentType.
type TimelineEntriesListPostJSONRequestBody = TimelineEntriesListRequest

// TimelineEntriesUpdateJSONRequestBody defines body for TimelineEntriesUpdate for application/json ContentType.
type TimelineEntriesUpdateJSONRequestBody = TimelineEntriesUpdateRequest

// WebCrawlerJobsControlJSONRequestBody defines body for WebCrawlerJobsControl for application/json ContentType.
type WebCrawlerJobsControlJSONRequestBody = WebCrawlerJobsControlRequest

// CreateWebCrawlerJobJSONRequestBody defines body for CreateWebCrawlerJob for application/json ContentType.
type CreateWebCrawlerJobJSONRequestBody = WebCrawlerJobsCreateRequest

// GetWebCrawlerJobPostJSONRequestBody defines body for GetWebCrawlerJobPost for application/json ContentType.
type GetWebCrawlerJobPostJSONRequestBody = WebCrawlerJobsGetRequest

// ListWebCrawlerJobsPostJSONRequestBody defines body for ListWebCrawlerJobsPost for application/json ContentType.
type ListWebCrawlerJobsPostJSONRequestBody = WebCrawlerJobsListRequest

// WebhooksCreateJSONRequestBody defines body for WebhooksCreate for application/json ContentType.
type WebhooksCreateJSONRequestBody = WebhooksCreateRequest

// WebhooksDeleteJSONRequestBody defines body for WebhooksDelete for application/json ContentType.
type WebhooksDeleteJSONRequestBody = WebhooksDeleteRequest

// WebhooksEventJSONRequestBody defines body for WebhooksEvent for application/json ContentType.
type WebhooksEventJSONRequestBody = WebhookEventRequest

// WebhooksGetPostJSONRequestBody defines body for WebhooksGetPost for application/json ContentType.
type WebhooksGetPostJSONRequestBody = WebhooksGetRequest

// WebhooksListPostJSONRequestBody defines body for WebhooksListPost for application/json ContentType.
type WebhooksListPostJSONRequestBody = WebhooksListRequest

// WebhooksUpdateJSONRequestBody defines body for WebhooksUpdate for application/json ContentType.
type WebhooksUpdateJSONRequestBody = WebhooksUpdateRequest

// WorksCreateJSONRequestBody defines body for WorksCreate for application/json ContentType.
type WorksCreateJSONRequestBody = WorksCreateRequest

// WorksDeleteJSONRequestBody defines body for WorksDelete for application/json ContentType.
type WorksDeleteJSONRequestBody = WorksDeleteRequest

// WorksExportPostJSONRequestBody defines body for WorksExportPost for application/json ContentType.
type WorksExportPostJSONRequestBody = WorksExportRequest

// WorksGetPostJSONRequestBody defines body for WorksGetPost for application/json ContentType.
type WorksGetPostJSONRequestBody = WorksGetRequest

// WorksListPostJSONRequestBody defines body for WorksListPost for application/json ContentType.
type WorksListPostJSONRequestBody = WorksListRequest

// WorksUpdateJSONRequestBody defines body for WorksUpdate for application/json ContentType.
type WorksUpdateJSONRequestBody = WorksUpdateRequest

// AsAuthToken returns the union data inside the Atom as a AuthToken
func (t Atom) AsAuthToken() (AuthToken, error) {
	var body AuthToken
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthToken overwrites any union data inside the Atom as the provided AuthToken
func (t *Atom) FromAuthToken(v AuthToken) error {
	t.Type = "auth_token"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthToken performs a merge with any union data inside the Atom, using the provided AuthToken
func (t *Atom) MergeAuthToken(v AuthToken) error {
	t.Type = "auth_token"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapability returns the union data inside the Atom as a Capability
func (t Atom) AsCapability() (Capability, error) {
	var body Capability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapability overwrites any union data inside the Atom as the provided Capability
func (t *Atom) FromCapability(v Capability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapability performs a merge with any union data inside the Atom, using the provided Capability
func (t *Atom) MergeCapability(v Capability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConversation returns the union data inside the Atom as a Conversation
func (t Atom) AsConversation() (Conversation, error) {
	var body Conversation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConversation overwrites any union data inside the Atom as the provided Conversation
func (t *Atom) FromConversation(v Conversation) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConversation performs a merge with any union data inside the Atom, using the provided Conversation
func (t *Atom) MergeConversation(v Conversation) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevUser returns the union data inside the Atom as a DevUser
func (t Atom) AsDevUser() (DevUser, error) {
	var body DevUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUser overwrites any union data inside the Atom as the provided DevUser
func (t *Atom) FromDevUser(v DevUser) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUser performs a merge with any union data inside the Atom, using the provided DevUser
func (t *Atom) MergeDevUser(v DevUser) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancement returns the union data inside the Atom as a Enhancement
func (t Atom) AsEnhancement() (Enhancement, error) {
	var body Enhancement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancement overwrites any union data inside the Atom as the provided Enhancement
func (t *Atom) FromEnhancement(v Enhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancement performs a merge with any union data inside the Atom, using the provided Enhancement
func (t *Atom) MergeEnhancement(v Enhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeature returns the union data inside the Atom as a Feature
func (t Atom) AsFeature() (Feature, error) {
	var body Feature
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeature overwrites any union data inside the Atom as the provided Feature
func (t *Atom) FromFeature(v Feature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeature performs a merge with any union data inside the Atom, using the provided Feature
func (t *Atom) MergeFeature(v Feature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroup returns the union data inside the Atom as a Group
func (t Atom) AsGroup() (Group, error) {
	var body Group
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroup overwrites any union data inside the Atom as the provided Group
func (t *Atom) FromGroup(v Group) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroup performs a merge with any union data inside the Atom, using the provided Group
func (t *Atom) MergeGroup(v Group) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssue returns the union data inside the Atom as a Issue
func (t Atom) AsIssue() (Issue, error) {
	var body Issue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssue overwrites any union data inside the Atom as the provided Issue
func (t *Atom) FromIssue(v Issue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssue performs a merge with any union data inside the Atom, using the provided Issue
func (t *Atom) MergeIssue(v Issue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLink returns the union data inside the Atom as a Link
func (t Atom) AsLink() (Link, error) {
	var body Link
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLink overwrites any union data inside the Atom as the provided Link
func (t *Atom) FromLink(v Link) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLink performs a merge with any union data inside the Atom, using the provided Link
func (t *Atom) MergeLink(v Link) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProduct returns the union data inside the Atom as a Product
func (t Atom) AsProduct() (Product, error) {
	var body Product
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProduct overwrites any union data inside the Atom as the provided Product
func (t *Atom) FromProduct(v Product) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProduct performs a merge with any union data inside the Atom, using the provided Product
func (t *Atom) MergeProduct(v Product) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevOrg returns the union data inside the Atom as a RevOrg
func (t Atom) AsRevOrg() (RevOrg, error) {
	var body RevOrg
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevOrg overwrites any union data inside the Atom as the provided RevOrg
func (t *Atom) FromRevOrg(v RevOrg) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevOrg performs a merge with any union data inside the Atom, using the provided RevOrg
func (t *Atom) MergeRevOrg(v RevOrg) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUser returns the union data inside the Atom as a RevUser
func (t Atom) AsRevUser() (RevUser, error) {
	var body RevUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUser overwrites any union data inside the Atom as the provided RevUser
func (t *Atom) FromRevUser(v RevUser) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUser performs a merge with any union data inside the Atom, using the provided RevUser
func (t *Atom) MergeRevUser(v RevUser) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServiceAccount returns the union data inside the Atom as a ServiceAccount
func (t Atom) AsServiceAccount() (ServiceAccount, error) {
	var body ServiceAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServiceAccount overwrites any union data inside the Atom as the provided ServiceAccount
func (t *Atom) FromServiceAccount(v ServiceAccount) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServiceAccount performs a merge with any union data inside the Atom, using the provided ServiceAccount
func (t *Atom) MergeServiceAccount(v ServiceAccount) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSla returns the union data inside the Atom as a Sla
func (t Atom) AsSla() (Sla, error) {
	var body Sla
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSla overwrites any union data inside the Atom as the provided Sla
func (t *Atom) FromSla(v Sla) error {
	t.Type = "sla"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSla performs a merge with any union data inside the Atom, using the provided Sla
func (t *Atom) MergeSla(v Sla) error {
	t.Type = "sla"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlaTracker returns the union data inside the Atom as a SlaTracker
func (t Atom) AsSlaTracker() (SlaTracker, error) {
	var body SlaTracker
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlaTracker overwrites any union data inside the Atom as the provided SlaTracker
func (t *Atom) FromSlaTracker(v SlaTracker) error {
	t.Type = "sla_tracker"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlaTracker performs a merge with any union data inside the Atom, using the provided SlaTracker
func (t *Atom) MergeSlaTracker(v SlaTracker) error {
	t.Type = "sla_tracker"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSysUser returns the union data inside the Atom as a SysUser
func (t Atom) AsSysUser() (SysUser, error) {
	var body SysUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSysUser overwrites any union data inside the Atom as the provided SysUser
func (t *Atom) FromSysUser(v SysUser) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSysUser performs a merge with any union data inside the Atom, using the provided SysUser
func (t *Atom) MergeSysUser(v SysUser) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTag returns the union data inside the Atom as a Tag
func (t Atom) AsTag() (Tag, error) {
	var body Tag
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTag overwrites any union data inside the Atom as the provided Tag
func (t *Atom) FromTag(v Tag) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTag performs a merge with any union data inside the Atom, using the provided Tag
func (t *Atom) MergeTag(v Tag) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTicket returns the union data inside the Atom as a Ticket
func (t Atom) AsTicket() (Ticket, error) {
	var body Ticket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTicket overwrites any union data inside the Atom as the provided Ticket
func (t *Atom) FromTicket(v Ticket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTicket performs a merge with any union data inside the Atom, using the provided Ticket
func (t *Atom) MergeTicket(v Ticket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimelineComment returns the union data inside the Atom as a TimelineComment
func (t Atom) AsTimelineComment() (TimelineComment, error) {
	var body TimelineComment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineComment overwrites any union data inside the Atom as the provided TimelineComment
func (t *Atom) FromTimelineComment(v TimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineComment performs a merge with any union data inside the Atom, using the provided TimelineComment
func (t *Atom) MergeTimelineComment(v TimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhook returns the union data inside the Atom as a Webhook
func (t Atom) AsWebhook() (Webhook, error) {
	var body Webhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhook overwrites any union data inside the Atom as the provided Webhook
func (t *Atom) FromWebhook(v Webhook) error {
	t.Type = "webhook"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhook performs a merge with any union data inside the Atom, using the provided Webhook
func (t *Atom) MergeWebhook(v Webhook) error {
	t.Type = "webhook"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Atom) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Atom) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "auth_token":
		return t.AsAuthToken()
	case "capability":
		return t.AsCapability()
	case "conversation":
		return t.AsConversation()
	case "dev_user":
		return t.AsDevUser()
	case "enhancement":
		return t.AsEnhancement()
	case "feature":
		return t.AsFeature()
	case "group":
		return t.AsGroup()
	case "issue":
		return t.AsIssue()
	case "link":
		return t.AsLink()
	case "product":
		return t.AsProduct()
	case "rev_org":
		return t.AsRevOrg()
	case "rev_user":
		return t.AsRevUser()
	case "service_account":
		return t.AsServiceAccount()
	case "sla":
		return t.AsSla()
	case "sla_tracker":
		return t.AsSlaTracker()
	case "sys_user":
		return t.AsSysUser()
	case "tag":
		return t.AsTag()
	case "ticket":
		return t.AsTicket()
	case "timeline_comment":
		return t.AsTimelineComment()
	case "webhook":
		return t.AsWebhook()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Atom) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Atom) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAuthTokenSummary returns the union data inside the AtomSummary as a AuthTokenSummary
func (t AtomSummary) AsAuthTokenSummary() (AuthTokenSummary, error) {
	var body AuthTokenSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthTokenSummary overwrites any union data inside the AtomSummary as the provided AuthTokenSummary
func (t *AtomSummary) FromAuthTokenSummary(v AuthTokenSummary) error {
	t.Type = "auth_token"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthTokenSummary performs a merge with any union data inside the AtomSummary, using the provided AuthTokenSummary
func (t *AtomSummary) MergeAuthTokenSummary(v AuthTokenSummary) error {
	t.Type = "auth_token"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapabilitySummary returns the union data inside the AtomSummary as a CapabilitySummary
func (t AtomSummary) AsCapabilitySummary() (CapabilitySummary, error) {
	var body CapabilitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapabilitySummary overwrites any union data inside the AtomSummary as the provided CapabilitySummary
func (t *AtomSummary) FromCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapabilitySummary performs a merge with any union data inside the AtomSummary, using the provided CapabilitySummary
func (t *AtomSummary) MergeCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConversationSummary returns the union data inside the AtomSummary as a ConversationSummary
func (t AtomSummary) AsConversationSummary() (ConversationSummary, error) {
	var body ConversationSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConversationSummary overwrites any union data inside the AtomSummary as the provided ConversationSummary
func (t *AtomSummary) FromConversationSummary(v ConversationSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConversationSummary performs a merge with any union data inside the AtomSummary, using the provided ConversationSummary
func (t *AtomSummary) MergeConversationSummary(v ConversationSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevUserSummary returns the union data inside the AtomSummary as a DevUserSummary
func (t AtomSummary) AsDevUserSummary() (DevUserSummary, error) {
	var body DevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUserSummary overwrites any union data inside the AtomSummary as the provided DevUserSummary
func (t *AtomSummary) FromDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUserSummary performs a merge with any union data inside the AtomSummary, using the provided DevUserSummary
func (t *AtomSummary) MergeDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancementSummary returns the union data inside the AtomSummary as a EnhancementSummary
func (t AtomSummary) AsEnhancementSummary() (EnhancementSummary, error) {
	var body EnhancementSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancementSummary overwrites any union data inside the AtomSummary as the provided EnhancementSummary
func (t *AtomSummary) FromEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancementSummary performs a merge with any union data inside the AtomSummary, using the provided EnhancementSummary
func (t *AtomSummary) MergeEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeatureSummary returns the union data inside the AtomSummary as a FeatureSummary
func (t AtomSummary) AsFeatureSummary() (FeatureSummary, error) {
	var body FeatureSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeatureSummary overwrites any union data inside the AtomSummary as the provided FeatureSummary
func (t *AtomSummary) FromFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeatureSummary performs a merge with any union data inside the AtomSummary, using the provided FeatureSummary
func (t *AtomSummary) MergeFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroupSummary returns the union data inside the AtomSummary as a GroupSummary
func (t AtomSummary) AsGroupSummary() (GroupSummary, error) {
	var body GroupSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroupSummary overwrites any union data inside the AtomSummary as the provided GroupSummary
func (t *AtomSummary) FromGroupSummary(v GroupSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroupSummary performs a merge with any union data inside the AtomSummary, using the provided GroupSummary
func (t *AtomSummary) MergeGroupSummary(v GroupSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueSummary returns the union data inside the AtomSummary as a IssueSummary
func (t AtomSummary) AsIssueSummary() (IssueSummary, error) {
	var body IssueSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueSummary overwrites any union data inside the AtomSummary as the provided IssueSummary
func (t *AtomSummary) FromIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueSummary performs a merge with any union data inside the AtomSummary, using the provided IssueSummary
func (t *AtomSummary) MergeIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkSummary returns the union data inside the AtomSummary as a LinkSummary
func (t AtomSummary) AsLinkSummary() (LinkSummary, error) {
	var body LinkSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkSummary overwrites any union data inside the AtomSummary as the provided LinkSummary
func (t *AtomSummary) FromLinkSummary(v LinkSummary) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkSummary performs a merge with any union data inside the AtomSummary, using the provided LinkSummary
func (t *AtomSummary) MergeLinkSummary(v LinkSummary) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProductSummary returns the union data inside the AtomSummary as a ProductSummary
func (t AtomSummary) AsProductSummary() (ProductSummary, error) {
	var body ProductSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProductSummary overwrites any union data inside the AtomSummary as the provided ProductSummary
func (t *AtomSummary) FromProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProductSummary performs a merge with any union data inside the AtomSummary, using the provided ProductSummary
func (t *AtomSummary) MergeProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevOrgSummary returns the union data inside the AtomSummary as a RevOrgSummary
func (t AtomSummary) AsRevOrgSummary() (RevOrgSummary, error) {
	var body RevOrgSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevOrgSummary overwrites any union data inside the AtomSummary as the provided RevOrgSummary
func (t *AtomSummary) FromRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevOrgSummary performs a merge with any union data inside the AtomSummary, using the provided RevOrgSummary
func (t *AtomSummary) MergeRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUserSummary returns the union data inside the AtomSummary as a RevUserSummary
func (t AtomSummary) AsRevUserSummary() (RevUserSummary, error) {
	var body RevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUserSummary overwrites any union data inside the AtomSummary as the provided RevUserSummary
func (t *AtomSummary) FromRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUserSummary performs a merge with any union data inside the AtomSummary, using the provided RevUserSummary
func (t *AtomSummary) MergeRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServiceAccountSummary returns the union data inside the AtomSummary as a ServiceAccountSummary
func (t AtomSummary) AsServiceAccountSummary() (ServiceAccountSummary, error) {
	var body ServiceAccountSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServiceAccountSummary overwrites any union data inside the AtomSummary as the provided ServiceAccountSummary
func (t *AtomSummary) FromServiceAccountSummary(v ServiceAccountSummary) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServiceAccountSummary performs a merge with any union data inside the AtomSummary, using the provided ServiceAccountSummary
func (t *AtomSummary) MergeServiceAccountSummary(v ServiceAccountSummary) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlaSummary returns the union data inside the AtomSummary as a SlaSummary
func (t AtomSummary) AsSlaSummary() (SlaSummary, error) {
	var body SlaSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlaSummary overwrites any union data inside the AtomSummary as the provided SlaSummary
func (t *AtomSummary) FromSlaSummary(v SlaSummary) error {
	t.Type = "sla"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlaSummary performs a merge with any union data inside the AtomSummary, using the provided SlaSummary
func (t *AtomSummary) MergeSlaSummary(v SlaSummary) error {
	t.Type = "sla"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlaTrackerSummary returns the union data inside the AtomSummary as a SlaTrackerSummary
func (t AtomSummary) AsSlaTrackerSummary() (SlaTrackerSummary, error) {
	var body SlaTrackerSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlaTrackerSummary overwrites any union data inside the AtomSummary as the provided SlaTrackerSummary
func (t *AtomSummary) FromSlaTrackerSummary(v SlaTrackerSummary) error {
	t.Type = "sla_tracker"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlaTrackerSummary performs a merge with any union data inside the AtomSummary, using the provided SlaTrackerSummary
func (t *AtomSummary) MergeSlaTrackerSummary(v SlaTrackerSummary) error {
	t.Type = "sla_tracker"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSysUserSummary returns the union data inside the AtomSummary as a SysUserSummary
func (t AtomSummary) AsSysUserSummary() (SysUserSummary, error) {
	var body SysUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSysUserSummary overwrites any union data inside the AtomSummary as the provided SysUserSummary
func (t *AtomSummary) FromSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSysUserSummary performs a merge with any union data inside the AtomSummary, using the provided SysUserSummary
func (t *AtomSummary) MergeSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTagSummary returns the union data inside the AtomSummary as a TagSummary
func (t AtomSummary) AsTagSummary() (TagSummary, error) {
	var body TagSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTagSummary overwrites any union data inside the AtomSummary as the provided TagSummary
func (t *AtomSummary) FromTagSummary(v TagSummary) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTagSummary performs a merge with any union data inside the AtomSummary, using the provided TagSummary
func (t *AtomSummary) MergeTagSummary(v TagSummary) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTicketSummary returns the union data inside the AtomSummary as a TicketSummary
func (t AtomSummary) AsTicketSummary() (TicketSummary, error) {
	var body TicketSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTicketSummary overwrites any union data inside the AtomSummary as the provided TicketSummary
func (t *AtomSummary) FromTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTicketSummary performs a merge with any union data inside the AtomSummary, using the provided TicketSummary
func (t *AtomSummary) MergeTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimelineCommentSummary returns the union data inside the AtomSummary as a TimelineCommentSummary
func (t AtomSummary) AsTimelineCommentSummary() (TimelineCommentSummary, error) {
	var body TimelineCommentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineCommentSummary overwrites any union data inside the AtomSummary as the provided TimelineCommentSummary
func (t *AtomSummary) FromTimelineCommentSummary(v TimelineCommentSummary) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineCommentSummary performs a merge with any union data inside the AtomSummary, using the provided TimelineCommentSummary
func (t *AtomSummary) MergeTimelineCommentSummary(v TimelineCommentSummary) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookSummary returns the union data inside the AtomSummary as a WebhookSummary
func (t AtomSummary) AsWebhookSummary() (WebhookSummary, error) {
	var body WebhookSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookSummary overwrites any union data inside the AtomSummary as the provided WebhookSummary
func (t *AtomSummary) FromWebhookSummary(v WebhookSummary) error {
	t.Type = "webhook"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookSummary performs a merge with any union data inside the AtomSummary, using the provided WebhookSummary
func (t *AtomSummary) MergeWebhookSummary(v WebhookSummary) error {
	t.Type = "webhook"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AtomSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AtomSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "auth_token":
		return t.AsAuthTokenSummary()
	case "capability":
		return t.AsCapabilitySummary()
	case "conversation":
		return t.AsConversationSummary()
	case "dev_user":
		return t.AsDevUserSummary()
	case "enhancement":
		return t.AsEnhancementSummary()
	case "feature":
		return t.AsFeatureSummary()
	case "group":
		return t.AsGroupSummary()
	case "issue":
		return t.AsIssueSummary()
	case "link":
		return t.AsLinkSummary()
	case "product":
		return t.AsProductSummary()
	case "rev_org":
		return t.AsRevOrgSummary()
	case "rev_user":
		return t.AsRevUserSummary()
	case "service_account":
		return t.AsServiceAccountSummary()
	case "sla":
		return t.AsSlaSummary()
	case "sla_tracker":
		return t.AsSlaTrackerSummary()
	case "sys_user":
		return t.AsSysUserSummary()
	case "tag":
		return t.AsTagSummary()
	case "ticket":
		return t.AsTicketSummary()
	case "timeline_comment":
		return t.AsTimelineCommentSummary()
	case "webhook":
		return t.AsWebhookSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AtomSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AtomSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAuthConnectionOptionsAzureAd returns the union data inside the AuthConnection as a AuthConnectionOptionsAzureAd
func (t AuthConnection) AsAuthConnectionOptionsAzureAd() (AuthConnectionOptionsAzureAd, error) {
	var body AuthConnectionOptionsAzureAd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsAzureAd overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsAzureAd
func (t *AuthConnection) FromAuthConnectionOptionsAzureAd(v AuthConnectionOptionsAzureAd) error {
	t.Type = "waad"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsAzureAd performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsAzureAd
func (t *AuthConnection) MergeAuthConnectionOptionsAzureAd(v AuthConnectionOptionsAzureAd) error {
	t.Type = "waad"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsGoogleApps returns the union data inside the AuthConnection as a AuthConnectionOptionsGoogleApps
func (t AuthConnection) AsAuthConnectionOptionsGoogleApps() (AuthConnectionOptionsGoogleApps, error) {
	var body AuthConnectionOptionsGoogleApps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsGoogleApps overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsGoogleApps
func (t *AuthConnection) FromAuthConnectionOptionsGoogleApps(v AuthConnectionOptionsGoogleApps) error {
	t.Type = "google_apps"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsGoogleApps performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsGoogleApps
func (t *AuthConnection) MergeAuthConnectionOptionsGoogleApps(v AuthConnectionOptionsGoogleApps) error {
	t.Type = "google_apps"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsOidc returns the union data inside the AuthConnection as a AuthConnectionOptionsOidc
func (t AuthConnection) AsAuthConnectionOptionsOidc() (AuthConnectionOptionsOidc, error) {
	var body AuthConnectionOptionsOidc
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsOidc overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsOidc
func (t *AuthConnection) FromAuthConnectionOptionsOidc(v AuthConnectionOptionsOidc) error {
	t.Type = "oidc"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsOidc performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsOidc
func (t *AuthConnection) MergeAuthConnectionOptionsOidc(v AuthConnectionOptionsOidc) error {
	t.Type = "oidc"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsOkta returns the union data inside the AuthConnection as a AuthConnectionOptionsOkta
func (t AuthConnection) AsAuthConnectionOptionsOkta() (AuthConnectionOptionsOkta, error) {
	var body AuthConnectionOptionsOkta
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsOkta overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsOkta
func (t *AuthConnection) FromAuthConnectionOptionsOkta(v AuthConnectionOptionsOkta) error {
	t.Type = "okta"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsOkta performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsOkta
func (t *AuthConnection) MergeAuthConnectionOptionsOkta(v AuthConnectionOptionsOkta) error {
	t.Type = "okta"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsSaml returns the union data inside the AuthConnection as a AuthConnectionOptionsSaml
func (t AuthConnection) AsAuthConnectionOptionsSaml() (AuthConnectionOptionsSaml, error) {
	var body AuthConnectionOptionsSaml
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsSaml overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsSaml
func (t *AuthConnection) FromAuthConnectionOptionsSaml(v AuthConnectionOptionsSaml) error {
	t.Type = "samlp"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsSaml performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsSaml
func (t *AuthConnection) MergeAuthConnectionOptionsSaml(v AuthConnectionOptionsSaml) error {
	t.Type = "samlp"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsSocial returns the union data inside the AuthConnection as a AuthConnectionOptionsSocial
func (t AuthConnection) AsAuthConnectionOptionsSocial() (AuthConnectionOptionsSocial, error) {
	var body AuthConnectionOptionsSocial
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsSocial overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsSocial
func (t *AuthConnection) FromAuthConnectionOptionsSocial(v AuthConnectionOptionsSocial) error {
	t.Type = "social"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsSocial performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsSocial
func (t *AuthConnection) MergeAuthConnectionOptionsSocial(v AuthConnectionOptionsSocial) error {
	t.Type = "social"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AuthConnection) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AuthConnection) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "google_apps":
		return t.AsAuthConnectionOptionsGoogleApps()
	case "oidc":
		return t.AsAuthConnectionOptionsOidc()
	case "okta":
		return t.AsAuthConnectionOptionsOkta()
	case "samlp":
		return t.AsAuthConnectionOptionsSaml()
	case "social":
		return t.AsAuthConnectionOptionsSocial()
	case "waad":
		return t.AsAuthConnectionOptionsAzureAd()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AuthConnection) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["display_name"], err = json.Marshal(t.DisplayName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'display_name': %w", err)
	}

	object["enabled"], err = json.Marshal(t.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AuthConnection) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["display_name"]; found {
		err = json.Unmarshal(raw, &t.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display_name': %w", err)
		}
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &t.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsBooleanExpressionAndExpression returns the union data inside the BooleanExpression as a BooleanExpressionAndExpression
func (t BooleanExpression) AsBooleanExpressionAndExpression() (BooleanExpressionAndExpression, error) {
	var body BooleanExpressionAndExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanExpressionAndExpression overwrites any union data inside the BooleanExpression as the provided BooleanExpressionAndExpression
func (t *BooleanExpression) FromBooleanExpressionAndExpression(v BooleanExpressionAndExpression) error {
	t.Type = "and"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanExpressionAndExpression performs a merge with any union data inside the BooleanExpression, using the provided BooleanExpressionAndExpression
func (t *BooleanExpression) MergeBooleanExpressionAndExpression(v BooleanExpressionAndExpression) error {
	t.Type = "and"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBooleanExpressionNotExpression returns the union data inside the BooleanExpression as a BooleanExpressionNotExpression
func (t BooleanExpression) AsBooleanExpressionNotExpression() (BooleanExpressionNotExpression, error) {
	var body BooleanExpressionNotExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanExpressionNotExpression overwrites any union data inside the BooleanExpression as the provided BooleanExpressionNotExpression
func (t *BooleanExpression) FromBooleanExpressionNotExpression(v BooleanExpressionNotExpression) error {
	t.Type = "not"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanExpressionNotExpression performs a merge with any union data inside the BooleanExpression, using the provided BooleanExpressionNotExpression
func (t *BooleanExpression) MergeBooleanExpressionNotExpression(v BooleanExpressionNotExpression) error {
	t.Type = "not"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBooleanExpressionOrExpression returns the union data inside the BooleanExpression as a BooleanExpressionOrExpression
func (t BooleanExpression) AsBooleanExpressionOrExpression() (BooleanExpressionOrExpression, error) {
	var body BooleanExpressionOrExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanExpressionOrExpression overwrites any union data inside the BooleanExpression as the provided BooleanExpressionOrExpression
func (t *BooleanExpression) FromBooleanExpressionOrExpression(v BooleanExpressionOrExpression) error {
	t.Type = "or"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanExpressionOrExpression performs a merge with any union data inside the BooleanExpression, using the provided BooleanExpressionOrExpression
func (t *BooleanExpression) MergeBooleanExpressionOrExpression(v BooleanExpressionOrExpression) error {
	t.Type = "or"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBooleanExpressionPrimitiveExpression returns the union data inside the BooleanExpression as a BooleanExpressionPrimitiveExpression
func (t BooleanExpression) AsBooleanExpressionPrimitiveExpression() (BooleanExpressionPrimitiveExpression, error) {
	var body BooleanExpressionPrimitiveExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanExpressionPrimitiveExpression overwrites any union data inside the BooleanExpression as the provided BooleanExpressionPrimitiveExpression
func (t *BooleanExpression) FromBooleanExpressionPrimitiveExpression(v BooleanExpressionPrimitiveExpression) error {
	t.Type = "primitive"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanExpressionPrimitiveExpression performs a merge with any union data inside the BooleanExpression, using the provided BooleanExpressionPrimitiveExpression
func (t *BooleanExpression) MergeBooleanExpressionPrimitiveExpression(v BooleanExpressionPrimitiveExpression) error {
	t.Type = "primitive"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BooleanExpression) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BooleanExpression) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "and":
		return t.AsBooleanExpressionAndExpression()
	case "not":
		return t.AsBooleanExpressionNotExpression()
	case "or":
		return t.AsBooleanExpressionOrExpression()
	case "primitive":
		return t.AsBooleanExpressionPrimitiveExpression()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BooleanExpression) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *BooleanExpression) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsChatsCreateRequestDm returns the union data inside the ChatsCreateRequest as a ChatsCreateRequestDm
func (t ChatsCreateRequest) AsChatsCreateRequestDm() (ChatsCreateRequestDm, error) {
	var body ChatsCreateRequestDm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatsCreateRequestDm overwrites any union data inside the ChatsCreateRequest as the provided ChatsCreateRequestDm
func (t *ChatsCreateRequest) FromChatsCreateRequestDm(v ChatsCreateRequestDm) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatsCreateRequestDm performs a merge with any union data inside the ChatsCreateRequest, using the provided ChatsCreateRequestDm
func (t *ChatsCreateRequest) MergeChatsCreateRequestDm(v ChatsCreateRequestDm) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatsCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ChatsCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dm":
		return t.AsChatsCreateRequestDm()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ChatsCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.CustomFields != nil {
		object["custom_fields"], err = json.Marshal(t.CustomFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_fields': %w", err)
		}
	}

	if t.CustomSchemaSpec != nil {
		object["custom_schema_spec"], err = json.Marshal(t.CustomSchemaSpec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_spec': %w", err)
		}
	}

	if t.GetIfConflict != nil {
		object["get_if_conflict"], err = json.Marshal(t.GetIfConflict)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'get_if_conflict': %w", err)
		}
	}

	if t.Title != nil {
		object["title"], err = json.Marshal(t.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ChatsCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["custom_fields"]; found {
		err = json.Unmarshal(raw, &t.CustomFields)
		if err != nil {
			return fmt.Errorf("error reading 'custom_fields': %w", err)
		}
	}

	if raw, found := object["custom_schema_spec"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaSpec)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_spec': %w", err)
		}
	}

	if raw, found := object["get_if_conflict"]; found {
		err = json.Unmarshal(raw, &t.GetIfConflict)
		if err != nil {
			return fmt.Errorf("error reading 'get_if_conflict': %w", err)
		}
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &t.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsChatsGetRequestDm returns the union data inside the ChatsGetRequest as a ChatsGetRequestDm
func (t ChatsGetRequest) AsChatsGetRequestDm() (ChatsGetRequestDm, error) {
	var body ChatsGetRequestDm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatsGetRequestDm overwrites any union data inside the ChatsGetRequest as the provided ChatsGetRequestDm
func (t *ChatsGetRequest) FromChatsGetRequestDm(v ChatsGetRequestDm) error {
	t.Type = func() *ChatType { v := ChatType("dm"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatsGetRequestDm performs a merge with any union data inside the ChatsGetRequest, using the provided ChatsGetRequestDm
func (t *ChatsGetRequest) MergeChatsGetRequestDm(v ChatsGetRequestDm) error {
	t.Type = func() *ChatType { v := ChatType("dm"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmpty returns the union data inside the ChatsGetRequest as a Empty
func (t ChatsGetRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the ChatsGetRequest as the provided Empty
func (t *ChatsGetRequest) FromEmpty(v Empty) error {
	t.Type = func() *ChatType { v := ChatType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the ChatsGetRequest, using the provided Empty
func (t *ChatsGetRequest) MergeEmpty(v Empty) error {
	t.Type = func() *ChatType { v := ChatType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatsGetRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ChatsGetRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dm":
		return t.AsChatsGetRequestDm()
	case "none":
		return t.AsEmpty()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ChatsGetRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *ChatsGetRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsChatsUpdateRequestDm returns the union data inside the ChatsUpdateRequest as a ChatsUpdateRequestDm
func (t ChatsUpdateRequest) AsChatsUpdateRequestDm() (ChatsUpdateRequestDm, error) {
	var body ChatsUpdateRequestDm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatsUpdateRequestDm overwrites any union data inside the ChatsUpdateRequest as the provided ChatsUpdateRequestDm
func (t *ChatsUpdateRequest) FromChatsUpdateRequestDm(v ChatsUpdateRequestDm) error {
	t.Type = func() *ChatType { v := ChatType("dm"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatsUpdateRequestDm performs a merge with any union data inside the ChatsUpdateRequest, using the provided ChatsUpdateRequestDm
func (t *ChatsUpdateRequest) MergeChatsUpdateRequestDm(v ChatsUpdateRequestDm) error {
	t.Type = func() *ChatType { v := ChatType("dm"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmpty returns the union data inside the ChatsUpdateRequest as a Empty
func (t ChatsUpdateRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the ChatsUpdateRequest as the provided Empty
func (t *ChatsUpdateRequest) FromEmpty(v Empty) error {
	t.Type = func() *ChatType { v := ChatType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the ChatsUpdateRequest, using the provided Empty
func (t *ChatsUpdateRequest) MergeEmpty(v Empty) error {
	t.Type = func() *ChatType { v := ChatType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatsUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ChatsUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dm":
		return t.AsChatsUpdateRequestDm()
	case "none":
		return t.AsEmpty()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ChatsUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.CustomFields != nil {
		object["custom_fields"], err = json.Marshal(t.CustomFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_fields': %w", err)
		}
	}

	if t.CustomSchemaSpec != nil {
		object["custom_schema_spec"], err = json.Marshal(t.CustomSchemaSpec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_spec': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Title != nil {
		object["title"], err = json.Marshal(t.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *ChatsUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["custom_fields"]; found {
		err = json.Unmarshal(raw, &t.CustomFields)
		if err != nil {
			return fmt.Errorf("error reading 'custom_fields': %w", err)
		}
	}

	if raw, found := object["custom_schema_spec"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaSpec)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_spec': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &t.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDateTimeFilter returns the union data inside the DateFilter as a DateTimeFilter
func (t DateFilter) AsDateTimeFilter() (DateTimeFilter, error) {
	var body DateTimeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFilter overwrites any union data inside the DateFilter as the provided DateTimeFilter
func (t *DateFilter) FromDateTimeFilter(v DateTimeFilter) error {
	t.Type = "range"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFilter performs a merge with any union data inside the DateFilter, using the provided DateTimeFilter
func (t *DateFilter) MergeDateTimeFilter(v DateTimeFilter) error {
	t.Type = "range"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTimePreset returns the union data inside the DateFilter as a DateTimePreset
func (t DateFilter) AsDateTimePreset() (DateTimePreset, error) {
	var body DateTimePreset
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimePreset overwrites any union data inside the DateFilter as the provided DateTimePreset
func (t *DateFilter) FromDateTimePreset(v DateTimePreset) error {
	t.Type = "preset"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimePreset performs a merge with any union data inside the DateFilter, using the provided DateTimePreset
func (t *DateFilter) MergeDateTimePreset(v DateTimePreset) error {
	t.Type = "preset"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DateFilter) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DateFilter) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "preset":
		return t.AsDateTimePreset()
	case "range":
		return t.AsDateTimeFilter()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DateFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *DateFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDateTimePresetLastNDays returns the union data inside the DateTimePreset as a DateTimePresetLastNDays
func (t DateTimePreset) AsDateTimePresetLastNDays() (DateTimePresetLastNDays, error) {
	var body DateTimePresetLastNDays
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimePresetLastNDays overwrites any union data inside the DateTimePreset as the provided DateTimePresetLastNDays
func (t *DateTimePreset) FromDateTimePresetLastNDays(v DateTimePresetLastNDays) error {
	t.PresetType = "last_n_days"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimePresetLastNDays performs a merge with any union data inside the DateTimePreset, using the provided DateTimePresetLastNDays
func (t *DateTimePreset) MergeDateTimePresetLastNDays(v DateTimePresetLastNDays) error {
	t.PresetType = "last_n_days"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTimePresetNextNDays returns the union data inside the DateTimePreset as a DateTimePresetNextNDays
func (t DateTimePreset) AsDateTimePresetNextNDays() (DateTimePresetNextNDays, error) {
	var body DateTimePresetNextNDays
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimePresetNextNDays overwrites any union data inside the DateTimePreset as the provided DateTimePresetNextNDays
func (t *DateTimePreset) FromDateTimePresetNextNDays(v DateTimePresetNextNDays) error {
	t.PresetType = "next_n_days"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimePresetNextNDays performs a merge with any union data inside the DateTimePreset, using the provided DateTimePresetNextNDays
func (t *DateTimePreset) MergeDateTimePresetNextNDays(v DateTimePresetNextNDays) error {
	t.PresetType = "next_n_days"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DateTimePreset) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"preset_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DateTimePreset) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "last_n_days":
		return t.AsDateTimePresetLastNDays()
	case "next_n_days":
		return t.AsDateTimePresetNextNDays()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DateTimePreset) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["preset_type"], err = json.Marshal(t.PresetType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'preset_type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *DateTimePreset) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["preset_type"]; found {
		err = json.Unmarshal(raw, &t.PresetType)
		if err != nil {
			return fmt.Errorf("error reading 'preset_type': %w", err)
		}
	}

	return err
}

// AsDevOrgAuthConnectionsCreateRequestAzureAdOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestAzureAdOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestAzureAdOptions() (DevOrgAuthConnectionsCreateRequestAzureAdOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestAzureAdOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestAzureAdOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestAzureAdOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestAzureAdOptions(v DevOrgAuthConnectionsCreateRequestAzureAdOptions) error {
	t.Type = "waad"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestAzureAdOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestAzureAdOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestAzureAdOptions(v DevOrgAuthConnectionsCreateRequestAzureAdOptions) error {
	t.Type = "waad"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsCreateRequestGoogleAppsOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestGoogleAppsOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestGoogleAppsOptions() (DevOrgAuthConnectionsCreateRequestGoogleAppsOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestGoogleAppsOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestGoogleAppsOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestGoogleAppsOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestGoogleAppsOptions(v DevOrgAuthConnectionsCreateRequestGoogleAppsOptions) error {
	t.Type = "google_apps"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestGoogleAppsOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestGoogleAppsOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestGoogleAppsOptions(v DevOrgAuthConnectionsCreateRequestGoogleAppsOptions) error {
	t.Type = "google_apps"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsCreateRequestOidcOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestOidcOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestOidcOptions() (DevOrgAuthConnectionsCreateRequestOidcOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestOidcOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestOidcOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestOidcOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestOidcOptions(v DevOrgAuthConnectionsCreateRequestOidcOptions) error {
	t.Type = "oidc"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestOidcOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestOidcOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestOidcOptions(v DevOrgAuthConnectionsCreateRequestOidcOptions) error {
	t.Type = "oidc"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsCreateRequestOktaOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestOktaOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestOktaOptions() (DevOrgAuthConnectionsCreateRequestOktaOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestOktaOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestOktaOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestOktaOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestOktaOptions(v DevOrgAuthConnectionsCreateRequestOktaOptions) error {
	t.Type = "okta"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestOktaOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestOktaOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestOktaOptions(v DevOrgAuthConnectionsCreateRequestOktaOptions) error {
	t.Type = "okta"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsCreateRequestSamlOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestSamlOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestSamlOptions() (DevOrgAuthConnectionsCreateRequestSamlOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestSamlOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestSamlOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestSamlOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestSamlOptions(v DevOrgAuthConnectionsCreateRequestSamlOptions) error {
	t.Type = "samlp"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestSamlOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestSamlOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestSamlOptions(v DevOrgAuthConnectionsCreateRequestSamlOptions) error {
	t.Type = "samlp"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevOrgAuthConnectionsCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DevOrgAuthConnectionsCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "google_apps":
		return t.AsDevOrgAuthConnectionsCreateRequestGoogleAppsOptions()
	case "oidc":
		return t.AsDevOrgAuthConnectionsCreateRequestOidcOptions()
	case "okta":
		return t.AsDevOrgAuthConnectionsCreateRequestOktaOptions()
	case "samlp":
		return t.AsDevOrgAuthConnectionsCreateRequestSamlOptions()
	case "waad":
		return t.AsDevOrgAuthConnectionsCreateRequestAzureAdOptions()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DevOrgAuthConnectionsCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.DisplayName != nil {
		object["display_name"], err = json.Marshal(t.DisplayName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'display_name': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *DevOrgAuthConnectionsCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["display_name"]; found {
		err = json.Unmarshal(raw, &t.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display_name': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDevOrgAuthConnectionsUpdateRequestAzureAdOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestAzureAdOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestAzureAdOptions() (DevOrgAuthConnectionsUpdateRequestAzureAdOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestAzureAdOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestAzureAdOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestAzureAdOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestAzureAdOptions(v DevOrgAuthConnectionsUpdateRequestAzureAdOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("waad"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestAzureAdOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestAzureAdOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestAzureAdOptions(v DevOrgAuthConnectionsUpdateRequestAzureAdOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("waad"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions() (DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions(v DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("google_apps"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions(v DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("google_apps"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsUpdateRequestOidcOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestOidcOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestOidcOptions() (DevOrgAuthConnectionsUpdateRequestOidcOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestOidcOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestOidcOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestOidcOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestOidcOptions(v DevOrgAuthConnectionsUpdateRequestOidcOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("oidc"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestOidcOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestOidcOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestOidcOptions(v DevOrgAuthConnectionsUpdateRequestOidcOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("oidc"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsUpdateRequestOktaOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestOktaOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestOktaOptions() (DevOrgAuthConnectionsUpdateRequestOktaOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestOktaOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestOktaOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestOktaOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestOktaOptions(v DevOrgAuthConnectionsUpdateRequestOktaOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("okta"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestOktaOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestOktaOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestOktaOptions(v DevOrgAuthConnectionsUpdateRequestOktaOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("okta"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsUpdateRequestSamlOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestSamlOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestSamlOptions() (DevOrgAuthConnectionsUpdateRequestSamlOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestSamlOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestSamlOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestSamlOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestSamlOptions(v DevOrgAuthConnectionsUpdateRequestSamlOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("samlp"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestSamlOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestSamlOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestSamlOptions(v DevOrgAuthConnectionsUpdateRequestSamlOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("samlp"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmpty returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a Empty
func (t DevOrgAuthConnectionsUpdateRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided Empty
func (t *DevOrgAuthConnectionsUpdateRequest) FromEmpty(v Empty) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided Empty
func (t *DevOrgAuthConnectionsUpdateRequest) MergeEmpty(v Empty) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevOrgAuthConnectionsUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DevOrgAuthConnectionsUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "google_apps":
		return t.AsDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions()
	case "none":
		return t.AsEmpty()
	case "oidc":
		return t.AsDevOrgAuthConnectionsUpdateRequestOidcOptions()
	case "okta":
		return t.AsDevOrgAuthConnectionsUpdateRequestOktaOptions()
	case "samlp":
		return t.AsDevOrgAuthConnectionsUpdateRequestSamlOptions()
	case "waad":
		return t.AsDevOrgAuthConnectionsUpdateRequestAzureAdOptions()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DevOrgAuthConnectionsUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.DisplayName != nil {
		object["display_name"], err = json.Marshal(t.DisplayName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'display_name': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *DevOrgAuthConnectionsUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["display_name"]; found {
		err = json.Unmarshal(raw, &t.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display_name': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorBadRequestArtifactAlreadyAttachedToAParent returns the union data inside the ErrorBadRequest as a ErrorBadRequestArtifactAlreadyAttachedToAParent
func (t ErrorBadRequest) AsErrorBadRequestArtifactAlreadyAttachedToAParent() (ErrorBadRequestArtifactAlreadyAttachedToAParent, error) {
	var body ErrorBadRequestArtifactAlreadyAttachedToAParent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestArtifactAlreadyAttachedToAParent overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestArtifactAlreadyAttachedToAParent
func (t *ErrorBadRequest) FromErrorBadRequestArtifactAlreadyAttachedToAParent(v ErrorBadRequestArtifactAlreadyAttachedToAParent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestArtifactAlreadyAttachedToAParent performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestArtifactAlreadyAttachedToAParent
func (t *ErrorBadRequest) MergeErrorBadRequestArtifactAlreadyAttachedToAParent(v ErrorBadRequestArtifactAlreadyAttachedToAParent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestBadRequest returns the union data inside the ErrorBadRequest as a ErrorBadRequestBadRequest
func (t ErrorBadRequest) AsErrorBadRequestBadRequest() (ErrorBadRequestBadRequest, error) {
	var body ErrorBadRequestBadRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestBadRequest overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestBadRequest
func (t *ErrorBadRequest) FromErrorBadRequestBadRequest(v ErrorBadRequestBadRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestBadRequest performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestBadRequest
func (t *ErrorBadRequest) MergeErrorBadRequestBadRequest(v ErrorBadRequestBadRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationError returns the union data inside the ErrorBadRequest as a ErrorBadRequestCustomizationValidationError
func (t ErrorBadRequest) AsErrorBadRequestCustomizationValidationError() (ErrorBadRequestCustomizationValidationError, error) {
	var body ErrorBadRequestCustomizationValidationError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationError overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestCustomizationValidationError
func (t *ErrorBadRequest) FromErrorBadRequestCustomizationValidationError(v ErrorBadRequestCustomizationValidationError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationError performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestCustomizationValidationError
func (t *ErrorBadRequest) MergeErrorBadRequestCustomizationValidationError(v ErrorBadRequestCustomizationValidationError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestInvalidApiVersion returns the union data inside the ErrorBadRequest as a ErrorBadRequestInvalidApiVersion
func (t ErrorBadRequest) AsErrorBadRequestInvalidApiVersion() (ErrorBadRequestInvalidApiVersion, error) {
	var body ErrorBadRequestInvalidApiVersion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestInvalidApiVersion overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestInvalidApiVersion
func (t *ErrorBadRequest) FromErrorBadRequestInvalidApiVersion(v ErrorBadRequestInvalidApiVersion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestInvalidApiVersion performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestInvalidApiVersion
func (t *ErrorBadRequest) MergeErrorBadRequestInvalidApiVersion(v ErrorBadRequestInvalidApiVersion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestInvalidEnumValue returns the union data inside the ErrorBadRequest as a ErrorBadRequestInvalidEnumValue
func (t ErrorBadRequest) AsErrorBadRequestInvalidEnumValue() (ErrorBadRequestInvalidEnumValue, error) {
	var body ErrorBadRequestInvalidEnumValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestInvalidEnumValue overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestInvalidEnumValue
func (t *ErrorBadRequest) FromErrorBadRequestInvalidEnumValue(v ErrorBadRequestInvalidEnumValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestInvalidEnumValue performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestInvalidEnumValue
func (t *ErrorBadRequest) MergeErrorBadRequestInvalidEnumValue(v ErrorBadRequestInvalidEnumValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestInvalidField returns the union data inside the ErrorBadRequest as a ErrorBadRequestInvalidField
func (t ErrorBadRequest) AsErrorBadRequestInvalidField() (ErrorBadRequestInvalidField, error) {
	var body ErrorBadRequestInvalidField
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestInvalidField overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestInvalidField
func (t *ErrorBadRequest) FromErrorBadRequestInvalidField(v ErrorBadRequestInvalidField) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestInvalidField performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestInvalidField
func (t *ErrorBadRequest) MergeErrorBadRequestInvalidField(v ErrorBadRequestInvalidField) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestInvalidId returns the union data inside the ErrorBadRequest as a ErrorBadRequestInvalidId
func (t ErrorBadRequest) AsErrorBadRequestInvalidId() (ErrorBadRequestInvalidId, error) {
	var body ErrorBadRequestInvalidId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestInvalidId overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestInvalidId
func (t *ErrorBadRequest) FromErrorBadRequestInvalidId(v ErrorBadRequestInvalidId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestInvalidId performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestInvalidId
func (t *ErrorBadRequest) MergeErrorBadRequestInvalidId(v ErrorBadRequestInvalidId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestMergeWorksError returns the union data inside the ErrorBadRequest as a ErrorBadRequestMergeWorksError
func (t ErrorBadRequest) AsErrorBadRequestMergeWorksError() (ErrorBadRequestMergeWorksError, error) {
	var body ErrorBadRequestMergeWorksError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestMergeWorksError overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestMergeWorksError
func (t *ErrorBadRequest) FromErrorBadRequestMergeWorksError(v ErrorBadRequestMergeWorksError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestMergeWorksError performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestMergeWorksError
func (t *ErrorBadRequest) MergeErrorBadRequestMergeWorksError(v ErrorBadRequestMergeWorksError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestMissingDependency returns the union data inside the ErrorBadRequest as a ErrorBadRequestMissingDependency
func (t ErrorBadRequest) AsErrorBadRequestMissingDependency() (ErrorBadRequestMissingDependency, error) {
	var body ErrorBadRequestMissingDependency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestMissingDependency overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestMissingDependency
func (t *ErrorBadRequest) FromErrorBadRequestMissingDependency(v ErrorBadRequestMissingDependency) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestMissingDependency performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestMissingDependency
func (t *ErrorBadRequest) MergeErrorBadRequestMissingDependency(v ErrorBadRequestMissingDependency) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestMissingRequiredField returns the union data inside the ErrorBadRequest as a ErrorBadRequestMissingRequiredField
func (t ErrorBadRequest) AsErrorBadRequestMissingRequiredField() (ErrorBadRequestMissingRequiredField, error) {
	var body ErrorBadRequestMissingRequiredField
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestMissingRequiredField overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestMissingRequiredField
func (t *ErrorBadRequest) FromErrorBadRequestMissingRequiredField(v ErrorBadRequestMissingRequiredField) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestMissingRequiredField performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestMissingRequiredField
func (t *ErrorBadRequest) MergeErrorBadRequestMissingRequiredField(v ErrorBadRequestMissingRequiredField) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestParseError returns the union data inside the ErrorBadRequest as a ErrorBadRequestParseError
func (t ErrorBadRequest) AsErrorBadRequestParseError() (ErrorBadRequestParseError, error) {
	var body ErrorBadRequestParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestParseError overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestParseError
func (t *ErrorBadRequest) FromErrorBadRequestParseError(v ErrorBadRequestParseError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestParseError performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestParseError
func (t *ErrorBadRequest) MergeErrorBadRequestParseError(v ErrorBadRequestParseError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestStaleSchemaFragments returns the union data inside the ErrorBadRequest as a ErrorBadRequestStaleSchemaFragments
func (t ErrorBadRequest) AsErrorBadRequestStaleSchemaFragments() (ErrorBadRequestStaleSchemaFragments, error) {
	var body ErrorBadRequestStaleSchemaFragments
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestStaleSchemaFragments overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestStaleSchemaFragments
func (t *ErrorBadRequest) FromErrorBadRequestStaleSchemaFragments(v ErrorBadRequestStaleSchemaFragments) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestStaleSchemaFragments performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestStaleSchemaFragments
func (t *ErrorBadRequest) MergeErrorBadRequestStaleSchemaFragments(v ErrorBadRequestStaleSchemaFragments) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestUnexpectedIdType returns the union data inside the ErrorBadRequest as a ErrorBadRequestUnexpectedIdType
func (t ErrorBadRequest) AsErrorBadRequestUnexpectedIdType() (ErrorBadRequestUnexpectedIdType, error) {
	var body ErrorBadRequestUnexpectedIdType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestUnexpectedIdType overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestUnexpectedIdType
func (t *ErrorBadRequest) FromErrorBadRequestUnexpectedIdType(v ErrorBadRequestUnexpectedIdType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestUnexpectedIdType performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestUnexpectedIdType
func (t *ErrorBadRequest) MergeErrorBadRequestUnexpectedIdType(v ErrorBadRequestUnexpectedIdType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestUnexpectedJsonType returns the union data inside the ErrorBadRequest as a ErrorBadRequestUnexpectedJsonType
func (t ErrorBadRequest) AsErrorBadRequestUnexpectedJsonType() (ErrorBadRequestUnexpectedJsonType, error) {
	var body ErrorBadRequestUnexpectedJsonType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestUnexpectedJsonType overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestUnexpectedJsonType
func (t *ErrorBadRequest) FromErrorBadRequestUnexpectedJsonType(v ErrorBadRequestUnexpectedJsonType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestUnexpectedJsonType performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestUnexpectedJsonType
func (t *ErrorBadRequest) MergeErrorBadRequestUnexpectedJsonType(v ErrorBadRequestUnexpectedJsonType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestValueNotPermitted returns the union data inside the ErrorBadRequest as a ErrorBadRequestValueNotPermitted
func (t ErrorBadRequest) AsErrorBadRequestValueNotPermitted() (ErrorBadRequestValueNotPermitted, error) {
	var body ErrorBadRequestValueNotPermitted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestValueNotPermitted overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestValueNotPermitted
func (t *ErrorBadRequest) FromErrorBadRequestValueNotPermitted(v ErrorBadRequestValueNotPermitted) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestValueNotPermitted performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestValueNotPermitted
func (t *ErrorBadRequest) MergeErrorBadRequestValueNotPermitted(v ErrorBadRequestValueNotPermitted) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestWorkflowComponentValidationErrors returns the union data inside the ErrorBadRequest as a ErrorBadRequestWorkflowComponentValidationErrors
func (t ErrorBadRequest) AsErrorBadRequestWorkflowComponentValidationErrors() (ErrorBadRequestWorkflowComponentValidationErrors, error) {
	var body ErrorBadRequestWorkflowComponentValidationErrors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestWorkflowComponentValidationErrors overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestWorkflowComponentValidationErrors
func (t *ErrorBadRequest) FromErrorBadRequestWorkflowComponentValidationErrors(v ErrorBadRequestWorkflowComponentValidationErrors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestWorkflowComponentValidationErrors performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestWorkflowComponentValidationErrors
func (t *ErrorBadRequest) MergeErrorBadRequestWorkflowComponentValidationErrors(v ErrorBadRequestWorkflowComponentValidationErrors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorBadRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorBadRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorBadRequestCustomizationValidationErrorBadIdType returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorBadIdType
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorBadIdType() (ErrorBadRequestCustomizationValidationErrorBadIdType, error) {
	var body ErrorBadRequestCustomizationValidationErrorBadIdType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorBadIdType overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorBadIdType
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorBadIdType(v ErrorBadRequestCustomizationValidationErrorBadIdType) error {
	t.Subtype = "bad_id_type"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorBadIdType performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorBadIdType
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorBadIdType(v ErrorBadRequestCustomizationValidationErrorBadIdType) error {
	t.Subtype = "bad_id_type"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorDateParseError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorDateParseError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorDateParseError() (ErrorBadRequestCustomizationValidationErrorDateParseError, error) {
	var body ErrorBadRequestCustomizationValidationErrorDateParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorDateParseError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorDateParseError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorDateParseError(v ErrorBadRequestCustomizationValidationErrorDateParseError) error {
	t.Subtype = "date_parse_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorDateParseError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorDateParseError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorDateParseError(v ErrorBadRequestCustomizationValidationErrorDateParseError) error {
	t.Subtype = "date_parse_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorEnumOutOfRange returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorEnumOutOfRange
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorEnumOutOfRange() (ErrorBadRequestCustomizationValidationErrorEnumOutOfRange, error) {
	var body ErrorBadRequestCustomizationValidationErrorEnumOutOfRange
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorEnumOutOfRange overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorEnumOutOfRange
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorEnumOutOfRange(v ErrorBadRequestCustomizationValidationErrorEnumOutOfRange) error {
	t.Subtype = "enum_out_of_range"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorEnumOutOfRange performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorEnumOutOfRange
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorEnumOutOfRange(v ErrorBadRequestCustomizationValidationErrorEnumOutOfRange) error {
	t.Subtype = "enum_out_of_range"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorExpressionParseError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorExpressionParseError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorExpressionParseError() (ErrorBadRequestCustomizationValidationErrorExpressionParseError, error) {
	var body ErrorBadRequestCustomizationValidationErrorExpressionParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorExpressionParseError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorExpressionParseError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorExpressionParseError(v ErrorBadRequestCustomizationValidationErrorExpressionParseError) error {
	t.Subtype = "expression_parse_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorExpressionParseError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorExpressionParseError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorExpressionParseError(v ErrorBadRequestCustomizationValidationErrorExpressionParseError) error {
	t.Subtype = "expression_parse_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFieldDropped returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFieldDropped
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFieldDropped() (ErrorBadRequestCustomizationValidationErrorFieldDropped, error) {
	var body ErrorBadRequestCustomizationValidationErrorFieldDropped
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFieldDropped overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFieldDropped
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFieldDropped(v ErrorBadRequestCustomizationValidationErrorFieldDropped) error {
	t.Subtype = "field_dropped"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFieldDropped performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFieldDropped
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFieldDropped(v ErrorBadRequestCustomizationValidationErrorFieldDropped) error {
	t.Subtype = "field_dropped"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFieldImmutable returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFieldImmutable
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFieldImmutable() (ErrorBadRequestCustomizationValidationErrorFieldImmutable, error) {
	var body ErrorBadRequestCustomizationValidationErrorFieldImmutable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFieldImmutable overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFieldImmutable
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFieldImmutable(v ErrorBadRequestCustomizationValidationErrorFieldImmutable) error {
	t.Subtype = "field_immutable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFieldImmutable performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFieldImmutable
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFieldImmutable(v ErrorBadRequestCustomizationValidationErrorFieldImmutable) error {
	t.Subtype = "field_immutable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFieldNotInSchema returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFieldNotInSchema
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFieldNotInSchema() (ErrorBadRequestCustomizationValidationErrorFieldNotInSchema, error) {
	var body ErrorBadRequestCustomizationValidationErrorFieldNotInSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFieldNotInSchema overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFieldNotInSchema
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFieldNotInSchema(v ErrorBadRequestCustomizationValidationErrorFieldNotInSchema) error {
	t.Subtype = "field_not_in_schema"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFieldNotInSchema performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFieldNotInSchema
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFieldNotInSchema(v ErrorBadRequestCustomizationValidationErrorFieldNotInSchema) error {
	t.Subtype = "field_not_in_schema"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFieldRequired returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFieldRequired
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFieldRequired() (ErrorBadRequestCustomizationValidationErrorFieldRequired, error) {
	var body ErrorBadRequestCustomizationValidationErrorFieldRequired
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFieldRequired overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFieldRequired
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFieldRequired(v ErrorBadRequestCustomizationValidationErrorFieldRequired) error {
	t.Subtype = "field_required"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFieldRequired performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFieldRequired
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFieldRequired(v ErrorBadRequestCustomizationValidationErrorFieldRequired) error {
	t.Subtype = "field_required"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFragmentNotFound returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFragmentNotFound
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFragmentNotFound() (ErrorBadRequestCustomizationValidationErrorFragmentNotFound, error) {
	var body ErrorBadRequestCustomizationValidationErrorFragmentNotFound
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFragmentNotFound overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFragmentNotFound
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFragmentNotFound(v ErrorBadRequestCustomizationValidationErrorFragmentNotFound) error {
	t.Subtype = "fragment_not_found"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFragmentNotFound performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFragmentNotFound
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFragmentNotFound(v ErrorBadRequestCustomizationValidationErrorFragmentNotFound) error {
	t.Subtype = "fragment_not_found"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorIdParseError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorIdParseError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorIdParseError() (ErrorBadRequestCustomizationValidationErrorIdParseError, error) {
	var body ErrorBadRequestCustomizationValidationErrorIdParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorIdParseError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorIdParseError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorIdParseError(v ErrorBadRequestCustomizationValidationErrorIdParseError) error {
	t.Subtype = "id_parse_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorIdParseError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorIdParseError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorIdParseError(v ErrorBadRequestCustomizationValidationErrorIdParseError) error {
	t.Subtype = "id_parse_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed() (ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed, error) {
	var body ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed(v ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed) error {
	t.Subtype = "id_type_not_allowed"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed(v ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed) error {
	t.Subtype = "id_type_not_allowed"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorInvalidArgument returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorInvalidArgument
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorInvalidArgument() (ErrorBadRequestCustomizationValidationErrorInvalidArgument, error) {
	var body ErrorBadRequestCustomizationValidationErrorInvalidArgument
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorInvalidArgument overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorInvalidArgument
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorInvalidArgument(v ErrorBadRequestCustomizationValidationErrorInvalidArgument) error {
	t.Subtype = "invalid_argument"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorInvalidArgument performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorInvalidArgument
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorInvalidArgument(v ErrorBadRequestCustomizationValidationErrorInvalidArgument) error {
	t.Subtype = "invalid_argument"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorTimestampParseError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorTimestampParseError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorTimestampParseError() (ErrorBadRequestCustomizationValidationErrorTimestampParseError, error) {
	var body ErrorBadRequestCustomizationValidationErrorTimestampParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorTimestampParseError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorTimestampParseError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorTimestampParseError(v ErrorBadRequestCustomizationValidationErrorTimestampParseError) error {
	t.Subtype = "timestamp_parse_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorTimestampParseError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorTimestampParseError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorTimestampParseError(v ErrorBadRequestCustomizationValidationErrorTimestampParseError) error {
	t.Subtype = "timestamp_parse_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorUnknownError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorUnknownError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorUnknownError() (ErrorBadRequestCustomizationValidationErrorUnknownError, error) {
	var body ErrorBadRequestCustomizationValidationErrorUnknownError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorUnknownError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorUnknownError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorUnknownError(v ErrorBadRequestCustomizationValidationErrorUnknownError) error {
	t.Subtype = "unknown_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorUnknownError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorUnknownError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorUnknownError(v ErrorBadRequestCustomizationValidationErrorUnknownError) error {
	t.Subtype = "unknown_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorUnsupportedType returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorUnsupportedType
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorUnsupportedType() (ErrorBadRequestCustomizationValidationErrorUnsupportedType, error) {
	var body ErrorBadRequestCustomizationValidationErrorUnsupportedType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorUnsupportedType overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorUnsupportedType
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorUnsupportedType(v ErrorBadRequestCustomizationValidationErrorUnsupportedType) error {
	t.Subtype = "unsupported_type"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorUnsupportedType performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorUnsupportedType
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorUnsupportedType(v ErrorBadRequestCustomizationValidationErrorUnsupportedType) error {
	t.Subtype = "unsupported_type"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorWrongType returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorWrongType
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorWrongType() (ErrorBadRequestCustomizationValidationErrorWrongType, error) {
	var body ErrorBadRequestCustomizationValidationErrorWrongType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorWrongType overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorWrongType
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorWrongType(v ErrorBadRequestCustomizationValidationErrorWrongType) error {
	t.Subtype = "wrong_type"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorWrongType performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorWrongType
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorWrongType(v ErrorBadRequestCustomizationValidationErrorWrongType) error {
	t.Subtype = "wrong_type"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorBadRequestCustomizationValidationError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"subtype"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ErrorBadRequestCustomizationValidationError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "bad_id_type":
		return t.AsErrorBadRequestCustomizationValidationErrorBadIdType()
	case "date_parse_error":
		return t.AsErrorBadRequestCustomizationValidationErrorDateParseError()
	case "enum_out_of_range":
		return t.AsErrorBadRequestCustomizationValidationErrorEnumOutOfRange()
	case "expression_parse_error":
		return t.AsErrorBadRequestCustomizationValidationErrorExpressionParseError()
	case "field_dropped":
		return t.AsErrorBadRequestCustomizationValidationErrorFieldDropped()
	case "field_immutable":
		return t.AsErrorBadRequestCustomizationValidationErrorFieldImmutable()
	case "field_not_in_schema":
		return t.AsErrorBadRequestCustomizationValidationErrorFieldNotInSchema()
	case "field_required":
		return t.AsErrorBadRequestCustomizationValidationErrorFieldRequired()
	case "fragment_not_found":
		return t.AsErrorBadRequestCustomizationValidationErrorFragmentNotFound()
	case "id_parse_error":
		return t.AsErrorBadRequestCustomizationValidationErrorIdParseError()
	case "id_type_not_allowed":
		return t.AsErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed()
	case "invalid_argument":
		return t.AsErrorBadRequestCustomizationValidationErrorInvalidArgument()
	case "timestamp_parse_error":
		return t.AsErrorBadRequestCustomizationValidationErrorTimestampParseError()
	case "unknown_error":
		return t.AsErrorBadRequestCustomizationValidationErrorUnknownError()
	case "unsupported_type":
		return t.AsErrorBadRequestCustomizationValidationErrorUnsupportedType()
	case "wrong_type":
		return t.AsErrorBadRequestCustomizationValidationErrorWrongType()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ErrorBadRequestCustomizationValidationError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.FieldName != nil {
		object["field_name"], err = json.Marshal(t.FieldName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'field_name': %w", err)
		}
	}

	if t.Reason != nil {
		object["reason"], err = json.Marshal(t.Reason)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reason': %w", err)
		}
	}

	object["subtype"], err = json.Marshal(t.Subtype)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'subtype': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorBadRequestCustomizationValidationError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["field_name"]; found {
		err = json.Unmarshal(raw, &t.FieldName)
		if err != nil {
			return fmt.Errorf("error reading 'field_name': %w", err)
		}
	}

	if raw, found := object["reason"]; found {
		err = json.Unmarshal(raw, &t.Reason)
		if err != nil {
			return fmt.Errorf("error reading 'reason': %w", err)
		}
	}

	if raw, found := object["subtype"]; found {
		err = json.Unmarshal(raw, &t.Subtype)
		if err != nil {
			return fmt.Errorf("error reading 'subtype': %w", err)
		}
	}

	return err
}

// AsErrorConflictConflict returns the union data inside the ErrorConflict as a ErrorConflictConflict
func (t ErrorConflict) AsErrorConflictConflict() (ErrorConflictConflict, error) {
	var body ErrorConflictConflict
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorConflictConflict overwrites any union data inside the ErrorConflict as the provided ErrorConflictConflict
func (t *ErrorConflict) FromErrorConflictConflict(v ErrorConflictConflict) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorConflictConflict performs a merge with any union data inside the ErrorConflict, using the provided ErrorConflictConflict
func (t *ErrorConflict) MergeErrorConflictConflict(v ErrorConflictConflict) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorConflict) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorConflict) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorForbiddenForbidden returns the union data inside the ErrorForbidden as a ErrorForbiddenForbidden
func (t ErrorForbidden) AsErrorForbiddenForbidden() (ErrorForbiddenForbidden, error) {
	var body ErrorForbiddenForbidden
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorForbiddenForbidden overwrites any union data inside the ErrorForbidden as the provided ErrorForbiddenForbidden
func (t *ErrorForbidden) FromErrorForbiddenForbidden(v ErrorForbiddenForbidden) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorForbiddenForbidden performs a merge with any union data inside the ErrorForbidden, using the provided ErrorForbiddenForbidden
func (t *ErrorForbidden) MergeErrorForbiddenForbidden(v ErrorForbiddenForbidden) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorForbidden) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorForbidden) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorInternalServerErrorInternalError returns the union data inside the ErrorInternalServerError as a ErrorInternalServerErrorInternalError
func (t ErrorInternalServerError) AsErrorInternalServerErrorInternalError() (ErrorInternalServerErrorInternalError, error) {
	var body ErrorInternalServerErrorInternalError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorInternalServerErrorInternalError overwrites any union data inside the ErrorInternalServerError as the provided ErrorInternalServerErrorInternalError
func (t *ErrorInternalServerError) FromErrorInternalServerErrorInternalError(v ErrorInternalServerErrorInternalError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorInternalServerErrorInternalError performs a merge with any union data inside the ErrorInternalServerError, using the provided ErrorInternalServerErrorInternalError
func (t *ErrorInternalServerError) MergeErrorInternalServerErrorInternalError(v ErrorInternalServerErrorInternalError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorInternalServerError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	if t.ReferenceId != nil {
		object["reference_id"], err = json.Marshal(t.ReferenceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reference_id': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorInternalServerError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["reference_id"]; found {
		err = json.Unmarshal(raw, &t.ReferenceId)
		if err != nil {
			return fmt.Errorf("error reading 'reference_id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorNotFoundNotFound returns the union data inside the ErrorNotFound as a ErrorNotFoundNotFound
func (t ErrorNotFound) AsErrorNotFoundNotFound() (ErrorNotFoundNotFound, error) {
	var body ErrorNotFoundNotFound
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorNotFoundNotFound overwrites any union data inside the ErrorNotFound as the provided ErrorNotFoundNotFound
func (t *ErrorNotFound) FromErrorNotFoundNotFound(v ErrorNotFoundNotFound) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorNotFoundNotFound performs a merge with any union data inside the ErrorNotFound, using the provided ErrorNotFoundNotFound
func (t *ErrorNotFound) MergeErrorNotFoundNotFound(v ErrorNotFoundNotFound) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorNotFound) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorNotFound) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorServiceUnavailableServiceUnavailable returns the union data inside the ErrorServiceUnavailable as a ErrorServiceUnavailableServiceUnavailable
func (t ErrorServiceUnavailable) AsErrorServiceUnavailableServiceUnavailable() (ErrorServiceUnavailableServiceUnavailable, error) {
	var body ErrorServiceUnavailableServiceUnavailable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorServiceUnavailableServiceUnavailable overwrites any union data inside the ErrorServiceUnavailable as the provided ErrorServiceUnavailableServiceUnavailable
func (t *ErrorServiceUnavailable) FromErrorServiceUnavailableServiceUnavailable(v ErrorServiceUnavailableServiceUnavailable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorServiceUnavailableServiceUnavailable performs a merge with any union data inside the ErrorServiceUnavailable, using the provided ErrorServiceUnavailableServiceUnavailable
func (t *ErrorServiceUnavailable) MergeErrorServiceUnavailableServiceUnavailable(v ErrorServiceUnavailableServiceUnavailable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorServiceUnavailable) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorServiceUnavailable) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorTooManyRequestsTooManyRequests returns the union data inside the ErrorTooManyRequests as a ErrorTooManyRequestsTooManyRequests
func (t ErrorTooManyRequests) AsErrorTooManyRequestsTooManyRequests() (ErrorTooManyRequestsTooManyRequests, error) {
	var body ErrorTooManyRequestsTooManyRequests
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorTooManyRequestsTooManyRequests overwrites any union data inside the ErrorTooManyRequests as the provided ErrorTooManyRequestsTooManyRequests
func (t *ErrorTooManyRequests) FromErrorTooManyRequestsTooManyRequests(v ErrorTooManyRequestsTooManyRequests) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorTooManyRequestsTooManyRequests performs a merge with any union data inside the ErrorTooManyRequests, using the provided ErrorTooManyRequestsTooManyRequests
func (t *ErrorTooManyRequests) MergeErrorTooManyRequestsTooManyRequests(v ErrorTooManyRequestsTooManyRequests) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorTooManyRequests) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	if t.RetryAfter != nil {
		object["retry_after"], err = json.Marshal(t.RetryAfter)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'retry_after': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorTooManyRequests) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["retry_after"]; found {
		err = json.Unmarshal(raw, &t.RetryAfter)
		if err != nil {
			return fmt.Errorf("error reading 'retry_after': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorUnauthorizedUnauthenticated returns the union data inside the ErrorUnauthorized as a ErrorUnauthorizedUnauthenticated
func (t ErrorUnauthorized) AsErrorUnauthorizedUnauthenticated() (ErrorUnauthorizedUnauthenticated, error) {
	var body ErrorUnauthorizedUnauthenticated
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorUnauthorizedUnauthenticated overwrites any union data inside the ErrorUnauthorized as the provided ErrorUnauthorizedUnauthenticated
func (t *ErrorUnauthorized) FromErrorUnauthorizedUnauthenticated(v ErrorUnauthorizedUnauthenticated) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorUnauthorizedUnauthenticated performs a merge with any union data inside the ErrorUnauthorized, using the provided ErrorUnauthorizedUnauthenticated
func (t *ErrorUnauthorized) MergeErrorUnauthorizedUnauthenticated(v ErrorUnauthorizedUnauthenticated) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorUnauthorized) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorUnauthorized) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsEmpty returns the union data inside the EventSlaTrackerFetched as a Empty
func (t EventSlaTrackerFetched) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the EventSlaTrackerFetched as the provided Empty
func (t *EventSlaTrackerFetched) FromEmpty(v Empty) error {
	t.Result = "forbidden"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the EventSlaTrackerFetched, using the provided Empty
func (t *EventSlaTrackerFetched) MergeEmpty(v Empty) error {
	t.Result = "forbidden"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEventSlaTrackerFetchedOk returns the union data inside the EventSlaTrackerFetched as a EventSlaTrackerFetchedOk
func (t EventSlaTrackerFetched) AsEventSlaTrackerFetchedOk() (EventSlaTrackerFetchedOk, error) {
	var body EventSlaTrackerFetchedOk
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEventSlaTrackerFetchedOk overwrites any union data inside the EventSlaTrackerFetched as the provided EventSlaTrackerFetchedOk
func (t *EventSlaTrackerFetched) FromEventSlaTrackerFetchedOk(v EventSlaTrackerFetchedOk) error {
	t.Result = "ok"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEventSlaTrackerFetchedOk performs a merge with any union data inside the EventSlaTrackerFetched, using the provided EventSlaTrackerFetchedOk
func (t *EventSlaTrackerFetched) MergeEventSlaTrackerFetchedOk(v EventSlaTrackerFetchedOk) error {
	t.Result = "ok"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EventSlaTrackerFetched) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"result"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EventSlaTrackerFetched) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "forbidden":
		return t.AsEmpty()
	case "ok":
		return t.AsEventSlaTrackerFetchedOk()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EventSlaTrackerFetched) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["result"], err = json.Marshal(t.Result)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'result': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *EventSlaTrackerFetched) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["result"]; found {
		err = json.Unmarshal(raw, &t.Result)
		if err != nil {
			return fmt.Errorf("error reading 'result': %w", err)
		}
	}

	return err
}

// AsEmpty returns the union data inside the EventWorkFetched as a Empty
func (t EventWorkFetched) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the EventWorkFetched as the provided Empty
func (t *EventWorkFetched) FromEmpty(v Empty) error {
	t.Result = "forbidden"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the EventWorkFetched, using the provided Empty
func (t *EventWorkFetched) MergeEmpty(v Empty) error {
	t.Result = "forbidden"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEventWorkFetchedOk returns the union data inside the EventWorkFetched as a EventWorkFetchedOk
func (t EventWorkFetched) AsEventWorkFetchedOk() (EventWorkFetchedOk, error) {
	var body EventWorkFetchedOk
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEventWorkFetchedOk overwrites any union data inside the EventWorkFetched as the provided EventWorkFetchedOk
func (t *EventWorkFetched) FromEventWorkFetchedOk(v EventWorkFetchedOk) error {
	t.Result = "ok"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEventWorkFetchedOk performs a merge with any union data inside the EventWorkFetched, using the provided EventWorkFetchedOk
func (t *EventWorkFetched) MergeEventWorkFetchedOk(v EventWorkFetchedOk) error {
	t.Result = "ok"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EventWorkFetched) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"result"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EventWorkFetched) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "forbidden":
		return t.AsEmpty()
	case "ok":
		return t.AsEventWorkFetchedOk()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EventWorkFetched) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["result"], err = json.Marshal(t.Result)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'result': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *EventWorkFetched) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["result"]; found {
		err = json.Unmarshal(raw, &t.Result)
		if err != nil {
			return fmt.Errorf("error reading 'result': %w", err)
		}
	}

	return err
}

// AsCapabilitySummary returns the union data inside the LinkEndpointSummary as a CapabilitySummary
func (t LinkEndpointSummary) AsCapabilitySummary() (CapabilitySummary, error) {
	var body CapabilitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapabilitySummary overwrites any union data inside the LinkEndpointSummary as the provided CapabilitySummary
func (t *LinkEndpointSummary) FromCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapabilitySummary performs a merge with any union data inside the LinkEndpointSummary, using the provided CapabilitySummary
func (t *LinkEndpointSummary) MergeCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConversationSummary returns the union data inside the LinkEndpointSummary as a ConversationSummary
func (t LinkEndpointSummary) AsConversationSummary() (ConversationSummary, error) {
	var body ConversationSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConversationSummary overwrites any union data inside the LinkEndpointSummary as the provided ConversationSummary
func (t *LinkEndpointSummary) FromConversationSummary(v ConversationSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConversationSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided ConversationSummary
func (t *LinkEndpointSummary) MergeConversationSummary(v ConversationSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevUserSummary returns the union data inside the LinkEndpointSummary as a DevUserSummary
func (t LinkEndpointSummary) AsDevUserSummary() (DevUserSummary, error) {
	var body DevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUserSummary overwrites any union data inside the LinkEndpointSummary as the provided DevUserSummary
func (t *LinkEndpointSummary) FromDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUserSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided DevUserSummary
func (t *LinkEndpointSummary) MergeDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancementSummary returns the union data inside the LinkEndpointSummary as a EnhancementSummary
func (t LinkEndpointSummary) AsEnhancementSummary() (EnhancementSummary, error) {
	var body EnhancementSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancementSummary overwrites any union data inside the LinkEndpointSummary as the provided EnhancementSummary
func (t *LinkEndpointSummary) FromEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancementSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided EnhancementSummary
func (t *LinkEndpointSummary) MergeEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeatureSummary returns the union data inside the LinkEndpointSummary as a FeatureSummary
func (t LinkEndpointSummary) AsFeatureSummary() (FeatureSummary, error) {
	var body FeatureSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeatureSummary overwrites any union data inside the LinkEndpointSummary as the provided FeatureSummary
func (t *LinkEndpointSummary) FromFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeatureSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided FeatureSummary
func (t *LinkEndpointSummary) MergeFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueSummary returns the union data inside the LinkEndpointSummary as a IssueSummary
func (t LinkEndpointSummary) AsIssueSummary() (IssueSummary, error) {
	var body IssueSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueSummary overwrites any union data inside the LinkEndpointSummary as the provided IssueSummary
func (t *LinkEndpointSummary) FromIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided IssueSummary
func (t *LinkEndpointSummary) MergeIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProductSummary returns the union data inside the LinkEndpointSummary as a ProductSummary
func (t LinkEndpointSummary) AsProductSummary() (ProductSummary, error) {
	var body ProductSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProductSummary overwrites any union data inside the LinkEndpointSummary as the provided ProductSummary
func (t *LinkEndpointSummary) FromProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProductSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided ProductSummary
func (t *LinkEndpointSummary) MergeProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevOrgSummary returns the union data inside the LinkEndpointSummary as a RevOrgSummary
func (t LinkEndpointSummary) AsRevOrgSummary() (RevOrgSummary, error) {
	var body RevOrgSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevOrgSummary overwrites any union data inside the LinkEndpointSummary as the provided RevOrgSummary
func (t *LinkEndpointSummary) FromRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevOrgSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided RevOrgSummary
func (t *LinkEndpointSummary) MergeRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUserSummary returns the union data inside the LinkEndpointSummary as a RevUserSummary
func (t LinkEndpointSummary) AsRevUserSummary() (RevUserSummary, error) {
	var body RevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUserSummary overwrites any union data inside the LinkEndpointSummary as the provided RevUserSummary
func (t *LinkEndpointSummary) FromRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUserSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided RevUserSummary
func (t *LinkEndpointSummary) MergeRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTicketSummary returns the union data inside the LinkEndpointSummary as a TicketSummary
func (t LinkEndpointSummary) AsTicketSummary() (TicketSummary, error) {
	var body TicketSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTicketSummary overwrites any union data inside the LinkEndpointSummary as the provided TicketSummary
func (t *LinkEndpointSummary) FromTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTicketSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided TicketSummary
func (t *LinkEndpointSummary) MergeTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LinkEndpointSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t LinkEndpointSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capability":
		return t.AsCapabilitySummary()
	case "conversation":
		return t.AsConversationSummary()
	case "dev_user":
		return t.AsDevUserSummary()
	case "enhancement":
		return t.AsEnhancementSummary()
	case "feature":
		return t.AsFeatureSummary()
	case "issue":
		return t.AsIssueSummary()
	case "product":
		return t.AsProductSummary()
	case "rev_org":
		return t.AsRevOrgSummary()
	case "rev_user":
		return t.AsRevUserSummary()
	case "ticket":
		return t.AsTicketSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t LinkEndpointSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *LinkEndpointSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDevUserSummary returns the union data inside the MemberSummary as a DevUserSummary
func (t MemberSummary) AsDevUserSummary() (DevUserSummary, error) {
	var body DevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUserSummary overwrites any union data inside the MemberSummary as the provided DevUserSummary
func (t *MemberSummary) FromDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUserSummary performs a merge with any union data inside the MemberSummary, using the provided DevUserSummary
func (t *MemberSummary) MergeDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroupSummary returns the union data inside the MemberSummary as a GroupSummary
func (t MemberSummary) AsGroupSummary() (GroupSummary, error) {
	var body GroupSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroupSummary overwrites any union data inside the MemberSummary as the provided GroupSummary
func (t *MemberSummary) FromGroupSummary(v GroupSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroupSummary performs a merge with any union data inside the MemberSummary, using the provided GroupSummary
func (t *MemberSummary) MergeGroupSummary(v GroupSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUserSummary returns the union data inside the MemberSummary as a RevUserSummary
func (t MemberSummary) AsRevUserSummary() (RevUserSummary, error) {
	var body RevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUserSummary overwrites any union data inside the MemberSummary as the provided RevUserSummary
func (t *MemberSummary) FromRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUserSummary performs a merge with any union data inside the MemberSummary, using the provided RevUserSummary
func (t *MemberSummary) MergeRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSysUserSummary returns the union data inside the MemberSummary as a SysUserSummary
func (t MemberSummary) AsSysUserSummary() (SysUserSummary, error) {
	var body SysUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSysUserSummary overwrites any union data inside the MemberSummary as the provided SysUserSummary
func (t *MemberSummary) FromSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSysUserSummary performs a merge with any union data inside the MemberSummary, using the provided SysUserSummary
func (t *MemberSummary) MergeSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MemberSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MemberSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dev_user":
		return t.AsDevUserSummary()
	case "group":
		return t.AsGroupSummary()
	case "rev_user":
		return t.AsRevUserSummary()
	case "sys_user":
		return t.AsSysUserSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MemberSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *MemberSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsRevOrgSummary returns the union data inside the OrgSummary as a RevOrgSummary
func (t OrgSummary) AsRevOrgSummary() (RevOrgSummary, error) {
	var body RevOrgSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevOrgSummary overwrites any union data inside the OrgSummary as the provided RevOrgSummary
func (t *OrgSummary) FromRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevOrgSummary performs a merge with any union data inside the OrgSummary, using the provided RevOrgSummary
func (t *OrgSummary) MergeRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrgSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OrgSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "rev_org":
		return t.AsRevOrgSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OrgSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *OrgSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsCapability returns the union data inside the Part as a Capability
func (t Part) AsCapability() (Capability, error) {
	var body Capability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapability overwrites any union data inside the Part as the provided Capability
func (t *Part) FromCapability(v Capability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapability performs a merge with any union data inside the Part, using the provided Capability
func (t *Part) MergeCapability(v Capability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancement returns the union data inside the Part as a Enhancement
func (t Part) AsEnhancement() (Enhancement, error) {
	var body Enhancement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancement overwrites any union data inside the Part as the provided Enhancement
func (t *Part) FromEnhancement(v Enhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancement performs a merge with any union data inside the Part, using the provided Enhancement
func (t *Part) MergeEnhancement(v Enhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeature returns the union data inside the Part as a Feature
func (t Part) AsFeature() (Feature, error) {
	var body Feature
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeature overwrites any union data inside the Part as the provided Feature
func (t *Part) FromFeature(v Feature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeature performs a merge with any union data inside the Part, using the provided Feature
func (t *Part) MergeFeature(v Feature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProduct returns the union data inside the Part as a Product
func (t Part) AsProduct() (Product, error) {
	var body Product
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProduct overwrites any union data inside the Part as the provided Product
func (t *Part) FromProduct(v Product) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProduct performs a merge with any union data inside the Part, using the provided Product
func (t *Part) MergeProduct(v Product) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Part) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Part) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capability":
		return t.AsCapability()
	case "enhancement":
		return t.AsEnhancement()
	case "feature":
		return t.AsFeature()
	case "product":
		return t.AsProduct()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Part) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Part) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsCapabilitySummary returns the union data inside the PartSummary as a CapabilitySummary
func (t PartSummary) AsCapabilitySummary() (CapabilitySummary, error) {
	var body CapabilitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapabilitySummary overwrites any union data inside the PartSummary as the provided CapabilitySummary
func (t *PartSummary) FromCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapabilitySummary performs a merge with any union data inside the PartSummary, using the provided CapabilitySummary
func (t *PartSummary) MergeCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancementSummary returns the union data inside the PartSummary as a EnhancementSummary
func (t PartSummary) AsEnhancementSummary() (EnhancementSummary, error) {
	var body EnhancementSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancementSummary overwrites any union data inside the PartSummary as the provided EnhancementSummary
func (t *PartSummary) FromEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancementSummary performs a merge with any union data inside the PartSummary, using the provided EnhancementSummary
func (t *PartSummary) MergeEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeatureSummary returns the union data inside the PartSummary as a FeatureSummary
func (t PartSummary) AsFeatureSummary() (FeatureSummary, error) {
	var body FeatureSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeatureSummary overwrites any union data inside the PartSummary as the provided FeatureSummary
func (t *PartSummary) FromFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeatureSummary performs a merge with any union data inside the PartSummary, using the provided FeatureSummary
func (t *PartSummary) MergeFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProductSummary returns the union data inside the PartSummary as a ProductSummary
func (t PartSummary) AsProductSummary() (ProductSummary, error) {
	var body ProductSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProductSummary overwrites any union data inside the PartSummary as the provided ProductSummary
func (t *PartSummary) FromProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProductSummary performs a merge with any union data inside the PartSummary, using the provided ProductSummary
func (t *PartSummary) MergeProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PartSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PartSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capability":
		return t.AsCapabilitySummary()
	case "enhancement":
		return t.AsEnhancementSummary()
	case "feature":
		return t.AsFeatureSummary()
	case "product":
		return t.AsProductSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PartSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *PartSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsPartsCreateRequestCapability returns the union data inside the PartsCreateRequest as a PartsCreateRequestCapability
func (t PartsCreateRequest) AsPartsCreateRequestCapability() (PartsCreateRequestCapability, error) {
	var body PartsCreateRequestCapability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestCapability overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestCapability
func (t *PartsCreateRequest) FromPartsCreateRequestCapability(v PartsCreateRequestCapability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestCapability performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestCapability
func (t *PartsCreateRequest) MergePartsCreateRequestCapability(v PartsCreateRequestCapability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsCreateRequestEnhancement returns the union data inside the PartsCreateRequest as a PartsCreateRequestEnhancement
func (t PartsCreateRequest) AsPartsCreateRequestEnhancement() (PartsCreateRequestEnhancement, error) {
	var body PartsCreateRequestEnhancement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestEnhancement overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestEnhancement
func (t *PartsCreateRequest) FromPartsCreateRequestEnhancement(v PartsCreateRequestEnhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestEnhancement performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestEnhancement
func (t *PartsCreateRequest) MergePartsCreateRequestEnhancement(v PartsCreateRequestEnhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsCreateRequestFeature returns the union data inside the PartsCreateRequest as a PartsCreateRequestFeature
func (t PartsCreateRequest) AsPartsCreateRequestFeature() (PartsCreateRequestFeature, error) {
	var body PartsCreateRequestFeature
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestFeature overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestFeature
func (t *PartsCreateRequest) FromPartsCreateRequestFeature(v PartsCreateRequestFeature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestFeature performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestFeature
func (t *PartsCreateRequest) MergePartsCreateRequestFeature(v PartsCreateRequestFeature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsCreateRequestProduct returns the union data inside the PartsCreateRequest as a PartsCreateRequestProduct
func (t PartsCreateRequest) AsPartsCreateRequestProduct() (PartsCreateRequestProduct, error) {
	var body PartsCreateRequestProduct
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestProduct overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestProduct
func (t *PartsCreateRequest) FromPartsCreateRequestProduct(v PartsCreateRequestProduct) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestProduct performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestProduct
func (t *PartsCreateRequest) MergePartsCreateRequestProduct(v PartsCreateRequestProduct) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PartsCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PartsCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capability":
		return t.AsPartsCreateRequestCapability()
	case "enhancement":
		return t.AsPartsCreateRequestEnhancement()
	case "feature":
		return t.AsPartsCreateRequestFeature()
	case "product":
		return t.AsPartsCreateRequestProduct()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PartsCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Artifacts != nil {
		object["artifacts"], err = json.Marshal(t.Artifacts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artifacts': %w", err)
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["owned_by"], err = json.Marshal(t.OwnedBy)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'owned_by': %w", err)
	}

	if t.Tags != nil {
		object["tags"], err = json.Marshal(t.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *PartsCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["artifacts"]; found {
		err = json.Unmarshal(raw, &t.Artifacts)
		if err != nil {
			return fmt.Errorf("error reading 'artifacts': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["owned_by"]; found {
		err = json.Unmarshal(raw, &t.OwnedBy)
		if err != nil {
			return fmt.Errorf("error reading 'owned_by': %w", err)
		}
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &t.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsEmpty returns the union data inside the PartsUpdateRequest as a Empty
func (t PartsUpdateRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the PartsUpdateRequest as the provided Empty
func (t *PartsUpdateRequest) FromEmpty(v Empty) error {
	t.Type = func() *PartType { v := PartType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the PartsUpdateRequest, using the provided Empty
func (t *PartsUpdateRequest) MergeEmpty(v Empty) error {
	t.Type = func() *PartType { v := PartType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestCapability returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestCapability
func (t PartsUpdateRequest) AsPartsUpdateRequestCapability() (PartsUpdateRequestCapability, error) {
	var body PartsUpdateRequestCapability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestCapability overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestCapability
func (t *PartsUpdateRequest) FromPartsUpdateRequestCapability(v PartsUpdateRequestCapability) error {
	t.Type = func() *PartType { v := PartType("capability"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestCapability performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestCapability
func (t *PartsUpdateRequest) MergePartsUpdateRequestCapability(v PartsUpdateRequestCapability) error {
	t.Type = func() *PartType { v := PartType("capability"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestEnhancement returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestEnhancement
func (t PartsUpdateRequest) AsPartsUpdateRequestEnhancement() (PartsUpdateRequestEnhancement, error) {
	var body PartsUpdateRequestEnhancement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestEnhancement overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestEnhancement
func (t *PartsUpdateRequest) FromPartsUpdateRequestEnhancement(v PartsUpdateRequestEnhancement) error {
	t.Type = func() *PartType { v := PartType("enhancement"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestEnhancement performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestEnhancement
func (t *PartsUpdateRequest) MergePartsUpdateRequestEnhancement(v PartsUpdateRequestEnhancement) error {
	t.Type = func() *PartType { v := PartType("enhancement"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestFeature returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestFeature
func (t PartsUpdateRequest) AsPartsUpdateRequestFeature() (PartsUpdateRequestFeature, error) {
	var body PartsUpdateRequestFeature
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestFeature overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestFeature
func (t *PartsUpdateRequest) FromPartsUpdateRequestFeature(v PartsUpdateRequestFeature) error {
	t.Type = func() *PartType { v := PartType("feature"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestFeature performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestFeature
func (t *PartsUpdateRequest) MergePartsUpdateRequestFeature(v PartsUpdateRequestFeature) error {
	t.Type = func() *PartType { v := PartType("feature"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestProduct returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestProduct
func (t PartsUpdateRequest) AsPartsUpdateRequestProduct() (PartsUpdateRequestProduct, error) {
	var body PartsUpdateRequestProduct
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestProduct overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestProduct
func (t *PartsUpdateRequest) FromPartsUpdateRequestProduct(v PartsUpdateRequestProduct) error {
	t.Type = func() *PartType { v := PartType("product"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestProduct performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestProduct
func (t *PartsUpdateRequest) MergePartsUpdateRequestProduct(v PartsUpdateRequestProduct) error {
	t.Type = func() *PartType { v := PartType("product"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PartsUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PartsUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capability":
		return t.AsPartsUpdateRequestCapability()
	case "enhancement":
		return t.AsPartsUpdateRequestEnhancement()
	case "feature":
		return t.AsPartsUpdateRequestFeature()
	case "none":
		return t.AsEmpty()
	case "product":
		return t.AsPartsUpdateRequestProduct()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PartsUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Artifacts != nil {
		object["artifacts"], err = json.Marshal(t.Artifacts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artifacts': %w", err)
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Name != nil {
		object["name"], err = json.Marshal(t.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if t.OwnedBy != nil {
		object["owned_by"], err = json.Marshal(t.OwnedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owned_by': %w", err)
		}
	}

	if t.Tags != nil {
		object["tags"], err = json.Marshal(t.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *PartsUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["artifacts"]; found {
		err = json.Unmarshal(raw, &t.Artifacts)
		if err != nil {
			return fmt.Errorf("error reading 'artifacts': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["owned_by"]; found {
		err = json.Unmarshal(raw, &t.OwnedBy)
		if err != nil {
			return fmt.Errorf("error reading 'owned_by': %w", err)
		}
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &t.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsSchemaBoolFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaBoolFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaBoolFieldDescriptor() (SchemaBoolFieldDescriptor, error) {
	var body SchemaBoolFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaBoolFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaBoolFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaBoolFieldDescriptor(v SchemaBoolFieldDescriptor) error {
	t.FieldType = "bool"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaBoolFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaBoolFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaBoolFieldDescriptor(v SchemaBoolFieldDescriptor) error {
	t.FieldType = "bool"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaCompositeFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaCompositeFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaCompositeFieldDescriptor() (SchemaCompositeFieldDescriptor, error) {
	var body SchemaCompositeFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaCompositeFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaCompositeFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaCompositeFieldDescriptor(v SchemaCompositeFieldDescriptor) error {
	t.FieldType = "composite"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaCompositeFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaCompositeFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaCompositeFieldDescriptor(v SchemaCompositeFieldDescriptor) error {
	t.FieldType = "composite"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaDateFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaDateFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaDateFieldDescriptor() (SchemaDateFieldDescriptor, error) {
	var body SchemaDateFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaDateFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaDateFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaDateFieldDescriptor(v SchemaDateFieldDescriptor) error {
	t.FieldType = "date"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaDateFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaDateFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaDateFieldDescriptor(v SchemaDateFieldDescriptor) error {
	t.FieldType = "date"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaDoubleFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaDoubleFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaDoubleFieldDescriptor() (SchemaDoubleFieldDescriptor, error) {
	var body SchemaDoubleFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaDoubleFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaDoubleFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaDoubleFieldDescriptor(v SchemaDoubleFieldDescriptor) error {
	t.FieldType = "double"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaDoubleFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaDoubleFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaDoubleFieldDescriptor(v SchemaDoubleFieldDescriptor) error {
	t.FieldType = "double"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaEnumFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaEnumFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaEnumFieldDescriptor() (SchemaEnumFieldDescriptor, error) {
	var body SchemaEnumFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaEnumFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaEnumFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaEnumFieldDescriptor(v SchemaEnumFieldDescriptor) error {
	t.FieldType = "enum"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaEnumFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaEnumFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaEnumFieldDescriptor(v SchemaEnumFieldDescriptor) error {
	t.FieldType = "enum"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaFieldDescriptorArrayType returns the union data inside the SchemaFieldDescriptor as a SchemaFieldDescriptorArrayType
func (t SchemaFieldDescriptor) AsSchemaFieldDescriptorArrayType() (SchemaFieldDescriptorArrayType, error) {
	var body SchemaFieldDescriptorArrayType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaFieldDescriptorArrayType overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaFieldDescriptorArrayType
func (t *SchemaFieldDescriptor) FromSchemaFieldDescriptorArrayType(v SchemaFieldDescriptorArrayType) error {
	t.FieldType = "array"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaFieldDescriptorArrayType performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaFieldDescriptorArrayType
func (t *SchemaFieldDescriptor) MergeSchemaFieldDescriptorArrayType(v SchemaFieldDescriptorArrayType) error {
	t.FieldType = "array"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaIdFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaIdFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaIdFieldDescriptor() (SchemaIdFieldDescriptor, error) {
	var body SchemaIdFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaIdFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaIdFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaIdFieldDescriptor(v SchemaIdFieldDescriptor) error {
	t.FieldType = "id"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaIdFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaIdFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaIdFieldDescriptor(v SchemaIdFieldDescriptor) error {
	t.FieldType = "id"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaIntFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaIntFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaIntFieldDescriptor() (SchemaIntFieldDescriptor, error) {
	var body SchemaIntFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaIntFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaIntFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaIntFieldDescriptor(v SchemaIntFieldDescriptor) error {
	t.FieldType = "int"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaIntFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaIntFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaIntFieldDescriptor(v SchemaIntFieldDescriptor) error {
	t.FieldType = "int"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaJsonValueFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaJsonValueFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaJsonValueFieldDescriptor() (SchemaJsonValueFieldDescriptor, error) {
	var body SchemaJsonValueFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaJsonValueFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaJsonValueFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaJsonValueFieldDescriptor(v SchemaJsonValueFieldDescriptor) error {
	t.FieldType = "json_value"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaJsonValueFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaJsonValueFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaJsonValueFieldDescriptor(v SchemaJsonValueFieldDescriptor) error {
	t.FieldType = "json_value"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaRichTextFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaRichTextFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaRichTextFieldDescriptor() (SchemaRichTextFieldDescriptor, error) {
	var body SchemaRichTextFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaRichTextFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaRichTextFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaRichTextFieldDescriptor(v SchemaRichTextFieldDescriptor) error {
	t.FieldType = "rich_text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaRichTextFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaRichTextFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaRichTextFieldDescriptor(v SchemaRichTextFieldDescriptor) error {
	t.FieldType = "rich_text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaStructFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaStructFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaStructFieldDescriptor() (SchemaStructFieldDescriptor, error) {
	var body SchemaStructFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaStructFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaStructFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaStructFieldDescriptor(v SchemaStructFieldDescriptor) error {
	t.FieldType = "struct"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaStructFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaStructFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaStructFieldDescriptor(v SchemaStructFieldDescriptor) error {
	t.FieldType = "struct"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTextFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaTextFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaTextFieldDescriptor() (SchemaTextFieldDescriptor, error) {
	var body SchemaTextFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTextFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaTextFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaTextFieldDescriptor(v SchemaTextFieldDescriptor) error {
	t.FieldType = "text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTextFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaTextFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaTextFieldDescriptor(v SchemaTextFieldDescriptor) error {
	t.FieldType = "text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTimestampFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaTimestampFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaTimestampFieldDescriptor() (SchemaTimestampFieldDescriptor, error) {
	var body SchemaTimestampFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTimestampFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaTimestampFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaTimestampFieldDescriptor(v SchemaTimestampFieldDescriptor) error {
	t.FieldType = "timestamp"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTimestampFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaTimestampFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaTimestampFieldDescriptor(v SchemaTimestampFieldDescriptor) error {
	t.FieldType = "timestamp"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTokensFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaTokensFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaTokensFieldDescriptor() (SchemaTokensFieldDescriptor, error) {
	var body SchemaTokensFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTokensFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaTokensFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaTokensFieldDescriptor(v SchemaTokensFieldDescriptor) error {
	t.FieldType = "tokens"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTokensFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaTokensFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaTokensFieldDescriptor(v SchemaTokensFieldDescriptor) error {
	t.FieldType = "tokens"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaUenumFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaUenumFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaUenumFieldDescriptor() (SchemaUenumFieldDescriptor, error) {
	var body SchemaUenumFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaUenumFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaUenumFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaUenumFieldDescriptor(v SchemaUenumFieldDescriptor) error {
	t.FieldType = "uenum"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaUenumFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaUenumFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaUenumFieldDescriptor(v SchemaUenumFieldDescriptor) error {
	t.FieldType = "uenum"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaUnknownFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaUnknownFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaUnknownFieldDescriptor() (SchemaUnknownFieldDescriptor, error) {
	var body SchemaUnknownFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaUnknownFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaUnknownFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaUnknownFieldDescriptor(v SchemaUnknownFieldDescriptor) error {
	t.FieldType = "unknown"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaUnknownFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaUnknownFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaUnknownFieldDescriptor(v SchemaUnknownFieldDescriptor) error {
	t.FieldType = "unknown"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchemaFieldDescriptor) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"field_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SchemaFieldDescriptor) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "array":
		return t.AsSchemaFieldDescriptorArrayType()
	case "bool":
		return t.AsSchemaBoolFieldDescriptor()
	case "composite":
		return t.AsSchemaCompositeFieldDescriptor()
	case "date":
		return t.AsSchemaDateFieldDescriptor()
	case "double":
		return t.AsSchemaDoubleFieldDescriptor()
	case "enum":
		return t.AsSchemaEnumFieldDescriptor()
	case "id":
		return t.AsSchemaIdFieldDescriptor()
	case "int":
		return t.AsSchemaIntFieldDescriptor()
	case "json_value":
		return t.AsSchemaJsonValueFieldDescriptor()
	case "rich_text":
		return t.AsSchemaRichTextFieldDescriptor()
	case "struct":
		return t.AsSchemaStructFieldDescriptor()
	case "text":
		return t.AsSchemaTextFieldDescriptor()
	case "timestamp":
		return t.AsSchemaTimestampFieldDescriptor()
	case "tokens":
		return t.AsSchemaTokensFieldDescriptor()
	case "uenum":
		return t.AsSchemaUenumFieldDescriptor()
	case "unknown":
		return t.AsSchemaUnknownFieldDescriptor()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SchemaFieldDescriptor) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["field_type"], err = json.Marshal(t.FieldType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'field_type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SchemaFieldDescriptor) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["field_type"]; found {
		err = json.Unmarshal(raw, &t.FieldType)
		if err != nil {
			return fmt.Errorf("error reading 'field_type': %w", err)
		}
	}

	return err
}

// AsSchemaBoolListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaBoolListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaBoolListFieldDescriptor() (SchemaBoolListFieldDescriptor, error) {
	var body SchemaBoolListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaBoolListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaBoolListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaBoolListFieldDescriptor(v SchemaBoolListFieldDescriptor) error {
	t.BaseType = "bool"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaBoolListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaBoolListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaBoolListFieldDescriptor(v SchemaBoolListFieldDescriptor) error {
	t.BaseType = "bool"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaCompositeListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaCompositeListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaCompositeListFieldDescriptor() (SchemaCompositeListFieldDescriptor, error) {
	var body SchemaCompositeListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaCompositeListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaCompositeListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaCompositeListFieldDescriptor(v SchemaCompositeListFieldDescriptor) error {
	t.BaseType = "composite"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaCompositeListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaCompositeListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaCompositeListFieldDescriptor(v SchemaCompositeListFieldDescriptor) error {
	t.BaseType = "composite"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaDateListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaDateListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaDateListFieldDescriptor() (SchemaDateListFieldDescriptor, error) {
	var body SchemaDateListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaDateListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaDateListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaDateListFieldDescriptor(v SchemaDateListFieldDescriptor) error {
	t.BaseType = "date"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaDateListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaDateListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaDateListFieldDescriptor(v SchemaDateListFieldDescriptor) error {
	t.BaseType = "date"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaDoubleListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaDoubleListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaDoubleListFieldDescriptor() (SchemaDoubleListFieldDescriptor, error) {
	var body SchemaDoubleListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaDoubleListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaDoubleListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaDoubleListFieldDescriptor(v SchemaDoubleListFieldDescriptor) error {
	t.BaseType = "double"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaDoubleListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaDoubleListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaDoubleListFieldDescriptor(v SchemaDoubleListFieldDescriptor) error {
	t.BaseType = "double"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaEnumListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaEnumListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaEnumListFieldDescriptor() (SchemaEnumListFieldDescriptor, error) {
	var body SchemaEnumListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaEnumListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaEnumListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaEnumListFieldDescriptor(v SchemaEnumListFieldDescriptor) error {
	t.BaseType = "enum"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaEnumListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaEnumListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaEnumListFieldDescriptor(v SchemaEnumListFieldDescriptor) error {
	t.BaseType = "enum"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaIdListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaIdListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaIdListFieldDescriptor() (SchemaIdListFieldDescriptor, error) {
	var body SchemaIdListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaIdListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaIdListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaIdListFieldDescriptor(v SchemaIdListFieldDescriptor) error {
	t.BaseType = "id"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaIdListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaIdListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaIdListFieldDescriptor(v SchemaIdListFieldDescriptor) error {
	t.BaseType = "id"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaIntListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaIntListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaIntListFieldDescriptor() (SchemaIntListFieldDescriptor, error) {
	var body SchemaIntListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaIntListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaIntListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaIntListFieldDescriptor(v SchemaIntListFieldDescriptor) error {
	t.BaseType = "int"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaIntListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaIntListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaIntListFieldDescriptor(v SchemaIntListFieldDescriptor) error {
	t.BaseType = "int"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaJsonValueListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaJsonValueListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaJsonValueListFieldDescriptor() (SchemaJsonValueListFieldDescriptor, error) {
	var body SchemaJsonValueListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaJsonValueListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaJsonValueListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaJsonValueListFieldDescriptor(v SchemaJsonValueListFieldDescriptor) error {
	t.BaseType = "json_value"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaJsonValueListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaJsonValueListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaJsonValueListFieldDescriptor(v SchemaJsonValueListFieldDescriptor) error {
	t.BaseType = "json_value"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaRichTextListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaRichTextListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaRichTextListFieldDescriptor() (SchemaRichTextListFieldDescriptor, error) {
	var body SchemaRichTextListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaRichTextListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaRichTextListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaRichTextListFieldDescriptor(v SchemaRichTextListFieldDescriptor) error {
	t.BaseType = "rich_text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaRichTextListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaRichTextListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaRichTextListFieldDescriptor(v SchemaRichTextListFieldDescriptor) error {
	t.BaseType = "rich_text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaStructListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaStructListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaStructListFieldDescriptor() (SchemaStructListFieldDescriptor, error) {
	var body SchemaStructListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaStructListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaStructListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaStructListFieldDescriptor(v SchemaStructListFieldDescriptor) error {
	t.BaseType = "struct"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaStructListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaStructListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaStructListFieldDescriptor(v SchemaStructListFieldDescriptor) error {
	t.BaseType = "struct"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTextListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaTextListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaTextListFieldDescriptor() (SchemaTextListFieldDescriptor, error) {
	var body SchemaTextListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTextListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaTextListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaTextListFieldDescriptor(v SchemaTextListFieldDescriptor) error {
	t.BaseType = "text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTextListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaTextListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaTextListFieldDescriptor(v SchemaTextListFieldDescriptor) error {
	t.BaseType = "text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTimestampListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaTimestampListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaTimestampListFieldDescriptor() (SchemaTimestampListFieldDescriptor, error) {
	var body SchemaTimestampListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTimestampListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaTimestampListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaTimestampListFieldDescriptor(v SchemaTimestampListFieldDescriptor) error {
	t.BaseType = "timestamp"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTimestampListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaTimestampListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaTimestampListFieldDescriptor(v SchemaTimestampListFieldDescriptor) error {
	t.BaseType = "timestamp"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTokensListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaTokensListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaTokensListFieldDescriptor() (SchemaTokensListFieldDescriptor, error) {
	var body SchemaTokensListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTokensListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaTokensListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaTokensListFieldDescriptor(v SchemaTokensListFieldDescriptor) error {
	t.BaseType = "tokens"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTokensListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaTokensListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaTokensListFieldDescriptor(v SchemaTokensListFieldDescriptor) error {
	t.BaseType = "tokens"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaUenumListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaUenumListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaUenumListFieldDescriptor() (SchemaUenumListFieldDescriptor, error) {
	var body SchemaUenumListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaUenumListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaUenumListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaUenumListFieldDescriptor(v SchemaUenumListFieldDescriptor) error {
	t.BaseType = "uenum"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaUenumListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaUenumListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaUenumListFieldDescriptor(v SchemaUenumListFieldDescriptor) error {
	t.BaseType = "uenum"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchemaFieldDescriptorArrayType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"base_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SchemaFieldDescriptorArrayType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "bool":
		return t.AsSchemaBoolListFieldDescriptor()
	case "composite":
		return t.AsSchemaCompositeListFieldDescriptor()
	case "date":
		return t.AsSchemaDateListFieldDescriptor()
	case "double":
		return t.AsSchemaDoubleListFieldDescriptor()
	case "enum":
		return t.AsSchemaEnumListFieldDescriptor()
	case "id":
		return t.AsSchemaIdListFieldDescriptor()
	case "int":
		return t.AsSchemaIntListFieldDescriptor()
	case "json_value":
		return t.AsSchemaJsonValueListFieldDescriptor()
	case "rich_text":
		return t.AsSchemaRichTextListFieldDescriptor()
	case "struct":
		return t.AsSchemaStructListFieldDescriptor()
	case "text":
		return t.AsSchemaTextListFieldDescriptor()
	case "timestamp":
		return t.AsSchemaTimestampListFieldDescriptor()
	case "tokens":
		return t.AsSchemaTokensListFieldDescriptor()
	case "uenum":
		return t.AsSchemaUenumListFieldDescriptor()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SchemaFieldDescriptorArrayType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["base_type"], err = json.Marshal(t.BaseType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'base_type': %w", err)
	}

	if t.EqItems != nil {
		object["eq_items"], err = json.Marshal(t.EqItems)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'eq_items': %w", err)
		}
	}

	if t.MaxItems != nil {
		object["max_items"], err = json.Marshal(t.MaxItems)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_items': %w", err)
		}
	}

	if t.MinItems != nil {
		object["min_items"], err = json.Marshal(t.MinItems)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'min_items': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *SchemaFieldDescriptorArrayType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["base_type"]; found {
		err = json.Unmarshal(raw, &t.BaseType)
		if err != nil {
			return fmt.Errorf("error reading 'base_type': %w", err)
		}
	}

	if raw, found := object["eq_items"]; found {
		err = json.Unmarshal(raw, &t.EqItems)
		if err != nil {
			return fmt.Errorf("error reading 'eq_items': %w", err)
		}
	}

	if raw, found := object["max_items"]; found {
		err = json.Unmarshal(raw, &t.MaxItems)
		if err != nil {
			return fmt.Errorf("error reading 'max_items': %w", err)
		}
	}

	if raw, found := object["min_items"]; found {
		err = json.Unmarshal(raw, &t.MinItems)
		if err != nil {
			return fmt.Errorf("error reading 'min_items': %w", err)
		}
	}

	return err
}

// AsSnapKitActionRequestButton returns the union data inside the SnapKitActionRequest as a SnapKitActionRequestButton
func (t SnapKitActionRequest) AsSnapKitActionRequestButton() (SnapKitActionRequestButton, error) {
	var body SnapKitActionRequestButton
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapKitActionRequestButton overwrites any union data inside the SnapKitActionRequest as the provided SnapKitActionRequestButton
func (t *SnapKitActionRequest) FromSnapKitActionRequestButton(v SnapKitActionRequestButton) error {
	t.Type = "button"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapKitActionRequestButton performs a merge with any union data inside the SnapKitActionRequest, using the provided SnapKitActionRequestButton
func (t *SnapKitActionRequest) MergeSnapKitActionRequestButton(v SnapKitActionRequestButton) error {
	t.Type = "button"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapKitActionRequestForm returns the union data inside the SnapKitActionRequest as a SnapKitActionRequestForm
func (t SnapKitActionRequest) AsSnapKitActionRequestForm() (SnapKitActionRequestForm, error) {
	var body SnapKitActionRequestForm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapKitActionRequestForm overwrites any union data inside the SnapKitActionRequest as the provided SnapKitActionRequestForm
func (t *SnapKitActionRequest) FromSnapKitActionRequestForm(v SnapKitActionRequestForm) error {
	t.Type = "form"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapKitActionRequestForm performs a merge with any union data inside the SnapKitActionRequest, using the provided SnapKitActionRequestForm
func (t *SnapKitActionRequest) MergeSnapKitActionRequestForm(v SnapKitActionRequestForm) error {
	t.Type = "form"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SnapKitActionRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SnapKitActionRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "button":
		return t.AsSnapKitActionRequestButton()
	case "form":
		return t.AsSnapKitActionRequestForm()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SnapKitActionRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["action_id"], err = json.Marshal(t.ActionId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'action_id': %w", err)
	}

	if t.ActionType != nil {
		object["action_type"], err = json.Marshal(t.ActionType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'action_type': %w", err)
		}
	}

	if t.BlockId != nil {
		object["block_id"], err = json.Marshal(t.BlockId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'block_id': %w", err)
		}
	}

	object["timestamp"], err = json.Marshal(t.Timestamp)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'timestamp': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SnapKitActionRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["action_id"]; found {
		err = json.Unmarshal(raw, &t.ActionId)
		if err != nil {
			return fmt.Errorf("error reading 'action_id': %w", err)
		}
	}

	if raw, found := object["action_type"]; found {
		err = json.Unmarshal(raw, &t.ActionType)
		if err != nil {
			return fmt.Errorf("error reading 'action_type': %w", err)
		}
	}

	if raw, found := object["block_id"]; found {
		err = json.Unmarshal(raw, &t.BlockId)
		if err != nil {
			return fmt.Errorf("error reading 'block_id': %w", err)
		}
	}

	if raw, found := object["timestamp"]; found {
		err = json.Unmarshal(raw, &t.Timestamp)
		if err != nil {
			return fmt.Errorf("error reading 'timestamp': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsTimelineEntriesCreateRequestTimelineComment returns the union data inside the TimelineEntriesCreateRequest as a TimelineEntriesCreateRequestTimelineComment
func (t TimelineEntriesCreateRequest) AsTimelineEntriesCreateRequestTimelineComment() (TimelineEntriesCreateRequestTimelineComment, error) {
	var body TimelineEntriesCreateRequestTimelineComment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineEntriesCreateRequestTimelineComment overwrites any union data inside the TimelineEntriesCreateRequest as the provided TimelineEntriesCreateRequestTimelineComment
func (t *TimelineEntriesCreateRequest) FromTimelineEntriesCreateRequestTimelineComment(v TimelineEntriesCreateRequestTimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineEntriesCreateRequestTimelineComment performs a merge with any union data inside the TimelineEntriesCreateRequest, using the provided TimelineEntriesCreateRequestTimelineComment
func (t *TimelineEntriesCreateRequest) MergeTimelineEntriesCreateRequestTimelineComment(v TimelineEntriesCreateRequestTimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TimelineEntriesCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TimelineEntriesCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "timeline_comment":
		return t.AsTimelineEntriesCreateRequestTimelineComment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TimelineEntriesCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.ExpiresAt != nil {
		object["expires_at"], err = json.Marshal(t.ExpiresAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'expires_at': %w", err)
		}
	}

	object["object"], err = json.Marshal(t.Object)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'object': %w", err)
	}

	if t.PrivateTo != nil {
		object["private_to"], err = json.Marshal(t.PrivateTo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'private_to': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if t.Visibility != nil {
		object["visibility"], err = json.Marshal(t.Visibility)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'visibility': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *TimelineEntriesCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["expires_at"]; found {
		err = json.Unmarshal(raw, &t.ExpiresAt)
		if err != nil {
			return fmt.Errorf("error reading 'expires_at': %w", err)
		}
	}

	if raw, found := object["object"]; found {
		err = json.Unmarshal(raw, &t.Object)
		if err != nil {
			return fmt.Errorf("error reading 'object': %w", err)
		}
	}

	if raw, found := object["private_to"]; found {
		err = json.Unmarshal(raw, &t.PrivateTo)
		if err != nil {
			return fmt.Errorf("error reading 'private_to': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	if raw, found := object["visibility"]; found {
		err = json.Unmarshal(raw, &t.Visibility)
		if err != nil {
			return fmt.Errorf("error reading 'visibility': %w", err)
		}
	}

	return err
}

// AsTimelineEntriesUpdateRequestTimelineComment returns the union data inside the TimelineEntriesUpdateRequest as a TimelineEntriesUpdateRequestTimelineComment
func (t TimelineEntriesUpdateRequest) AsTimelineEntriesUpdateRequestTimelineComment() (TimelineEntriesUpdateRequestTimelineComment, error) {
	var body TimelineEntriesUpdateRequestTimelineComment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineEntriesUpdateRequestTimelineComment overwrites any union data inside the TimelineEntriesUpdateRequest as the provided TimelineEntriesUpdateRequestTimelineComment
func (t *TimelineEntriesUpdateRequest) FromTimelineEntriesUpdateRequestTimelineComment(v TimelineEntriesUpdateRequestTimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineEntriesUpdateRequestTimelineComment performs a merge with any union data inside the TimelineEntriesUpdateRequest, using the provided TimelineEntriesUpdateRequestTimelineComment
func (t *TimelineEntriesUpdateRequest) MergeTimelineEntriesUpdateRequestTimelineComment(v TimelineEntriesUpdateRequestTimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TimelineEntriesUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TimelineEntriesUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "timeline_comment":
		return t.AsTimelineEntriesUpdateRequestTimelineComment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TimelineEntriesUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *TimelineEntriesUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsTimelineComment returns the union data inside the TimelineEntry as a TimelineComment
func (t TimelineEntry) AsTimelineComment() (TimelineComment, error) {
	var body TimelineComment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineComment overwrites any union data inside the TimelineEntry as the provided TimelineComment
func (t *TimelineEntry) FromTimelineComment(v TimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineComment performs a merge with any union data inside the TimelineEntry, using the provided TimelineComment
func (t *TimelineEntry) MergeTimelineComment(v TimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TimelineEntry) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TimelineEntry) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "timeline_comment":
		return t.AsTimelineComment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TimelineEntry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *TimelineEntry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDevUserSummary returns the union data inside the UserSummary as a DevUserSummary
func (t UserSummary) AsDevUserSummary() (DevUserSummary, error) {
	var body DevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUserSummary overwrites any union data inside the UserSummary as the provided DevUserSummary
func (t *UserSummary) FromDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUserSummary performs a merge with any union data inside the UserSummary, using the provided DevUserSummary
func (t *UserSummary) MergeDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUserSummary returns the union data inside the UserSummary as a RevUserSummary
func (t UserSummary) AsRevUserSummary() (RevUserSummary, error) {
	var body RevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUserSummary overwrites any union data inside the UserSummary as the provided RevUserSummary
func (t *UserSummary) FromRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUserSummary performs a merge with any union data inside the UserSummary, using the provided RevUserSummary
func (t *UserSummary) MergeRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServiceAccountSummary returns the union data inside the UserSummary as a ServiceAccountSummary
func (t UserSummary) AsServiceAccountSummary() (ServiceAccountSummary, error) {
	var body ServiceAccountSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServiceAccountSummary overwrites any union data inside the UserSummary as the provided ServiceAccountSummary
func (t *UserSummary) FromServiceAccountSummary(v ServiceAccountSummary) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServiceAccountSummary performs a merge with any union data inside the UserSummary, using the provided ServiceAccountSummary
func (t *UserSummary) MergeServiceAccountSummary(v ServiceAccountSummary) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSysUserSummary returns the union data inside the UserSummary as a SysUserSummary
func (t UserSummary) AsSysUserSummary() (SysUserSummary, error) {
	var body SysUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSysUserSummary overwrites any union data inside the UserSummary as the provided SysUserSummary
func (t *UserSummary) FromSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSysUserSummary performs a merge with any union data inside the UserSummary, using the provided SysUserSummary
func (t *UserSummary) MergeSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UserSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UserSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dev_user":
		return t.AsDevUserSummary()
	case "rev_user":
		return t.AsRevUserSummary()
	case "service_account":
		return t.AsServiceAccountSummary()
	case "sys_user":
		return t.AsSysUserSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UserSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *UserSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsIssue returns the union data inside the Work as a Issue
func (t Work) AsIssue() (Issue, error) {
	var body Issue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssue overwrites any union data inside the Work as the provided Issue
func (t *Work) FromIssue(v Issue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssue performs a merge with any union data inside the Work, using the provided Issue
func (t *Work) MergeIssue(v Issue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTicket returns the union data inside the Work as a Ticket
func (t Work) AsTicket() (Ticket, error) {
	var body Ticket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTicket overwrites any union data inside the Work as the provided Ticket
func (t *Work) FromTicket(v Ticket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTicket performs a merge with any union data inside the Work, using the provided Ticket
func (t *Work) MergeTicket(v Ticket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Work) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Work) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "issue":
		return t.AsIssue()
	case "ticket":
		return t.AsTicket()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Work) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Work) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsWorksCreateRequestIssue returns the union data inside the WorksCreateRequest as a WorksCreateRequestIssue
func (t WorksCreateRequest) AsWorksCreateRequestIssue() (WorksCreateRequestIssue, error) {
	var body WorksCreateRequestIssue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksCreateRequestIssue overwrites any union data inside the WorksCreateRequest as the provided WorksCreateRequestIssue
func (t *WorksCreateRequest) FromWorksCreateRequestIssue(v WorksCreateRequestIssue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksCreateRequestIssue performs a merge with any union data inside the WorksCreateRequest, using the provided WorksCreateRequestIssue
func (t *WorksCreateRequest) MergeWorksCreateRequestIssue(v WorksCreateRequestIssue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksCreateRequestTicket returns the union data inside the WorksCreateRequest as a WorksCreateRequestTicket
func (t WorksCreateRequest) AsWorksCreateRequestTicket() (WorksCreateRequestTicket, error) {
	var body WorksCreateRequestTicket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksCreateRequestTicket overwrites any union data inside the WorksCreateRequest as the provided WorksCreateRequestTicket
func (t *WorksCreateRequest) FromWorksCreateRequestTicket(v WorksCreateRequestTicket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksCreateRequestTicket performs a merge with any union data inside the WorksCreateRequest, using the provided WorksCreateRequestTicket
func (t *WorksCreateRequest) MergeWorksCreateRequestTicket(v WorksCreateRequestTicket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorksCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t WorksCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "issue":
		return t.AsWorksCreateRequestIssue()
	case "ticket":
		return t.AsWorksCreateRequestTicket()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t WorksCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["applies_to_part"], err = json.Marshal(t.AppliesToPart)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'applies_to_part': %w", err)
	}

	if t.Artifacts != nil {
		object["artifacts"], err = json.Marshal(t.Artifacts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artifacts': %w", err)
		}
	}

	if t.Body != nil {
		object["body"], err = json.Marshal(t.Body)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body': %w", err)
		}
	}

	object["owned_by"], err = json.Marshal(t.OwnedBy)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'owned_by': %w", err)
	}

	if t.ReportedBy != nil {
		object["reported_by"], err = json.Marshal(t.ReportedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reported_by': %w", err)
		}
	}

	if t.Stage != nil {
		object["stage"], err = json.Marshal(t.Stage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage': %w", err)
		}
	}

	if t.StageValidationOptions != nil {
		object["stage_validation_options"], err = json.Marshal(t.StageValidationOptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_validation_options': %w", err)
		}
	}

	if t.Tags != nil {
		object["tags"], err = json.Marshal(t.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if t.TargetCloseDate != nil {
		object["target_close_date"], err = json.Marshal(t.TargetCloseDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target_close_date': %w", err)
		}
	}

	object["title"], err = json.Marshal(t.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *WorksCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["applies_to_part"]; found {
		err = json.Unmarshal(raw, &t.AppliesToPart)
		if err != nil {
			return fmt.Errorf("error reading 'applies_to_part': %w", err)
		}
	}

	if raw, found := object["artifacts"]; found {
		err = json.Unmarshal(raw, &t.Artifacts)
		if err != nil {
			return fmt.Errorf("error reading 'artifacts': %w", err)
		}
	}

	if raw, found := object["body"]; found {
		err = json.Unmarshal(raw, &t.Body)
		if err != nil {
			return fmt.Errorf("error reading 'body': %w", err)
		}
	}

	if raw, found := object["owned_by"]; found {
		err = json.Unmarshal(raw, &t.OwnedBy)
		if err != nil {
			return fmt.Errorf("error reading 'owned_by': %w", err)
		}
	}

	if raw, found := object["reported_by"]; found {
		err = json.Unmarshal(raw, &t.ReportedBy)
		if err != nil {
			return fmt.Errorf("error reading 'reported_by': %w", err)
		}
	}

	if raw, found := object["stage"]; found {
		err = json.Unmarshal(raw, &t.Stage)
		if err != nil {
			return fmt.Errorf("error reading 'stage': %w", err)
		}
	}

	if raw, found := object["stage_validation_options"]; found {
		err = json.Unmarshal(raw, &t.StageValidationOptions)
		if err != nil {
			return fmt.Errorf("error reading 'stage_validation_options': %w", err)
		}
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &t.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
	}

	if raw, found := object["target_close_date"]; found {
		err = json.Unmarshal(raw, &t.TargetCloseDate)
		if err != nil {
			return fmt.Errorf("error reading 'target_close_date': %w", err)
		}
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &t.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsEmpty returns the union data inside the WorksUpdateRequest as a Empty
func (t WorksUpdateRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the WorksUpdateRequest as the provided Empty
func (t *WorksUpdateRequest) FromEmpty(v Empty) error {
	t.Type = func() *WorkType { v := WorkType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the WorksUpdateRequest, using the provided Empty
func (t *WorksUpdateRequest) MergeEmpty(v Empty) error {
	t.Type = func() *WorkType { v := WorkType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksUpdateRequestIssue returns the union data inside the WorksUpdateRequest as a WorksUpdateRequestIssue
func (t WorksUpdateRequest) AsWorksUpdateRequestIssue() (WorksUpdateRequestIssue, error) {
	var body WorksUpdateRequestIssue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksUpdateRequestIssue overwrites any union data inside the WorksUpdateRequest as the provided WorksUpdateRequestIssue
func (t *WorksUpdateRequest) FromWorksUpdateRequestIssue(v WorksUpdateRequestIssue) error {
	t.Type = func() *WorkType { v := WorkType("issue"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksUpdateRequestIssue performs a merge with any union data inside the WorksUpdateRequest, using the provided WorksUpdateRequestIssue
func (t *WorksUpdateRequest) MergeWorksUpdateRequestIssue(v WorksUpdateRequestIssue) error {
	t.Type = func() *WorkType { v := WorkType("issue"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksUpdateRequestTicket returns the union data inside the WorksUpdateRequest as a WorksUpdateRequestTicket
func (t WorksUpdateRequest) AsWorksUpdateRequestTicket() (WorksUpdateRequestTicket, error) {
	var body WorksUpdateRequestTicket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksUpdateRequestTicket overwrites any union data inside the WorksUpdateRequest as the provided WorksUpdateRequestTicket
func (t *WorksUpdateRequest) FromWorksUpdateRequestTicket(v WorksUpdateRequestTicket) error {
	t.Type = func() *WorkType { v := WorkType("ticket"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksUpdateRequestTicket performs a merge with any union data inside the WorksUpdateRequest, using the provided WorksUpdateRequestTicket
func (t *WorksUpdateRequest) MergeWorksUpdateRequestTicket(v WorksUpdateRequestTicket) error {
	t.Type = func() *WorkType { v := WorkType("ticket"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorksUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t WorksUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "issue":
		return t.AsWorksUpdateRequestIssue()
	case "none":
		return t.AsEmpty()
	case "ticket":
		return t.AsWorksUpdateRequestTicket()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t WorksUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.AppliesToPart != nil {
		object["applies_to_part"], err = json.Marshal(t.AppliesToPart)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'applies_to_part': %w", err)
		}
	}

	if t.Artifacts != nil {
		object["artifacts"], err = json.Marshal(t.Artifacts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artifacts': %w", err)
		}
	}

	if t.Body != nil {
		object["body"], err = json.Marshal(t.Body)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.OwnedBy != nil {
		object["owned_by"], err = json.Marshal(t.OwnedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owned_by': %w", err)
		}
	}

	if t.ReportedBy != nil {
		object["reported_by"], err = json.Marshal(t.ReportedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reported_by': %w", err)
		}
	}

	if t.Stage != nil {
		object["stage"], err = json.Marshal(t.Stage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage': %w", err)
		}
	}

	if t.StageValidationOptions != nil {
		object["stage_validation_options"], err = json.Marshal(t.StageValidationOptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_validation_options': %w", err)
		}
	}

	if t.StagedInfo != nil {
		object["staged_info"], err = json.Marshal(t.StagedInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'staged_info': %w", err)
		}
	}

	if t.Tags != nil {
		object["tags"], err = json.Marshal(t.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if t.TargetCloseDate != nil {
		object["target_close_date"], err = json.Marshal(t.TargetCloseDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target_close_date': %w", err)
		}
	}

	if t.Title != nil {
		object["title"], err = json.Marshal(t.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *WorksUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["applies_to_part"]; found {
		err = json.Unmarshal(raw, &t.AppliesToPart)
		if err != nil {
			return fmt.Errorf("error reading 'applies_to_part': %w", err)
		}
	}

	if raw, found := object["artifacts"]; found {
		err = json.Unmarshal(raw, &t.Artifacts)
		if err != nil {
			return fmt.Errorf("error reading 'artifacts': %w", err)
		}
	}

	if raw, found := object["body"]; found {
		err = json.Unmarshal(raw, &t.Body)
		if err != nil {
			return fmt.Errorf("error reading 'body': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["owned_by"]; found {
		err = json.Unmarshal(raw, &t.OwnedBy)
		if err != nil {
			return fmt.Errorf("error reading 'owned_by': %w", err)
		}
	}

	if raw, found := object["reported_by"]; found {
		err = json.Unmarshal(raw, &t.ReportedBy)
		if err != nil {
			return fmt.Errorf("error reading 'reported_by': %w", err)
		}
	}

	if raw, found := object["stage"]; found {
		err = json.Unmarshal(raw, &t.Stage)
		if err != nil {
			return fmt.Errorf("error reading 'stage': %w", err)
		}
	}

	if raw, found := object["stage_validation_options"]; found {
		err = json.Unmarshal(raw, &t.StageValidationOptions)
		if err != nil {
			return fmt.Errorf("error reading 'stage_validation_options': %w", err)
		}
	}

	if raw, found := object["staged_info"]; found {
		err = json.Unmarshal(raw, &t.StagedInfo)
		if err != nil {
			return fmt.Errorf("error reading 'staged_info': %w", err)
		}
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &t.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
	}

	if raw, found := object["target_close_date"]; found {
		err = json.Unmarshal(raw, &t.TargetCloseDate)
		if err != nil {
			return fmt.Errorf("error reading 'target_close_date': %w", err)
		}
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &t.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AccountsCreateWithBody request with any body
	AccountsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsCreate(ctx context.Context, body AccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsDeleteWithBody request with any body
	AccountsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsDelete(ctx context.Context, body AccountsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsExport request
	AccountsExport(ctx context.Context, params *AccountsExportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsExportPostWithBody request with any body
	AccountsExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsExportPost(ctx context.Context, body AccountsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsGet request
	AccountsGet(ctx context.Context, params *AccountsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsGetPostWithBody request with any body
	AccountsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsGetPost(ctx context.Context, body AccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsList request
	AccountsList(ctx context.Context, params *AccountsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsListPostWithBody request with any body
	AccountsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsListPost(ctx context.Context, body AccountsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsMergeWithBody request with any body
	AccountsMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsMerge(ctx context.Context, body AccountsMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsUpdateWithBody request with any body
	AccountsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsUpdate(ctx context.Context, body AccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateArticleWithBody request with any body
	CreateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateArticle(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteArticleWithBody request with any body
	DeleteArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteArticle(ctx context.Context, body DeleteArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArticle request
	GetArticle(ctx context.Context, params *GetArticleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArticlePostWithBody request with any body
	GetArticlePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetArticlePost(ctx context.Context, body GetArticlePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListArticles request
	ListArticles(ctx context.Context, params *ListArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListArticlesPostWithBody request with any body
	ListArticlesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListArticlesPost(ctx context.Context, body ListArticlesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateArticleWithBody request with any body
	UpdateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateArticle(ctx context.Context, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsGet request
	ArtifactsGet(ctx context.Context, params *ArtifactsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsGetPostWithBody request with any body
	ArtifactsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsGetPost(ctx context.Context, body ArtifactsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsList request
	ArtifactsList(ctx context.Context, params *ArtifactsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsListPostWithBody request with any body
	ArtifactsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsListPost(ctx context.Context, body ArtifactsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsLocate request
	ArtifactsLocate(ctx context.Context, params *ArtifactsLocateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsLocatePostWithBody request with any body
	ArtifactsLocatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsLocatePost(ctx context.Context, body ArtifactsLocatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsPrepareWithBody request with any body
	ArtifactsPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsPrepare(ctx context.Context, body ArtifactsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsHardDeleteVersionWithBody request with any body
	ArtifactsHardDeleteVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsHardDeleteVersion(ctx context.Context, body ArtifactsHardDeleteVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsVersionsPrepareWithBody request with any body
	ArtifactsVersionsPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsVersionsPrepare(ctx context.Context, body ArtifactsVersionsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AtomsGet request
	AtomsGet(ctx context.Context, params *AtomsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AtomsGetPostWithBody request with any body
	AtomsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AtomsGetPost(ctx context.Context, body AtomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensCreateWithBody request with any body
	AuthTokensCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensCreate(ctx context.Context, body AuthTokensCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensDeleteWithBody request with any body
	AuthTokensDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensDelete(ctx context.Context, body AuthTokensDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensGet request
	AuthTokensGet(ctx context.Context, params *AuthTokensGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensGetPostWithBody request with any body
	AuthTokensGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensGetPost(ctx context.Context, body AuthTokensGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensInfo request
	AuthTokensInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensInfoPostWithBody request with any body
	AuthTokensInfoPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensInfoPost(ctx context.Context, body AuthTokensInfoPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensList request
	AuthTokensList(ctx context.Context, params *AuthTokensListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensListPostWithBody request with any body
	AuthTokensListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensListPost(ctx context.Context, body AuthTokensListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensSelfDeleteWithBody request with any body
	AuthTokensSelfDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensSelfDelete(ctx context.Context, body AuthTokensSelfDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensUpdateWithBody request with any body
	AuthTokensUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensUpdate(ctx context.Context, body AuthTokensUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatsCreateWithBody request with any body
	ChatsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatsCreate(ctx context.Context, body ChatsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatsGet request
	ChatsGet(ctx context.Context, params *ChatsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatsGetPostWithBody request with any body
	ChatsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatsGetPost(ctx context.Context, body ChatsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatsUpdateWithBody request with any body
	ChatsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatsUpdate(ctx context.Context, body ChatsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesCreateWithBody request with any body
	CodeChangesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesCreate(ctx context.Context, body CodeChangesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesDeleteWithBody request with any body
	CodeChangesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesDelete(ctx context.Context, body CodeChangesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesGet request
	CodeChangesGet(ctx context.Context, params *CodeChangesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesGetPostWithBody request with any body
	CodeChangesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesGetPost(ctx context.Context, body CodeChangesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesList request
	CodeChangesList(ctx context.Context, params *CodeChangesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesListPostWithBody request with any body
	CodeChangesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesListPost(ctx context.Context, body CodeChangesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesUpdateWithBody request with any body
	CodeChangesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesUpdate(ctx context.Context, body CodeChangesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsCreateWithBody request with any body
	CommandsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommandsCreate(ctx context.Context, body CommandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsGet request
	CommandsGet(ctx context.Context, params *CommandsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsGetPostWithBody request with any body
	CommandsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommandsGetPost(ctx context.Context, body CommandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsList request
	CommandsList(ctx context.Context, params *CommandsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsListPostWithBody request with any body
	CommandsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommandsListPost(ctx context.Context, body CommandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsUpdateWithBody request with any body
	CommandsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommandsUpdate(ctx context.Context, body CommandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsCreateWithBody request with any body
	ConversationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsCreate(ctx context.Context, body ConversationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsDeleteWithBody request with any body
	ConversationsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsDelete(ctx context.Context, body ConversationsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsGet request
	ConversationsGet(ctx context.Context, params *ConversationsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsGetPostWithBody request with any body
	ConversationsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsGetPost(ctx context.Context, body ConversationsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsList request
	ConversationsList(ctx context.Context, params *ConversationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsListPostWithBody request with any body
	ConversationsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsListPost(ctx context.Context, body ConversationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsUpdateWithBody request with any body
	ConversationsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsUpdate(ctx context.Context, body ConversationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsCreateWithBody request with any body
	DevOrgAuthConnectionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsCreate(ctx context.Context, body DevOrgAuthConnectionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsDeleteWithBody request with any body
	DevOrgAuthConnectionsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsDelete(ctx context.Context, body DevOrgAuthConnectionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsGet request
	DevOrgAuthConnectionsGet(ctx context.Context, params *DevOrgAuthConnectionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsGetPostWithBody request with any body
	DevOrgAuthConnectionsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsGetPost(ctx context.Context, body DevOrgAuthConnectionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsList request
	DevOrgAuthConnectionsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsListPostWithBody request with any body
	DevOrgAuthConnectionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsListPost(ctx context.Context, body DevOrgAuthConnectionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsToggleWithBody request with any body
	DevOrgAuthConnectionsToggleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsToggle(ctx context.Context, body DevOrgAuthConnectionsToggleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsUpdateWithBody request with any body
	DevOrgAuthConnectionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsUpdate(ctx context.Context, body DevOrgAuthConnectionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgsGet request
	DevOrgsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgsGetPostWithBody request with any body
	DevOrgsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgsGetPost(ctx context.Context, body DevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersActivateWithBody request with any body
	DevUsersActivateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersActivate(ctx context.Context, body DevUsersActivateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersCreateWithBody request with any body
	DevUsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersCreate(ctx context.Context, body DevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersDeactivateWithBody request with any body
	DevUsersDeactivateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersDeactivate(ctx context.Context, body DevUsersDeactivateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersGet request
	DevUsersGet(ctx context.Context, params *DevUsersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersGetPostWithBody request with any body
	DevUsersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersGetPost(ctx context.Context, body DevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersIdentitiesLinkWithBody request with any body
	DevUsersIdentitiesLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersIdentitiesLink(ctx context.Context, body DevUsersIdentitiesLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersIdentitiesUnlinkWithBody request with any body
	DevUsersIdentitiesUnlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersIdentitiesUnlink(ctx context.Context, body DevUsersIdentitiesUnlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersList request
	DevUsersList(ctx context.Context, params *DevUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersListPostWithBody request with any body
	DevUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersListPost(ctx context.Context, body DevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersMergeWithBody request with any body
	DevUsersMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersMerge(ctx context.Context, body DevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersSelf request
	DevUsersSelf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersSelfPostWithBody request with any body
	DevUsersSelfPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersSelfPost(ctx context.Context, body DevUsersSelfPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersSelfUpdateWithBody request with any body
	DevUsersSelfUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersSelfUpdate(ctx context.Context, body DevUsersSelfUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersUpdateWithBody request with any body
	DevUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersUpdate(ctx context.Context, body DevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesCount request
	DirectoriesCount(ctx context.Context, params *DirectoriesCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesCountPostWithBody request with any body
	DirectoriesCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesCountPost(ctx context.Context, body DirectoriesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesCreateWithBody request with any body
	DirectoriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesCreate(ctx context.Context, body DirectoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesDeleteWithBody request with any body
	DirectoriesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesDelete(ctx context.Context, body DirectoriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesGet request
	DirectoriesGet(ctx context.Context, params *DirectoriesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesGetPostWithBody request with any body
	DirectoriesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesGetPost(ctx context.Context, body DirectoriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesList request
	DirectoriesList(ctx context.Context, params *DirectoriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesListPostWithBody request with any body
	DirectoriesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesListPost(ctx context.Context, body DirectoriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesUpdateWithBody request with any body
	DirectoriesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesUpdate(ctx context.Context, body DirectoriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsCreateWithBody request with any body
	GroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsCreate(ctx context.Context, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsGet request
	GroupsGet(ctx context.Context, params *GroupsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsGetPostWithBody request with any body
	GroupsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsGetPost(ctx context.Context, body GroupsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsList request
	GroupsList(ctx context.Context, params *GroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsListPostWithBody request with any body
	GroupsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsListPost(ctx context.Context, body GroupsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupMembersAddWithBody request with any body
	GroupMembersAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupMembersAdd(ctx context.Context, body GroupMembersAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupMembersList request
	GroupMembersList(ctx context.Context, params *GroupMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupMembersListPostWithBody request with any body
	GroupMembersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupMembersListPost(ctx context.Context, body GroupMembersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupMembersRemoveWithBody request with any body
	GroupMembersRemoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupMembersRemove(ctx context.Context, body GroupMembersRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsUpdateWithBody request with any body
	GroupsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsUpdate(ctx context.Context, body GroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// KeyringsCreateCallback request
	KeyringsCreateCallback(ctx context.Context, params *KeyringsCreateCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// KeyringsCreateCallbackPostWithBody request with any body
	KeyringsCreateCallbackPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	KeyringsCreateCallbackPost(ctx context.Context, body KeyringsCreateCallbackPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksCreateWithBody request with any body
	LinksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksCreate(ctx context.Context, body LinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksDeleteWithBody request with any body
	LinksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksDelete(ctx context.Context, body LinksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksGet request
	LinksGet(ctx context.Context, params *LinksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksGetPostWithBody request with any body
	LinksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksGetPost(ctx context.Context, body LinksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksList request
	LinksList(ctx context.Context, params *LinksListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksListPostWithBody request with any body
	LinksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksListPost(ctx context.Context, body LinksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksReplaceWithBody request with any body
	LinksReplaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksReplace(ctx context.Context, body LinksReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsCount request
	MeetingsCount(ctx context.Context, params *MeetingsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsCountPostWithBody request with any body
	MeetingsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsCountPost(ctx context.Context, body MeetingsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsCreateWithBody request with any body
	MeetingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsCreate(ctx context.Context, body MeetingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsDeleteWithBody request with any body
	MeetingsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsDelete(ctx context.Context, body MeetingsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsGet request
	MeetingsGet(ctx context.Context, params *MeetingsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsGetPostWithBody request with any body
	MeetingsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsGetPost(ctx context.Context, body MeetingsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsList request
	MeetingsList(ctx context.Context, params *MeetingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsListPostWithBody request with any body
	MeetingsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsListPost(ctx context.Context, body MeetingsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsUpdateWithBody request with any body
	MeetingsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsUpdate(ctx context.Context, body MeetingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricActionExecuteWithBody request with any body
	MetricActionExecuteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricActionExecute(ctx context.Context, body MetricActionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsCreateWithBody request with any body
	MetricDefinitionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsCreate(ctx context.Context, body MetricDefinitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsDeleteWithBody request with any body
	MetricDefinitionsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsDelete(ctx context.Context, body MetricDefinitionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsGet request
	MetricDefinitionsGet(ctx context.Context, params *MetricDefinitionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsGetPostWithBody request with any body
	MetricDefinitionsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsGetPost(ctx context.Context, body MetricDefinitionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsList request
	MetricDefinitionsList(ctx context.Context, params *MetricDefinitionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsListPostWithBody request with any body
	MetricDefinitionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsListPost(ctx context.Context, body MetricDefinitionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsUpdateWithBody request with any body
	MetricDefinitionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsUpdate(ctx context.Context, body MetricDefinitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricTrackersGet request
	MetricTrackersGet(ctx context.Context, params *MetricTrackersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricTrackersGetPostWithBody request with any body
	MetricTrackersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricTrackersGetPost(ctx context.Context, body MetricTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgScheduleFragmentsCreateWithBody request with any body
	OrgScheduleFragmentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgScheduleFragmentsCreate(ctx context.Context, body OrgScheduleFragmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgScheduleFragmentsGet request
	OrgScheduleFragmentsGet(ctx context.Context, params *OrgScheduleFragmentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgScheduleFragmentsGetPostWithBody request with any body
	OrgScheduleFragmentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgScheduleFragmentsGetPost(ctx context.Context, body OrgScheduleFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgScheduleFragmentsTransitionWithBody request with any body
	OrgScheduleFragmentsTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgScheduleFragmentsTransition(ctx context.Context, body OrgScheduleFragmentsTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesCreateWithBody request with any body
	OrgSchedulesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesCreate(ctx context.Context, body OrgSchedulesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesEvaluate request
	OrgSchedulesEvaluate(ctx context.Context, params *OrgSchedulesEvaluateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesEvaluatePostWithBody request with any body
	OrgSchedulesEvaluatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesEvaluatePost(ctx context.Context, body OrgSchedulesEvaluatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesGet request
	OrgSchedulesGet(ctx context.Context, params *OrgSchedulesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesGetPostWithBody request with any body
	OrgSchedulesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesGetPost(ctx context.Context, body OrgSchedulesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesList request
	OrgSchedulesList(ctx context.Context, params *OrgSchedulesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesListPostWithBody request with any body
	OrgSchedulesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesListPost(ctx context.Context, body OrgSchedulesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesSetFutureWithBody request with any body
	OrgSchedulesSetFutureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesSetFuture(ctx context.Context, body OrgSchedulesSetFutureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesTransitionWithBody request with any body
	OrgSchedulesTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesTransition(ctx context.Context, body OrgSchedulesTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesUpdateWithBody request with any body
	OrgSchedulesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesUpdate(ctx context.Context, body OrgSchedulesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsCreateWithBody request with any body
	PartsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsCreate(ctx context.Context, body PartsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsDeleteWithBody request with any body
	PartsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsDelete(ctx context.Context, body PartsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsGet request
	PartsGet(ctx context.Context, params *PartsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsGetPostWithBody request with any body
	PartsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsGetPost(ctx context.Context, body PartsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsList request
	PartsList(ctx context.Context, params *PartsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsListPostWithBody request with any body
	PartsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsListPost(ctx context.Context, body PartsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsUpdateWithBody request with any body
	PartsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsUpdate(ctx context.Context, body PartsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsList request
	ReactionsList(ctx context.Context, params *ReactionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsListPostWithBody request with any body
	ReactionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionsListPost(ctx context.Context, body ReactionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsUpdateWithBody request with any body
	ReactionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionsUpdate(ctx context.Context, body ReactionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsCreateWithBody request with any body
	RevOrgsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsCreate(ctx context.Context, body RevOrgsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsDeleteWithBody request with any body
	RevOrgsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsDelete(ctx context.Context, body RevOrgsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsGet request
	RevOrgsGet(ctx context.Context, params *RevOrgsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsGetPostWithBody request with any body
	RevOrgsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsGetPost(ctx context.Context, body RevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsList request
	RevOrgsList(ctx context.Context, params *RevOrgsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsListPostWithBody request with any body
	RevOrgsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsListPost(ctx context.Context, body RevOrgsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsUpdateWithBody request with any body
	RevOrgsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsUpdate(ctx context.Context, body RevOrgsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersCreateWithBody request with any body
	RevUsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersCreate(ctx context.Context, body RevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersDeleteWithBody request with any body
	RevUsersDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersDelete(ctx context.Context, body RevUsersDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersGet request
	RevUsersGet(ctx context.Context, params *RevUsersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersGetPostWithBody request with any body
	RevUsersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersGetPost(ctx context.Context, body RevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersList request
	RevUsersList(ctx context.Context, params *RevUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersListPostWithBody request with any body
	RevUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersListPost(ctx context.Context, body RevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersMergeWithBody request with any body
	RevUsersMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersMerge(ctx context.Context, body RevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersScan request
	RevUsersScan(ctx context.Context, params *RevUsersScanParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersScanPostWithBody request with any body
	RevUsersScanPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersScanPost(ctx context.Context, body RevUsersScanPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersUpdateWithBody request with any body
	RevUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersUpdate(ctx context.Context, body RevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServiceAccountsCreateWithBody request with any body
	ServiceAccountsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ServiceAccountsCreate(ctx context.Context, body ServiceAccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServiceAccountsGet request
	ServiceAccountsGet(ctx context.Context, params *ServiceAccountsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServiceAccountsGetPostWithBody request with any body
	ServiceAccountsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ServiceAccountsGetPost(ctx context.Context, body ServiceAccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaTrackersGet request
	SlaTrackersGet(ctx context.Context, params *SlaTrackersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaTrackersGetPostWithBody request with any body
	SlaTrackersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlaTrackersGetPost(ctx context.Context, body SlaTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaTrackersList request
	SlaTrackersList(ctx context.Context, params *SlaTrackersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaTrackersListPostWithBody request with any body
	SlaTrackersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlaTrackersListPost(ctx context.Context, body SlaTrackersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasAssignWithBody request with any body
	SlasAssignWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasAssign(ctx context.Context, body SlasAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasCreateWithBody request with any body
	SlasCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasCreate(ctx context.Context, body SlasCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasGet request
	SlasGet(ctx context.Context, params *SlasGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasGetPostWithBody request with any body
	SlasGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasGetPost(ctx context.Context, body SlasGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasList request
	SlasList(ctx context.Context, params *SlasListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasListPostWithBody request with any body
	SlasListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasListPost(ctx context.Context, body SlasListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasTransitionWithBody request with any body
	SlasTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasTransition(ctx context.Context, body SlasTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasUpdateWithBody request with any body
	SlasUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasUpdate(ctx context.Context, body SlasUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapKitActionExecuteDeferredWithBody request with any body
	SnapKitActionExecuteDeferredWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnapKitActionExecuteDeferred(ctx context.Context, body SnapKitActionExecuteDeferredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapWidgetsCreateWithBody request with any body
	SnapWidgetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnapWidgetsCreate(ctx context.Context, body SnapWidgetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysCreateWithBody request with any body
	SurveysCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysCreate(ctx context.Context, body SurveysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysDeleteWithBody request with any body
	SurveysDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysDelete(ctx context.Context, body SurveysDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysGet request
	SurveysGet(ctx context.Context, params *SurveysGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysGetPostWithBody request with any body
	SurveysGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysGetPost(ctx context.Context, body SurveysGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysList request
	SurveysList(ctx context.Context, params *SurveysListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysListPostWithBody request with any body
	SurveysListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysListPost(ctx context.Context, body SurveysListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysResponsesList request
	SurveysResponsesList(ctx context.Context, params *SurveysResponsesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysResponsesListPostWithBody request with any body
	SurveysResponsesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysResponsesListPost(ctx context.Context, body SurveysResponsesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysResponsesUpdateWithBody request with any body
	SurveysResponsesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysResponsesUpdate(ctx context.Context, body SurveysResponsesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysSendWithBody request with any body
	SurveysSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysSend(ctx context.Context, body SurveysSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysSubmitWithBody request with any body
	SurveysSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysSubmit(ctx context.Context, body SurveysSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysUpdateWithBody request with any body
	SurveysUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysUpdate(ctx context.Context, body SurveysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SysUsersList request
	SysUsersList(ctx context.Context, params *SysUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SysUsersListPostWithBody request with any body
	SysUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SysUsersListPost(ctx context.Context, body SysUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SysUsersUpdateWithBody request with any body
	SysUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SysUsersUpdate(ctx context.Context, body SysUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsCreateWithBody request with any body
	TagsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsCreate(ctx context.Context, body TagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsDeleteWithBody request with any body
	TagsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsDelete(ctx context.Context, body TagsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsGet request
	TagsGet(ctx context.Context, params *TagsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsGetPostWithBody request with any body
	TagsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsGetPost(ctx context.Context, body TagsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsList request
	TagsList(ctx context.Context, params *TagsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsListPostWithBody request with any body
	TagsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsListPost(ctx context.Context, body TagsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsUpdateWithBody request with any body
	TagsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsUpdate(ctx context.Context, body TagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesCreateWithBody request with any body
	TimelineEntriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesCreate(ctx context.Context, body TimelineEntriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesDeleteWithBody request with any body
	TimelineEntriesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesDelete(ctx context.Context, body TimelineEntriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesGet request
	TimelineEntriesGet(ctx context.Context, params *TimelineEntriesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesGetPostWithBody request with any body
	TimelineEntriesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesGetPost(ctx context.Context, body TimelineEntriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesList request
	TimelineEntriesList(ctx context.Context, params *TimelineEntriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesListPostWithBody request with any body
	TimelineEntriesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesListPost(ctx context.Context, body TimelineEntriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesUpdateWithBody request with any body
	TimelineEntriesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesUpdate(ctx context.Context, body TimelineEntriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebCrawlerJobsControlWithBody request with any body
	WebCrawlerJobsControlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebCrawlerJobsControl(ctx context.Context, body WebCrawlerJobsControlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebCrawlerJobWithBody request with any body
	CreateWebCrawlerJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebCrawlerJob(ctx context.Context, body CreateWebCrawlerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebCrawlerJob request
	GetWebCrawlerJob(ctx context.Context, params *GetWebCrawlerJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebCrawlerJobPostWithBody request with any body
	GetWebCrawlerJobPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetWebCrawlerJobPost(ctx context.Context, body GetWebCrawlerJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebCrawlerJobs request
	ListWebCrawlerJobs(ctx context.Context, params *ListWebCrawlerJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebCrawlerJobsPostWithBody request with any body
	ListWebCrawlerJobsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListWebCrawlerJobsPost(ctx context.Context, body ListWebCrawlerJobsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksCreateWithBody request with any body
	WebhooksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksCreate(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksDeleteWithBody request with any body
	WebhooksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksDelete(ctx context.Context, body WebhooksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksEventWithBody request with any body
	WebhooksEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksEvent(ctx context.Context, body WebhooksEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksGet request
	WebhooksGet(ctx context.Context, params *WebhooksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksGetPostWithBody request with any body
	WebhooksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksGetPost(ctx context.Context, body WebhooksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksList request
	WebhooksList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksListPostWithBody request with any body
	WebhooksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksListPost(ctx context.Context, body WebhooksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksUpdateWithBody request with any body
	WebhooksUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksUpdate(ctx context.Context, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksCreateWithBody request with any body
	WorksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksCreate(ctx context.Context, body WorksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksDeleteWithBody request with any body
	WorksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksDelete(ctx context.Context, body WorksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksExport request
	WorksExport(ctx context.Context, params *WorksExportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksExportPostWithBody request with any body
	WorksExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksExportPost(ctx context.Context, body WorksExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksGet request
	WorksGet(ctx context.Context, params *WorksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksGetPostWithBody request with any body
	WorksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksGetPost(ctx context.Context, body WorksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksList request
	WorksList(ctx context.Context, params *WorksListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksListPostWithBody request with any body
	WorksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksListPost(ctx context.Context, body WorksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksUpdateWithBody request with any body
	WorksUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksUpdate(ctx context.Context, body WorksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AccountsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsCreate(ctx context.Context, body AccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsDelete(ctx context.Context, body AccountsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsExport(ctx context.Context, params *AccountsExportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsExportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsExportPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsExportPost(ctx context.Context, body AccountsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsExportPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsGet(ctx context.Context, params *AccountsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsGetPost(ctx context.Context, body AccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsList(ctx context.Context, params *AccountsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsListPost(ctx context.Context, body AccountsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsMergeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsMerge(ctx context.Context, body AccountsMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsMergeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsUpdate(ctx context.Context, body AccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateArticleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateArticle(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateArticleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteArticleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteArticle(ctx context.Context, body DeleteArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteArticleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticle(ctx context.Context, params *GetArticleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticlePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticlePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticlePost(ctx context.Context, body GetArticlePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticlePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListArticles(ctx context.Context, params *ListArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListArticlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListArticlesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListArticlesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListArticlesPost(ctx context.Context, body ListArticlesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListArticlesPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateArticleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateArticle(ctx context.Context, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateArticleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsGet(ctx context.Context, params *ArtifactsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsGetPost(ctx context.Context, body ArtifactsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsList(ctx context.Context, params *ArtifactsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsListPost(ctx context.Context, body ArtifactsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsLocate(ctx context.Context, params *ArtifactsLocateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsLocateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsLocatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsLocatePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsLocatePost(ctx context.Context, body ArtifactsLocatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsLocatePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsPrepareRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsPrepare(ctx context.Context, body ArtifactsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsPrepareRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsHardDeleteVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsHardDeleteVersionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsHardDeleteVersion(ctx context.Context, body ArtifactsHardDeleteVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsHardDeleteVersionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsVersionsPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsVersionsPrepareRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsVersionsPrepare(ctx context.Context, body ArtifactsVersionsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsVersionsPrepareRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AtomsGet(ctx context.Context, params *AtomsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAtomsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AtomsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAtomsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AtomsGetPost(ctx context.Context, body AtomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAtomsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensCreate(ctx context.Context, body AuthTokensCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensDelete(ctx context.Context, body AuthTokensDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensGet(ctx context.Context, params *AuthTokensGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensGetPost(ctx context.Context, body AuthTokensGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensInfoPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensInfoPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensInfoPost(ctx context.Context, body AuthTokensInfoPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensInfoPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensList(ctx context.Context, params *AuthTokensListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensListPost(ctx context.Context, body AuthTokensListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensSelfDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensSelfDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensSelfDelete(ctx context.Context, body AuthTokensSelfDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensSelfDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensUpdate(ctx context.Context, body AuthTokensUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsCreate(ctx context.Context, body ChatsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsGet(ctx context.Context, params *ChatsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsGetPost(ctx context.Context, body ChatsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsUpdate(ctx context.Context, body ChatsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesCreate(ctx context.Context, body CodeChangesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesDelete(ctx context.Context, body CodeChangesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesGet(ctx context.Context, params *CodeChangesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesGetPost(ctx context.Context, body CodeChangesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesList(ctx context.Context, params *CodeChangesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesListPost(ctx context.Context, body CodeChangesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesUpdate(ctx context.Context, body CodeChangesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsCreate(ctx context.Context, body CommandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsGet(ctx context.Context, params *CommandsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsGetPost(ctx context.Context, body CommandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsList(ctx context.Context, params *CommandsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsListPost(ctx context.Context, body CommandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsUpdate(ctx context.Context, body CommandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsCreate(ctx context.Context, body ConversationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsDelete(ctx context.Context, body ConversationsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsGet(ctx context.Context, params *ConversationsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsGetPost(ctx context.Context, body ConversationsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsList(ctx context.Context, params *ConversationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsListPost(ctx context.Context, body ConversationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsUpdate(ctx context.Context, body ConversationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsCreate(ctx context.Context, body DevOrgAuthConnectionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsDelete(ctx context.Context, body DevOrgAuthConnectionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsGet(ctx context.Context, params *DevOrgAuthConnectionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsGetPost(ctx context.Context, body DevOrgAuthConnectionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsListPost(ctx context.Context, body DevOrgAuthConnectionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsToggleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsToggleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsToggle(ctx context.Context, body DevOrgAuthConnectionsToggleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsToggleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsUpdate(ctx context.Context, body DevOrgAuthConnectionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgsGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgsGetPost(ctx context.Context, body DevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersActivateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersActivateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersActivate(ctx context.Context, body DevUsersActivateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersActivateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersCreate(ctx context.Context, body DevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersDeactivateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersDeactivateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersDeactivate(ctx context.Context, body DevUsersDeactivateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersDeactivateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersGet(ctx context.Context, params *DevUsersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersGetPost(ctx context.Context, body DevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersIdentitiesLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersIdentitiesLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersIdentitiesLink(ctx context.Context, body DevUsersIdentitiesLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersIdentitiesLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersIdentitiesUnlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersIdentitiesUnlinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersIdentitiesUnlink(ctx context.Context, body DevUsersIdentitiesUnlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersIdentitiesUnlinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersList(ctx context.Context, params *DevUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersListPost(ctx context.Context, body DevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersMergeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersMerge(ctx context.Context, body DevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersMergeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelfPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelfPost(ctx context.Context, body DevUsersSelfPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelfUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelfUpdate(ctx context.Context, body DevUsersSelfUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersUpdate(ctx context.Context, body DevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCount(ctx context.Context, params *DirectoriesCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCountPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCountPost(ctx context.Context, body DirectoriesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCountPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCreate(ctx context.Context, body DirectoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesDelete(ctx context.Context, body DirectoriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesGet(ctx context.Context, params *DirectoriesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesGetPost(ctx context.Context, body DirectoriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesList(ctx context.Context, params *DirectoriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesListPost(ctx context.Context, body DirectoriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesUpdate(ctx context.Context, body DirectoriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsCreate(ctx context.Context, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsGet(ctx context.Context, params *GroupsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsGetPost(ctx context.Context, body GroupsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsList(ctx context.Context, params *GroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsListPost(ctx context.Context, body GroupsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersAddRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersAdd(ctx context.Context, body GroupMembersAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersAddRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersList(ctx context.Context, params *GroupMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersListPost(ctx context.Context, body GroupMembersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersRemoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersRemoveRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersRemove(ctx context.Context, body GroupMembersRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersRemoveRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsUpdate(ctx context.Context, body GroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KeyringsCreateCallback(ctx context.Context, params *KeyringsCreateCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKeyringsCreateCallbackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KeyringsCreateCallbackPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKeyringsCreateCallbackPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KeyringsCreateCallbackPost(ctx context.Context, body KeyringsCreateCallbackPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKeyringsCreateCallbackPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksCreate(ctx context.Context, body LinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksDelete(ctx context.Context, body LinksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksGet(ctx context.Context, params *LinksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksGetPost(ctx context.Context, body LinksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksList(ctx context.Context, params *LinksListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksListPost(ctx context.Context, body LinksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksReplaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksReplaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksReplace(ctx context.Context, body LinksReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksReplaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCount(ctx context.Context, params *MeetingsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCountPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCountPost(ctx context.Context, body MeetingsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCountPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCreate(ctx context.Context, body MeetingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsDelete(ctx context.Context, body MeetingsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsGet(ctx context.Context, params *MeetingsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsGetPost(ctx context.Context, body MeetingsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsList(ctx context.Context, params *MeetingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsListPost(ctx context.Context, body MeetingsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsUpdate(ctx context.Context, body MeetingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricActionExecuteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricActionExecuteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricActionExecute(ctx context.Context, body MetricActionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricActionExecuteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsCreate(ctx context.Context, body MetricDefinitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsDelete(ctx context.Context, body MetricDefinitionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsGet(ctx context.Context, params *MetricDefinitionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsGetPost(ctx context.Context, body MetricDefinitionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsList(ctx context.Context, params *MetricDefinitionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsListPost(ctx context.Context, body MetricDefinitionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsUpdate(ctx context.Context, body MetricDefinitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricTrackersGet(ctx context.Context, params *MetricTrackersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricTrackersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricTrackersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricTrackersGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricTrackersGetPost(ctx context.Context, body MetricTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricTrackersGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsCreate(ctx context.Context, body OrgScheduleFragmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsGet(ctx context.Context, params *OrgScheduleFragmentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsGetPost(ctx context.Context, body OrgScheduleFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsTransitionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsTransition(ctx context.Context, body OrgScheduleFragmentsTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsTransitionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesCreate(ctx context.Context, body OrgSchedulesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesEvaluate(ctx context.Context, params *OrgSchedulesEvaluateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesEvaluateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesEvaluatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesEvaluatePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesEvaluatePost(ctx context.Context, body OrgSchedulesEvaluatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesEvaluatePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesGet(ctx context.Context, params *OrgSchedulesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesGetPost(ctx context.Context, body OrgSchedulesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesList(ctx context.Context, params *OrgSchedulesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesListPost(ctx context.Context, body OrgSchedulesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesSetFutureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesSetFutureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesSetFuture(ctx context.Context, body OrgSchedulesSetFutureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesSetFutureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesTransitionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesTransition(ctx context.Context, body OrgSchedulesTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesTransitionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesUpdate(ctx context.Context, body OrgSchedulesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsCreate(ctx context.Context, body PartsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsDelete(ctx context.Context, body PartsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsGet(ctx context.Context, params *PartsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsGetPost(ctx context.Context, body PartsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsList(ctx context.Context, params *PartsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsListPost(ctx context.Context, body PartsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsUpdate(ctx context.Context, body PartsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsList(ctx context.Context, params *ReactionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsListPost(ctx context.Context, body ReactionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsUpdate(ctx context.Context, body ReactionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsCreate(ctx context.Context, body RevOrgsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsDelete(ctx context.Context, body RevOrgsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsGet(ctx context.Context, params *RevOrgsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsGetPost(ctx context.Context, body RevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsList(ctx context.Context, params *RevOrgsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsListPost(ctx context.Context, body RevOrgsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsUpdate(ctx context.Context, body RevOrgsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersCreate(ctx context.Context, body RevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersDelete(ctx context.Context, body RevUsersDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersGet(ctx context.Context, params *RevUsersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersGetPost(ctx context.Context, body RevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersList(ctx context.Context, params *RevUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersListPost(ctx context.Context, body RevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersMergeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersMerge(ctx context.Context, body RevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersMergeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersScan(ctx context.Context, params *RevUsersScanParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersScanRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersScanPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersScanPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersScanPost(ctx context.Context, body RevUsersScanPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersScanPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersUpdate(ctx context.Context, body RevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsCreate(ctx context.Context, body ServiceAccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsGet(ctx context.Context, params *ServiceAccountsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsGetPost(ctx context.Context, body ServiceAccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersGet(ctx context.Context, params *SlaTrackersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersGetPost(ctx context.Context, body SlaTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersList(ctx context.Context, params *SlaTrackersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersListPost(ctx context.Context, body SlaTrackersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasAssignWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasAssignRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasAssign(ctx context.Context, body SlasAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasAssignRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasCreate(ctx context.Context, body SlasCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasGet(ctx context.Context, params *SlasGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasGetPost(ctx context.Context, body SlasGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasList(ctx context.Context, params *SlasListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasListPost(ctx context.Context, body SlasListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasTransitionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasTransition(ctx context.Context, body SlasTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasTransitionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasUpdate(ctx context.Context, body SlasUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapKitActionExecuteDeferredWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapKitActionExecuteDeferredRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapKitActionExecuteDeferred(ctx context.Context, body SnapKitActionExecuteDeferredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapKitActionExecuteDeferredRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapWidgetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapWidgetsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapWidgetsCreate(ctx context.Context, body SnapWidgetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapWidgetsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysCreate(ctx context.Context, body SurveysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysDelete(ctx context.Context, body SurveysDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysGet(ctx context.Context, params *SurveysGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysGetPost(ctx context.Context, body SurveysGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysList(ctx context.Context, params *SurveysListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysListPost(ctx context.Context, body SurveysListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesList(ctx context.Context, params *SurveysResponsesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesListPost(ctx context.Context, body SurveysResponsesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesUpdate(ctx context.Context, body SurveysResponsesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysSendRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysSend(ctx context.Context, body SurveysSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysSendRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysSubmit(ctx context.Context, body SurveysSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysUpdate(ctx context.Context, body SurveysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersList(ctx context.Context, params *SysUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersListPost(ctx context.Context, body SysUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersUpdate(ctx context.Context, body SysUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsCreate(ctx context.Context, body TagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsDelete(ctx context.Context, body TagsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsGet(ctx context.Context, params *TagsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsGetPost(ctx context.Context, body TagsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsList(ctx context.Context, params *TagsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsListPost(ctx context.Context, body TagsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsUpdate(ctx context.Context, body TagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesCreate(ctx context.Context, body TimelineEntriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesDelete(ctx context.Context, body TimelineEntriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesGet(ctx context.Context, params *TimelineEntriesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesGetPost(ctx context.Context, body TimelineEntriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesList(ctx context.Context, params *TimelineEntriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesListPost(ctx context.Context, body TimelineEntriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesUpdate(ctx context.Context, body TimelineEntriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebCrawlerJobsControlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebCrawlerJobsControlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebCrawlerJobsControl(ctx context.Context, body WebCrawlerJobsControlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebCrawlerJobsControlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebCrawlerJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebCrawlerJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebCrawlerJob(ctx context.Context, body CreateWebCrawlerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebCrawlerJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebCrawlerJob(ctx context.Context, params *GetWebCrawlerJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebCrawlerJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebCrawlerJobPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebCrawlerJobPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebCrawlerJobPost(ctx context.Context, body GetWebCrawlerJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebCrawlerJobPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebCrawlerJobs(ctx context.Context, params *ListWebCrawlerJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebCrawlerJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebCrawlerJobsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebCrawlerJobsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebCrawlerJobsPost(ctx context.Context, body ListWebCrawlerJobsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebCrawlerJobsPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksCreate(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksDelete(ctx context.Context, body WebhooksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksEvent(ctx context.Context, body WebhooksEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksGet(ctx context.Context, params *WebhooksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksGetPost(ctx context.Context, body WebhooksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksListPost(ctx context.Context, body WebhooksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksUpdate(ctx context.Context, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksCreate(ctx context.Context, body WorksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksDelete(ctx context.Context, body WorksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksExport(ctx context.Context, params *WorksExportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksExportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksExportPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksExportPost(ctx context.Context, body WorksExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksExportPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksGet(ctx context.Context, params *WorksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksGetPost(ctx context.Context, body WorksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksList(ctx context.Context, params *WorksListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksListPost(ctx context.Context, body WorksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksUpdate(ctx context.Context, body WorksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAccountsCreateRequest calls the generic AccountsCreate builder with application/json body
func NewAccountsCreateRequest(server string, body AccountsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsCreateRequestWithBody generates requests for AccountsCreate with any type of body
func NewAccountsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsDeleteRequest calls the generic AccountsDelete builder with application/json body
func NewAccountsDeleteRequest(server string, body AccountsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsDeleteRequestWithBody generates requests for AccountsDelete with any type of body
func NewAccountsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsExportRequest generates requests for AccountsExport
func NewAccountsExportRequest(server string, params *AccountsExportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "display_name", runtime.ParamLocationQuery, *params.DisplayName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRefs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_refs", runtime.ParamLocationQuery, *params.ExternalRefs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage", runtime.ParamLocationQuery, *params.Stage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tier", runtime.ParamLocationQuery, *params.Tier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Websites != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "websites", runtime.ParamLocationQuery, *params.Websites); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountsExportPostRequest calls the generic AccountsExportPost builder with application/json body
func NewAccountsExportPostRequest(server string, body AccountsExportPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsExportPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsExportPostRequestWithBody generates requests for AccountsExportPost with any type of body
func NewAccountsExportPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsGetRequest generates requests for AccountsGet
func NewAccountsGetRequest(server string, params *AccountsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountsGetPostRequest calls the generic AccountsGetPost builder with application/json body
func NewAccountsGetPostRequest(server string, body AccountsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsGetPostRequestWithBody generates requests for AccountsGetPost with any type of body
func NewAccountsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsListRequest generates requests for AccountsList
func NewAccountsListRequest(server string, params *AccountsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "display_name", runtime.ParamLocationQuery, *params.DisplayName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRefs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_refs", runtime.ParamLocationQuery, *params.ExternalRefs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage", runtime.ParamLocationQuery, *params.Stage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tier", runtime.ParamLocationQuery, *params.Tier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Websites != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "websites", runtime.ParamLocationQuery, *params.Websites); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountsListPostRequest calls the generic AccountsListPost builder with application/json body
func NewAccountsListPostRequest(server string, body AccountsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsListPostRequestWithBody generates requests for AccountsListPost with any type of body
func NewAccountsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsMergeRequest calls the generic AccountsMerge builder with application/json body
func NewAccountsMergeRequest(server string, body AccountsMergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsMergeRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsMergeRequestWithBody generates requests for AccountsMerge with any type of body
func NewAccountsMergeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsUpdateRequest calls the generic AccountsUpdate builder with application/json body
func NewAccountsUpdateRequest(server string, body AccountsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsUpdateRequestWithBody generates requests for AccountsUpdate with any type of body
func NewAccountsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateArticleRequest calls the generic CreateArticle builder with application/json body
func NewCreateArticleRequest(server string, body CreateArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateArticleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateArticleRequestWithBody generates requests for CreateArticle with any type of body
func NewCreateArticleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteArticleRequest calls the generic DeleteArticle builder with application/json body
func NewDeleteArticleRequest(server string, body DeleteArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteArticleRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteArticleRequestWithBody generates requests for DeleteArticle with any type of body
func NewDeleteArticleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetArticleRequest generates requests for GetArticle
func NewGetArticleRequest(server string, params *GetArticleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dev_org", runtime.ParamLocationQuery, *params.DevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArticlePostRequest calls the generic GetArticlePost builder with application/json body
func NewGetArticlePostRequest(server string, body GetArticlePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetArticlePostRequestWithBody(server, "application/json", bodyReader)
}

// NewGetArticlePostRequestWithBody generates requests for GetArticlePost with any type of body
func NewGetArticlePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListArticlesRequest generates requests for ListArticles
func NewListArticlesRequest(server string, params *ListArticlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_parts", runtime.ParamLocationQuery, *params.AppliesToParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArticleType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "article_type", runtime.ParamLocationQuery, *params.ArticleType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthoredBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "authored_by", runtime.ParamLocationQuery, *params.AuthoredBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Brands != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "brands", runtime.ParamLocationQuery, *params.Brands); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dev_org", runtime.ParamLocationQuery, *params.DevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SharedWithMember != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "shared_with.member", runtime.ParamLocationQuery, *params.SharedWithMember); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SharedWithRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "shared_with.role", runtime.ParamLocationQuery, *params.SharedWithRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListArticlesPostRequest calls the generic ListArticlesPost builder with application/json body
func NewListArticlesPostRequest(server string, body ListArticlesPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListArticlesPostRequestWithBody(server, "application/json", bodyReader)
}

// NewListArticlesPostRequestWithBody generates requests for ListArticlesPost with any type of body
func NewListArticlesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateArticleRequest calls the generic UpdateArticle builder with application/json body
func NewUpdateArticleRequest(server string, body UpdateArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateArticleRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateArticleRequestWithBody generates requests for UpdateArticle with any type of body
func NewUpdateArticleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsGetRequest generates requests for ArtifactsGet
func NewArtifactsGetRequest(server string, params *ArtifactsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtifactsGetPostRequest calls the generic ArtifactsGetPost builder with application/json body
func NewArtifactsGetPostRequest(server string, body ArtifactsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsGetPostRequestWithBody generates requests for ArtifactsGetPost with any type of body
func NewArtifactsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsListRequest generates requests for ArtifactsList
func NewArtifactsListRequest(server string, params *ArtifactsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_id", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtifactsListPostRequest calls the generic ArtifactsListPost builder with application/json body
func NewArtifactsListPostRequest(server string, body ArtifactsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsListPostRequestWithBody generates requests for ArtifactsListPost with any type of body
func NewArtifactsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsLocateRequest generates requests for ArtifactsLocate
func NewArtifactsLocateRequest(server string, params *ArtifactsLocateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.locate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtifactsLocatePostRequest calls the generic ArtifactsLocatePost builder with application/json body
func NewArtifactsLocatePostRequest(server string, body ArtifactsLocatePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsLocatePostRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsLocatePostRequestWithBody generates requests for ArtifactsLocatePost with any type of body
func NewArtifactsLocatePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.locate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsPrepareRequest calls the generic ArtifactsPrepare builder with application/json body
func NewArtifactsPrepareRequest(server string, body ArtifactsPrepareJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsPrepareRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsPrepareRequestWithBody generates requests for ArtifactsPrepare with any type of body
func NewArtifactsPrepareRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.prepare")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsHardDeleteVersionRequest calls the generic ArtifactsHardDeleteVersion builder with application/json body
func NewArtifactsHardDeleteVersionRequest(server string, body ArtifactsHardDeleteVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsHardDeleteVersionRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsHardDeleteVersionRequestWithBody generates requests for ArtifactsHardDeleteVersion with any type of body
func NewArtifactsHardDeleteVersionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.versions.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsVersionsPrepareRequest calls the generic ArtifactsVersionsPrepare builder with application/json body
func NewArtifactsVersionsPrepareRequest(server string, body ArtifactsVersionsPrepareJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsVersionsPrepareRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsVersionsPrepareRequestWithBody generates requests for ArtifactsVersionsPrepare with any type of body
func NewArtifactsVersionsPrepareRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.versions.prepare")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAtomsGetRequest generates requests for AtomsGet
func NewAtomsGetRequest(server string, params *AtomsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/atoms.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAtomsGetPostRequest calls the generic AtomsGetPost builder with application/json body
func NewAtomsGetPostRequest(server string, body AtomsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAtomsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAtomsGetPostRequestWithBody generates requests for AtomsGetPost with any type of body
func NewAtomsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/atoms.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensCreateRequest calls the generic AuthTokensCreate builder with application/json body
func NewAuthTokensCreateRequest(server string, body AuthTokensCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensCreateRequestWithBody generates requests for AuthTokensCreate with any type of body
func NewAuthTokensCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensDeleteRequest calls the generic AuthTokensDelete builder with application/json body
func NewAuthTokensDeleteRequest(server string, body AuthTokensDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensDeleteRequestWithBody generates requests for AuthTokensDelete with any type of body
func NewAuthTokensDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensGetRequest generates requests for AuthTokensGet
func NewAuthTokensGetRequest(server string, params *AuthTokensGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "token_id", runtime.ParamLocationQuery, params.TokenId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthTokensGetPostRequest calls the generic AuthTokensGetPost builder with application/json body
func NewAuthTokensGetPostRequest(server string, body AuthTokensGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensGetPostRequestWithBody generates requests for AuthTokensGetPost with any type of body
func NewAuthTokensGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensInfoRequest generates requests for AuthTokensInfo
func NewAuthTokensInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthTokensInfoPostRequest calls the generic AuthTokensInfoPost builder with application/json body
func NewAuthTokensInfoPostRequest(server string, body AuthTokensInfoPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensInfoPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensInfoPostRequestWithBody generates requests for AuthTokensInfoPost with any type of body
func NewAuthTokensInfoPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensListRequest generates requests for AuthTokensList
func NewAuthTokensListRequest(server string, params *AuthTokensListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestedTokenType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "requested_token_type", runtime.ParamLocationQuery, *params.RequestedTokenType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthTokensListPostRequest calls the generic AuthTokensListPost builder with application/json body
func NewAuthTokensListPostRequest(server string, body AuthTokensListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensListPostRequestWithBody generates requests for AuthTokensListPost with any type of body
func NewAuthTokensListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensSelfDeleteRequest calls the generic AuthTokensSelfDelete builder with application/json body
func NewAuthTokensSelfDeleteRequest(server string, body AuthTokensSelfDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensSelfDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensSelfDeleteRequestWithBody generates requests for AuthTokensSelfDelete with any type of body
func NewAuthTokensSelfDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.self.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensUpdateRequest calls the generic AuthTokensUpdate builder with application/json body
func NewAuthTokensUpdateRequest(server string, body AuthTokensUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensUpdateRequestWithBody generates requests for AuthTokensUpdate with any type of body
func NewAuthTokensUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatsCreateRequest calls the generic ChatsCreate builder with application/json body
func NewChatsCreateRequest(server string, body ChatsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewChatsCreateRequestWithBody generates requests for ChatsCreate with any type of body
func NewChatsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatsGetRequest generates requests for ChatsGet
func NewChatsGetRequest(server string, params *ChatsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatsGetPostRequest calls the generic ChatsGetPost builder with application/json body
func NewChatsGetPostRequest(server string, body ChatsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewChatsGetPostRequestWithBody generates requests for ChatsGetPost with any type of body
func NewChatsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatsUpdateRequest calls the generic ChatsUpdate builder with application/json body
func NewChatsUpdateRequest(server string, body ChatsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewChatsUpdateRequestWithBody generates requests for ChatsUpdate with any type of body
func NewChatsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesCreateRequest calls the generic CodeChangesCreate builder with application/json body
func NewCodeChangesCreateRequest(server string, body CodeChangesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesCreateRequestWithBody generates requests for CodeChangesCreate with any type of body
func NewCodeChangesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesDeleteRequest calls the generic CodeChangesDelete builder with application/json body
func NewCodeChangesDeleteRequest(server string, body CodeChangesDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesDeleteRequestWithBody generates requests for CodeChangesDelete with any type of body
func NewCodeChangesDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesGetRequest generates requests for CodeChangesGet
func NewCodeChangesGetRequest(server string, params *CodeChangesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeChangesGetPostRequest calls the generic CodeChangesGetPost builder with application/json body
func NewCodeChangesGetPostRequest(server string, body CodeChangesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesGetPostRequestWithBody generates requests for CodeChangesGetPost with any type of body
func NewCodeChangesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesListRequest generates requests for CodeChangesList
func NewCodeChangesListRequest(server string, params *CodeChangesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeChangesListPostRequest calls the generic CodeChangesListPost builder with application/json body
func NewCodeChangesListPostRequest(server string, body CodeChangesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesListPostRequestWithBody generates requests for CodeChangesListPost with any type of body
func NewCodeChangesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesUpdateRequest calls the generic CodeChangesUpdate builder with application/json body
func NewCodeChangesUpdateRequest(server string, body CodeChangesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesUpdateRequestWithBody generates requests for CodeChangesUpdate with any type of body
func NewCodeChangesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommandsCreateRequest calls the generic CommandsCreate builder with application/json body
func NewCommandsCreateRequest(server string, body CommandsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommandsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCommandsCreateRequestWithBody generates requests for CommandsCreate with any type of body
func NewCommandsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommandsGetRequest generates requests for CommandsGet
func NewCommandsGetRequest(server string, params *CommandsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommandsGetPostRequest calls the generic CommandsGetPost builder with application/json body
func NewCommandsGetPostRequest(server string, body CommandsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommandsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCommandsGetPostRequestWithBody generates requests for CommandsGetPost with any type of body
func NewCommandsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommandsListRequest generates requests for CommandsList
func NewCommandsListRequest(server string, params *CommandsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutorType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "executor_type", runtime.ParamLocationQuery, *params.ExecutorType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_object_id", runtime.ParamLocationQuery, *params.SourceObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommandsListPostRequest calls the generic CommandsListPost builder with application/json body
func NewCommandsListPostRequest(server string, body CommandsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommandsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCommandsListPostRequestWithBody generates requests for CommandsListPost with any type of body
func NewCommandsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommandsUpdateRequest calls the generic CommandsUpdate builder with application/json body
func NewCommandsUpdateRequest(server string, body CommandsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommandsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewCommandsUpdateRequestWithBody generates requests for CommandsUpdate with any type of body
func NewCommandsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsCreateRequest calls the generic ConversationsCreate builder with application/json body
func NewConversationsCreateRequest(server string, body ConversationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsCreateRequestWithBody generates requests for ConversationsCreate with any type of body
func NewConversationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsDeleteRequest calls the generic ConversationsDelete builder with application/json body
func NewConversationsDeleteRequest(server string, body ConversationsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsDeleteRequestWithBody generates requests for ConversationsDelete with any type of body
func NewConversationsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsGetRequest generates requests for ConversationsGet
func NewConversationsGetRequest(server string, params *ConversationsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConversationsGetPostRequest calls the generic ConversationsGetPost builder with application/json body
func NewConversationsGetPostRequest(server string, body ConversationsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsGetPostRequestWithBody generates requests for ConversationsGetPost with any type of body
func NewConversationsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsListRequest generates requests for ConversationsList
func NewConversationsListRequest(server string, params *ConversationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_parts", runtime.ParamLocationQuery, *params.AppliesToParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Brand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "brand", runtime.ParamLocationQuery, *params.Brand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "channels", runtime.ParamLocationQuery, *params.Channels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsCreatorVerified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_creator_verified", runtime.ParamLocationQuery, *params.IsCreatorVerified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFrozen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_frozen", runtime.ParamLocationQuery, *params.IsFrozen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSpam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_spam", runtime.ParamLocationQuery, *params.IsSpam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Members != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "members", runtime.ParamLocationQuery, *params.Members); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_org", runtime.ParamLocationQuery, *params.RevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrgs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_orgs", runtime.ParamLocationQuery, *params.RevOrgs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sla_summary.stage", runtime.ParamLocationQuery, *params.SlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_channel", runtime.ParamLocationQuery, *params.SourceChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceChannelV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_channel_v2", runtime.ParamLocationQuery, *params.SourceChannelV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_channels", runtime.ParamLocationQuery, *params.SourceChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage.name", runtime.ParamLocationQuery, *params.StageName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagsV2Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags_v2.id", runtime.ParamLocationQuery, *params.TagsV2Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagsV2Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags_v2.value", runtime.ParamLocationQuery, *params.TagsV2Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConversationsListPostRequest calls the generic ConversationsListPost builder with application/json body
func NewConversationsListPostRequest(server string, body ConversationsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsListPostRequestWithBody generates requests for ConversationsListPost with any type of body
func NewConversationsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsUpdateRequest calls the generic ConversationsUpdate builder with application/json body
func NewConversationsUpdateRequest(server string, body ConversationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsUpdateRequestWithBody generates requests for ConversationsUpdate with any type of body
func NewConversationsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsCreateRequest calls the generic DevOrgAuthConnectionsCreate builder with application/json body
func NewDevOrgAuthConnectionsCreateRequest(server string, body DevOrgAuthConnectionsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsCreateRequestWithBody generates requests for DevOrgAuthConnectionsCreate with any type of body
func NewDevOrgAuthConnectionsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsDeleteRequest calls the generic DevOrgAuthConnectionsDelete builder with application/json body
func NewDevOrgAuthConnectionsDeleteRequest(server string, body DevOrgAuthConnectionsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsDeleteRequestWithBody generates requests for DevOrgAuthConnectionsDelete with any type of body
func NewDevOrgAuthConnectionsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsGetRequest generates requests for DevOrgAuthConnectionsGet
func NewDevOrgAuthConnectionsGetRequest(server string, params *DevOrgAuthConnectionsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevOrgAuthConnectionsGetPostRequest calls the generic DevOrgAuthConnectionsGetPost builder with application/json body
func NewDevOrgAuthConnectionsGetPostRequest(server string, body DevOrgAuthConnectionsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsGetPostRequestWithBody generates requests for DevOrgAuthConnectionsGetPost with any type of body
func NewDevOrgAuthConnectionsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsListRequest generates requests for DevOrgAuthConnectionsList
func NewDevOrgAuthConnectionsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevOrgAuthConnectionsListPostRequest calls the generic DevOrgAuthConnectionsListPost builder with application/json body
func NewDevOrgAuthConnectionsListPostRequest(server string, body DevOrgAuthConnectionsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsListPostRequestWithBody generates requests for DevOrgAuthConnectionsListPost with any type of body
func NewDevOrgAuthConnectionsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsToggleRequest calls the generic DevOrgAuthConnectionsToggle builder with application/json body
func NewDevOrgAuthConnectionsToggleRequest(server string, body DevOrgAuthConnectionsToggleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsToggleRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsToggleRequestWithBody generates requests for DevOrgAuthConnectionsToggle with any type of body
func NewDevOrgAuthConnectionsToggleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.toggle")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsUpdateRequest calls the generic DevOrgAuthConnectionsUpdate builder with application/json body
func NewDevOrgAuthConnectionsUpdateRequest(server string, body DevOrgAuthConnectionsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsUpdateRequestWithBody generates requests for DevOrgAuthConnectionsUpdate with any type of body
func NewDevOrgAuthConnectionsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgsGetRequest generates requests for DevOrgsGet
func NewDevOrgsGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevOrgsGetPostRequest calls the generic DevOrgsGetPost builder with application/json body
func NewDevOrgsGetPostRequest(server string, body DevOrgsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgsGetPostRequestWithBody generates requests for DevOrgsGetPost with any type of body
func NewDevOrgsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersActivateRequest calls the generic DevUsersActivate builder with application/json body
func NewDevUsersActivateRequest(server string, body DevUsersActivateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersActivateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersActivateRequestWithBody generates requests for DevUsersActivate with any type of body
func NewDevUsersActivateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.activate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersCreateRequest calls the generic DevUsersCreate builder with application/json body
func NewDevUsersCreateRequest(server string, body DevUsersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersCreateRequestWithBody generates requests for DevUsersCreate with any type of body
func NewDevUsersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersDeactivateRequest calls the generic DevUsersDeactivate builder with application/json body
func NewDevUsersDeactivateRequest(server string, body DevUsersDeactivateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersDeactivateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersDeactivateRequestWithBody generates requests for DevUsersDeactivate with any type of body
func NewDevUsersDeactivateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.deactivate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersGetRequest generates requests for DevUsersGet
func NewDevUsersGetRequest(server string, params *DevUsersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevUsersGetPostRequest calls the generic DevUsersGetPost builder with application/json body
func NewDevUsersGetPostRequest(server string, body DevUsersGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersGetPostRequestWithBody generates requests for DevUsersGetPost with any type of body
func NewDevUsersGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersIdentitiesLinkRequest calls the generic DevUsersIdentitiesLink builder with application/json body
func NewDevUsersIdentitiesLinkRequest(server string, body DevUsersIdentitiesLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersIdentitiesLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersIdentitiesLinkRequestWithBody generates requests for DevUsersIdentitiesLink with any type of body
func NewDevUsersIdentitiesLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.identities.link")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersIdentitiesUnlinkRequest calls the generic DevUsersIdentitiesUnlink builder with application/json body
func NewDevUsersIdentitiesUnlinkRequest(server string, body DevUsersIdentitiesUnlinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersIdentitiesUnlinkRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersIdentitiesUnlinkRequestWithBody generates requests for DevUsersIdentitiesUnlink with any type of body
func NewDevUsersIdentitiesUnlinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.identities.unlink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersListRequest generates requests for DevUsersList
func NewDevUsersListRequest(server string, params *DevUsersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalIdentityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_identity.id", runtime.ParamLocationQuery, *params.ExternalIdentityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalIdentityIssuer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_identity.issuer", runtime.ParamLocationQuery, *params.ExternalIdentityIssuer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevUsersListPostRequest calls the generic DevUsersListPost builder with application/json body
func NewDevUsersListPostRequest(server string, body DevUsersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersListPostRequestWithBody generates requests for DevUsersListPost with any type of body
func NewDevUsersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersMergeRequest calls the generic DevUsersMerge builder with application/json body
func NewDevUsersMergeRequest(server string, body DevUsersMergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersMergeRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersMergeRequestWithBody generates requests for DevUsersMerge with any type of body
func NewDevUsersMergeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersSelfRequest generates requests for DevUsersSelf
func NewDevUsersSelfRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevUsersSelfPostRequest calls the generic DevUsersSelfPost builder with application/json body
func NewDevUsersSelfPostRequest(server string, body DevUsersSelfPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersSelfPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersSelfPostRequestWithBody generates requests for DevUsersSelfPost with any type of body
func NewDevUsersSelfPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersSelfUpdateRequest calls the generic DevUsersSelfUpdate builder with application/json body
func NewDevUsersSelfUpdateRequest(server string, body DevUsersSelfUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersSelfUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersSelfUpdateRequestWithBody generates requests for DevUsersSelfUpdate with any type of body
func NewDevUsersSelfUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.self.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersUpdateRequest calls the generic DevUsersUpdate builder with application/json body
func NewDevUsersUpdateRequest(server string, body DevUsersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersUpdateRequestWithBody generates requests for DevUsersUpdate with any type of body
func NewDevUsersUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesCountRequest generates requests for DirectoriesCount
func NewDirectoriesCountRequest(server string, params *DirectoriesCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDirectoriesCountPostRequest calls the generic DirectoriesCountPost builder with application/json body
func NewDirectoriesCountPostRequest(server string, body DirectoriesCountPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesCountPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesCountPostRequestWithBody generates requests for DirectoriesCountPost with any type of body
func NewDirectoriesCountPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesCreateRequest calls the generic DirectoriesCreate builder with application/json body
func NewDirectoriesCreateRequest(server string, body DirectoriesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesCreateRequestWithBody generates requests for DirectoriesCreate with any type of body
func NewDirectoriesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesDeleteRequest calls the generic DirectoriesDelete builder with application/json body
func NewDirectoriesDeleteRequest(server string, body DirectoriesDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesDeleteRequestWithBody generates requests for DirectoriesDelete with any type of body
func NewDirectoriesDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesGetRequest generates requests for DirectoriesGet
func NewDirectoriesGetRequest(server string, params *DirectoriesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dev_org", runtime.ParamLocationQuery, *params.DevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDirectoriesGetPostRequest calls the generic DirectoriesGetPost builder with application/json body
func NewDirectoriesGetPostRequest(server string, body DirectoriesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesGetPostRequestWithBody generates requests for DirectoriesGetPost with any type of body
func NewDirectoriesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesListRequest generates requests for DirectoriesList
func NewDirectoriesListRequest(server string, params *DirectoriesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dev_org", runtime.ParamLocationQuery, *params.DevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDirectoriesListPostRequest calls the generic DirectoriesListPost builder with application/json body
func NewDirectoriesListPostRequest(server string, body DirectoriesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesListPostRequestWithBody generates requests for DirectoriesListPost with any type of body
func NewDirectoriesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesUpdateRequest calls the generic DirectoriesUpdate builder with application/json body
func NewDirectoriesUpdateRequest(server string, body DirectoriesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesUpdateRequestWithBody generates requests for DirectoriesUpdate with any type of body
func NewDirectoriesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupsCreateRequest calls the generic GroupsCreate builder with application/json body
func NewGroupsCreateRequest(server string, body GroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupsCreateRequestWithBody generates requests for GroupsCreate with any type of body
func NewGroupsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupsGetRequest generates requests for GroupsGet
func NewGroupsGetRequest(server string, params *GroupsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupsGetPostRequest calls the generic GroupsGetPost builder with application/json body
func NewGroupsGetPostRequest(server string, body GroupsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupsGetPostRequestWithBody generates requests for GroupsGetPost with any type of body
func NewGroupsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupsListRequest generates requests for GroupsList
func NewGroupsListRequest(server string, params *GroupsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group_type", runtime.ParamLocationQuery, *params.GroupType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IngestionSource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ingestion_source", runtime.ParamLocationQuery, *params.IngestionSource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDefault != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_default", runtime.ParamLocationQuery, *params.IsDefault); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_type", runtime.ParamLocationQuery, *params.MemberType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataExternalReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.external_reference", runtime.ParamLocationQuery, *params.SyncMetadataExternalReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataOriginSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.origin_system", runtime.ParamLocationQuery, *params.SyncMetadataOriginSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupsListPostRequest calls the generic GroupsListPost builder with application/json body
func NewGroupsListPostRequest(server string, body GroupsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupsListPostRequestWithBody generates requests for GroupsListPost with any type of body
func NewGroupsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupMembersAddRequest calls the generic GroupMembersAdd builder with application/json body
func NewGroupMembersAddRequest(server string, body GroupMembersAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupMembersAddRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupMembersAddRequestWithBody generates requests for GroupMembersAdd with any type of body
func NewGroupMembersAddRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.members.add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupMembersListRequest generates requests for GroupMembersList
func NewGroupMembersListRequest(server string, params *GroupMembersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.members.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group", runtime.ParamLocationQuery, params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupMembersListPostRequest calls the generic GroupMembersListPost builder with application/json body
func NewGroupMembersListPostRequest(server string, body GroupMembersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupMembersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupMembersListPostRequestWithBody generates requests for GroupMembersListPost with any type of body
func NewGroupMembersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.members.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupMembersRemoveRequest calls the generic GroupMembersRemove builder with application/json body
func NewGroupMembersRemoveRequest(server string, body GroupMembersRemoveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupMembersRemoveRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupMembersRemoveRequestWithBody generates requests for GroupMembersRemove with any type of body
func NewGroupMembersRemoveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.members.remove")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupsUpdateRequest calls the generic GroupsUpdate builder with application/json body
func NewGroupsUpdateRequest(server string, body GroupsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupsUpdateRequestWithBody generates requests for GroupsUpdate with any type of body
func NewGroupsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewKeyringsCreateCallbackRequest generates requests for KeyringsCreateCallback
func NewKeyringsCreateCallbackRequest(server string, params *KeyringsCreateCallbackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keyrings.authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "code", runtime.ParamLocationQuery, params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewKeyringsCreateCallbackPostRequest calls the generic KeyringsCreateCallbackPost builder with application/json body
func NewKeyringsCreateCallbackPostRequest(server string, body KeyringsCreateCallbackPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewKeyringsCreateCallbackPostRequestWithBody(server, "application/json", bodyReader)
}

// NewKeyringsCreateCallbackPostRequestWithBody generates requests for KeyringsCreateCallbackPost with any type of body
func NewKeyringsCreateCallbackPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keyrings.authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksCreateRequest calls the generic LinksCreate builder with application/json body
func NewLinksCreateRequest(server string, body LinksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksCreateRequestWithBody generates requests for LinksCreate with any type of body
func NewLinksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksDeleteRequest calls the generic LinksDelete builder with application/json body
func NewLinksDeleteRequest(server string, body LinksDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksDeleteRequestWithBody generates requests for LinksDelete with any type of body
func NewLinksDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksGetRequest generates requests for LinksGet
func NewLinksGetRequest(server string, params *LinksGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinksGetPostRequest calls the generic LinksGetPost builder with application/json body
func NewLinksGetPostRequest(server string, body LinksGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksGetPostRequestWithBody generates requests for LinksGetPost with any type of body
func NewLinksGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksListRequest generates requests for LinksList
func NewLinksListRequest(server string, params *LinksListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object", runtime.ParamLocationQuery, params.Object); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "link_type", runtime.ParamLocationQuery, *params.LinkType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object_types", runtime.ParamLocationQuery, *params.ObjectTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinksListPostRequest calls the generic LinksListPost builder with application/json body
func NewLinksListPostRequest(server string, body LinksListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksListPostRequestWithBody generates requests for LinksListPost with any type of body
func NewLinksListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksReplaceRequest calls the generic LinksReplace builder with application/json body
func NewLinksReplaceRequest(server string, body LinksReplaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksReplaceRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksReplaceRequestWithBody generates requests for LinksReplace with any type of body
func NewLinksReplaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.replace")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsCountRequest generates requests for MeetingsCount
func NewMeetingsCountRequest(server string, params *MeetingsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Channel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "channel", runtime.ParamLocationQuery, *params.Channel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksLinkType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.link_type", runtime.ParamLocationQuery, *params.LinksLinkType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksTarget != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.target", runtime.ParamLocationQuery, *params.LinksTarget); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksTargetObjectType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.target_object_type", runtime.ParamLocationQuery, *params.LinksTargetObjectType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Members != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "members", runtime.ParamLocationQuery, *params.Members); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Organizer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "organizer", runtime.ParamLocationQuery, *params.Organizer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingsCountPostRequest calls the generic MeetingsCountPost builder with application/json body
func NewMeetingsCountPostRequest(server string, body MeetingsCountPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsCountPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsCountPostRequestWithBody generates requests for MeetingsCountPost with any type of body
func NewMeetingsCountPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsCreateRequest calls the generic MeetingsCreate builder with application/json body
func NewMeetingsCreateRequest(server string, body MeetingsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsCreateRequestWithBody generates requests for MeetingsCreate with any type of body
func NewMeetingsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsDeleteRequest calls the generic MeetingsDelete builder with application/json body
func NewMeetingsDeleteRequest(server string, body MeetingsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsDeleteRequestWithBody generates requests for MeetingsDelete with any type of body
func NewMeetingsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsGetRequest generates requests for MeetingsGet
func NewMeetingsGetRequest(server string, params *MeetingsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingsGetPostRequest calls the generic MeetingsGetPost builder with application/json body
func NewMeetingsGetPostRequest(server string, body MeetingsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsGetPostRequestWithBody generates requests for MeetingsGetPost with any type of body
func NewMeetingsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsListRequest generates requests for MeetingsList
func NewMeetingsListRequest(server string, params *MeetingsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Channel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "channel", runtime.ParamLocationQuery, *params.Channel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksLinkType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.link_type", runtime.ParamLocationQuery, *params.LinksLinkType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksTarget != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.target", runtime.ParamLocationQuery, *params.LinksTarget); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksTargetObjectType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.target_object_type", runtime.ParamLocationQuery, *params.LinksTargetObjectType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Members != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "members", runtime.ParamLocationQuery, *params.Members); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Organizer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "organizer", runtime.ParamLocationQuery, *params.Organizer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingsListPostRequest calls the generic MeetingsListPost builder with application/json body
func NewMeetingsListPostRequest(server string, body MeetingsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsListPostRequestWithBody generates requests for MeetingsListPost with any type of body
func NewMeetingsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsUpdateRequest calls the generic MeetingsUpdate builder with application/json body
func NewMeetingsUpdateRequest(server string, body MeetingsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsUpdateRequestWithBody generates requests for MeetingsUpdate with any type of body
func NewMeetingsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricActionExecuteRequest calls the generic MetricActionExecute builder with application/json body
func NewMetricActionExecuteRequest(server string, body MetricActionExecuteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricActionExecuteRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricActionExecuteRequestWithBody generates requests for MetricActionExecute with any type of body
func NewMetricActionExecuteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-action.execute")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsCreateRequest calls the generic MetricDefinitionsCreate builder with application/json body
func NewMetricDefinitionsCreateRequest(server string, body MetricDefinitionsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsCreateRequestWithBody generates requests for MetricDefinitionsCreate with any type of body
func NewMetricDefinitionsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsDeleteRequest calls the generic MetricDefinitionsDelete builder with application/json body
func NewMetricDefinitionsDeleteRequest(server string, body MetricDefinitionsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsDeleteRequestWithBody generates requests for MetricDefinitionsDelete with any type of body
func NewMetricDefinitionsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsGetRequest generates requests for MetricDefinitionsGet
func NewMetricDefinitionsGetRequest(server string, params *MetricDefinitionsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricDefinitionsGetPostRequest calls the generic MetricDefinitionsGetPost builder with application/json body
func NewMetricDefinitionsGetPostRequest(server string, body MetricDefinitionsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsGetPostRequestWithBody generates requests for MetricDefinitionsGetPost with any type of body
func NewMetricDefinitionsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsListRequest generates requests for MetricDefinitionsList
func NewMetricDefinitionsListRequest(server string, params *MetricDefinitionsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_type", runtime.ParamLocationQuery, *params.AppliesToType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeCustomMetrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include_custom_metrics", runtime.ParamLocationQuery, *params.IncludeCustomMetrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricDefinitionsListPostRequest calls the generic MetricDefinitionsListPost builder with application/json body
func NewMetricDefinitionsListPostRequest(server string, body MetricDefinitionsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsListPostRequestWithBody generates requests for MetricDefinitionsListPost with any type of body
func NewMetricDefinitionsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsUpdateRequest calls the generic MetricDefinitionsUpdate builder with application/json body
func NewMetricDefinitionsUpdateRequest(server string, body MetricDefinitionsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsUpdateRequestWithBody generates requests for MetricDefinitionsUpdate with any type of body
func NewMetricDefinitionsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricTrackersGetRequest generates requests for MetricTrackersGet
func NewMetricTrackersGetRequest(server string, params *MetricTrackersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-trackers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metric", runtime.ParamLocationQuery, params.Metric); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object", runtime.ParamLocationQuery, params.Object); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricTrackersGetPostRequest calls the generic MetricTrackersGetPost builder with application/json body
func NewMetricTrackersGetPostRequest(server string, body MetricTrackersGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricTrackersGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricTrackersGetPostRequestWithBody generates requests for MetricTrackersGetPost with any type of body
func NewMetricTrackersGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-trackers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgScheduleFragmentsCreateRequest calls the generic OrgScheduleFragmentsCreate builder with application/json body
func NewOrgScheduleFragmentsCreateRequest(server string, body OrgScheduleFragmentsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgScheduleFragmentsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgScheduleFragmentsCreateRequestWithBody generates requests for OrgScheduleFragmentsCreate with any type of body
func NewOrgScheduleFragmentsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedule-fragments.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgScheduleFragmentsGetRequest generates requests for OrgScheduleFragmentsGet
func NewOrgScheduleFragmentsGetRequest(server string, params *OrgScheduleFragmentsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedule-fragments.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgScheduleFragmentsGetPostRequest calls the generic OrgScheduleFragmentsGetPost builder with application/json body
func NewOrgScheduleFragmentsGetPostRequest(server string, body OrgScheduleFragmentsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgScheduleFragmentsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgScheduleFragmentsGetPostRequestWithBody generates requests for OrgScheduleFragmentsGetPost with any type of body
func NewOrgScheduleFragmentsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedule-fragments.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgScheduleFragmentsTransitionRequest calls the generic OrgScheduleFragmentsTransition builder with application/json body
func NewOrgScheduleFragmentsTransitionRequest(server string, body OrgScheduleFragmentsTransitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgScheduleFragmentsTransitionRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgScheduleFragmentsTransitionRequestWithBody generates requests for OrgScheduleFragmentsTransition with any type of body
func NewOrgScheduleFragmentsTransitionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedule-fragments.transition")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesCreateRequest calls the generic OrgSchedulesCreate builder with application/json body
func NewOrgSchedulesCreateRequest(server string, body OrgSchedulesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesCreateRequestWithBody generates requests for OrgSchedulesCreate with any type of body
func NewOrgSchedulesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesEvaluateRequest generates requests for OrgSchedulesEvaluate
func NewOrgSchedulesEvaluateRequest(server string, params *OrgSchedulesEvaluateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.evaluate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instants", runtime.ParamLocationQuery, params.Instants); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgSchedulesEvaluatePostRequest calls the generic OrgSchedulesEvaluatePost builder with application/json body
func NewOrgSchedulesEvaluatePostRequest(server string, body OrgSchedulesEvaluatePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesEvaluatePostRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesEvaluatePostRequestWithBody generates requests for OrgSchedulesEvaluatePost with any type of body
func NewOrgSchedulesEvaluatePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.evaluate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesGetRequest generates requests for OrgSchedulesGet
func NewOrgSchedulesGetRequest(server string, params *OrgSchedulesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgSchedulesGetPostRequest calls the generic OrgSchedulesGetPost builder with application/json body
func NewOrgSchedulesGetPostRequest(server string, body OrgSchedulesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesGetPostRequestWithBody generates requests for OrgSchedulesGetPost with any type of body
func NewOrgSchedulesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesListRequest generates requests for OrgSchedulesList
func NewOrgSchedulesListRequest(server string, params *OrgSchedulesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedById != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by_id", runtime.ParamLocationQuery, *params.CreatedById); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgSchedulesListPostRequest calls the generic OrgSchedulesListPost builder with application/json body
func NewOrgSchedulesListPostRequest(server string, body OrgSchedulesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesListPostRequestWithBody generates requests for OrgSchedulesListPost with any type of body
func NewOrgSchedulesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesSetFutureRequest calls the generic OrgSchedulesSetFuture builder with application/json body
func NewOrgSchedulesSetFutureRequest(server string, body OrgSchedulesSetFutureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesSetFutureRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesSetFutureRequestWithBody generates requests for OrgSchedulesSetFuture with any type of body
func NewOrgSchedulesSetFutureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.set-future")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesTransitionRequest calls the generic OrgSchedulesTransition builder with application/json body
func NewOrgSchedulesTransitionRequest(server string, body OrgSchedulesTransitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesTransitionRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesTransitionRequestWithBody generates requests for OrgSchedulesTransition with any type of body
func NewOrgSchedulesTransitionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.transition")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesUpdateRequest calls the generic OrgSchedulesUpdate builder with application/json body
func NewOrgSchedulesUpdateRequest(server string, body OrgSchedulesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesUpdateRequestWithBody generates requests for OrgSchedulesUpdate with any type of body
func NewOrgSchedulesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsCreateRequest calls the generic PartsCreate builder with application/json body
func NewPartsCreateRequest(server string, body PartsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsCreateRequestWithBody generates requests for PartsCreate with any type of body
func NewPartsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsDeleteRequest calls the generic PartsDelete builder with application/json body
func NewPartsDeleteRequest(server string, body PartsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsDeleteRequestWithBody generates requests for PartsDelete with any type of body
func NewPartsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsGetRequest generates requests for PartsGet
func NewPartsGetRequest(server string, params *PartsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPartsGetPostRequest calls the generic PartsGetPost builder with application/json body
func NewPartsGetPostRequest(server string, body PartsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsGetPostRequestWithBody generates requests for PartsGetPost with any type of body
func NewPartsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsListRequest generates requests for PartsList
func NewPartsListRequest(server string, params *PartsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentPartLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_part.level", runtime.ParamLocationQuery, *params.ParentPartLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentPartParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_part.parts", runtime.ParamLocationQuery, *params.ParentPartParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPartsListPostRequest calls the generic PartsListPost builder with application/json body
func NewPartsListPostRequest(server string, body PartsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsListPostRequestWithBody generates requests for PartsListPost with any type of body
func NewPartsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsUpdateRequest calls the generic PartsUpdate builder with application/json body
func NewPartsUpdateRequest(server string, body PartsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsUpdateRequestWithBody generates requests for PartsUpdate with any type of body
func NewPartsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsListRequest generates requests for ReactionsList
func NewReactionsListRequest(server string, params *ReactionsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reactions.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "emoji", runtime.ParamLocationQuery, params.Emoji); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object", runtime.ParamLocationQuery, params.Object); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionsListPostRequest calls the generic ReactionsListPost builder with application/json body
func NewReactionsListPostRequest(server string, body ReactionsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewReactionsListPostRequestWithBody generates requests for ReactionsListPost with any type of body
func NewReactionsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reactions.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsUpdateRequest calls the generic ReactionsUpdate builder with application/json body
func NewReactionsUpdateRequest(server string, body ReactionsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewReactionsUpdateRequestWithBody generates requests for ReactionsUpdate with any type of body
func NewReactionsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reactions.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsCreateRequest calls the generic RevOrgsCreate builder with application/json body
func NewRevOrgsCreateRequest(server string, body RevOrgsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsCreateRequestWithBody generates requests for RevOrgsCreate with any type of body
func NewRevOrgsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsDeleteRequest calls the generic RevOrgsDelete builder with application/json body
func NewRevOrgsDeleteRequest(server string, body RevOrgsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsDeleteRequestWithBody generates requests for RevOrgsDelete with any type of body
func NewRevOrgsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsGetRequest generates requests for RevOrgsGet
func NewRevOrgsGetRequest(server string, params *RevOrgsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevOrgsGetPostRequest calls the generic RevOrgsGetPost builder with application/json body
func NewRevOrgsGetPostRequest(server string, body RevOrgsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsGetPostRequestWithBody generates requests for RevOrgsGetPost with any type of body
func NewRevOrgsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsListRequest generates requests for RevOrgsList
func NewRevOrgsListRequest(server string, params *RevOrgsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "display_name", runtime.ParamLocationQuery, *params.DisplayName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevOrgsListPostRequest calls the generic RevOrgsListPost builder with application/json body
func NewRevOrgsListPostRequest(server string, body RevOrgsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsListPostRequestWithBody generates requests for RevOrgsListPost with any type of body
func NewRevOrgsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsUpdateRequest calls the generic RevOrgsUpdate builder with application/json body
func NewRevOrgsUpdateRequest(server string, body RevOrgsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsUpdateRequestWithBody generates requests for RevOrgsUpdate with any type of body
func NewRevOrgsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersCreateRequest calls the generic RevUsersCreate builder with application/json body
func NewRevUsersCreateRequest(server string, body RevUsersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersCreateRequestWithBody generates requests for RevUsersCreate with any type of body
func NewRevUsersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersDeleteRequest calls the generic RevUsersDelete builder with application/json body
func NewRevUsersDeleteRequest(server string, body RevUsersDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersDeleteRequestWithBody generates requests for RevUsersDelete with any type of body
func NewRevUsersDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersGetRequest generates requests for RevUsersGet
func NewRevUsersGetRequest(server string, params *RevUsersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevUsersGetPostRequest calls the generic RevUsersGetPost builder with application/json body
func NewRevUsersGetPostRequest(server string, body RevUsersGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersGetPostRequestWithBody generates requests for RevUsersGetPost with any type of body
func NewRevUsersGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersListRequest generates requests for RevUsersList
func NewRevUsersListRequest(server string, params *RevUsersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Associations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "associations", runtime.ParamLocationQuery, *params.Associations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsVerified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_verified", runtime.ParamLocationQuery, *params.IsVerified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PhoneNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "phone_numbers", runtime.ParamLocationQuery, *params.PhoneNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_org", runtime.ParamLocationQuery, *params.RevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevUsersListPostRequest calls the generic RevUsersListPost builder with application/json body
func NewRevUsersListPostRequest(server string, body RevUsersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersListPostRequestWithBody generates requests for RevUsersListPost with any type of body
func NewRevUsersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersMergeRequest calls the generic RevUsersMerge builder with application/json body
func NewRevUsersMergeRequest(server string, body RevUsersMergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersMergeRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersMergeRequestWithBody generates requests for RevUsersMerge with any type of body
func NewRevUsersMergeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersScanRequest generates requests for RevUsersScan
func NewRevUsersScanRequest(server string, params *RevUsersScanParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.scan")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Associations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "associations", runtime.ParamLocationQuery, *params.Associations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsVerified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_verified", runtime.ParamLocationQuery, *params.IsVerified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PhoneNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "phone_numbers", runtime.ParamLocationQuery, *params.PhoneNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_org", runtime.ParamLocationQuery, *params.RevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevUsersScanPostRequest calls the generic RevUsersScanPost builder with application/json body
func NewRevUsersScanPostRequest(server string, body RevUsersScanPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersScanPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersScanPostRequestWithBody generates requests for RevUsersScanPost with any type of body
func NewRevUsersScanPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.scan")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersUpdateRequest calls the generic RevUsersUpdate builder with application/json body
func NewRevUsersUpdateRequest(server string, body RevUsersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersUpdateRequestWithBody generates requests for RevUsersUpdate with any type of body
func NewRevUsersUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewServiceAccountsCreateRequest calls the generic ServiceAccountsCreate builder with application/json body
func NewServiceAccountsCreateRequest(server string, body ServiceAccountsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewServiceAccountsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewServiceAccountsCreateRequestWithBody generates requests for ServiceAccountsCreate with any type of body
func NewServiceAccountsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewServiceAccountsGetRequest generates requests for ServiceAccountsGet
func NewServiceAccountsGetRequest(server string, params *ServiceAccountsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServiceAccountsGetPostRequest calls the generic ServiceAccountsGetPost builder with application/json body
func NewServiceAccountsGetPostRequest(server string, body ServiceAccountsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewServiceAccountsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewServiceAccountsGetPostRequestWithBody generates requests for ServiceAccountsGetPost with any type of body
func NewServiceAccountsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlaTrackersGetRequest generates requests for SlaTrackersGet
func NewSlaTrackersGetRequest(server string, params *SlaTrackersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sla-trackers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlaTrackersGetPostRequest calls the generic SlaTrackersGetPost builder with application/json body
func NewSlaTrackersGetPostRequest(server string, body SlaTrackersGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlaTrackersGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSlaTrackersGetPostRequestWithBody generates requests for SlaTrackersGetPost with any type of body
func NewSlaTrackersGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sla-trackers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlaTrackersListRequest generates requests for SlaTrackersList
func NewSlaTrackersListRequest(server string, params *SlaTrackersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sla-trackers.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage", runtime.ParamLocationQuery, *params.Stage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlaTrackersListPostRequest calls the generic SlaTrackersListPost builder with application/json body
func NewSlaTrackersListPostRequest(server string, body SlaTrackersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlaTrackersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSlaTrackersListPostRequestWithBody generates requests for SlaTrackersListPost with any type of body
func NewSlaTrackersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sla-trackers.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasAssignRequest calls the generic SlasAssign builder with application/json body
func NewSlasAssignRequest(server string, body SlasAssignJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasAssignRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasAssignRequestWithBody generates requests for SlasAssign with any type of body
func NewSlasAssignRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.assign")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasCreateRequest calls the generic SlasCreate builder with application/json body
func NewSlasCreateRequest(server string, body SlasCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasCreateRequestWithBody generates requests for SlasCreate with any type of body
func NewSlasCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasGetRequest generates requests for SlasGet
func NewSlasGetRequest(server string, params *SlasGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlasGetPostRequest calls the generic SlasGetPost builder with application/json body
func NewSlasGetPostRequest(server string, body SlasGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasGetPostRequestWithBody generates requests for SlasGetPost with any type of body
func NewSlasGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasListRequest generates requests for SlasList
func NewSlasListRequest(server string, params *SlasListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to", runtime.ParamLocationQuery, *params.AppliesTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AppliesToOp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_op", runtime.ParamLocationQuery, *params.AppliesToOp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SlaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sla_type", runtime.ParamLocationQuery, *params.SlaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlasListPostRequest calls the generic SlasListPost builder with application/json body
func NewSlasListPostRequest(server string, body SlasListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasListPostRequestWithBody generates requests for SlasListPost with any type of body
func NewSlasListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasTransitionRequest calls the generic SlasTransition builder with application/json body
func NewSlasTransitionRequest(server string, body SlasTransitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasTransitionRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasTransitionRequestWithBody generates requests for SlasTransition with any type of body
func NewSlasTransitionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.transition")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasUpdateRequest calls the generic SlasUpdate builder with application/json body
func NewSlasUpdateRequest(server string, body SlasUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasUpdateRequestWithBody generates requests for SlasUpdate with any type of body
func NewSlasUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSnapKitActionExecuteDeferredRequest calls the generic SnapKitActionExecuteDeferred builder with application/json body
func NewSnapKitActionExecuteDeferredRequest(server string, body SnapKitActionExecuteDeferredJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnapKitActionExecuteDeferredRequestWithBody(server, "application/json", bodyReader)
}

// NewSnapKitActionExecuteDeferredRequestWithBody generates requests for SnapKitActionExecuteDeferred with any type of body
func NewSnapKitActionExecuteDeferredRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snap-kit-action.execute.deferred")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSnapWidgetsCreateRequest calls the generic SnapWidgetsCreate builder with application/json body
func NewSnapWidgetsCreateRequest(server string, body SnapWidgetsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnapWidgetsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSnapWidgetsCreateRequestWithBody generates requests for SnapWidgetsCreate with any type of body
func NewSnapWidgetsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snap-widgets.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysCreateRequest calls the generic SurveysCreate builder with application/json body
func NewSurveysCreateRequest(server string, body SurveysCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysCreateRequestWithBody generates requests for SurveysCreate with any type of body
func NewSurveysCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysDeleteRequest calls the generic SurveysDelete builder with application/json body
func NewSurveysDeleteRequest(server string, body SurveysDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysDeleteRequestWithBody generates requests for SurveysDelete with any type of body
func NewSurveysDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysGetRequest generates requests for SurveysGet
func NewSurveysGetRequest(server string, params *SurveysGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSurveysGetPostRequest calls the generic SurveysGetPost builder with application/json body
func NewSurveysGetPostRequest(server string, body SurveysGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysGetPostRequestWithBody generates requests for SurveysGetPost with any type of body
func NewSurveysGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysListRequest generates requests for SurveysList
func NewSurveysListRequest(server string, params *SurveysListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSurveysListPostRequest calls the generic SurveysListPost builder with application/json body
func NewSurveysListPostRequest(server string, body SurveysListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysListPostRequestWithBody generates requests for SurveysListPost with any type of body
func NewSurveysListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysResponsesListRequest generates requests for SurveysResponsesList
func NewSurveysResponsesListRequest(server string, params *SurveysResponsesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.responses.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DispatchIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dispatch_ids", runtime.ParamLocationQuery, *params.DispatchIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Objects != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "objects", runtime.ParamLocationQuery, *params.Objects); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recipient != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "recipient", runtime.ParamLocationQuery, *params.Recipient); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stages", runtime.ParamLocationQuery, *params.Stages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Surveys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "surveys", runtime.ParamLocationQuery, *params.Surveys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSurveysResponsesListPostRequest calls the generic SurveysResponsesListPost builder with application/json body
func NewSurveysResponsesListPostRequest(server string, body SurveysResponsesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysResponsesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysResponsesListPostRequestWithBody generates requests for SurveysResponsesListPost with any type of body
func NewSurveysResponsesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.responses.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysResponsesUpdateRequest calls the generic SurveysResponsesUpdate builder with application/json body
func NewSurveysResponsesUpdateRequest(server string, body SurveysResponsesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysResponsesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysResponsesUpdateRequestWithBody generates requests for SurveysResponsesUpdate with any type of body
func NewSurveysResponsesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.responses.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysSendRequest calls the generic SurveysSend builder with application/json body
func NewSurveysSendRequest(server string, body SurveysSendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysSendRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysSendRequestWithBody generates requests for SurveysSend with any type of body
func NewSurveysSendRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.send")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysSubmitRequest calls the generic SurveysSubmit builder with application/json body
func NewSurveysSubmitRequest(server string, body SurveysSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysSubmitRequestWithBody generates requests for SurveysSubmit with any type of body
func NewSurveysSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysUpdateRequest calls the generic SurveysUpdate builder with application/json body
func NewSurveysUpdateRequest(server string, body SurveysUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysUpdateRequestWithBody generates requests for SurveysUpdate with any type of body
func NewSurveysUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSysUsersListRequest generates requests for SysUsersList
func NewSysUsersListRequest(server string, params *SysUsersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sys-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSysUsersListPostRequest calls the generic SysUsersListPost builder with application/json body
func NewSysUsersListPostRequest(server string, body SysUsersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSysUsersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSysUsersListPostRequestWithBody generates requests for SysUsersListPost with any type of body
func NewSysUsersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sys-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSysUsersUpdateRequest calls the generic SysUsersUpdate builder with application/json body
func NewSysUsersUpdateRequest(server string, body SysUsersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSysUsersUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSysUsersUpdateRequestWithBody generates requests for SysUsersUpdate with any type of body
func NewSysUsersUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sys-users.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsCreateRequest calls the generic TagsCreate builder with application/json body
func NewTagsCreateRequest(server string, body TagsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsCreateRequestWithBody generates requests for TagsCreate with any type of body
func NewTagsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsDeleteRequest calls the generic TagsDelete builder with application/json body
func NewTagsDeleteRequest(server string, body TagsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsDeleteRequestWithBody generates requests for TagsDelete with any type of body
func NewTagsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsGetRequest generates requests for TagsGet
func NewTagsGetRequest(server string, params *TagsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsGetPostRequest calls the generic TagsGetPost builder with application/json body
func NewTagsGetPostRequest(server string, body TagsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsGetPostRequestWithBody generates requests for TagsGetPost with any type of body
func NewTagsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsListRequest generates requests for TagsList
func NewTagsListRequest(server string, params *TagsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsListPostRequest calls the generic TagsListPost builder with application/json body
func NewTagsListPostRequest(server string, body TagsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsListPostRequestWithBody generates requests for TagsListPost with any type of body
func NewTagsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsUpdateRequest calls the generic TagsUpdate builder with application/json body
func NewTagsUpdateRequest(server string, body TagsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsUpdateRequestWithBody generates requests for TagsUpdate with any type of body
func NewTagsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesCreateRequest calls the generic TimelineEntriesCreate builder with application/json body
func NewTimelineEntriesCreateRequest(server string, body TimelineEntriesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesCreateRequestWithBody generates requests for TimelineEntriesCreate with any type of body
func NewTimelineEntriesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesDeleteRequest calls the generic TimelineEntriesDelete builder with application/json body
func NewTimelineEntriesDeleteRequest(server string, body TimelineEntriesDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesDeleteRequestWithBody generates requests for TimelineEntriesDelete with any type of body
func NewTimelineEntriesDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesGetRequest generates requests for TimelineEntriesGet
func NewTimelineEntriesGetRequest(server string, params *TimelineEntriesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTimelineEntriesGetPostRequest calls the generic TimelineEntriesGetPost builder with application/json body
func NewTimelineEntriesGetPostRequest(server string, body TimelineEntriesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesGetPostRequestWithBody generates requests for TimelineEntriesGetPost with any type of body
func NewTimelineEntriesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesListRequest generates requests for TimelineEntriesList
func NewTimelineEntriesListRequest(server string, params *TimelineEntriesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object", runtime.ParamLocationQuery, params.Object); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Visibility != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "visibility", runtime.ParamLocationQuery, *params.Visibility); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTimelineEntriesListPostRequest calls the generic TimelineEntriesListPost builder with application/json body
func NewTimelineEntriesListPostRequest(server string, body TimelineEntriesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesListPostRequestWithBody generates requests for TimelineEntriesListPost with any type of body
func NewTimelineEntriesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesUpdateRequest calls the generic TimelineEntriesUpdate builder with application/json body
func NewTimelineEntriesUpdateRequest(server string, body TimelineEntriesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesUpdateRequestWithBody generates requests for TimelineEntriesUpdate with any type of body
func NewTimelineEntriesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebCrawlerJobsControlRequest calls the generic WebCrawlerJobsControl builder with application/json body
func NewWebCrawlerJobsControlRequest(server string, body WebCrawlerJobsControlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebCrawlerJobsControlRequestWithBody(server, "application/json", bodyReader)
}

// NewWebCrawlerJobsControlRequestWithBody generates requests for WebCrawlerJobsControl with any type of body
func NewWebCrawlerJobsControlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.control")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWebCrawlerJobRequest calls the generic CreateWebCrawlerJob builder with application/json body
func NewCreateWebCrawlerJobRequest(server string, body CreateWebCrawlerJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebCrawlerJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWebCrawlerJobRequestWithBody generates requests for CreateWebCrawlerJob with any type of body
func NewCreateWebCrawlerJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWebCrawlerJobRequest generates requests for GetWebCrawlerJob
func NewGetWebCrawlerJobRequest(server string, params *GetWebCrawlerJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebCrawlerJobPostRequest calls the generic GetWebCrawlerJobPost builder with application/json body
func NewGetWebCrawlerJobPostRequest(server string, body GetWebCrawlerJobPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetWebCrawlerJobPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGetWebCrawlerJobPostRequestWithBody generates requests for GetWebCrawlerJobPost with any type of body
func NewGetWebCrawlerJobPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWebCrawlerJobsRequest generates requests for ListWebCrawlerJobs
func NewListWebCrawlerJobsRequest(server string, params *ListWebCrawlerJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWebCrawlerJobsPostRequest calls the generic ListWebCrawlerJobsPost builder with application/json body
func NewListWebCrawlerJobsPostRequest(server string, body ListWebCrawlerJobsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListWebCrawlerJobsPostRequestWithBody(server, "application/json", bodyReader)
}

// NewListWebCrawlerJobsPostRequestWithBody generates requests for ListWebCrawlerJobsPost with any type of body
func NewListWebCrawlerJobsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksCreateRequest calls the generic WebhooksCreate builder with application/json body
func NewWebhooksCreateRequest(server string, body WebhooksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksCreateRequestWithBody generates requests for WebhooksCreate with any type of body
func NewWebhooksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksDeleteRequest calls the generic WebhooksDelete builder with application/json body
func NewWebhooksDeleteRequest(server string, body WebhooksDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksDeleteRequestWithBody generates requests for WebhooksDelete with any type of body
func NewWebhooksDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksEventRequest calls the generic WebhooksEvent builder with application/json body
func NewWebhooksEventRequest(server string, body WebhooksEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksEventRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksEventRequestWithBody generates requests for WebhooksEvent with any type of body
func NewWebhooksEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.event")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksGetRequest generates requests for WebhooksGet
func NewWebhooksGetRequest(server string, params *WebhooksGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksGetPostRequest calls the generic WebhooksGetPost builder with application/json body
func NewWebhooksGetPostRequest(server string, body WebhooksGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksGetPostRequestWithBody generates requests for WebhooksGetPost with any type of body
func NewWebhooksGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksListRequest generates requests for WebhooksList
func NewWebhooksListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksListPostRequest calls the generic WebhooksListPost builder with application/json body
func NewWebhooksListPostRequest(server string, body WebhooksListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksListPostRequestWithBody generates requests for WebhooksListPost with any type of body
func NewWebhooksListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksUpdateRequest calls the generic WebhooksUpdate builder with application/json body
func NewWebhooksUpdateRequest(server string, body WebhooksUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksUpdateRequestWithBody generates requests for WebhooksUpdate with any type of body
func NewWebhooksUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksCreateRequest calls the generic WorksCreate builder with application/json body
func NewWorksCreateRequest(server string, body WorksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksCreateRequestWithBody generates requests for WorksCreate with any type of body
func NewWorksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksDeleteRequest calls the generic WorksDelete builder with application/json body
func NewWorksDeleteRequest(server string, body WorksDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksDeleteRequestWithBody generates requests for WorksDelete with any type of body
func NewWorksDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksExportRequest generates requests for WorksExport
func NewWorksExportRequest(server string, params *WorksExportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToPart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_part", runtime.ParamLocationQuery, *params.AppliesToPart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueAccounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.accounts", runtime.ParamLocationQuery, *params.IssueAccounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuePriority != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.priority", runtime.ParamLocationQuery, *params.IssuePriority); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuePriorityV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.priority_v2", runtime.ParamLocationQuery, *params.IssuePriorityV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueRevOrgs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.rev_orgs", runtime.ParamLocationQuery, *params.IssueRevOrgs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.sla_summary.stage", runtime.ParamLocationQuery, *params.IssueSlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSprint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.sprint", runtime.ParamLocationQuery, *params.IssueSprint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reported_by", runtime.ParamLocationQuery, *params.ReportedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage.name", runtime.ParamLocationQuery, *params.StageName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StagedInfoIsStaged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "staged_info.is_staged", runtime.ParamLocationQuery, *params.StagedInfoIsStaged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataExternalReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.external_reference", runtime.ParamLocationQuery, *params.SyncMetadataExternalReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataOriginSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.origin_system", runtime.ParamLocationQuery, *params.SyncMetadataOriginSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketBrand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.brand", runtime.ParamLocationQuery, *params.TicketBrand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.channels", runtime.ParamLocationQuery, *params.TicketChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketChannelsV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.channels_v2", runtime.ParamLocationQuery, *params.TicketChannelsV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.group", runtime.ParamLocationQuery, *params.TicketGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketIsFrozen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.is_frozen", runtime.ParamLocationQuery, *params.TicketIsFrozen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketIsSpam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.is_spam", runtime.ParamLocationQuery, *params.TicketIsSpam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketNeedsResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.needs_response", runtime.ParamLocationQuery, *params.TicketNeedsResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketRevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.rev_org", runtime.ParamLocationQuery, *params.TicketRevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSeverity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.severity", runtime.ParamLocationQuery, *params.TicketSeverity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.sla_summary.stage", runtime.ParamLocationQuery, *params.TicketSlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSourceChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.source_channel", runtime.ParamLocationQuery, *params.TicketSourceChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSourceChannelV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.source_channel_v2", runtime.ParamLocationQuery, *params.TicketSourceChannelV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorksExportPostRequest calls the generic WorksExportPost builder with application/json body
func NewWorksExportPostRequest(server string, body WorksExportPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksExportPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksExportPostRequestWithBody generates requests for WorksExportPost with any type of body
func NewWorksExportPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksGetRequest generates requests for WorksGet
func NewWorksGetRequest(server string, params *WorksGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorksGetPostRequest calls the generic WorksGetPost builder with application/json body
func NewWorksGetPostRequest(server string, body WorksGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksGetPostRequestWithBody generates requests for WorksGetPost with any type of body
func NewWorksGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksListRequest generates requests for WorksList
func NewWorksListRequest(server string, params *WorksListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToPart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_part", runtime.ParamLocationQuery, *params.AppliesToPart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueAccounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.accounts", runtime.ParamLocationQuery, *params.IssueAccounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuePriority != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.priority", runtime.ParamLocationQuery, *params.IssuePriority); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuePriorityV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.priority_v2", runtime.ParamLocationQuery, *params.IssuePriorityV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueRevOrgs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.rev_orgs", runtime.ParamLocationQuery, *params.IssueRevOrgs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.sla_summary.stage", runtime.ParamLocationQuery, *params.IssueSlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSprint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.sprint", runtime.ParamLocationQuery, *params.IssueSprint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reported_by", runtime.ParamLocationQuery, *params.ReportedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage.name", runtime.ParamLocationQuery, *params.StageName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StagedInfoIsStaged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "staged_info.is_staged", runtime.ParamLocationQuery, *params.StagedInfoIsStaged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataExternalReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.external_reference", runtime.ParamLocationQuery, *params.SyncMetadataExternalReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataOriginSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.origin_system", runtime.ParamLocationQuery, *params.SyncMetadataOriginSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketBrand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.brand", runtime.ParamLocationQuery, *params.TicketBrand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.channels", runtime.ParamLocationQuery, *params.TicketChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketChannelsV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.channels_v2", runtime.ParamLocationQuery, *params.TicketChannelsV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.group", runtime.ParamLocationQuery, *params.TicketGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketIsFrozen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.is_frozen", runtime.ParamLocationQuery, *params.TicketIsFrozen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketIsSpam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.is_spam", runtime.ParamLocationQuery, *params.TicketIsSpam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketNeedsResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.needs_response", runtime.ParamLocationQuery, *params.TicketNeedsResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketRevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.rev_org", runtime.ParamLocationQuery, *params.TicketRevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSeverity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.severity", runtime.ParamLocationQuery, *params.TicketSeverity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.sla_summary.stage", runtime.ParamLocationQuery, *params.TicketSlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSourceChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.source_channel", runtime.ParamLocationQuery, *params.TicketSourceChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSourceChannelV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.source_channel_v2", runtime.ParamLocationQuery, *params.TicketSourceChannelV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorksListPostRequest calls the generic WorksListPost builder with application/json body
func NewWorksListPostRequest(server string, body WorksListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksListPostRequestWithBody generates requests for WorksListPost with any type of body
func NewWorksListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksUpdateRequest calls the generic WorksUpdate builder with application/json body
func NewWorksUpdateRequest(server string, body WorksUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksUpdateRequestWithBody generates requests for WorksUpdate with any type of body
func NewWorksUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AccountsCreateWithBodyWithResponse request with any body
	AccountsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsCreateResponse, error)

	AccountsCreateWithResponse(ctx context.Context, body AccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsCreateResponse, error)

	// AccountsDeleteWithBodyWithResponse request with any body
	AccountsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsDeleteResponse, error)

	AccountsDeleteWithResponse(ctx context.Context, body AccountsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsDeleteResponse, error)

	// AccountsExportWithResponse request
	AccountsExportWithResponse(ctx context.Context, params *AccountsExportParams, reqEditors ...RequestEditorFn) (*AccountsExportResponse, error)

	// AccountsExportPostWithBodyWithResponse request with any body
	AccountsExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsExportPostResponse, error)

	AccountsExportPostWithResponse(ctx context.Context, body AccountsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsExportPostResponse, error)

	// AccountsGetWithResponse request
	AccountsGetWithResponse(ctx context.Context, params *AccountsGetParams, reqEditors ...RequestEditorFn) (*AccountsGetResponse, error)

	// AccountsGetPostWithBodyWithResponse request with any body
	AccountsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsGetPostResponse, error)

	AccountsGetPostWithResponse(ctx context.Context, body AccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsGetPostResponse, error)

	// AccountsListWithResponse request
	AccountsListWithResponse(ctx context.Context, params *AccountsListParams, reqEditors ...RequestEditorFn) (*AccountsListResponse, error)

	// AccountsListPostWithBodyWithResponse request with any body
	AccountsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsListPostResponse, error)

	AccountsListPostWithResponse(ctx context.Context, body AccountsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsListPostResponse, error)

	// AccountsMergeWithBodyWithResponse request with any body
	AccountsMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsMergeResponse, error)

	AccountsMergeWithResponse(ctx context.Context, body AccountsMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsMergeResponse, error)

	// AccountsUpdateWithBodyWithResponse request with any body
	AccountsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsUpdateResponse, error)

	AccountsUpdateWithResponse(ctx context.Context, body AccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsUpdateResponse, error)

	// CreateArticleWithBodyWithResponse request with any body
	CreateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error)

	CreateArticleWithResponse(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error)

	// DeleteArticleWithBodyWithResponse request with any body
	DeleteArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteArticleResponse, error)

	DeleteArticleWithResponse(ctx context.Context, body DeleteArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteArticleResponse, error)

	// GetArticleWithResponse request
	GetArticleWithResponse(ctx context.Context, params *GetArticleParams, reqEditors ...RequestEditorFn) (*GetArticleResponse, error)

	// GetArticlePostWithBodyWithResponse request with any body
	GetArticlePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetArticlePostResponse, error)

	GetArticlePostWithResponse(ctx context.Context, body GetArticlePostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetArticlePostResponse, error)

	// ListArticlesWithResponse request
	ListArticlesWithResponse(ctx context.Context, params *ListArticlesParams, reqEditors ...RequestEditorFn) (*ListArticlesResponse, error)

	// ListArticlesPostWithBodyWithResponse request with any body
	ListArticlesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListArticlesPostResponse, error)

	ListArticlesPostWithResponse(ctx context.Context, body ListArticlesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListArticlesPostResponse, error)

	// UpdateArticleWithBodyWithResponse request with any body
	UpdateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error)

	UpdateArticleWithResponse(ctx context.Context, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error)

	// ArtifactsGetWithResponse request
	ArtifactsGetWithResponse(ctx context.Context, params *ArtifactsGetParams, reqEditors ...RequestEditorFn) (*ArtifactsGetResponse, error)

	// ArtifactsGetPostWithBodyWithResponse request with any body
	ArtifactsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsGetPostResponse, error)

	ArtifactsGetPostWithResponse(ctx context.Context, body ArtifactsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsGetPostResponse, error)

	// ArtifactsListWithResponse request
	ArtifactsListWithResponse(ctx context.Context, params *ArtifactsListParams, reqEditors ...RequestEditorFn) (*ArtifactsListResponse, error)

	// ArtifactsListPostWithBodyWithResponse request with any body
	ArtifactsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsListPostResponse, error)

	ArtifactsListPostWithResponse(ctx context.Context, body ArtifactsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsListPostResponse, error)

	// ArtifactsLocateWithResponse request
	ArtifactsLocateWithResponse(ctx context.Context, params *ArtifactsLocateParams, reqEditors ...RequestEditorFn) (*ArtifactsLocateResponse, error)

	// ArtifactsLocatePostWithBodyWithResponse request with any body
	ArtifactsLocatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsLocatePostResponse, error)

	ArtifactsLocatePostWithResponse(ctx context.Context, body ArtifactsLocatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsLocatePostResponse, error)

	// ArtifactsPrepareWithBodyWithResponse request with any body
	ArtifactsPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsPrepareResponse, error)

	ArtifactsPrepareWithResponse(ctx context.Context, body ArtifactsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsPrepareResponse, error)

	// ArtifactsHardDeleteVersionWithBodyWithResponse request with any body
	ArtifactsHardDeleteVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsHardDeleteVersionResponse, error)

	ArtifactsHardDeleteVersionWithResponse(ctx context.Context, body ArtifactsHardDeleteVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsHardDeleteVersionResponse, error)

	// ArtifactsVersionsPrepareWithBodyWithResponse request with any body
	ArtifactsVersionsPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsVersionsPrepareResponse, error)

	ArtifactsVersionsPrepareWithResponse(ctx context.Context, body ArtifactsVersionsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsVersionsPrepareResponse, error)

	// AtomsGetWithResponse request
	AtomsGetWithResponse(ctx context.Context, params *AtomsGetParams, reqEditors ...RequestEditorFn) (*AtomsGetResponse, error)

	// AtomsGetPostWithBodyWithResponse request with any body
	AtomsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AtomsGetPostResponse, error)

	AtomsGetPostWithResponse(ctx context.Context, body AtomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AtomsGetPostResponse, error)

	// AuthTokensCreateWithBodyWithResponse request with any body
	AuthTokensCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensCreateResponse, error)

	AuthTokensCreateWithResponse(ctx context.Context, body AuthTokensCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensCreateResponse, error)

	// AuthTokensDeleteWithBodyWithResponse request with any body
	AuthTokensDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensDeleteResponse, error)

	AuthTokensDeleteWithResponse(ctx context.Context, body AuthTokensDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensDeleteResponse, error)

	// AuthTokensGetWithResponse request
	AuthTokensGetWithResponse(ctx context.Context, params *AuthTokensGetParams, reqEditors ...RequestEditorFn) (*AuthTokensGetResponse, error)

	// AuthTokensGetPostWithBodyWithResponse request with any body
	AuthTokensGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensGetPostResponse, error)

	AuthTokensGetPostWithResponse(ctx context.Context, body AuthTokensGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensGetPostResponse, error)

	// AuthTokensInfoWithResponse request
	AuthTokensInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthTokensInfoResponse, error)

	// AuthTokensInfoPostWithBodyWithResponse request with any body
	AuthTokensInfoPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensInfoPostResponse, error)

	AuthTokensInfoPostWithResponse(ctx context.Context, body AuthTokensInfoPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensInfoPostResponse, error)

	// AuthTokensListWithResponse request
	AuthTokensListWithResponse(ctx context.Context, params *AuthTokensListParams, reqEditors ...RequestEditorFn) (*AuthTokensListResponse, error)

	// AuthTokensListPostWithBodyWithResponse request with any body
	AuthTokensListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensListPostResponse, error)

	AuthTokensListPostWithResponse(ctx context.Context, body AuthTokensListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensListPostResponse, error)

	// AuthTokensSelfDeleteWithBodyWithResponse request with any body
	AuthTokensSelfDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensSelfDeleteResponse, error)

	AuthTokensSelfDeleteWithResponse(ctx context.Context, body AuthTokensSelfDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensSelfDeleteResponse, error)

	// AuthTokensUpdateWithBodyWithResponse request with any body
	AuthTokensUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensUpdateResponse, error)

	AuthTokensUpdateWithResponse(ctx context.Context, body AuthTokensUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensUpdateResponse, error)

	// ChatsCreateWithBodyWithResponse request with any body
	ChatsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsCreateResponse, error)

	ChatsCreateWithResponse(ctx context.Context, body ChatsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsCreateResponse, error)

	// ChatsGetWithResponse request
	ChatsGetWithResponse(ctx context.Context, params *ChatsGetParams, reqEditors ...RequestEditorFn) (*ChatsGetResponse, error)

	// ChatsGetPostWithBodyWithResponse request with any body
	ChatsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsGetPostResponse, error)

	ChatsGetPostWithResponse(ctx context.Context, body ChatsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsGetPostResponse, error)

	// ChatsUpdateWithBodyWithResponse request with any body
	ChatsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsUpdateResponse, error)

	ChatsUpdateWithResponse(ctx context.Context, body ChatsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsUpdateResponse, error)

	// CodeChangesCreateWithBodyWithResponse request with any body
	CodeChangesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesCreateResponse, error)

	CodeChangesCreateWithResponse(ctx context.Context, body CodeChangesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesCreateResponse, error)

	// CodeChangesDeleteWithBodyWithResponse request with any body
	CodeChangesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesDeleteResponse, error)

	CodeChangesDeleteWithResponse(ctx context.Context, body CodeChangesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesDeleteResponse, error)

	// CodeChangesGetWithResponse request
	CodeChangesGetWithResponse(ctx context.Context, params *CodeChangesGetParams, reqEditors ...RequestEditorFn) (*CodeChangesGetResponse, error)

	// CodeChangesGetPostWithBodyWithResponse request with any body
	CodeChangesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesGetPostResponse, error)

	CodeChangesGetPostWithResponse(ctx context.Context, body CodeChangesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesGetPostResponse, error)

	// CodeChangesListWithResponse request
	CodeChangesListWithResponse(ctx context.Context, params *CodeChangesListParams, reqEditors ...RequestEditorFn) (*CodeChangesListResponse, error)

	// CodeChangesListPostWithBodyWithResponse request with any body
	CodeChangesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesListPostResponse, error)

	CodeChangesListPostWithResponse(ctx context.Context, body CodeChangesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesListPostResponse, error)

	// CodeChangesUpdateWithBodyWithResponse request with any body
	CodeChangesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesUpdateResponse, error)

	CodeChangesUpdateWithResponse(ctx context.Context, body CodeChangesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesUpdateResponse, error)

	// CommandsCreateWithBodyWithResponse request with any body
	CommandsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsCreateResponse, error)

	CommandsCreateWithResponse(ctx context.Context, body CommandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsCreateResponse, error)

	// CommandsGetWithResponse request
	CommandsGetWithResponse(ctx context.Context, params *CommandsGetParams, reqEditors ...RequestEditorFn) (*CommandsGetResponse, error)

	// CommandsGetPostWithBodyWithResponse request with any body
	CommandsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsGetPostResponse, error)

	CommandsGetPostWithResponse(ctx context.Context, body CommandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsGetPostResponse, error)

	// CommandsListWithResponse request
	CommandsListWithResponse(ctx context.Context, params *CommandsListParams, reqEditors ...RequestEditorFn) (*CommandsListResponse, error)

	// CommandsListPostWithBodyWithResponse request with any body
	CommandsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsListPostResponse, error)

	CommandsListPostWithResponse(ctx context.Context, body CommandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsListPostResponse, error)

	// CommandsUpdateWithBodyWithResponse request with any body
	CommandsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsUpdateResponse, error)

	CommandsUpdateWithResponse(ctx context.Context, body CommandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsUpdateResponse, error)

	// ConversationsCreateWithBodyWithResponse request with any body
	ConversationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsCreateResponse, error)

	ConversationsCreateWithResponse(ctx context.Context, body ConversationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsCreateResponse, error)

	// ConversationsDeleteWithBodyWithResponse request with any body
	ConversationsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsDeleteResponse, error)

	ConversationsDeleteWithResponse(ctx context.Context, body ConversationsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsDeleteResponse, error)

	// ConversationsGetWithResponse request
	ConversationsGetWithResponse(ctx context.Context, params *ConversationsGetParams, reqEditors ...RequestEditorFn) (*ConversationsGetResponse, error)

	// ConversationsGetPostWithBodyWithResponse request with any body
	ConversationsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsGetPostResponse, error)

	ConversationsGetPostWithResponse(ctx context.Context, body ConversationsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsGetPostResponse, error)

	// ConversationsListWithResponse request
	ConversationsListWithResponse(ctx context.Context, params *ConversationsListParams, reqEditors ...RequestEditorFn) (*ConversationsListResponse, error)

	// ConversationsListPostWithBodyWithResponse request with any body
	ConversationsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsListPostResponse, error)

	ConversationsListPostWithResponse(ctx context.Context, body ConversationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsListPostResponse, error)

	// ConversationsUpdateWithBodyWithResponse request with any body
	ConversationsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsUpdateResponse, error)

	ConversationsUpdateWithResponse(ctx context.Context, body ConversationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsUpdateResponse, error)

	// DevOrgAuthConnectionsCreateWithBodyWithResponse request with any body
	DevOrgAuthConnectionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsCreateResponse, error)

	DevOrgAuthConnectionsCreateWithResponse(ctx context.Context, body DevOrgAuthConnectionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsCreateResponse, error)

	// DevOrgAuthConnectionsDeleteWithBodyWithResponse request with any body
	DevOrgAuthConnectionsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsDeleteResponse, error)

	DevOrgAuthConnectionsDeleteWithResponse(ctx context.Context, body DevOrgAuthConnectionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsDeleteResponse, error)

	// DevOrgAuthConnectionsGetWithResponse request
	DevOrgAuthConnectionsGetWithResponse(ctx context.Context, params *DevOrgAuthConnectionsGetParams, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetResponse, error)

	// DevOrgAuthConnectionsGetPostWithBodyWithResponse request with any body
	DevOrgAuthConnectionsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetPostResponse, error)

	DevOrgAuthConnectionsGetPostWithResponse(ctx context.Context, body DevOrgAuthConnectionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetPostResponse, error)

	// DevOrgAuthConnectionsListWithResponse request
	DevOrgAuthConnectionsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListResponse, error)

	// DevOrgAuthConnectionsListPostWithBodyWithResponse request with any body
	DevOrgAuthConnectionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListPostResponse, error)

	DevOrgAuthConnectionsListPostWithResponse(ctx context.Context, body DevOrgAuthConnectionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListPostResponse, error)

	// DevOrgAuthConnectionsToggleWithBodyWithResponse request with any body
	DevOrgAuthConnectionsToggleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsToggleResponse, error)

	DevOrgAuthConnectionsToggleWithResponse(ctx context.Context, body DevOrgAuthConnectionsToggleJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsToggleResponse, error)

	// DevOrgAuthConnectionsUpdateWithBodyWithResponse request with any body
	DevOrgAuthConnectionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsUpdateResponse, error)

	DevOrgAuthConnectionsUpdateWithResponse(ctx context.Context, body DevOrgAuthConnectionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsUpdateResponse, error)

	// DevOrgsGetWithResponse request
	DevOrgsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevOrgsGetResponse, error)

	// DevOrgsGetPostWithBodyWithResponse request with any body
	DevOrgsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgsGetPostResponse, error)

	DevOrgsGetPostWithResponse(ctx context.Context, body DevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgsGetPostResponse, error)

	// DevUsersActivateWithBodyWithResponse request with any body
	DevUsersActivateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersActivateResponse, error)

	DevUsersActivateWithResponse(ctx context.Context, body DevUsersActivateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersActivateResponse, error)

	// DevUsersCreateWithBodyWithResponse request with any body
	DevUsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersCreateResponse, error)

	DevUsersCreateWithResponse(ctx context.Context, body DevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersCreateResponse, error)

	// DevUsersDeactivateWithBodyWithResponse request with any body
	DevUsersDeactivateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersDeactivateResponse, error)

	DevUsersDeactivateWithResponse(ctx context.Context, body DevUsersDeactivateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersDeactivateResponse, error)

	// DevUsersGetWithResponse request
	DevUsersGetWithResponse(ctx context.Context, params *DevUsersGetParams, reqEditors ...RequestEditorFn) (*DevUsersGetResponse, error)

	// DevUsersGetPostWithBodyWithResponse request with any body
	DevUsersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersGetPostResponse, error)

	DevUsersGetPostWithResponse(ctx context.Context, body DevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersGetPostResponse, error)

	// DevUsersIdentitiesLinkWithBodyWithResponse request with any body
	DevUsersIdentitiesLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesLinkResponse, error)

	DevUsersIdentitiesLinkWithResponse(ctx context.Context, body DevUsersIdentitiesLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesLinkResponse, error)

	// DevUsersIdentitiesUnlinkWithBodyWithResponse request with any body
	DevUsersIdentitiesUnlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesUnlinkResponse, error)

	DevUsersIdentitiesUnlinkWithResponse(ctx context.Context, body DevUsersIdentitiesUnlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesUnlinkResponse, error)

	// DevUsersListWithResponse request
	DevUsersListWithResponse(ctx context.Context, params *DevUsersListParams, reqEditors ...RequestEditorFn) (*DevUsersListResponse, error)

	// DevUsersListPostWithBodyWithResponse request with any body
	DevUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersListPostResponse, error)

	DevUsersListPostWithResponse(ctx context.Context, body DevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersListPostResponse, error)

	// DevUsersMergeWithBodyWithResponse request with any body
	DevUsersMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersMergeResponse, error)

	DevUsersMergeWithResponse(ctx context.Context, body DevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersMergeResponse, error)

	// DevUsersSelfWithResponse request
	DevUsersSelfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevUsersSelfResponse, error)

	// DevUsersSelfPostWithBodyWithResponse request with any body
	DevUsersSelfPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersSelfPostResponse, error)

	DevUsersSelfPostWithResponse(ctx context.Context, body DevUsersSelfPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersSelfPostResponse, error)

	// DevUsersSelfUpdateWithBodyWithResponse request with any body
	DevUsersSelfUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersSelfUpdateResponse, error)

	DevUsersSelfUpdateWithResponse(ctx context.Context, body DevUsersSelfUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersSelfUpdateResponse, error)

	// DevUsersUpdateWithBodyWithResponse request with any body
	DevUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersUpdateResponse, error)

	DevUsersUpdateWithResponse(ctx context.Context, body DevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersUpdateResponse, error)

	// DirectoriesCountWithResponse request
	DirectoriesCountWithResponse(ctx context.Context, params *DirectoriesCountParams, reqEditors ...RequestEditorFn) (*DirectoriesCountResponse, error)

	// DirectoriesCountPostWithBodyWithResponse request with any body
	DirectoriesCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesCountPostResponse, error)

	DirectoriesCountPostWithResponse(ctx context.Context, body DirectoriesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesCountPostResponse, error)

	// DirectoriesCreateWithBodyWithResponse request with any body
	DirectoriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesCreateResponse, error)

	DirectoriesCreateWithResponse(ctx context.Context, body DirectoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesCreateResponse, error)

	// DirectoriesDeleteWithBodyWithResponse request with any body
	DirectoriesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesDeleteResponse, error)

	DirectoriesDeleteWithResponse(ctx context.Context, body DirectoriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesDeleteResponse, error)

	// DirectoriesGetWithResponse request
	DirectoriesGetWithResponse(ctx context.Context, params *DirectoriesGetParams, reqEditors ...RequestEditorFn) (*DirectoriesGetResponse, error)

	// DirectoriesGetPostWithBodyWithResponse request with any body
	DirectoriesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesGetPostResponse, error)

	DirectoriesGetPostWithResponse(ctx context.Context, body DirectoriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesGetPostResponse, error)

	// DirectoriesListWithResponse request
	DirectoriesListWithResponse(ctx context.Context, params *DirectoriesListParams, reqEditors ...RequestEditorFn) (*DirectoriesListResponse, error)

	// DirectoriesListPostWithBodyWithResponse request with any body
	DirectoriesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesListPostResponse, error)

	DirectoriesListPostWithResponse(ctx context.Context, body DirectoriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesListPostResponse, error)

	// DirectoriesUpdateWithBodyWithResponse request with any body
	DirectoriesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesUpdateResponse, error)

	DirectoriesUpdateWithResponse(ctx context.Context, body DirectoriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesUpdateResponse, error)

	// GroupsCreateWithBodyWithResponse request with any body
	GroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error)

	GroupsCreateWithResponse(ctx context.Context, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error)

	// GroupsGetWithResponse request
	GroupsGetWithResponse(ctx context.Context, params *GroupsGetParams, reqEditors ...RequestEditorFn) (*GroupsGetResponse, error)

	// GroupsGetPostWithBodyWithResponse request with any body
	GroupsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsGetPostResponse, error)

	GroupsGetPostWithResponse(ctx context.Context, body GroupsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsGetPostResponse, error)

	// GroupsListWithResponse request
	GroupsListWithResponse(ctx context.Context, params *GroupsListParams, reqEditors ...RequestEditorFn) (*GroupsListResponse, error)

	// GroupsListPostWithBodyWithResponse request with any body
	GroupsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsListPostResponse, error)

	GroupsListPostWithResponse(ctx context.Context, body GroupsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsListPostResponse, error)

	// GroupMembersAddWithBodyWithResponse request with any body
	GroupMembersAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersAddResponse, error)

	GroupMembersAddWithResponse(ctx context.Context, body GroupMembersAddJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersAddResponse, error)

	// GroupMembersListWithResponse request
	GroupMembersListWithResponse(ctx context.Context, params *GroupMembersListParams, reqEditors ...RequestEditorFn) (*GroupMembersListResponse, error)

	// GroupMembersListPostWithBodyWithResponse request with any body
	GroupMembersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersListPostResponse, error)

	GroupMembersListPostWithResponse(ctx context.Context, body GroupMembersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersListPostResponse, error)

	// GroupMembersRemoveWithBodyWithResponse request with any body
	GroupMembersRemoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersRemoveResponse, error)

	GroupMembersRemoveWithResponse(ctx context.Context, body GroupMembersRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersRemoveResponse, error)

	// GroupsUpdateWithBodyWithResponse request with any body
	GroupsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsUpdateResponse, error)

	GroupsUpdateWithResponse(ctx context.Context, body GroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsUpdateResponse, error)

	// KeyringsCreateCallbackWithResponse request
	KeyringsCreateCallbackWithResponse(ctx context.Context, params *KeyringsCreateCallbackParams, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackResponse, error)

	// KeyringsCreateCallbackPostWithBodyWithResponse request with any body
	KeyringsCreateCallbackPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackPostResponse, error)

	KeyringsCreateCallbackPostWithResponse(ctx context.Context, body KeyringsCreateCallbackPostJSONRequestBody, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackPostResponse, error)

	// LinksCreateWithBodyWithResponse request with any body
	LinksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksCreateResponse, error)

	LinksCreateWithResponse(ctx context.Context, body LinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksCreateResponse, error)

	// LinksDeleteWithBodyWithResponse request with any body
	LinksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksDeleteResponse, error)

	LinksDeleteWithResponse(ctx context.Context, body LinksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksDeleteResponse, error)

	// LinksGetWithResponse request
	LinksGetWithResponse(ctx context.Context, params *LinksGetParams, reqEditors ...RequestEditorFn) (*LinksGetResponse, error)

	// LinksGetPostWithBodyWithResponse request with any body
	LinksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksGetPostResponse, error)

	LinksGetPostWithResponse(ctx context.Context, body LinksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksGetPostResponse, error)

	// LinksListWithResponse request
	LinksListWithResponse(ctx context.Context, params *LinksListParams, reqEditors ...RequestEditorFn) (*LinksListResponse, error)

	// LinksListPostWithBodyWithResponse request with any body
	LinksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksListPostResponse, error)

	LinksListPostWithResponse(ctx context.Context, body LinksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksListPostResponse, error)

	// LinksReplaceWithBodyWithResponse request with any body
	LinksReplaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksReplaceResponse, error)

	LinksReplaceWithResponse(ctx context.Context, body LinksReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksReplaceResponse, error)

	// MeetingsCountWithResponse request
	MeetingsCountWithResponse(ctx context.Context, params *MeetingsCountParams, reqEditors ...RequestEditorFn) (*MeetingsCountResponse, error)

	// MeetingsCountPostWithBodyWithResponse request with any body
	MeetingsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsCountPostResponse, error)

	MeetingsCountPostWithResponse(ctx context.Context, body MeetingsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsCountPostResponse, error)

	// MeetingsCreateWithBodyWithResponse request with any body
	MeetingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsCreateResponse, error)

	MeetingsCreateWithResponse(ctx context.Context, body MeetingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsCreateResponse, error)

	// MeetingsDeleteWithBodyWithResponse request with any body
	MeetingsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsDeleteResponse, error)

	MeetingsDeleteWithResponse(ctx context.Context, body MeetingsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsDeleteResponse, error)

	// MeetingsGetWithResponse request
	MeetingsGetWithResponse(ctx context.Context, params *MeetingsGetParams, reqEditors ...RequestEditorFn) (*MeetingsGetResponse, error)

	// MeetingsGetPostWithBodyWithResponse request with any body
	MeetingsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsGetPostResponse, error)

	MeetingsGetPostWithResponse(ctx context.Context, body MeetingsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsGetPostResponse, error)

	// MeetingsListWithResponse request
	MeetingsListWithResponse(ctx context.Context, params *MeetingsListParams, reqEditors ...RequestEditorFn) (*MeetingsListResponse, error)

	// MeetingsListPostWithBodyWithResponse request with any body
	MeetingsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsListPostResponse, error)

	MeetingsListPostWithResponse(ctx context.Context, body MeetingsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsListPostResponse, error)

	// MeetingsUpdateWithBodyWithResponse request with any body
	MeetingsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsUpdateResponse, error)

	MeetingsUpdateWithResponse(ctx context.Context, body MeetingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsUpdateResponse, error)

	// MetricActionExecuteWithBodyWithResponse request with any body
	MetricActionExecuteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricActionExecuteResponse, error)

	MetricActionExecuteWithResponse(ctx context.Context, body MetricActionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricActionExecuteResponse, error)

	// MetricDefinitionsCreateWithBodyWithResponse request with any body
	MetricDefinitionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsCreateResponse, error)

	MetricDefinitionsCreateWithResponse(ctx context.Context, body MetricDefinitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsCreateResponse, error)

	// MetricDefinitionsDeleteWithBodyWithResponse request with any body
	MetricDefinitionsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsDeleteResponse, error)

	MetricDefinitionsDeleteWithResponse(ctx context.Context, body MetricDefinitionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsDeleteResponse, error)

	// MetricDefinitionsGetWithResponse request
	MetricDefinitionsGetWithResponse(ctx context.Context, params *MetricDefinitionsGetParams, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetResponse, error)

	// MetricDefinitionsGetPostWithBodyWithResponse request with any body
	MetricDefinitionsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetPostResponse, error)

	MetricDefinitionsGetPostWithResponse(ctx context.Context, body MetricDefinitionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetPostResponse, error)

	// MetricDefinitionsListWithResponse request
	MetricDefinitionsListWithResponse(ctx context.Context, params *MetricDefinitionsListParams, reqEditors ...RequestEditorFn) (*MetricDefinitionsListResponse, error)

	// MetricDefinitionsListPostWithBodyWithResponse request with any body
	MetricDefinitionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsListPostResponse, error)

	MetricDefinitionsListPostWithResponse(ctx context.Context, body MetricDefinitionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsListPostResponse, error)

	// MetricDefinitionsUpdateWithBodyWithResponse request with any body
	MetricDefinitionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsUpdateResponse, error)

	MetricDefinitionsUpdateWithResponse(ctx context.Context, body MetricDefinitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsUpdateResponse, error)

	// MetricTrackersGetWithResponse request
	MetricTrackersGetWithResponse(ctx context.Context, params *MetricTrackersGetParams, reqEditors ...RequestEditorFn) (*MetricTrackersGetResponse, error)

	// MetricTrackersGetPostWithBodyWithResponse request with any body
	MetricTrackersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricTrackersGetPostResponse, error)

	MetricTrackersGetPostWithResponse(ctx context.Context, body MetricTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricTrackersGetPostResponse, error)

	// OrgScheduleFragmentsCreateWithBodyWithResponse request with any body
	OrgScheduleFragmentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsCreateResponse, error)

	OrgScheduleFragmentsCreateWithResponse(ctx context.Context, body OrgScheduleFragmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsCreateResponse, error)

	// OrgScheduleFragmentsGetWithResponse request
	OrgScheduleFragmentsGetWithResponse(ctx context.Context, params *OrgScheduleFragmentsGetParams, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetResponse, error)

	// OrgScheduleFragmentsGetPostWithBodyWithResponse request with any body
	OrgScheduleFragmentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetPostResponse, error)

	OrgScheduleFragmentsGetPostWithResponse(ctx context.Context, body OrgScheduleFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetPostResponse, error)

	// OrgScheduleFragmentsTransitionWithBodyWithResponse request with any body
	OrgScheduleFragmentsTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsTransitionResponse, error)

	OrgScheduleFragmentsTransitionWithResponse(ctx context.Context, body OrgScheduleFragmentsTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsTransitionResponse, error)

	// OrgSchedulesCreateWithBodyWithResponse request with any body
	OrgSchedulesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesCreateResponse, error)

	OrgSchedulesCreateWithResponse(ctx context.Context, body OrgSchedulesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesCreateResponse, error)

	// OrgSchedulesEvaluateWithResponse request
	OrgSchedulesEvaluateWithResponse(ctx context.Context, params *OrgSchedulesEvaluateParams, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluateResponse, error)

	// OrgSchedulesEvaluatePostWithBodyWithResponse request with any body
	OrgSchedulesEvaluatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluatePostResponse, error)

	OrgSchedulesEvaluatePostWithResponse(ctx context.Context, body OrgSchedulesEvaluatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluatePostResponse, error)

	// OrgSchedulesGetWithResponse request
	OrgSchedulesGetWithResponse(ctx context.Context, params *OrgSchedulesGetParams, reqEditors ...RequestEditorFn) (*OrgSchedulesGetResponse, error)

	// OrgSchedulesGetPostWithBodyWithResponse request with any body
	OrgSchedulesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesGetPostResponse, error)

	OrgSchedulesGetPostWithResponse(ctx context.Context, body OrgSchedulesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesGetPostResponse, error)

	// OrgSchedulesListWithResponse request
	OrgSchedulesListWithResponse(ctx context.Context, params *OrgSchedulesListParams, reqEditors ...RequestEditorFn) (*OrgSchedulesListResponse, error)

	// OrgSchedulesListPostWithBodyWithResponse request with any body
	OrgSchedulesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesListPostResponse, error)

	OrgSchedulesListPostWithResponse(ctx context.Context, body OrgSchedulesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesListPostResponse, error)

	// OrgSchedulesSetFutureWithBodyWithResponse request with any body
	OrgSchedulesSetFutureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesSetFutureResponse, error)

	OrgSchedulesSetFutureWithResponse(ctx context.Context, body OrgSchedulesSetFutureJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesSetFutureResponse, error)

	// OrgSchedulesTransitionWithBodyWithResponse request with any body
	OrgSchedulesTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesTransitionResponse, error)

	OrgSchedulesTransitionWithResponse(ctx context.Context, body OrgSchedulesTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesTransitionResponse, error)

	// OrgSchedulesUpdateWithBodyWithResponse request with any body
	OrgSchedulesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesUpdateResponse, error)

	OrgSchedulesUpdateWithResponse(ctx context.Context, body OrgSchedulesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesUpdateResponse, error)

	// PartsCreateWithBodyWithResponse request with any body
	PartsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsCreateResponse, error)

	PartsCreateWithResponse(ctx context.Context, body PartsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsCreateResponse, error)

	// PartsDeleteWithBodyWithResponse request with any body
	PartsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsDeleteResponse, error)

	PartsDeleteWithResponse(ctx context.Context, body PartsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsDeleteResponse, error)

	// PartsGetWithResponse request
	PartsGetWithResponse(ctx context.Context, params *PartsGetParams, reqEditors ...RequestEditorFn) (*PartsGetResponse, error)

	// PartsGetPostWithBodyWithResponse request with any body
	PartsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsGetPostResponse, error)

	PartsGetPostWithResponse(ctx context.Context, body PartsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsGetPostResponse, error)

	// PartsListWithResponse request
	PartsListWithResponse(ctx context.Context, params *PartsListParams, reqEditors ...RequestEditorFn) (*PartsListResponse, error)

	// PartsListPostWithBodyWithResponse request with any body
	PartsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsListPostResponse, error)

	PartsListPostWithResponse(ctx context.Context, body PartsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsListPostResponse, error)

	// PartsUpdateWithBodyWithResponse request with any body
	PartsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsUpdateResponse, error)

	PartsUpdateWithResponse(ctx context.Context, body PartsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsUpdateResponse, error)

	// ReactionsListWithResponse request
	ReactionsListWithResponse(ctx context.Context, params *ReactionsListParams, reqEditors ...RequestEditorFn) (*ReactionsListResponse, error)

	// ReactionsListPostWithBodyWithResponse request with any body
	ReactionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionsListPostResponse, error)

	ReactionsListPostWithResponse(ctx context.Context, body ReactionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionsListPostResponse, error)

	// ReactionsUpdateWithBodyWithResponse request with any body
	ReactionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionsUpdateResponse, error)

	ReactionsUpdateWithResponse(ctx context.Context, body ReactionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionsUpdateResponse, error)

	// RevOrgsCreateWithBodyWithResponse request with any body
	RevOrgsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsCreateResponse, error)

	RevOrgsCreateWithResponse(ctx context.Context, body RevOrgsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsCreateResponse, error)

	// RevOrgsDeleteWithBodyWithResponse request with any body
	RevOrgsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsDeleteResponse, error)

	RevOrgsDeleteWithResponse(ctx context.Context, body RevOrgsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsDeleteResponse, error)

	// RevOrgsGetWithResponse request
	RevOrgsGetWithResponse(ctx context.Context, params *RevOrgsGetParams, reqEditors ...RequestEditorFn) (*RevOrgsGetResponse, error)

	// RevOrgsGetPostWithBodyWithResponse request with any body
	RevOrgsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsGetPostResponse, error)

	RevOrgsGetPostWithResponse(ctx context.Context, body RevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsGetPostResponse, error)

	// RevOrgsListWithResponse request
	RevOrgsListWithResponse(ctx context.Context, params *RevOrgsListParams, reqEditors ...RequestEditorFn) (*RevOrgsListResponse, error)

	// RevOrgsListPostWithBodyWithResponse request with any body
	RevOrgsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsListPostResponse, error)

	RevOrgsListPostWithResponse(ctx context.Context, body RevOrgsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsListPostResponse, error)

	// RevOrgsUpdateWithBodyWithResponse request with any body
	RevOrgsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsUpdateResponse, error)

	RevOrgsUpdateWithResponse(ctx context.Context, body RevOrgsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsUpdateResponse, error)

	// RevUsersCreateWithBodyWithResponse request with any body
	RevUsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersCreateResponse, error)

	RevUsersCreateWithResponse(ctx context.Context, body RevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersCreateResponse, error)

	// RevUsersDeleteWithBodyWithResponse request with any body
	RevUsersDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersDeleteResponse, error)

	RevUsersDeleteWithResponse(ctx context.Context, body RevUsersDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersDeleteResponse, error)

	// RevUsersGetWithResponse request
	RevUsersGetWithResponse(ctx context.Context, params *RevUsersGetParams, reqEditors ...RequestEditorFn) (*RevUsersGetResponse, error)

	// RevUsersGetPostWithBodyWithResponse request with any body
	RevUsersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersGetPostResponse, error)

	RevUsersGetPostWithResponse(ctx context.Context, body RevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersGetPostResponse, error)

	// RevUsersListWithResponse request
	RevUsersListWithResponse(ctx context.Context, params *RevUsersListParams, reqEditors ...RequestEditorFn) (*RevUsersListResponse, error)

	// RevUsersListPostWithBodyWithResponse request with any body
	RevUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersListPostResponse, error)

	RevUsersListPostWithResponse(ctx context.Context, body RevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersListPostResponse, error)

	// RevUsersMergeWithBodyWithResponse request with any body
	RevUsersMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersMergeResponse, error)

	RevUsersMergeWithResponse(ctx context.Context, body RevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersMergeResponse, error)

	// RevUsersScanWithResponse request
	RevUsersScanWithResponse(ctx context.Context, params *RevUsersScanParams, reqEditors ...RequestEditorFn) (*RevUsersScanResponse, error)

	// RevUsersScanPostWithBodyWithResponse request with any body
	RevUsersScanPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersScanPostResponse, error)

	RevUsersScanPostWithResponse(ctx context.Context, body RevUsersScanPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersScanPostResponse, error)

	// RevUsersUpdateWithBodyWithResponse request with any body
	RevUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersUpdateResponse, error)

	RevUsersUpdateWithResponse(ctx context.Context, body RevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersUpdateResponse, error)

	// ServiceAccountsCreateWithBodyWithResponse request with any body
	ServiceAccountsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsCreateResponse, error)

	ServiceAccountsCreateWithResponse(ctx context.Context, body ServiceAccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsCreateResponse, error)

	// ServiceAccountsGetWithResponse request
	ServiceAccountsGetWithResponse(ctx context.Context, params *ServiceAccountsGetParams, reqEditors ...RequestEditorFn) (*ServiceAccountsGetResponse, error)

	// ServiceAccountsGetPostWithBodyWithResponse request with any body
	ServiceAccountsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsGetPostResponse, error)

	ServiceAccountsGetPostWithResponse(ctx context.Context, body ServiceAccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsGetPostResponse, error)

	// SlaTrackersGetWithResponse request
	SlaTrackersGetWithResponse(ctx context.Context, params *SlaTrackersGetParams, reqEditors ...RequestEditorFn) (*SlaTrackersGetResponse, error)

	// SlaTrackersGetPostWithBodyWithResponse request with any body
	SlaTrackersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersGetPostResponse, error)

	SlaTrackersGetPostWithResponse(ctx context.Context, body SlaTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersGetPostResponse, error)

	// SlaTrackersListWithResponse request
	SlaTrackersListWithResponse(ctx context.Context, params *SlaTrackersListParams, reqEditors ...RequestEditorFn) (*SlaTrackersListResponse, error)

	// SlaTrackersListPostWithBodyWithResponse request with any body
	SlaTrackersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersListPostResponse, error)

	SlaTrackersListPostWithResponse(ctx context.Context, body SlaTrackersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersListPostResponse, error)

	// SlasAssignWithBodyWithResponse request with any body
	SlasAssignWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasAssignResponse, error)

	SlasAssignWithResponse(ctx context.Context, body SlasAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasAssignResponse, error)

	// SlasCreateWithBodyWithResponse request with any body
	SlasCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasCreateResponse, error)

	SlasCreateWithResponse(ctx context.Context, body SlasCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasCreateResponse, error)

	// SlasGetWithResponse request
	SlasGetWithResponse(ctx context.Context, params *SlasGetParams, reqEditors ...RequestEditorFn) (*SlasGetResponse, error)

	// SlasGetPostWithBodyWithResponse request with any body
	SlasGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasGetPostResponse, error)

	SlasGetPostWithResponse(ctx context.Context, body SlasGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasGetPostResponse, error)

	// SlasListWithResponse request
	SlasListWithResponse(ctx context.Context, params *SlasListParams, reqEditors ...RequestEditorFn) (*SlasListResponse, error)

	// SlasListPostWithBodyWithResponse request with any body
	SlasListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasListPostResponse, error)

	SlasListPostWithResponse(ctx context.Context, body SlasListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasListPostResponse, error)

	// SlasTransitionWithBodyWithResponse request with any body
	SlasTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasTransitionResponse, error)

	SlasTransitionWithResponse(ctx context.Context, body SlasTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasTransitionResponse, error)

	// SlasUpdateWithBodyWithResponse request with any body
	SlasUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasUpdateResponse, error)

	SlasUpdateWithResponse(ctx context.Context, body SlasUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasUpdateResponse, error)

	// SnapKitActionExecuteDeferredWithBodyWithResponse request with any body
	SnapKitActionExecuteDeferredWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapKitActionExecuteDeferredResponse, error)

	SnapKitActionExecuteDeferredWithResponse(ctx context.Context, body SnapKitActionExecuteDeferredJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapKitActionExecuteDeferredResponse, error)

	// SnapWidgetsCreateWithBodyWithResponse request with any body
	SnapWidgetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapWidgetsCreateResponse, error)

	SnapWidgetsCreateWithResponse(ctx context.Context, body SnapWidgetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapWidgetsCreateResponse, error)

	// SurveysCreateWithBodyWithResponse request with any body
	SurveysCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysCreateResponse, error)

	SurveysCreateWithResponse(ctx context.Context, body SurveysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysCreateResponse, error)

	// SurveysDeleteWithBodyWithResponse request with any body
	SurveysDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysDeleteResponse, error)

	SurveysDeleteWithResponse(ctx context.Context, body SurveysDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysDeleteResponse, error)

	// SurveysGetWithResponse request
	SurveysGetWithResponse(ctx context.Context, params *SurveysGetParams, reqEditors ...RequestEditorFn) (*SurveysGetResponse, error)

	// SurveysGetPostWithBodyWithResponse request with any body
	SurveysGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysGetPostResponse, error)

	SurveysGetPostWithResponse(ctx context.Context, body SurveysGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysGetPostResponse, error)

	// SurveysListWithResponse request
	SurveysListWithResponse(ctx context.Context, params *SurveysListParams, reqEditors ...RequestEditorFn) (*SurveysListResponse, error)

	// SurveysListPostWithBodyWithResponse request with any body
	SurveysListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysListPostResponse, error)

	SurveysListPostWithResponse(ctx context.Context, body SurveysListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysListPostResponse, error)

	// SurveysResponsesListWithResponse request
	SurveysResponsesListWithResponse(ctx context.Context, params *SurveysResponsesListParams, reqEditors ...RequestEditorFn) (*SurveysResponsesListResponse, error)

	// SurveysResponsesListPostWithBodyWithResponse request with any body
	SurveysResponsesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysResponsesListPostResponse, error)

	SurveysResponsesListPostWithResponse(ctx context.Context, body SurveysResponsesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysResponsesListPostResponse, error)

	// SurveysResponsesUpdateWithBodyWithResponse request with any body
	SurveysResponsesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysResponsesUpdateResponse, error)

	SurveysResponsesUpdateWithResponse(ctx context.Context, body SurveysResponsesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysResponsesUpdateResponse, error)

	// SurveysSendWithBodyWithResponse request with any body
	SurveysSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysSendResponse, error)

	SurveysSendWithResponse(ctx context.Context, body SurveysSendJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysSendResponse, error)

	// SurveysSubmitWithBodyWithResponse request with any body
	SurveysSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysSubmitResponse, error)

	SurveysSubmitWithResponse(ctx context.Context, body SurveysSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysSubmitResponse, error)

	// SurveysUpdateWithBodyWithResponse request with any body
	SurveysUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysUpdateResponse, error)

	SurveysUpdateWithResponse(ctx context.Context, body SurveysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysUpdateResponse, error)

	// SysUsersListWithResponse request
	SysUsersListWithResponse(ctx context.Context, params *SysUsersListParams, reqEditors ...RequestEditorFn) (*SysUsersListResponse, error)

	// SysUsersListPostWithBodyWithResponse request with any body
	SysUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SysUsersListPostResponse, error)

	SysUsersListPostWithResponse(ctx context.Context, body SysUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SysUsersListPostResponse, error)

	// SysUsersUpdateWithBodyWithResponse request with any body
	SysUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SysUsersUpdateResponse, error)

	SysUsersUpdateWithResponse(ctx context.Context, body SysUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SysUsersUpdateResponse, error)

	// TagsCreateWithBodyWithResponse request with any body
	TagsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsCreateResponse, error)

	TagsCreateWithResponse(ctx context.Context, body TagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsCreateResponse, error)

	// TagsDeleteWithBodyWithResponse request with any body
	TagsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsDeleteResponse, error)

	TagsDeleteWithResponse(ctx context.Context, body TagsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsDeleteResponse, error)

	// TagsGetWithResponse request
	TagsGetWithResponse(ctx context.Context, params *TagsGetParams, reqEditors ...RequestEditorFn) (*TagsGetResponse, error)

	// TagsGetPostWithBodyWithResponse request with any body
	TagsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsGetPostResponse, error)

	TagsGetPostWithResponse(ctx context.Context, body TagsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsGetPostResponse, error)

	// TagsListWithResponse request
	TagsListWithResponse(ctx context.Context, params *TagsListParams, reqEditors ...RequestEditorFn) (*TagsListResponse, error)

	// TagsListPostWithBodyWithResponse request with any body
	TagsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsListPostResponse, error)

	TagsListPostWithResponse(ctx context.Context, body TagsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsListPostResponse, error)

	// TagsUpdateWithBodyWithResponse request with any body
	TagsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsUpdateResponse, error)

	TagsUpdateWithResponse(ctx context.Context, body TagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsUpdateResponse, error)

	// TimelineEntriesCreateWithBodyWithResponse request with any body
	TimelineEntriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesCreateResponse, error)

	TimelineEntriesCreateWithResponse(ctx context.Context, body TimelineEntriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesCreateResponse, error)

	// TimelineEntriesDeleteWithBodyWithResponse request with any body
	TimelineEntriesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesDeleteResponse, error)

	TimelineEntriesDeleteWithResponse(ctx context.Context, body TimelineEntriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesDeleteResponse, error)

	// TimelineEntriesGetWithResponse request
	TimelineEntriesGetWithResponse(ctx context.Context, params *TimelineEntriesGetParams, reqEditors ...RequestEditorFn) (*TimelineEntriesGetResponse, error)

	// TimelineEntriesGetPostWithBodyWithResponse request with any body
	TimelineEntriesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesGetPostResponse, error)

	TimelineEntriesGetPostWithResponse(ctx context.Context, body TimelineEntriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesGetPostResponse, error)

	// TimelineEntriesListWithResponse request
	TimelineEntriesListWithResponse(ctx context.Context, params *TimelineEntriesListParams, reqEditors ...RequestEditorFn) (*TimelineEntriesListResponse, error)

	// TimelineEntriesListPostWithBodyWithResponse request with any body
	TimelineEntriesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesListPostResponse, error)

	TimelineEntriesListPostWithResponse(ctx context.Context, body TimelineEntriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesListPostResponse, error)

	// TimelineEntriesUpdateWithBodyWithResponse request with any body
	TimelineEntriesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesUpdateResponse, error)

	TimelineEntriesUpdateWithResponse(ctx context.Context, body TimelineEntriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesUpdateResponse, error)

	// WebCrawlerJobsControlWithBodyWithResponse request with any body
	WebCrawlerJobsControlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebCrawlerJobsControlResponse, error)

	WebCrawlerJobsControlWithResponse(ctx context.Context, body WebCrawlerJobsControlJSONRequestBody, reqEditors ...RequestEditorFn) (*WebCrawlerJobsControlResponse, error)

	// CreateWebCrawlerJobWithBodyWithResponse request with any body
	CreateWebCrawlerJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebCrawlerJobResponse, error)

	CreateWebCrawlerJobWithResponse(ctx context.Context, body CreateWebCrawlerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebCrawlerJobResponse, error)

	// GetWebCrawlerJobWithResponse request
	GetWebCrawlerJobWithResponse(ctx context.Context, params *GetWebCrawlerJobParams, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobResponse, error)

	// GetWebCrawlerJobPostWithBodyWithResponse request with any body
	GetWebCrawlerJobPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobPostResponse, error)

	GetWebCrawlerJobPostWithResponse(ctx context.Context, body GetWebCrawlerJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobPostResponse, error)

	// ListWebCrawlerJobsWithResponse request
	ListWebCrawlerJobsWithResponse(ctx context.Context, params *ListWebCrawlerJobsParams, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsResponse, error)

	// ListWebCrawlerJobsPostWithBodyWithResponse request with any body
	ListWebCrawlerJobsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsPostResponse, error)

	ListWebCrawlerJobsPostWithResponse(ctx context.Context, body ListWebCrawlerJobsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsPostResponse, error)

	// WebhooksCreateWithBodyWithResponse request with any body
	WebhooksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error)

	WebhooksCreateWithResponse(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error)

	// WebhooksDeleteWithBodyWithResponse request with any body
	WebhooksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error)

	WebhooksDeleteWithResponse(ctx context.Context, body WebhooksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error)

	// WebhooksEventWithBodyWithResponse request with any body
	WebhooksEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksEventResponse, error)

	WebhooksEventWithResponse(ctx context.Context, body WebhooksEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksEventResponse, error)

	// WebhooksGetWithResponse request
	WebhooksGetWithResponse(ctx context.Context, params *WebhooksGetParams, reqEditors ...RequestEditorFn) (*WebhooksGetResponse, error)

	// WebhooksGetPostWithBodyWithResponse request with any body
	WebhooksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksGetPostResponse, error)

	WebhooksGetPostWithResponse(ctx context.Context, body WebhooksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksGetPostResponse, error)

	// WebhooksListWithResponse request
	WebhooksListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WebhooksListResponse, error)

	// WebhooksListPostWithBodyWithResponse request with any body
	WebhooksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksListPostResponse, error)

	WebhooksListPostWithResponse(ctx context.Context, body WebhooksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksListPostResponse, error)

	// WebhooksUpdateWithBodyWithResponse request with any body
	WebhooksUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error)

	WebhooksUpdateWithResponse(ctx context.Context, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error)

	// WorksCreateWithBodyWithResponse request with any body
	WorksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksCreateResponse, error)

	WorksCreateWithResponse(ctx context.Context, body WorksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksCreateResponse, error)

	// WorksDeleteWithBodyWithResponse request with any body
	WorksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksDeleteResponse, error)

	WorksDeleteWithResponse(ctx context.Context, body WorksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksDeleteResponse, error)

	// WorksExportWithResponse request
	WorksExportWithResponse(ctx context.Context, params *WorksExportParams, reqEditors ...RequestEditorFn) (*WorksExportResponse, error)

	// WorksExportPostWithBodyWithResponse request with any body
	WorksExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksExportPostResponse, error)

	WorksExportPostWithResponse(ctx context.Context, body WorksExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksExportPostResponse, error)

	// WorksGetWithResponse request
	WorksGetWithResponse(ctx context.Context, params *WorksGetParams, reqEditors ...RequestEditorFn) (*WorksGetResponse, error)

	// WorksGetPostWithBodyWithResponse request with any body
	WorksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksGetPostResponse, error)

	WorksGetPostWithResponse(ctx context.Context, body WorksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksGetPostResponse, error)

	// WorksListWithResponse request
	WorksListWithResponse(ctx context.Context, params *WorksListParams, reqEditors ...RequestEditorFn) (*WorksListResponse, error)

	// WorksListPostWithBodyWithResponse request with any body
	WorksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksListPostResponse, error)

	WorksListPostWithResponse(ctx context.Context, body WorksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksListPostResponse, error)

	// WorksUpdateWithBodyWithResponse request with any body
	WorksUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksUpdateResponse, error)

	WorksUpdateWithResponse(ctx context.Context, body WorksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksUpdateResponse, error)
}

type AccountsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccountsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsExportPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsExportPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsExportPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsMergeResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ArticlesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArticlePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetArticlePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticlePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListArticlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListArticlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListArticlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListArticlesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListArticlesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListArticlesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsLocateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsLocateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsLocateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsLocateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsLocatePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsLocateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsLocatePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsLocatePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsPrepareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsPrepareResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsPrepareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsPrepareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsHardDeleteVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsHardDeleteVersionResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsHardDeleteVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsHardDeleteVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsVersionsPrepareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsVersionsPrepareResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsVersionsPrepareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsVersionsPrepareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AtomsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AtomsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AtomsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AtomsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AtomsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AtomsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AtomsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AtomsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthTokensCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensInfoResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensInfoPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensInfoResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensInfoPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensInfoPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensSelfDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensSelfDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensSelfDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ChatsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ChatsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ChatsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ChatsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DevOrgAuthConnectionsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgAuthConnectionsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgAuthConnectionsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgAuthConnectionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgAuthConnectionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsToggleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsToggleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsToggleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DevOrgAuthConnectionsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersActivateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersActivateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersActivateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersActivateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DevUsersCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersDeactivateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersDeactivateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersDeactivateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersDeactivateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersIdentitiesLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersIdentitiesLinkResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersIdentitiesLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersIdentitiesLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersIdentitiesUnlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersIdentitiesUnlinkResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersIdentitiesUnlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersIdentitiesUnlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersMergeResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersSelfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersSelfResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersSelfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersSelfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersSelfPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersSelfResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersSelfPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersSelfPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersSelfUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersSelfUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersSelfUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesCountPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesCountPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesCountPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DirectoriesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GroupsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupMembersAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMembersAddResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupMembersAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupMembersAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupMembersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMembersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupMembersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupMembersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupMembersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMembersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupMembersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupMembersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupMembersRemoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMembersRemoveResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupMembersRemoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupMembersRemoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type KeyringsCreateCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r KeyringsCreateCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r KeyringsCreateCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type KeyringsCreateCallbackPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r KeyringsCreateCallbackPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r KeyringsCreateCallbackPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LinksCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksReplaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LinksReplaceResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksReplaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksReplaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsCountPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsCountPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsCountPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MeetingsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricActionExecuteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricActionExecuteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricActionExecuteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricActionExecuteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MetricDefinitionsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *MetricDefinitionsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricTrackersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricTrackersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricTrackersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricTrackersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricTrackersGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricTrackersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricTrackersGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricTrackersGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgScheduleFragmentsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OrgScheduleFragmentsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgScheduleFragmentsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgScheduleFragmentsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgScheduleFragmentsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgScheduleFragmentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgScheduleFragmentsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgScheduleFragmentsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgScheduleFragmentsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgScheduleFragmentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgScheduleFragmentsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgScheduleFragmentsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgScheduleFragmentsTransitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgScheduleFragmentsTransitionResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgScheduleFragmentsTransitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgScheduleFragmentsTransitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OrgSchedulesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesEvaluateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesEvaluateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesEvaluateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesEvaluateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesEvaluatePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesEvaluateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesEvaluatePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesEvaluatePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesSetFutureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesSetFutureResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesSetFutureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesSetFutureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesTransitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesTransitionResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesTransitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesTransitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OrgSchedulesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PartsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReactionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ReactionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReactionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ReactionsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReactionsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ReactionsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RevOrgsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RevUsersCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersMergeResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersScanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersScanResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersScanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersScanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersScanPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersScanResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersScanPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersScanPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServiceAccountsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ServiceAccountsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServiceAccountsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServiceAccountsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ServiceAccountsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServiceAccountsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServiceAccountsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ServiceAccountsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServiceAccountsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaTrackersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlaTrackersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlaTrackersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaTrackersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaTrackersGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlaTrackersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlaTrackersGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaTrackersGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaTrackersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlaTrackersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlaTrackersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaTrackersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaTrackersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlaTrackersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlaTrackersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaTrackersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasAssignResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasAssignResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasAssignResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasAssignResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SlasCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasTransitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasTransitionResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasTransitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasTransitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SlasUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapKitActionExecuteDeferredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapKitActionExecuteDeferredResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SnapKitActionExecuteDeferredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapKitActionExecuteDeferredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapWidgetsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SnapWidgetsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SnapWidgetsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapWidgetsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SurveysCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysResponsesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysResponsesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysResponsesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysResponsesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysResponsesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysResponsesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysResponsesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysResponsesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysResponsesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SurveysResponsesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysResponsesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysResponsesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysSendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysSendResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysSendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysSendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SurveysSubmitResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SysUsersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SysUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SysUsersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SysUsersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SysUsersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SysUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SysUsersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SysUsersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SysUsersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SysUsersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SysUsersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SysUsersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TagsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TimelineEntriesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebCrawlerJobsControlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsControlResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebCrawlerJobsControlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebCrawlerJobsControlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebCrawlerJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebCrawlerJobsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateWebCrawlerJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebCrawlerJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebCrawlerJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetWebCrawlerJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebCrawlerJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebCrawlerJobPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetWebCrawlerJobPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebCrawlerJobPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebCrawlerJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListWebCrawlerJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebCrawlerJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebCrawlerJobsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListWebCrawlerJobsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebCrawlerJobsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebhooksCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookEventResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WorksCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksExportPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksExportPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksExportPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AccountsCreateWithBodyWithResponse request with arbitrary body returning *AccountsCreateResponse
func (c *ClientWithResponses) AccountsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsCreateResponse, error) {
	rsp, err := c.AccountsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsCreateResponse(rsp)
}

func (c *ClientWithResponses) AccountsCreateWithResponse(ctx context.Context, body AccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsCreateResponse, error) {
	rsp, err := c.AccountsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsCreateResponse(rsp)
}

// AccountsDeleteWithBodyWithResponse request with arbitrary body returning *AccountsDeleteResponse
func (c *ClientWithResponses) AccountsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsDeleteResponse, error) {
	rsp, err := c.AccountsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsDeleteResponse(rsp)
}

func (c *ClientWithResponses) AccountsDeleteWithResponse(ctx context.Context, body AccountsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsDeleteResponse, error) {
	rsp, err := c.AccountsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsDeleteResponse(rsp)
}

// AccountsExportWithResponse request returning *AccountsExportResponse
func (c *ClientWithResponses) AccountsExportWithResponse(ctx context.Context, params *AccountsExportParams, reqEditors ...RequestEditorFn) (*AccountsExportResponse, error) {
	rsp, err := c.AccountsExport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsExportResponse(rsp)
}

// AccountsExportPostWithBodyWithResponse request with arbitrary body returning *AccountsExportPostResponse
func (c *ClientWithResponses) AccountsExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsExportPostResponse, error) {
	rsp, err := c.AccountsExportPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsExportPostResponse(rsp)
}

func (c *ClientWithResponses) AccountsExportPostWithResponse(ctx context.Context, body AccountsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsExportPostResponse, error) {
	rsp, err := c.AccountsExportPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsExportPostResponse(rsp)
}

// AccountsGetWithResponse request returning *AccountsGetResponse
func (c *ClientWithResponses) AccountsGetWithResponse(ctx context.Context, params *AccountsGetParams, reqEditors ...RequestEditorFn) (*AccountsGetResponse, error) {
	rsp, err := c.AccountsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsGetResponse(rsp)
}

// AccountsGetPostWithBodyWithResponse request with arbitrary body returning *AccountsGetPostResponse
func (c *ClientWithResponses) AccountsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsGetPostResponse, error) {
	rsp, err := c.AccountsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsGetPostResponse(rsp)
}

func (c *ClientWithResponses) AccountsGetPostWithResponse(ctx context.Context, body AccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsGetPostResponse, error) {
	rsp, err := c.AccountsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsGetPostResponse(rsp)
}

// AccountsListWithResponse request returning *AccountsListResponse
func (c *ClientWithResponses) AccountsListWithResponse(ctx context.Context, params *AccountsListParams, reqEditors ...RequestEditorFn) (*AccountsListResponse, error) {
	rsp, err := c.AccountsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsListResponse(rsp)
}

// AccountsListPostWithBodyWithResponse request with arbitrary body returning *AccountsListPostResponse
func (c *ClientWithResponses) AccountsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsListPostResponse, error) {
	rsp, err := c.AccountsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsListPostResponse(rsp)
}

func (c *ClientWithResponses) AccountsListPostWithResponse(ctx context.Context, body AccountsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsListPostResponse, error) {
	rsp, err := c.AccountsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsListPostResponse(rsp)
}

// AccountsMergeWithBodyWithResponse request with arbitrary body returning *AccountsMergeResponse
func (c *ClientWithResponses) AccountsMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsMergeResponse, error) {
	rsp, err := c.AccountsMergeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsMergeResponse(rsp)
}

func (c *ClientWithResponses) AccountsMergeWithResponse(ctx context.Context, body AccountsMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsMergeResponse, error) {
	rsp, err := c.AccountsMerge(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsMergeResponse(rsp)
}

// AccountsUpdateWithBodyWithResponse request with arbitrary body returning *AccountsUpdateResponse
func (c *ClientWithResponses) AccountsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsUpdateResponse, error) {
	rsp, err := c.AccountsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsUpdateResponse(rsp)
}

func (c *ClientWithResponses) AccountsUpdateWithResponse(ctx context.Context, body AccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsUpdateResponse, error) {
	rsp, err := c.AccountsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsUpdateResponse(rsp)
}

// CreateArticleWithBodyWithResponse request with arbitrary body returning *CreateArticleResponse
func (c *ClientWithResponses) CreateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error) {
	rsp, err := c.CreateArticleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateArticleResponse(rsp)
}

func (c *ClientWithResponses) CreateArticleWithResponse(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error) {
	rsp, err := c.CreateArticle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateArticleResponse(rsp)
}

// DeleteArticleWithBodyWithResponse request with arbitrary body returning *DeleteArticleResponse
func (c *ClientWithResponses) DeleteArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteArticleResponse, error) {
	rsp, err := c.DeleteArticleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteArticleResponse(rsp)
}

func (c *ClientWithResponses) DeleteArticleWithResponse(ctx context.Context, body DeleteArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteArticleResponse, error) {
	rsp, err := c.DeleteArticle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteArticleResponse(rsp)
}

// GetArticleWithResponse request returning *GetArticleResponse
func (c *ClientWithResponses) GetArticleWithResponse(ctx context.Context, params *GetArticleParams, reqEditors ...RequestEditorFn) (*GetArticleResponse, error) {
	rsp, err := c.GetArticle(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticleResponse(rsp)
}

// GetArticlePostWithBodyWithResponse request with arbitrary body returning *GetArticlePostResponse
func (c *ClientWithResponses) GetArticlePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetArticlePostResponse, error) {
	rsp, err := c.GetArticlePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticlePostResponse(rsp)
}

func (c *ClientWithResponses) GetArticlePostWithResponse(ctx context.Context, body GetArticlePostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetArticlePostResponse, error) {
	rsp, err := c.GetArticlePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticlePostResponse(rsp)
}

// ListArticlesWithResponse request returning *ListArticlesResponse
func (c *ClientWithResponses) ListArticlesWithResponse(ctx context.Context, params *ListArticlesParams, reqEditors ...RequestEditorFn) (*ListArticlesResponse, error) {
	rsp, err := c.ListArticles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListArticlesResponse(rsp)
}

// ListArticlesPostWithBodyWithResponse request with arbitrary body returning *ListArticlesPostResponse
func (c *ClientWithResponses) ListArticlesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListArticlesPostResponse, error) {
	rsp, err := c.ListArticlesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListArticlesPostResponse(rsp)
}

func (c *ClientWithResponses) ListArticlesPostWithResponse(ctx context.Context, body ListArticlesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListArticlesPostResponse, error) {
	rsp, err := c.ListArticlesPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListArticlesPostResponse(rsp)
}

// UpdateArticleWithBodyWithResponse request with arbitrary body returning *UpdateArticleResponse
func (c *ClientWithResponses) UpdateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error) {
	rsp, err := c.UpdateArticleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateArticleResponse(rsp)
}

func (c *ClientWithResponses) UpdateArticleWithResponse(ctx context.Context, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error) {
	rsp, err := c.UpdateArticle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateArticleResponse(rsp)
}

// ArtifactsGetWithResponse request returning *ArtifactsGetResponse
func (c *ClientWithResponses) ArtifactsGetWithResponse(ctx context.Context, params *ArtifactsGetParams, reqEditors ...RequestEditorFn) (*ArtifactsGetResponse, error) {
	rsp, err := c.ArtifactsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsGetResponse(rsp)
}

// ArtifactsGetPostWithBodyWithResponse request with arbitrary body returning *ArtifactsGetPostResponse
func (c *ClientWithResponses) ArtifactsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsGetPostResponse, error) {
	rsp, err := c.ArtifactsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsGetPostResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsGetPostWithResponse(ctx context.Context, body ArtifactsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsGetPostResponse, error) {
	rsp, err := c.ArtifactsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsGetPostResponse(rsp)
}

// ArtifactsListWithResponse request returning *ArtifactsListResponse
func (c *ClientWithResponses) ArtifactsListWithResponse(ctx context.Context, params *ArtifactsListParams, reqEditors ...RequestEditorFn) (*ArtifactsListResponse, error) {
	rsp, err := c.ArtifactsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsListResponse(rsp)
}

// ArtifactsListPostWithBodyWithResponse request with arbitrary body returning *ArtifactsListPostResponse
func (c *ClientWithResponses) ArtifactsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsListPostResponse, error) {
	rsp, err := c.ArtifactsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsListPostResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsListPostWithResponse(ctx context.Context, body ArtifactsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsListPostResponse, error) {
	rsp, err := c.ArtifactsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsListPostResponse(rsp)
}

// ArtifactsLocateWithResponse request returning *ArtifactsLocateResponse
func (c *ClientWithResponses) ArtifactsLocateWithResponse(ctx context.Context, params *ArtifactsLocateParams, reqEditors ...RequestEditorFn) (*ArtifactsLocateResponse, error) {
	rsp, err := c.ArtifactsLocate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsLocateResponse(rsp)
}

// ArtifactsLocatePostWithBodyWithResponse request with arbitrary body returning *ArtifactsLocatePostResponse
func (c *ClientWithResponses) ArtifactsLocatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsLocatePostResponse, error) {
	rsp, err := c.ArtifactsLocatePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsLocatePostResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsLocatePostWithResponse(ctx context.Context, body ArtifactsLocatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsLocatePostResponse, error) {
	rsp, err := c.ArtifactsLocatePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsLocatePostResponse(rsp)
}

// ArtifactsPrepareWithBodyWithResponse request with arbitrary body returning *ArtifactsPrepareResponse
func (c *ClientWithResponses) ArtifactsPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsPrepareResponse, error) {
	rsp, err := c.ArtifactsPrepareWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsPrepareResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsPrepareWithResponse(ctx context.Context, body ArtifactsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsPrepareResponse, error) {
	rsp, err := c.ArtifactsPrepare(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsPrepareResponse(rsp)
}

// ArtifactsHardDeleteVersionWithBodyWithResponse request with arbitrary body returning *ArtifactsHardDeleteVersionResponse
func (c *ClientWithResponses) ArtifactsHardDeleteVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsHardDeleteVersionResponse, error) {
	rsp, err := c.ArtifactsHardDeleteVersionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsHardDeleteVersionResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsHardDeleteVersionWithResponse(ctx context.Context, body ArtifactsHardDeleteVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsHardDeleteVersionResponse, error) {
	rsp, err := c.ArtifactsHardDeleteVersion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsHardDeleteVersionResponse(rsp)
}

// ArtifactsVersionsPrepareWithBodyWithResponse request with arbitrary body returning *ArtifactsVersionsPrepareResponse
func (c *ClientWithResponses) ArtifactsVersionsPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsVersionsPrepareResponse, error) {
	rsp, err := c.ArtifactsVersionsPrepareWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsVersionsPrepareResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsVersionsPrepareWithResponse(ctx context.Context, body ArtifactsVersionsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsVersionsPrepareResponse, error) {
	rsp, err := c.ArtifactsVersionsPrepare(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsVersionsPrepareResponse(rsp)
}

// AtomsGetWithResponse request returning *AtomsGetResponse
func (c *ClientWithResponses) AtomsGetWithResponse(ctx context.Context, params *AtomsGetParams, reqEditors ...RequestEditorFn) (*AtomsGetResponse, error) {
	rsp, err := c.AtomsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAtomsGetResponse(rsp)
}

// AtomsGetPostWithBodyWithResponse request with arbitrary body returning *AtomsGetPostResponse
func (c *ClientWithResponses) AtomsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AtomsGetPostResponse, error) {
	rsp, err := c.AtomsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAtomsGetPostResponse(rsp)
}

func (c *ClientWithResponses) AtomsGetPostWithResponse(ctx context.Context, body AtomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AtomsGetPostResponse, error) {
	rsp, err := c.AtomsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAtomsGetPostResponse(rsp)
}

// AuthTokensCreateWithBodyWithResponse request with arbitrary body returning *AuthTokensCreateResponse
func (c *ClientWithResponses) AuthTokensCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensCreateResponse, error) {
	rsp, err := c.AuthTokensCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensCreateResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensCreateWithResponse(ctx context.Context, body AuthTokensCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensCreateResponse, error) {
	rsp, err := c.AuthTokensCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensCreateResponse(rsp)
}

// AuthTokensDeleteWithBodyWithResponse request with arbitrary body returning *AuthTokensDeleteResponse
func (c *ClientWithResponses) AuthTokensDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensDeleteResponse, error) {
	rsp, err := c.AuthTokensDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensDeleteResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensDeleteWithResponse(ctx context.Context, body AuthTokensDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensDeleteResponse, error) {
	rsp, err := c.AuthTokensDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensDeleteResponse(rsp)
}

// AuthTokensGetWithResponse request returning *AuthTokensGetResponse
func (c *ClientWithResponses) AuthTokensGetWithResponse(ctx context.Context, params *AuthTokensGetParams, reqEditors ...RequestEditorFn) (*AuthTokensGetResponse, error) {
	rsp, err := c.AuthTokensGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensGetResponse(rsp)
}

// AuthTokensGetPostWithBodyWithResponse request with arbitrary body returning *AuthTokensGetPostResponse
func (c *ClientWithResponses) AuthTokensGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensGetPostResponse, error) {
	rsp, err := c.AuthTokensGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensGetPostResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensGetPostWithResponse(ctx context.Context, body AuthTokensGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensGetPostResponse, error) {
	rsp, err := c.AuthTokensGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensGetPostResponse(rsp)
}

// AuthTokensInfoWithResponse request returning *AuthTokensInfoResponse
func (c *ClientWithResponses) AuthTokensInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthTokensInfoResponse, error) {
	rsp, err := c.AuthTokensInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensInfoResponse(rsp)
}

// AuthTokensInfoPostWithBodyWithResponse request with arbitrary body returning *AuthTokensInfoPostResponse
func (c *ClientWithResponses) AuthTokensInfoPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensInfoPostResponse, error) {
	rsp, err := c.AuthTokensInfoPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensInfoPostResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensInfoPostWithResponse(ctx context.Context, body AuthTokensInfoPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensInfoPostResponse, error) {
	rsp, err := c.AuthTokensInfoPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensInfoPostResponse(rsp)
}

// AuthTokensListWithResponse request returning *AuthTokensListResponse
func (c *ClientWithResponses) AuthTokensListWithResponse(ctx context.Context, params *AuthTokensListParams, reqEditors ...RequestEditorFn) (*AuthTokensListResponse, error) {
	rsp, err := c.AuthTokensList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensListResponse(rsp)
}

// AuthTokensListPostWithBodyWithResponse request with arbitrary body returning *AuthTokensListPostResponse
func (c *ClientWithResponses) AuthTokensListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensListPostResponse, error) {
	rsp, err := c.AuthTokensListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensListPostResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensListPostWithResponse(ctx context.Context, body AuthTokensListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensListPostResponse, error) {
	rsp, err := c.AuthTokensListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensListPostResponse(rsp)
}

// AuthTokensSelfDeleteWithBodyWithResponse request with arbitrary body returning *AuthTokensSelfDeleteResponse
func (c *ClientWithResponses) AuthTokensSelfDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensSelfDeleteResponse, error) {
	rsp, err := c.AuthTokensSelfDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensSelfDeleteResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensSelfDeleteWithResponse(ctx context.Context, body AuthTokensSelfDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensSelfDeleteResponse, error) {
	rsp, err := c.AuthTokensSelfDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensSelfDeleteResponse(rsp)
}

// AuthTokensUpdateWithBodyWithResponse request with arbitrary body returning *AuthTokensUpdateResponse
func (c *ClientWithResponses) AuthTokensUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensUpdateResponse, error) {
	rsp, err := c.AuthTokensUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensUpdateResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensUpdateWithResponse(ctx context.Context, body AuthTokensUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensUpdateResponse, error) {
	rsp, err := c.AuthTokensUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensUpdateResponse(rsp)
}

// ChatsCreateWithBodyWithResponse request with arbitrary body returning *ChatsCreateResponse
func (c *ClientWithResponses) ChatsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsCreateResponse, error) {
	rsp, err := c.ChatsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsCreateResponse(rsp)
}

func (c *ClientWithResponses) ChatsCreateWithResponse(ctx context.Context, body ChatsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsCreateResponse, error) {
	rsp, err := c.ChatsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsCreateResponse(rsp)
}

// ChatsGetWithResponse request returning *ChatsGetResponse
func (c *ClientWithResponses) ChatsGetWithResponse(ctx context.Context, params *ChatsGetParams, reqEditors ...RequestEditorFn) (*ChatsGetResponse, error) {
	rsp, err := c.ChatsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsGetResponse(rsp)
}

// ChatsGetPostWithBodyWithResponse request with arbitrary body returning *ChatsGetPostResponse
func (c *ClientWithResponses) ChatsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsGetPostResponse, error) {
	rsp, err := c.ChatsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsGetPostResponse(rsp)
}

func (c *ClientWithResponses) ChatsGetPostWithResponse(ctx context.Context, body ChatsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsGetPostResponse, error) {
	rsp, err := c.ChatsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsGetPostResponse(rsp)
}

// ChatsUpdateWithBodyWithResponse request with arbitrary body returning *ChatsUpdateResponse
func (c *ClientWithResponses) ChatsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsUpdateResponse, error) {
	rsp, err := c.ChatsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ChatsUpdateWithResponse(ctx context.Context, body ChatsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsUpdateResponse, error) {
	rsp, err := c.ChatsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsUpdateResponse(rsp)
}

// CodeChangesCreateWithBodyWithResponse request with arbitrary body returning *CodeChangesCreateResponse
func (c *ClientWithResponses) CodeChangesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesCreateResponse, error) {
	rsp, err := c.CodeChangesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesCreateResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesCreateWithResponse(ctx context.Context, body CodeChangesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesCreateResponse, error) {
	rsp, err := c.CodeChangesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesCreateResponse(rsp)
}

// CodeChangesDeleteWithBodyWithResponse request with arbitrary body returning *CodeChangesDeleteResponse
func (c *ClientWithResponses) CodeChangesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesDeleteResponse, error) {
	rsp, err := c.CodeChangesDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesDeleteResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesDeleteWithResponse(ctx context.Context, body CodeChangesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesDeleteResponse, error) {
	rsp, err := c.CodeChangesDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesDeleteResponse(rsp)
}

// CodeChangesGetWithResponse request returning *CodeChangesGetResponse
func (c *ClientWithResponses) CodeChangesGetWithResponse(ctx context.Context, params *CodeChangesGetParams, reqEditors ...RequestEditorFn) (*CodeChangesGetResponse, error) {
	rsp, err := c.CodeChangesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesGetResponse(rsp)
}

// CodeChangesGetPostWithBodyWithResponse request with arbitrary body returning *CodeChangesGetPostResponse
func (c *ClientWithResponses) CodeChangesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesGetPostResponse, error) {
	rsp, err := c.CodeChangesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesGetPostResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesGetPostWithResponse(ctx context.Context, body CodeChangesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesGetPostResponse, error) {
	rsp, err := c.CodeChangesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesGetPostResponse(rsp)
}

// CodeChangesListWithResponse request returning *CodeChangesListResponse
func (c *ClientWithResponses) CodeChangesListWithResponse(ctx context.Context, params *CodeChangesListParams, reqEditors ...RequestEditorFn) (*CodeChangesListResponse, error) {
	rsp, err := c.CodeChangesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesListResponse(rsp)
}

// CodeChangesListPostWithBodyWithResponse request with arbitrary body returning *CodeChangesListPostResponse
func (c *ClientWithResponses) CodeChangesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesListPostResponse, error) {
	rsp, err := c.CodeChangesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesListPostResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesListPostWithResponse(ctx context.Context, body CodeChangesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesListPostResponse, error) {
	rsp, err := c.CodeChangesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesListPostResponse(rsp)
}

// CodeChangesUpdateWithBodyWithResponse request with arbitrary body returning *CodeChangesUpdateResponse
func (c *ClientWithResponses) CodeChangesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesUpdateResponse, error) {
	rsp, err := c.CodeChangesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesUpdateResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesUpdateWithResponse(ctx context.Context, body CodeChangesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesUpdateResponse, error) {
	rsp, err := c.CodeChangesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesUpdateResponse(rsp)
}

// CommandsCreateWithBodyWithResponse request with arbitrary body returning *CommandsCreateResponse
func (c *ClientWithResponses) CommandsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsCreateResponse, error) {
	rsp, err := c.CommandsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsCreateResponse(rsp)
}

func (c *ClientWithResponses) CommandsCreateWithResponse(ctx context.Context, body CommandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsCreateResponse, error) {
	rsp, err := c.CommandsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsCreateResponse(rsp)
}

// CommandsGetWithResponse request returning *CommandsGetResponse
func (c *ClientWithResponses) CommandsGetWithResponse(ctx context.Context, params *CommandsGetParams, reqEditors ...RequestEditorFn) (*CommandsGetResponse, error) {
	rsp, err := c.CommandsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsGetResponse(rsp)
}

// CommandsGetPostWithBodyWithResponse request with arbitrary body returning *CommandsGetPostResponse
func (c *ClientWithResponses) CommandsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsGetPostResponse, error) {
	rsp, err := c.CommandsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsGetPostResponse(rsp)
}

func (c *ClientWithResponses) CommandsGetPostWithResponse(ctx context.Context, body CommandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsGetPostResponse, error) {
	rsp, err := c.CommandsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsGetPostResponse(rsp)
}

// CommandsListWithResponse request returning *CommandsListResponse
func (c *ClientWithResponses) CommandsListWithResponse(ctx context.Context, params *CommandsListParams, reqEditors ...RequestEditorFn) (*CommandsListResponse, error) {
	rsp, err := c.CommandsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsListResponse(rsp)
}

// CommandsListPostWithBodyWithResponse request with arbitrary body returning *CommandsListPostResponse
func (c *ClientWithResponses) CommandsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsListPostResponse, error) {
	rsp, err := c.CommandsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsListPostResponse(rsp)
}

func (c *ClientWithResponses) CommandsListPostWithResponse(ctx context.Context, body CommandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsListPostResponse, error) {
	rsp, err := c.CommandsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsListPostResponse(rsp)
}

// CommandsUpdateWithBodyWithResponse request with arbitrary body returning *CommandsUpdateResponse
func (c *ClientWithResponses) CommandsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsUpdateResponse, error) {
	rsp, err := c.CommandsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsUpdateResponse(rsp)
}

func (c *ClientWithResponses) CommandsUpdateWithResponse(ctx context.Context, body CommandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsUpdateResponse, error) {
	rsp, err := c.CommandsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsUpdateResponse(rsp)
}

// ConversationsCreateWithBodyWithResponse request with arbitrary body returning *ConversationsCreateResponse
func (c *ClientWithResponses) ConversationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsCreateResponse, error) {
	rsp, err := c.ConversationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsCreateResponse(rsp)
}

func (c *ClientWithResponses) ConversationsCreateWithResponse(ctx context.Context, body ConversationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsCreateResponse, error) {
	rsp, err := c.ConversationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsCreateResponse(rsp)
}

// ConversationsDeleteWithBodyWithResponse request with arbitrary body returning *ConversationsDeleteResponse
func (c *ClientWithResponses) ConversationsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsDeleteResponse, error) {
	rsp, err := c.ConversationsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsDeleteResponse(rsp)
}

func (c *ClientWithResponses) ConversationsDeleteWithResponse(ctx context.Context, body ConversationsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsDeleteResponse, error) {
	rsp, err := c.ConversationsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsDeleteResponse(rsp)
}

// ConversationsGetWithResponse request returning *ConversationsGetResponse
func (c *ClientWithResponses) ConversationsGetWithResponse(ctx context.Context, params *ConversationsGetParams, reqEditors ...RequestEditorFn) (*ConversationsGetResponse, error) {
	rsp, err := c.ConversationsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsGetResponse(rsp)
}

// ConversationsGetPostWithBodyWithResponse request with arbitrary body returning *ConversationsGetPostResponse
func (c *ClientWithResponses) ConversationsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsGetPostResponse, error) {
	rsp, err := c.ConversationsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsGetPostResponse(rsp)
}

func (c *ClientWithResponses) ConversationsGetPostWithResponse(ctx context.Context, body ConversationsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsGetPostResponse, error) {
	rsp, err := c.ConversationsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsGetPostResponse(rsp)
}

// ConversationsListWithResponse request returning *ConversationsListResponse
func (c *ClientWithResponses) ConversationsListWithResponse(ctx context.Context, params *ConversationsListParams, reqEditors ...RequestEditorFn) (*ConversationsListResponse, error) {
	rsp, err := c.ConversationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsListResponse(rsp)
}

// ConversationsListPostWithBodyWithResponse request with arbitrary body returning *ConversationsListPostResponse
func (c *ClientWithResponses) ConversationsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsListPostResponse, error) {
	rsp, err := c.ConversationsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsListPostResponse(rsp)
}

func (c *ClientWithResponses) ConversationsListPostWithResponse(ctx context.Context, body ConversationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsListPostResponse, error) {
	rsp, err := c.ConversationsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsListPostResponse(rsp)
}

// ConversationsUpdateWithBodyWithResponse request with arbitrary body returning *ConversationsUpdateResponse
func (c *ClientWithResponses) ConversationsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsUpdateResponse, error) {
	rsp, err := c.ConversationsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ConversationsUpdateWithResponse(ctx context.Context, body ConversationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsUpdateResponse, error) {
	rsp, err := c.ConversationsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsUpdateResponse(rsp)
}

// DevOrgAuthConnectionsCreateWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsCreateResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsCreateResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsCreateResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsCreateWithResponse(ctx context.Context, body DevOrgAuthConnectionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsCreateResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsCreateResponse(rsp)
}

// DevOrgAuthConnectionsDeleteWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsDeleteResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsDeleteResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsDeleteResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsDeleteWithResponse(ctx context.Context, body DevOrgAuthConnectionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsDeleteResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsDeleteResponse(rsp)
}

// DevOrgAuthConnectionsGetWithResponse request returning *DevOrgAuthConnectionsGetResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsGetWithResponse(ctx context.Context, params *DevOrgAuthConnectionsGetParams, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsGetResponse(rsp)
}

// DevOrgAuthConnectionsGetPostWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsGetPostResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetPostResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsGetPostResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsGetPostWithResponse(ctx context.Context, body DevOrgAuthConnectionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetPostResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsGetPostResponse(rsp)
}

// DevOrgAuthConnectionsListWithResponse request returning *DevOrgAuthConnectionsListResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsListResponse(rsp)
}

// DevOrgAuthConnectionsListPostWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsListPostResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListPostResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsListPostResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsListPostWithResponse(ctx context.Context, body DevOrgAuthConnectionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListPostResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsListPostResponse(rsp)
}

// DevOrgAuthConnectionsToggleWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsToggleResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsToggleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsToggleResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsToggleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsToggleResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsToggleWithResponse(ctx context.Context, body DevOrgAuthConnectionsToggleJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsToggleResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsToggle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsToggleResponse(rsp)
}

// DevOrgAuthConnectionsUpdateWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsUpdateResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsUpdateResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsUpdateResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsUpdateWithResponse(ctx context.Context, body DevOrgAuthConnectionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsUpdateResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsUpdateResponse(rsp)
}

// DevOrgsGetWithResponse request returning *DevOrgsGetResponse
func (c *ClientWithResponses) DevOrgsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevOrgsGetResponse, error) {
	rsp, err := c.DevOrgsGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgsGetResponse(rsp)
}

// DevOrgsGetPostWithBodyWithResponse request with arbitrary body returning *DevOrgsGetPostResponse
func (c *ClientWithResponses) DevOrgsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgsGetPostResponse, error) {
	rsp, err := c.DevOrgsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgsGetPostResponse(rsp)
}

func (c *ClientWithResponses) DevOrgsGetPostWithResponse(ctx context.Context, body DevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgsGetPostResponse, error) {
	rsp, err := c.DevOrgsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgsGetPostResponse(rsp)
}

// DevUsersActivateWithBodyWithResponse request with arbitrary body returning *DevUsersActivateResponse
func (c *ClientWithResponses) DevUsersActivateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersActivateResponse, error) {
	rsp, err := c.DevUsersActivateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersActivateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersActivateWithResponse(ctx context.Context, body DevUsersActivateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersActivateResponse, error) {
	rsp, err := c.DevUsersActivate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersActivateResponse(rsp)
}

// DevUsersCreateWithBodyWithResponse request with arbitrary body returning *DevUsersCreateResponse
func (c *ClientWithResponses) DevUsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersCreateResponse, error) {
	rsp, err := c.DevUsersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersCreateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersCreateWithResponse(ctx context.Context, body DevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersCreateResponse, error) {
	rsp, err := c.DevUsersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersCreateResponse(rsp)
}

// DevUsersDeactivateWithBodyWithResponse request with arbitrary body returning *DevUsersDeactivateResponse
func (c *ClientWithResponses) DevUsersDeactivateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersDeactivateResponse, error) {
	rsp, err := c.DevUsersDeactivateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersDeactivateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersDeactivateWithResponse(ctx context.Context, body DevUsersDeactivateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersDeactivateResponse, error) {
	rsp, err := c.DevUsersDeactivate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersDeactivateResponse(rsp)
}

// DevUsersGetWithResponse request returning *DevUsersGetResponse
func (c *ClientWithResponses) DevUsersGetWithResponse(ctx context.Context, params *DevUsersGetParams, reqEditors ...RequestEditorFn) (*DevUsersGetResponse, error) {
	rsp, err := c.DevUsersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersGetResponse(rsp)
}

// DevUsersGetPostWithBodyWithResponse request with arbitrary body returning *DevUsersGetPostResponse
func (c *ClientWithResponses) DevUsersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersGetPostResponse, error) {
	rsp, err := c.DevUsersGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersGetPostResponse(rsp)
}

func (c *ClientWithResponses) DevUsersGetPostWithResponse(ctx context.Context, body DevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersGetPostResponse, error) {
	rsp, err := c.DevUsersGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersGetPostResponse(rsp)
}

// DevUsersIdentitiesLinkWithBodyWithResponse request with arbitrary body returning *DevUsersIdentitiesLinkResponse
func (c *ClientWithResponses) DevUsersIdentitiesLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesLinkResponse, error) {
	rsp, err := c.DevUsersIdentitiesLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersIdentitiesLinkResponse(rsp)
}

func (c *ClientWithResponses) DevUsersIdentitiesLinkWithResponse(ctx context.Context, body DevUsersIdentitiesLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesLinkResponse, error) {
	rsp, err := c.DevUsersIdentitiesLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersIdentitiesLinkResponse(rsp)
}

// DevUsersIdentitiesUnlinkWithBodyWithResponse request with arbitrary body returning *DevUsersIdentitiesUnlinkResponse
func (c *ClientWithResponses) DevUsersIdentitiesUnlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesUnlinkResponse, error) {
	rsp, err := c.DevUsersIdentitiesUnlinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersIdentitiesUnlinkResponse(rsp)
}

func (c *ClientWithResponses) DevUsersIdentitiesUnlinkWithResponse(ctx context.Context, body DevUsersIdentitiesUnlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesUnlinkResponse, error) {
	rsp, err := c.DevUsersIdentitiesUnlink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersIdentitiesUnlinkResponse(rsp)
}

// DevUsersListWithResponse request returning *DevUsersListResponse
func (c *ClientWithResponses) DevUsersListWithResponse(ctx context.Context, params *DevUsersListParams, reqEditors ...RequestEditorFn) (*DevUsersListResponse, error) {
	rsp, err := c.DevUsersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersListResponse(rsp)
}

// DevUsersListPostWithBodyWithResponse request with arbitrary body returning *DevUsersListPostResponse
func (c *ClientWithResponses) DevUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersListPostResponse, error) {
	rsp, err := c.DevUsersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersListPostResponse(rsp)
}

func (c *ClientWithResponses) DevUsersListPostWithResponse(ctx context.Context, body DevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersListPostResponse, error) {
	rsp, err := c.DevUsersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersListPostResponse(rsp)
}

// DevUsersMergeWithBodyWithResponse request with arbitrary body returning *DevUsersMergeResponse
func (c *ClientWithResponses) DevUsersMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersMergeResponse, error) {
	rsp, err := c.DevUsersMergeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersMergeResponse(rsp)
}

func (c *ClientWithResponses) DevUsersMergeWithResponse(ctx context.Context, body DevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersMergeResponse, error) {
	rsp, err := c.DevUsersMerge(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersMergeResponse(rsp)
}

// DevUsersSelfWithResponse request returning *DevUsersSelfResponse
func (c *ClientWithResponses) DevUsersSelfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevUsersSelfResponse, error) {
	rsp, err := c.DevUsersSelf(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfResponse(rsp)
}

// DevUsersSelfPostWithBodyWithResponse request with arbitrary body returning *DevUsersSelfPostResponse
func (c *ClientWithResponses) DevUsersSelfPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersSelfPostResponse, error) {
	rsp, err := c.DevUsersSelfPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfPostResponse(rsp)
}

func (c *ClientWithResponses) DevUsersSelfPostWithResponse(ctx context.Context, body DevUsersSelfPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersSelfPostResponse, error) {
	rsp, err := c.DevUsersSelfPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfPostResponse(rsp)
}

// DevUsersSelfUpdateWithBodyWithResponse request with arbitrary body returning *DevUsersSelfUpdateResponse
func (c *ClientWithResponses) DevUsersSelfUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersSelfUpdateResponse, error) {
	rsp, err := c.DevUsersSelfUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfUpdateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersSelfUpdateWithResponse(ctx context.Context, body DevUsersSelfUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersSelfUpdateResponse, error) {
	rsp, err := c.DevUsersSelfUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfUpdateResponse(rsp)
}

// DevUsersUpdateWithBodyWithResponse request with arbitrary body returning *DevUsersUpdateResponse
func (c *ClientWithResponses) DevUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersUpdateResponse, error) {
	rsp, err := c.DevUsersUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersUpdateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersUpdateWithResponse(ctx context.Context, body DevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersUpdateResponse, error) {
	rsp, err := c.DevUsersUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersUpdateResponse(rsp)
}

// DirectoriesCountWithResponse request returning *DirectoriesCountResponse
func (c *ClientWithResponses) DirectoriesCountWithResponse(ctx context.Context, params *DirectoriesCountParams, reqEditors ...RequestEditorFn) (*DirectoriesCountResponse, error) {
	rsp, err := c.DirectoriesCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCountResponse(rsp)
}

// DirectoriesCountPostWithBodyWithResponse request with arbitrary body returning *DirectoriesCountPostResponse
func (c *ClientWithResponses) DirectoriesCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesCountPostResponse, error) {
	rsp, err := c.DirectoriesCountPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCountPostResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesCountPostWithResponse(ctx context.Context, body DirectoriesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesCountPostResponse, error) {
	rsp, err := c.DirectoriesCountPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCountPostResponse(rsp)
}

// DirectoriesCreateWithBodyWithResponse request with arbitrary body returning *DirectoriesCreateResponse
func (c *ClientWithResponses) DirectoriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesCreateResponse, error) {
	rsp, err := c.DirectoriesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCreateResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesCreateWithResponse(ctx context.Context, body DirectoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesCreateResponse, error) {
	rsp, err := c.DirectoriesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCreateResponse(rsp)
}

// DirectoriesDeleteWithBodyWithResponse request with arbitrary body returning *DirectoriesDeleteResponse
func (c *ClientWithResponses) DirectoriesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesDeleteResponse, error) {
	rsp, err := c.DirectoriesDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesDeleteResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesDeleteWithResponse(ctx context.Context, body DirectoriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesDeleteResponse, error) {
	rsp, err := c.DirectoriesDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesDeleteResponse(rsp)
}

// DirectoriesGetWithResponse request returning *DirectoriesGetResponse
func (c *ClientWithResponses) DirectoriesGetWithResponse(ctx context.Context, params *DirectoriesGetParams, reqEditors ...RequestEditorFn) (*DirectoriesGetResponse, error) {
	rsp, err := c.DirectoriesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesGetResponse(rsp)
}

// DirectoriesGetPostWithBodyWithResponse request with arbitrary body returning *DirectoriesGetPostResponse
func (c *ClientWithResponses) DirectoriesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesGetPostResponse, error) {
	rsp, err := c.DirectoriesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesGetPostResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesGetPostWithResponse(ctx context.Context, body DirectoriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesGetPostResponse, error) {
	rsp, err := c.DirectoriesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesGetPostResponse(rsp)
}

// DirectoriesListWithResponse request returning *DirectoriesListResponse
func (c *ClientWithResponses) DirectoriesListWithResponse(ctx context.Context, params *DirectoriesListParams, reqEditors ...RequestEditorFn) (*DirectoriesListResponse, error) {
	rsp, err := c.DirectoriesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesListResponse(rsp)
}

// DirectoriesListPostWithBodyWithResponse request with arbitrary body returning *DirectoriesListPostResponse
func (c *ClientWithResponses) DirectoriesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesListPostResponse, error) {
	rsp, err := c.DirectoriesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesListPostResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesListPostWithResponse(ctx context.Context, body DirectoriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesListPostResponse, error) {
	rsp, err := c.DirectoriesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesListPostResponse(rsp)
}

// DirectoriesUpdateWithBodyWithResponse request with arbitrary body returning *DirectoriesUpdateResponse
func (c *ClientWithResponses) DirectoriesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesUpdateResponse, error) {
	rsp, err := c.DirectoriesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesUpdateResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesUpdateWithResponse(ctx context.Context, body DirectoriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesUpdateResponse, error) {
	rsp, err := c.DirectoriesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesUpdateResponse(rsp)
}

// GroupsCreateWithBodyWithResponse request with arbitrary body returning *GroupsCreateResponse
func (c *ClientWithResponses) GroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error) {
	rsp, err := c.GroupsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) GroupsCreateWithResponse(ctx context.Context, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error) {
	rsp, err := c.GroupsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsCreateResponse(rsp)
}

// GroupsGetWithResponse request returning *GroupsGetResponse
func (c *ClientWithResponses) GroupsGetWithResponse(ctx context.Context, params *GroupsGetParams, reqEditors ...RequestEditorFn) (*GroupsGetResponse, error) {
	rsp, err := c.GroupsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsGetResponse(rsp)
}

// GroupsGetPostWithBodyWithResponse request with arbitrary body returning *GroupsGetPostResponse
func (c *ClientWithResponses) GroupsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsGetPostResponse, error) {
	rsp, err := c.GroupsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsGetPostResponse(rsp)
}

func (c *ClientWithResponses) GroupsGetPostWithResponse(ctx context.Context, body GroupsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsGetPostResponse, error) {
	rsp, err := c.GroupsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsGetPostResponse(rsp)
}

// GroupsListWithResponse request returning *GroupsListResponse
func (c *ClientWithResponses) GroupsListWithResponse(ctx context.Context, params *GroupsListParams, reqEditors ...RequestEditorFn) (*GroupsListResponse, error) {
	rsp, err := c.GroupsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsListResponse(rsp)
}

// GroupsListPostWithBodyWithResponse request with arbitrary body returning *GroupsListPostResponse
func (c *ClientWithResponses) GroupsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsListPostResponse, error) {
	rsp, err := c.GroupsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsListPostResponse(rsp)
}

func (c *ClientWithResponses) GroupsListPostWithResponse(ctx context.Context, body GroupsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsListPostResponse, error) {
	rsp, err := c.GroupsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsListPostResponse(rsp)
}

// GroupMembersAddWithBodyWithResponse request with arbitrary body returning *GroupMembersAddResponse
func (c *ClientWithResponses) GroupMembersAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersAddResponse, error) {
	rsp, err := c.GroupMembersAddWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersAddResponse(rsp)
}

func (c *ClientWithResponses) GroupMembersAddWithResponse(ctx context.Context, body GroupMembersAddJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersAddResponse, error) {
	rsp, err := c.GroupMembersAdd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersAddResponse(rsp)
}

// GroupMembersListWithResponse request returning *GroupMembersListResponse
func (c *ClientWithResponses) GroupMembersListWithResponse(ctx context.Context, params *GroupMembersListParams, reqEditors ...RequestEditorFn) (*GroupMembersListResponse, error) {
	rsp, err := c.GroupMembersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersListResponse(rsp)
}

// GroupMembersListPostWithBodyWithResponse request with arbitrary body returning *GroupMembersListPostResponse
func (c *ClientWithResponses) GroupMembersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersListPostResponse, error) {
	rsp, err := c.GroupMembersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersListPostResponse(rsp)
}

func (c *ClientWithResponses) GroupMembersListPostWithResponse(ctx context.Context, body GroupMembersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersListPostResponse, error) {
	rsp, err := c.GroupMembersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersListPostResponse(rsp)
}

// GroupMembersRemoveWithBodyWithResponse request with arbitrary body returning *GroupMembersRemoveResponse
func (c *ClientWithResponses) GroupMembersRemoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersRemoveResponse, error) {
	rsp, err := c.GroupMembersRemoveWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersRemoveResponse(rsp)
}

func (c *ClientWithResponses) GroupMembersRemoveWithResponse(ctx context.Context, body GroupMembersRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersRemoveResponse, error) {
	rsp, err := c.GroupMembersRemove(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersRemoveResponse(rsp)
}

// GroupsUpdateWithBodyWithResponse request with arbitrary body returning *GroupsUpdateResponse
func (c *ClientWithResponses) GroupsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsUpdateResponse, error) {
	rsp, err := c.GroupsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsUpdateResponse(rsp)
}

func (c *ClientWithResponses) GroupsUpdateWithResponse(ctx context.Context, body GroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsUpdateResponse, error) {
	rsp, err := c.GroupsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsUpdateResponse(rsp)
}

// KeyringsCreateCallbackWithResponse request returning *KeyringsCreateCallbackResponse
func (c *ClientWithResponses) KeyringsCreateCallbackWithResponse(ctx context.Context, params *KeyringsCreateCallbackParams, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackResponse, error) {
	rsp, err := c.KeyringsCreateCallback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKeyringsCreateCallbackResponse(rsp)
}

// KeyringsCreateCallbackPostWithBodyWithResponse request with arbitrary body returning *KeyringsCreateCallbackPostResponse
func (c *ClientWithResponses) KeyringsCreateCallbackPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackPostResponse, error) {
	rsp, err := c.KeyringsCreateCallbackPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKeyringsCreateCallbackPostResponse(rsp)
}

func (c *ClientWithResponses) KeyringsCreateCallbackPostWithResponse(ctx context.Context, body KeyringsCreateCallbackPostJSONRequestBody, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackPostResponse, error) {
	rsp, err := c.KeyringsCreateCallbackPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKeyringsCreateCallbackPostResponse(rsp)
}

// LinksCreateWithBodyWithResponse request with arbitrary body returning *LinksCreateResponse
func (c *ClientWithResponses) LinksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksCreateResponse, error) {
	rsp, err := c.LinksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksCreateResponse(rsp)
}

func (c *ClientWithResponses) LinksCreateWithResponse(ctx context.Context, body LinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksCreateResponse, error) {
	rsp, err := c.LinksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksCreateResponse(rsp)
}

// LinksDeleteWithBodyWithResponse request with arbitrary body returning *LinksDeleteResponse
func (c *ClientWithResponses) LinksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksDeleteResponse, error) {
	rsp, err := c.LinksDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksDeleteResponse(rsp)
}

func (c *ClientWithResponses) LinksDeleteWithResponse(ctx context.Context, body LinksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksDeleteResponse, error) {
	rsp, err := c.LinksDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksDeleteResponse(rsp)
}

// LinksGetWithResponse request returning *LinksGetResponse
func (c *ClientWithResponses) LinksGetWithResponse(ctx context.Context, params *LinksGetParams, reqEditors ...RequestEditorFn) (*LinksGetResponse, error) {
	rsp, err := c.LinksGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksGetResponse(rsp)
}

// LinksGetPostWithBodyWithResponse request with arbitrary body returning *LinksGetPostResponse
func (c *ClientWithResponses) LinksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksGetPostResponse, error) {
	rsp, err := c.LinksGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksGetPostResponse(rsp)
}

func (c *ClientWithResponses) LinksGetPostWithResponse(ctx context.Context, body LinksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksGetPostResponse, error) {
	rsp, err := c.LinksGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksGetPostResponse(rsp)
}

// LinksListWithResponse request returning *LinksListResponse
func (c *ClientWithResponses) LinksListWithResponse(ctx context.Context, params *LinksListParams, reqEditors ...RequestEditorFn) (*LinksListResponse, error) {
	rsp, err := c.LinksList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksListResponse(rsp)
}

// LinksListPostWithBodyWithResponse request with arbitrary body returning *LinksListPostResponse
func (c *ClientWithResponses) LinksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksListPostResponse, error) {
	rsp, err := c.LinksListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksListPostResponse(rsp)
}

func (c *ClientWithResponses) LinksListPostWithResponse(ctx context.Context, body LinksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksListPostResponse, error) {
	rsp, err := c.LinksListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksListPostResponse(rsp)
}

// LinksReplaceWithBodyWithResponse request with arbitrary body returning *LinksReplaceResponse
func (c *ClientWithResponses) LinksReplaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksReplaceResponse, error) {
	rsp, err := c.LinksReplaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksReplaceResponse(rsp)
}

func (c *ClientWithResponses) LinksReplaceWithResponse(ctx context.Context, body LinksReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksReplaceResponse, error) {
	rsp, err := c.LinksReplace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksReplaceResponse(rsp)
}

// MeetingsCountWithResponse request returning *MeetingsCountResponse
func (c *ClientWithResponses) MeetingsCountWithResponse(ctx context.Context, params *MeetingsCountParams, reqEditors ...RequestEditorFn) (*MeetingsCountResponse, error) {
	rsp, err := c.MeetingsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCountResponse(rsp)
}

// MeetingsCountPostWithBodyWithResponse request with arbitrary body returning *MeetingsCountPostResponse
func (c *ClientWithResponses) MeetingsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsCountPostResponse, error) {
	rsp, err := c.MeetingsCountPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCountPostResponse(rsp)
}

func (c *ClientWithResponses) MeetingsCountPostWithResponse(ctx context.Context, body MeetingsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsCountPostResponse, error) {
	rsp, err := c.MeetingsCountPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCountPostResponse(rsp)
}

// MeetingsCreateWithBodyWithResponse request with arbitrary body returning *MeetingsCreateResponse
func (c *ClientWithResponses) MeetingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsCreateResponse, error) {
	rsp, err := c.MeetingsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCreateResponse(rsp)
}

func (c *ClientWithResponses) MeetingsCreateWithResponse(ctx context.Context, body MeetingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsCreateResponse, error) {
	rsp, err := c.MeetingsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCreateResponse(rsp)
}

// MeetingsDeleteWithBodyWithResponse request with arbitrary body returning *MeetingsDeleteResponse
func (c *ClientWithResponses) MeetingsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsDeleteResponse, error) {
	rsp, err := c.MeetingsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsDeleteResponse(rsp)
}

func (c *ClientWithResponses) MeetingsDeleteWithResponse(ctx context.Context, body MeetingsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsDeleteResponse, error) {
	rsp, err := c.MeetingsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsDeleteResponse(rsp)
}

// MeetingsGetWithResponse request returning *MeetingsGetResponse
func (c *ClientWithResponses) MeetingsGetWithResponse(ctx context.Context, params *MeetingsGetParams, reqEditors ...RequestEditorFn) (*MeetingsGetResponse, error) {
	rsp, err := c.MeetingsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsGetResponse(rsp)
}

// MeetingsGetPostWithBodyWithResponse request with arbitrary body returning *MeetingsGetPostResponse
func (c *ClientWithResponses) MeetingsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsGetPostResponse, error) {
	rsp, err := c.MeetingsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsGetPostResponse(rsp)
}

func (c *ClientWithResponses) MeetingsGetPostWithResponse(ctx context.Context, body MeetingsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsGetPostResponse, error) {
	rsp, err := c.MeetingsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsGetPostResponse(rsp)
}

// MeetingsListWithResponse request returning *MeetingsListResponse
func (c *ClientWithResponses) MeetingsListWithResponse(ctx context.Context, params *MeetingsListParams, reqEditors ...RequestEditorFn) (*MeetingsListResponse, error) {
	rsp, err := c.MeetingsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsListResponse(rsp)
}

// MeetingsListPostWithBodyWithResponse request with arbitrary body returning *MeetingsListPostResponse
func (c *ClientWithResponses) MeetingsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsListPostResponse, error) {
	rsp, err := c.MeetingsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsListPostResponse(rsp)
}

func (c *ClientWithResponses) MeetingsListPostWithResponse(ctx context.Context, body MeetingsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsListPostResponse, error) {
	rsp, err := c.MeetingsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsListPostResponse(rsp)
}

// MeetingsUpdateWithBodyWithResponse request with arbitrary body returning *MeetingsUpdateResponse
func (c *ClientWithResponses) MeetingsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsUpdateResponse, error) {
	rsp, err := c.MeetingsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsUpdateResponse(rsp)
}

func (c *ClientWithResponses) MeetingsUpdateWithResponse(ctx context.Context, body MeetingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsUpdateResponse, error) {
	rsp, err := c.MeetingsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsUpdateResponse(rsp)
}

// MetricActionExecuteWithBodyWithResponse request with arbitrary body returning *MetricActionExecuteResponse
func (c *ClientWithResponses) MetricActionExecuteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricActionExecuteResponse, error) {
	rsp, err := c.MetricActionExecuteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricActionExecuteResponse(rsp)
}

func (c *ClientWithResponses) MetricActionExecuteWithResponse(ctx context.Context, body MetricActionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricActionExecuteResponse, error) {
	rsp, err := c.MetricActionExecute(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricActionExecuteResponse(rsp)
}

// MetricDefinitionsCreateWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsCreateResponse
func (c *ClientWithResponses) MetricDefinitionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsCreateResponse, error) {
	rsp, err := c.MetricDefinitionsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsCreateResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsCreateWithResponse(ctx context.Context, body MetricDefinitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsCreateResponse, error) {
	rsp, err := c.MetricDefinitionsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsCreateResponse(rsp)
}

// MetricDefinitionsDeleteWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsDeleteResponse
func (c *ClientWithResponses) MetricDefinitionsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsDeleteResponse, error) {
	rsp, err := c.MetricDefinitionsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsDeleteResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsDeleteWithResponse(ctx context.Context, body MetricDefinitionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsDeleteResponse, error) {
	rsp, err := c.MetricDefinitionsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsDeleteResponse(rsp)
}

// MetricDefinitionsGetWithResponse request returning *MetricDefinitionsGetResponse
func (c *ClientWithResponses) MetricDefinitionsGetWithResponse(ctx context.Context, params *MetricDefinitionsGetParams, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetResponse, error) {
	rsp, err := c.MetricDefinitionsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsGetResponse(rsp)
}

// MetricDefinitionsGetPostWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsGetPostResponse
func (c *ClientWithResponses) MetricDefinitionsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetPostResponse, error) {
	rsp, err := c.MetricDefinitionsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsGetPostResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsGetPostWithResponse(ctx context.Context, body MetricDefinitionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetPostResponse, error) {
	rsp, err := c.MetricDefinitionsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsGetPostResponse(rsp)
}

// MetricDefinitionsListWithResponse request returning *MetricDefinitionsListResponse
func (c *ClientWithResponses) MetricDefinitionsListWithResponse(ctx context.Context, params *MetricDefinitionsListParams, reqEditors ...RequestEditorFn) (*MetricDefinitionsListResponse, error) {
	rsp, err := c.MetricDefinitionsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsListResponse(rsp)
}

// MetricDefinitionsListPostWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsListPostResponse
func (c *ClientWithResponses) MetricDefinitionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsListPostResponse, error) {
	rsp, err := c.MetricDefinitionsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsListPostResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsListPostWithResponse(ctx context.Context, body MetricDefinitionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsListPostResponse, error) {
	rsp, err := c.MetricDefinitionsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsListPostResponse(rsp)
}

// MetricDefinitionsUpdateWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsUpdateResponse
func (c *ClientWithResponses) MetricDefinitionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsUpdateResponse, error) {
	rsp, err := c.MetricDefinitionsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsUpdateResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsUpdateWithResponse(ctx context.Context, body MetricDefinitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsUpdateResponse, error) {
	rsp, err := c.MetricDefinitionsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsUpdateResponse(rsp)
}

// MetricTrackersGetWithResponse request returning *MetricTrackersGetResponse
func (c *ClientWithResponses) MetricTrackersGetWithResponse(ctx context.Context, params *MetricTrackersGetParams, reqEditors ...RequestEditorFn) (*MetricTrackersGetResponse, error) {
	rsp, err := c.MetricTrackersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricTrackersGetResponse(rsp)
}

// MetricTrackersGetPostWithBodyWithResponse request with arbitrary body returning *MetricTrackersGetPostResponse
func (c *ClientWithResponses) MetricTrackersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricTrackersGetPostResponse, error) {
	rsp, err := c.MetricTrackersGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricTrackersGetPostResponse(rsp)
}

func (c *ClientWithResponses) MetricTrackersGetPostWithResponse(ctx context.Context, body MetricTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricTrackersGetPostResponse, error) {
	rsp, err := c.MetricTrackersGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricTrackersGetPostResponse(rsp)
}

// OrgScheduleFragmentsCreateWithBodyWithResponse request with arbitrary body returning *OrgScheduleFragmentsCreateResponse
func (c *ClientWithResponses) OrgScheduleFragmentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsCreateResponse, error) {
	rsp, err := c.OrgScheduleFragmentsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsCreateResponse(rsp)
}

func (c *ClientWithResponses) OrgScheduleFragmentsCreateWithResponse(ctx context.Context, body OrgScheduleFragmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsCreateResponse, error) {
	rsp, err := c.OrgScheduleFragmentsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsCreateResponse(rsp)
}

// OrgScheduleFragmentsGetWithResponse request returning *OrgScheduleFragmentsGetResponse
func (c *ClientWithResponses) OrgScheduleFragmentsGetWithResponse(ctx context.Context, params *OrgScheduleFragmentsGetParams, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetResponse, error) {
	rsp, err := c.OrgScheduleFragmentsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsGetResponse(rsp)
}

// OrgScheduleFragmentsGetPostWithBodyWithResponse request with arbitrary body returning *OrgScheduleFragmentsGetPostResponse
func (c *ClientWithResponses) OrgScheduleFragmentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetPostResponse, error) {
	rsp, err := c.OrgScheduleFragmentsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsGetPostResponse(rsp)
}

func (c *ClientWithResponses) OrgScheduleFragmentsGetPostWithResponse(ctx context.Context, body OrgScheduleFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetPostResponse, error) {
	rsp, err := c.OrgScheduleFragmentsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsGetPostResponse(rsp)
}

// OrgScheduleFragmentsTransitionWithBodyWithResponse request with arbitrary body returning *OrgScheduleFragmentsTransitionResponse
func (c *ClientWithResponses) OrgScheduleFragmentsTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsTransitionResponse, error) {
	rsp, err := c.OrgScheduleFragmentsTransitionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsTransitionResponse(rsp)
}

func (c *ClientWithResponses) OrgScheduleFragmentsTransitionWithResponse(ctx context.Context, body OrgScheduleFragmentsTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsTransitionResponse, error) {
	rsp, err := c.OrgScheduleFragmentsTransition(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsTransitionResponse(rsp)
}

// OrgSchedulesCreateWithBodyWithResponse request with arbitrary body returning *OrgSchedulesCreateResponse
func (c *ClientWithResponses) OrgSchedulesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesCreateResponse, error) {
	rsp, err := c.OrgSchedulesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesCreateResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesCreateWithResponse(ctx context.Context, body OrgSchedulesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesCreateResponse, error) {
	rsp, err := c.OrgSchedulesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesCreateResponse(rsp)
}

// OrgSchedulesEvaluateWithResponse request returning *OrgSchedulesEvaluateResponse
func (c *ClientWithResponses) OrgSchedulesEvaluateWithResponse(ctx context.Context, params *OrgSchedulesEvaluateParams, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluateResponse, error) {
	rsp, err := c.OrgSchedulesEvaluate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesEvaluateResponse(rsp)
}

// OrgSchedulesEvaluatePostWithBodyWithResponse request with arbitrary body returning *OrgSchedulesEvaluatePostResponse
func (c *ClientWithResponses) OrgSchedulesEvaluatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluatePostResponse, error) {
	rsp, err := c.OrgSchedulesEvaluatePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesEvaluatePostResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesEvaluatePostWithResponse(ctx context.Context, body OrgSchedulesEvaluatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluatePostResponse, error) {
	rsp, err := c.OrgSchedulesEvaluatePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesEvaluatePostResponse(rsp)
}

// OrgSchedulesGetWithResponse request returning *OrgSchedulesGetResponse
func (c *ClientWithResponses) OrgSchedulesGetWithResponse(ctx context.Context, params *OrgSchedulesGetParams, reqEditors ...RequestEditorFn) (*OrgSchedulesGetResponse, error) {
	rsp, err := c.OrgSchedulesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesGetResponse(rsp)
}

// OrgSchedulesGetPostWithBodyWithResponse request with arbitrary body returning *OrgSchedulesGetPostResponse
func (c *ClientWithResponses) OrgSchedulesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesGetPostResponse, error) {
	rsp, err := c.OrgSchedulesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesGetPostResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesGetPostWithResponse(ctx context.Context, body OrgSchedulesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesGetPostResponse, error) {
	rsp, err := c.OrgSchedulesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesGetPostResponse(rsp)
}

// OrgSchedulesListWithResponse request returning *OrgSchedulesListResponse
func (c *ClientWithResponses) OrgSchedulesListWithResponse(ctx context.Context, params *OrgSchedulesListParams, reqEditors ...RequestEditorFn) (*OrgSchedulesListResponse, error) {
	rsp, err := c.OrgSchedulesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesListResponse(rsp)
}

// OrgSchedulesListPostWithBodyWithResponse request with arbitrary body returning *OrgSchedulesListPostResponse
func (c *ClientWithResponses) OrgSchedulesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesListPostResponse, error) {
	rsp, err := c.OrgSchedulesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesListPostResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesListPostWithResponse(ctx context.Context, body OrgSchedulesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesListPostResponse, error) {
	rsp, err := c.OrgSchedulesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesListPostResponse(rsp)
}

// OrgSchedulesSetFutureWithBodyWithResponse request with arbitrary body returning *OrgSchedulesSetFutureResponse
func (c *ClientWithResponses) OrgSchedulesSetFutureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesSetFutureResponse, error) {
	rsp, err := c.OrgSchedulesSetFutureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesSetFutureResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesSetFutureWithResponse(ctx context.Context, body OrgSchedulesSetFutureJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesSetFutureResponse, error) {
	rsp, err := c.OrgSchedulesSetFuture(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesSetFutureResponse(rsp)
}

// OrgSchedulesTransitionWithBodyWithResponse request with arbitrary body returning *OrgSchedulesTransitionResponse
func (c *ClientWithResponses) OrgSchedulesTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesTransitionResponse, error) {
	rsp, err := c.OrgSchedulesTransitionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesTransitionResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesTransitionWithResponse(ctx context.Context, body OrgSchedulesTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesTransitionResponse, error) {
	rsp, err := c.OrgSchedulesTransition(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesTransitionResponse(rsp)
}

// OrgSchedulesUpdateWithBodyWithResponse request with arbitrary body returning *OrgSchedulesUpdateResponse
func (c *ClientWithResponses) OrgSchedulesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesUpdateResponse, error) {
	rsp, err := c.OrgSchedulesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesUpdateResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesUpdateWithResponse(ctx context.Context, body OrgSchedulesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesUpdateResponse, error) {
	rsp, err := c.OrgSchedulesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesUpdateResponse(rsp)
}

// PartsCreateWithBodyWithResponse request with arbitrary body returning *PartsCreateResponse
func (c *ClientWithResponses) PartsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsCreateResponse, error) {
	rsp, err := c.PartsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsCreateResponse(rsp)
}

func (c *ClientWithResponses) PartsCreateWithResponse(ctx context.Context, body PartsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsCreateResponse, error) {
	rsp, err := c.PartsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsCreateResponse(rsp)
}

// PartsDeleteWithBodyWithResponse request with arbitrary body returning *PartsDeleteResponse
func (c *ClientWithResponses) PartsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsDeleteResponse, error) {
	rsp, err := c.PartsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsDeleteResponse(rsp)
}

func (c *ClientWithResponses) PartsDeleteWithResponse(ctx context.Context, body PartsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsDeleteResponse, error) {
	rsp, err := c.PartsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsDeleteResponse(rsp)
}

// PartsGetWithResponse request returning *PartsGetResponse
func (c *ClientWithResponses) PartsGetWithResponse(ctx context.Context, params *PartsGetParams, reqEditors ...RequestEditorFn) (*PartsGetResponse, error) {
	rsp, err := c.PartsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsGetResponse(rsp)
}

// PartsGetPostWithBodyWithResponse request with arbitrary body returning *PartsGetPostResponse
func (c *ClientWithResponses) PartsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsGetPostResponse, error) {
	rsp, err := c.PartsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsGetPostResponse(rsp)
}

func (c *ClientWithResponses) PartsGetPostWithResponse(ctx context.Context, body PartsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsGetPostResponse, error) {
	rsp, err := c.PartsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsGetPostResponse(rsp)
}

// PartsListWithResponse request returning *PartsListResponse
func (c *ClientWithResponses) PartsListWithResponse(ctx context.Context, params *PartsListParams, reqEditors ...RequestEditorFn) (*PartsListResponse, error) {
	rsp, err := c.PartsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsListResponse(rsp)
}

// PartsListPostWithBodyWithResponse request with arbitrary body returning *PartsListPostResponse
func (c *ClientWithResponses) PartsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsListPostResponse, error) {
	rsp, err := c.PartsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsListPostResponse(rsp)
}

func (c *ClientWithResponses) PartsListPostWithResponse(ctx context.Context, body PartsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsListPostResponse, error) {
	rsp, err := c.PartsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsListPostResponse(rsp)
}

// PartsUpdateWithBodyWithResponse request with arbitrary body returning *PartsUpdateResponse
func (c *ClientWithResponses) PartsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsUpdateResponse, error) {
	rsp, err := c.PartsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsUpdateResponse(rsp)
}

func (c *ClientWithResponses) PartsUpdateWithResponse(ctx context.Context, body PartsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsUpdateResponse, error) {
	rsp, err := c.PartsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsUpdateResponse(rsp)
}

// ReactionsListWithResponse request returning *ReactionsListResponse
func (c *ClientWithResponses) ReactionsListWithResponse(ctx context.Context, params *ReactionsListParams, reqEditors ...RequestEditorFn) (*ReactionsListResponse, error) {
	rsp, err := c.ReactionsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsListResponse(rsp)
}

// ReactionsListPostWithBodyWithResponse request with arbitrary body returning *ReactionsListPostResponse
func (c *ClientWithResponses) ReactionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionsListPostResponse, error) {
	rsp, err := c.ReactionsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsListPostResponse(rsp)
}

func (c *ClientWithResponses) ReactionsListPostWithResponse(ctx context.Context, body ReactionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionsListPostResponse, error) {
	rsp, err := c.ReactionsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsListPostResponse(rsp)
}

// ReactionsUpdateWithBodyWithResponse request with arbitrary body returning *ReactionsUpdateResponse
func (c *ClientWithResponses) ReactionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionsUpdateResponse, error) {
	rsp, err := c.ReactionsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ReactionsUpdateWithResponse(ctx context.Context, body ReactionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionsUpdateResponse, error) {
	rsp, err := c.ReactionsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsUpdateResponse(rsp)
}

// RevOrgsCreateWithBodyWithResponse request with arbitrary body returning *RevOrgsCreateResponse
func (c *ClientWithResponses) RevOrgsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsCreateResponse, error) {
	rsp, err := c.RevOrgsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsCreateResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsCreateWithResponse(ctx context.Context, body RevOrgsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsCreateResponse, error) {
	rsp, err := c.RevOrgsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsCreateResponse(rsp)
}

// RevOrgsDeleteWithBodyWithResponse request with arbitrary body returning *RevOrgsDeleteResponse
func (c *ClientWithResponses) RevOrgsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsDeleteResponse, error) {
	rsp, err := c.RevOrgsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsDeleteResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsDeleteWithResponse(ctx context.Context, body RevOrgsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsDeleteResponse, error) {
	rsp, err := c.RevOrgsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsDeleteResponse(rsp)
}

// RevOrgsGetWithResponse request returning *RevOrgsGetResponse
func (c *ClientWithResponses) RevOrgsGetWithResponse(ctx context.Context, params *RevOrgsGetParams, reqEditors ...RequestEditorFn) (*RevOrgsGetResponse, error) {
	rsp, err := c.RevOrgsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsGetResponse(rsp)
}

// RevOrgsGetPostWithBodyWithResponse request with arbitrary body returning *RevOrgsGetPostResponse
func (c *ClientWithResponses) RevOrgsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsGetPostResponse, error) {
	rsp, err := c.RevOrgsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsGetPostResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsGetPostWithResponse(ctx context.Context, body RevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsGetPostResponse, error) {
	rsp, err := c.RevOrgsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsGetPostResponse(rsp)
}

// RevOrgsListWithResponse request returning *RevOrgsListResponse
func (c *ClientWithResponses) RevOrgsListWithResponse(ctx context.Context, params *RevOrgsListParams, reqEditors ...RequestEditorFn) (*RevOrgsListResponse, error) {
	rsp, err := c.RevOrgsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsListResponse(rsp)
}

// RevOrgsListPostWithBodyWithResponse request with arbitrary body returning *RevOrgsListPostResponse
func (c *ClientWithResponses) RevOrgsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsListPostResponse, error) {
	rsp, err := c.RevOrgsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsListPostResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsListPostWithResponse(ctx context.Context, body RevOrgsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsListPostResponse, error) {
	rsp, err := c.RevOrgsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsListPostResponse(rsp)
}

// RevOrgsUpdateWithBodyWithResponse request with arbitrary body returning *RevOrgsUpdateResponse
func (c *ClientWithResponses) RevOrgsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsUpdateResponse, error) {
	rsp, err := c.RevOrgsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsUpdateResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsUpdateWithResponse(ctx context.Context, body RevOrgsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsUpdateResponse, error) {
	rsp, err := c.RevOrgsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsUpdateResponse(rsp)
}

// RevUsersCreateWithBodyWithResponse request with arbitrary body returning *RevUsersCreateResponse
func (c *ClientWithResponses) RevUsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersCreateResponse, error) {
	rsp, err := c.RevUsersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersCreateResponse(rsp)
}

func (c *ClientWithResponses) RevUsersCreateWithResponse(ctx context.Context, body RevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersCreateResponse, error) {
	rsp, err := c.RevUsersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersCreateResponse(rsp)
}

// RevUsersDeleteWithBodyWithResponse request with arbitrary body returning *RevUsersDeleteResponse
func (c *ClientWithResponses) RevUsersDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersDeleteResponse, error) {
	rsp, err := c.RevUsersDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersDeleteResponse(rsp)
}

func (c *ClientWithResponses) RevUsersDeleteWithResponse(ctx context.Context, body RevUsersDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersDeleteResponse, error) {
	rsp, err := c.RevUsersDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersDeleteResponse(rsp)
}

// RevUsersGetWithResponse request returning *RevUsersGetResponse
func (c *ClientWithResponses) RevUsersGetWithResponse(ctx context.Context, params *RevUsersGetParams, reqEditors ...RequestEditorFn) (*RevUsersGetResponse, error) {
	rsp, err := c.RevUsersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersGetResponse(rsp)
}

// RevUsersGetPostWithBodyWithResponse request with arbitrary body returning *RevUsersGetPostResponse
func (c *ClientWithResponses) RevUsersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersGetPostResponse, error) {
	rsp, err := c.RevUsersGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersGetPostResponse(rsp)
}

func (c *ClientWithResponses) RevUsersGetPostWithResponse(ctx context.Context, body RevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersGetPostResponse, error) {
	rsp, err := c.RevUsersGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersGetPostResponse(rsp)
}

// RevUsersListWithResponse request returning *RevUsersListResponse
func (c *ClientWithResponses) RevUsersListWithResponse(ctx context.Context, params *RevUsersListParams, reqEditors ...RequestEditorFn) (*RevUsersListResponse, error) {
	rsp, err := c.RevUsersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersListResponse(rsp)
}

// RevUsersListPostWithBodyWithResponse request with arbitrary body returning *RevUsersListPostResponse
func (c *ClientWithResponses) RevUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersListPostResponse, error) {
	rsp, err := c.RevUsersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersListPostResponse(rsp)
}

func (c *ClientWithResponses) RevUsersListPostWithResponse(ctx context.Context, body RevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersListPostResponse, error) {
	rsp, err := c.RevUsersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersListPostResponse(rsp)
}

// RevUsersMergeWithBodyWithResponse request with arbitrary body returning *RevUsersMergeResponse
func (c *ClientWithResponses) RevUsersMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersMergeResponse, error) {
	rsp, err := c.RevUsersMergeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersMergeResponse(rsp)
}

func (c *ClientWithResponses) RevUsersMergeWithResponse(ctx context.Context, body RevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersMergeResponse, error) {
	rsp, err := c.RevUsersMerge(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersMergeResponse(rsp)
}

// RevUsersScanWithResponse request returning *RevUsersScanResponse
func (c *ClientWithResponses) RevUsersScanWithResponse(ctx context.Context, params *RevUsersScanParams, reqEditors ...RequestEditorFn) (*RevUsersScanResponse, error) {
	rsp, err := c.RevUsersScan(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersScanResponse(rsp)
}

// RevUsersScanPostWithBodyWithResponse request with arbitrary body returning *RevUsersScanPostResponse
func (c *ClientWithResponses) RevUsersScanPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersScanPostResponse, error) {
	rsp, err := c.RevUsersScanPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersScanPostResponse(rsp)
}

func (c *ClientWithResponses) RevUsersScanPostWithResponse(ctx context.Context, body RevUsersScanPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersScanPostResponse, error) {
	rsp, err := c.RevUsersScanPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersScanPostResponse(rsp)
}

// RevUsersUpdateWithBodyWithResponse request with arbitrary body returning *RevUsersUpdateResponse
func (c *ClientWithResponses) RevUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersUpdateResponse, error) {
	rsp, err := c.RevUsersUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersUpdateResponse(rsp)
}

func (c *ClientWithResponses) RevUsersUpdateWithResponse(ctx context.Context, body RevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersUpdateResponse, error) {
	rsp, err := c.RevUsersUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersUpdateResponse(rsp)
}

// ServiceAccountsCreateWithBodyWithResponse request with arbitrary body returning *ServiceAccountsCreateResponse
func (c *ClientWithResponses) ServiceAccountsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsCreateResponse, error) {
	rsp, err := c.ServiceAccountsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsCreateResponse(rsp)
}

func (c *ClientWithResponses) ServiceAccountsCreateWithResponse(ctx context.Context, body ServiceAccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsCreateResponse, error) {
	rsp, err := c.ServiceAccountsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsCreateResponse(rsp)
}

// ServiceAccountsGetWithResponse request returning *ServiceAccountsGetResponse
func (c *ClientWithResponses) ServiceAccountsGetWithResponse(ctx context.Context, params *ServiceAccountsGetParams, reqEditors ...RequestEditorFn) (*ServiceAccountsGetResponse, error) {
	rsp, err := c.ServiceAccountsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsGetResponse(rsp)
}

// ServiceAccountsGetPostWithBodyWithResponse request with arbitrary body returning *ServiceAccountsGetPostResponse
func (c *ClientWithResponses) ServiceAccountsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsGetPostResponse, error) {
	rsp, err := c.ServiceAccountsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsGetPostResponse(rsp)
}

func (c *ClientWithResponses) ServiceAccountsGetPostWithResponse(ctx context.Context, body ServiceAccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsGetPostResponse, error) {
	rsp, err := c.ServiceAccountsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsGetPostResponse(rsp)
}

// SlaTrackersGetWithResponse request returning *SlaTrackersGetResponse
func (c *ClientWithResponses) SlaTrackersGetWithResponse(ctx context.Context, params *SlaTrackersGetParams, reqEditors ...RequestEditorFn) (*SlaTrackersGetResponse, error) {
	rsp, err := c.SlaTrackersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersGetResponse(rsp)
}

// SlaTrackersGetPostWithBodyWithResponse request with arbitrary body returning *SlaTrackersGetPostResponse
func (c *ClientWithResponses) SlaTrackersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersGetPostResponse, error) {
	rsp, err := c.SlaTrackersGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersGetPostResponse(rsp)
}

func (c *ClientWithResponses) SlaTrackersGetPostWithResponse(ctx context.Context, body SlaTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersGetPostResponse, error) {
	rsp, err := c.SlaTrackersGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersGetPostResponse(rsp)
}

// SlaTrackersListWithResponse request returning *SlaTrackersListResponse
func (c *ClientWithResponses) SlaTrackersListWithResponse(ctx context.Context, params *SlaTrackersListParams, reqEditors ...RequestEditorFn) (*SlaTrackersListResponse, error) {
	rsp, err := c.SlaTrackersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersListResponse(rsp)
}

// SlaTrackersListPostWithBodyWithResponse request with arbitrary body returning *SlaTrackersListPostResponse
func (c *ClientWithResponses) SlaTrackersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersListPostResponse, error) {
	rsp, err := c.SlaTrackersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersListPostResponse(rsp)
}

func (c *ClientWithResponses) SlaTrackersListPostWithResponse(ctx context.Context, body SlaTrackersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersListPostResponse, error) {
	rsp, err := c.SlaTrackersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersListPostResponse(rsp)
}

// SlasAssignWithBodyWithResponse request with arbitrary body returning *SlasAssignResponse
func (c *ClientWithResponses) SlasAssignWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasAssignResponse, error) {
	rsp, err := c.SlasAssignWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasAssignResponse(rsp)
}

func (c *ClientWithResponses) SlasAssignWithResponse(ctx context.Context, body SlasAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasAssignResponse, error) {
	rsp, err := c.SlasAssign(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasAssignResponse(rsp)
}

// SlasCreateWithBodyWithResponse request with arbitrary body returning *SlasCreateResponse
func (c *ClientWithResponses) SlasCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasCreateResponse, error) {
	rsp, err := c.SlasCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasCreateResponse(rsp)
}

func (c *ClientWithResponses) SlasCreateWithResponse(ctx context.Context, body SlasCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasCreateResponse, error) {
	rsp, err := c.SlasCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasCreateResponse(rsp)
}

// SlasGetWithResponse request returning *SlasGetResponse
func (c *ClientWithResponses) SlasGetWithResponse(ctx context.Context, params *SlasGetParams, reqEditors ...RequestEditorFn) (*SlasGetResponse, error) {
	rsp, err := c.SlasGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasGetResponse(rsp)
}

// SlasGetPostWithBodyWithResponse request with arbitrary body returning *SlasGetPostResponse
func (c *ClientWithResponses) SlasGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasGetPostResponse, error) {
	rsp, err := c.SlasGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasGetPostResponse(rsp)
}

func (c *ClientWithResponses) SlasGetPostWithResponse(ctx context.Context, body SlasGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasGetPostResponse, error) {
	rsp, err := c.SlasGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasGetPostResponse(rsp)
}

// SlasListWithResponse request returning *SlasListResponse
func (c *ClientWithResponses) SlasListWithResponse(ctx context.Context, params *SlasListParams, reqEditors ...RequestEditorFn) (*SlasListResponse, error) {
	rsp, err := c.SlasList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasListResponse(rsp)
}

// SlasListPostWithBodyWithResponse request with arbitrary body returning *SlasListPostResponse
func (c *ClientWithResponses) SlasListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasListPostResponse, error) {
	rsp, err := c.SlasListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasListPostResponse(rsp)
}

func (c *ClientWithResponses) SlasListPostWithResponse(ctx context.Context, body SlasListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasListPostResponse, error) {
	rsp, err := c.SlasListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasListPostResponse(rsp)
}

// SlasTransitionWithBodyWithResponse request with arbitrary body returning *SlasTransitionResponse
func (c *ClientWithResponses) SlasTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasTransitionResponse, error) {
	rsp, err := c.SlasTransitionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasTransitionResponse(rsp)
}

func (c *ClientWithResponses) SlasTransitionWithResponse(ctx context.Context, body SlasTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasTransitionResponse, error) {
	rsp, err := c.SlasTransition(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasTransitionResponse(rsp)
}

// SlasUpdateWithBodyWithResponse request with arbitrary body returning *SlasUpdateResponse
func (c *ClientWithResponses) SlasUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasUpdateResponse, error) {
	rsp, err := c.SlasUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasUpdateResponse(rsp)
}

func (c *ClientWithResponses) SlasUpdateWithResponse(ctx context.Context, body SlasUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasUpdateResponse, error) {
	rsp, err := c.SlasUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasUpdateResponse(rsp)
}

// SnapKitActionExecuteDeferredWithBodyWithResponse request with arbitrary body returning *SnapKitActionExecuteDeferredResponse
func (c *ClientWithResponses) SnapKitActionExecuteDeferredWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapKitActionExecuteDeferredResponse, error) {
	rsp, err := c.SnapKitActionExecuteDeferredWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapKitActionExecuteDeferredResponse(rsp)
}

func (c *ClientWithResponses) SnapKitActionExecuteDeferredWithResponse(ctx context.Context, body SnapKitActionExecuteDeferredJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapKitActionExecuteDeferredResponse, error) {
	rsp, err := c.SnapKitActionExecuteDeferred(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapKitActionExecuteDeferredResponse(rsp)
}

// SnapWidgetsCreateWithBodyWithResponse request with arbitrary body returning *SnapWidgetsCreateResponse
func (c *ClientWithResponses) SnapWidgetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapWidgetsCreateResponse, error) {
	rsp, err := c.SnapWidgetsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapWidgetsCreateResponse(rsp)
}

func (c *ClientWithResponses) SnapWidgetsCreateWithResponse(ctx context.Context, body SnapWidgetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapWidgetsCreateResponse, error) {
	rsp, err := c.SnapWidgetsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapWidgetsCreateResponse(rsp)
}

// SurveysCreateWithBodyWithResponse request with arbitrary body returning *SurveysCreateResponse
func (c *ClientWithResponses) SurveysCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysCreateResponse, error) {
	rsp, err := c.SurveysCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysCreateResponse(rsp)
}

func (c *ClientWithResponses) SurveysCreateWithResponse(ctx context.Context, body SurveysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysCreateResponse, error) {
	rsp, err := c.SurveysCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysCreateResponse(rsp)
}

// SurveysDeleteWithBodyWithResponse request with arbitrary body returning *SurveysDeleteResponse
func (c *ClientWithResponses) SurveysDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysDeleteResponse, error) {
	rsp, err := c.SurveysDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysDeleteResponse(rsp)
}

func (c *ClientWithResponses) SurveysDeleteWithResponse(ctx context.Context, body SurveysDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysDeleteResponse, error) {
	rsp, err := c.SurveysDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysDeleteResponse(rsp)
}

// SurveysGetWithResponse request returning *SurveysGetResponse
func (c *ClientWithResponses) SurveysGetWithResponse(ctx context.Context, params *SurveysGetParams, reqEditors ...RequestEditorFn) (*SurveysGetResponse, error) {
	rsp, err := c.SurveysGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysGetResponse(rsp)
}

// SurveysGetPostWithBodyWithResponse request with arbitrary body returning *SurveysGetPostResponse
func (c *ClientWithResponses) SurveysGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysGetPostResponse, error) {
	rsp, err := c.SurveysGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysGetPostResponse(rsp)
}

func (c *ClientWithResponses) SurveysGetPostWithResponse(ctx context.Context, body SurveysGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysGetPostResponse, error) {
	rsp, err := c.SurveysGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysGetPostResponse(rsp)
}

// SurveysListWithResponse request returning *SurveysListResponse
func (c *ClientWithResponses) SurveysListWithResponse(ctx context.Context, params *SurveysListParams, reqEditors ...RequestEditorFn) (*SurveysListResponse, error) {
	rsp, err := c.SurveysList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysListResponse(rsp)
}

// SurveysListPostWithBodyWithResponse request with arbitrary body returning *SurveysListPostResponse
func (c *ClientWithResponses) SurveysListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysListPostResponse, error) {
	rsp, err := c.SurveysListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysListPostResponse(rsp)
}

func (c *ClientWithResponses) SurveysListPostWithResponse(ctx context.Context, body SurveysListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysListPostResponse, error) {
	rsp, err := c.SurveysListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysListPostResponse(rsp)
}

// SurveysResponsesListWithResponse request returning *SurveysResponsesListResponse
func (c *ClientWithResponses) SurveysResponsesListWithResponse(ctx context.Context, params *SurveysResponsesListParams, reqEditors ...RequestEditorFn) (*SurveysResponsesListResponse, error) {
	rsp, err := c.SurveysResponsesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesListResponse(rsp)
}

// SurveysResponsesListPostWithBodyWithResponse request with arbitrary body returning *SurveysResponsesListPostResponse
func (c *ClientWithResponses) SurveysResponsesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysResponsesListPostResponse, error) {
	rsp, err := c.SurveysResponsesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesListPostResponse(rsp)
}

func (c *ClientWithResponses) SurveysResponsesListPostWithResponse(ctx context.Context, body SurveysResponsesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysResponsesListPostResponse, error) {
	rsp, err := c.SurveysResponsesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesListPostResponse(rsp)
}

// SurveysResponsesUpdateWithBodyWithResponse request with arbitrary body returning *SurveysResponsesUpdateResponse
func (c *ClientWithResponses) SurveysResponsesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysResponsesUpdateResponse, error) {
	rsp, err := c.SurveysResponsesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesUpdateResponse(rsp)
}

func (c *ClientWithResponses) SurveysResponsesUpdateWithResponse(ctx context.Context, body SurveysResponsesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysResponsesUpdateResponse, error) {
	rsp, err := c.SurveysResponsesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesUpdateResponse(rsp)
}

// SurveysSendWithBodyWithResponse request with arbitrary body returning *SurveysSendResponse
func (c *ClientWithResponses) SurveysSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysSendResponse, error) {
	rsp, err := c.SurveysSendWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysSendResponse(rsp)
}

func (c *ClientWithResponses) SurveysSendWithResponse(ctx context.Context, body SurveysSendJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysSendResponse, error) {
	rsp, err := c.SurveysSend(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysSendResponse(rsp)
}

// SurveysSubmitWithBodyWithResponse request with arbitrary body returning *SurveysSubmitResponse
func (c *ClientWithResponses) SurveysSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysSubmitResponse, error) {
	rsp, err := c.SurveysSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysSubmitResponse(rsp)
}

func (c *ClientWithResponses) SurveysSubmitWithResponse(ctx context.Context, body SurveysSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysSubmitResponse, error) {
	rsp, err := c.SurveysSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysSubmitResponse(rsp)
}

// SurveysUpdateWithBodyWithResponse request with arbitrary body returning *SurveysUpdateResponse
func (c *ClientWithResponses) SurveysUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysUpdateResponse, error) {
	rsp, err := c.SurveysUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysUpdateResponse(rsp)
}

func (c *ClientWithResponses) SurveysUpdateWithResponse(ctx context.Context, body SurveysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysUpdateResponse, error) {
	rsp, err := c.SurveysUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysUpdateResponse(rsp)
}

// SysUsersListWithResponse request returning *SysUsersListResponse
func (c *ClientWithResponses) SysUsersListWithResponse(ctx context.Context, params *SysUsersListParams, reqEditors ...RequestEditorFn) (*SysUsersListResponse, error) {
	rsp, err := c.SysUsersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersListResponse(rsp)
}

// SysUsersListPostWithBodyWithResponse request with arbitrary body returning *SysUsersListPostResponse
func (c *ClientWithResponses) SysUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SysUsersListPostResponse, error) {
	rsp, err := c.SysUsersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersListPostResponse(rsp)
}

func (c *ClientWithResponses) SysUsersListPostWithResponse(ctx context.Context, body SysUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SysUsersListPostResponse, error) {
	rsp, err := c.SysUsersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersListPostResponse(rsp)
}

// SysUsersUpdateWithBodyWithResponse request with arbitrary body returning *SysUsersUpdateResponse
func (c *ClientWithResponses) SysUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SysUsersUpdateResponse, error) {
	rsp, err := c.SysUsersUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersUpdateResponse(rsp)
}

func (c *ClientWithResponses) SysUsersUpdateWithResponse(ctx context.Context, body SysUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SysUsersUpdateResponse, error) {
	rsp, err := c.SysUsersUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersUpdateResponse(rsp)
}

// TagsCreateWithBodyWithResponse request with arbitrary body returning *TagsCreateResponse
func (c *ClientWithResponses) TagsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsCreateResponse, error) {
	rsp, err := c.TagsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsCreateResponse(rsp)
}

func (c *ClientWithResponses) TagsCreateWithResponse(ctx context.Context, body TagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsCreateResponse, error) {
	rsp, err := c.TagsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsCreateResponse(rsp)
}

// TagsDeleteWithBodyWithResponse request with arbitrary body returning *TagsDeleteResponse
func (c *ClientWithResponses) TagsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsDeleteResponse, error) {
	rsp, err := c.TagsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsDeleteResponse(rsp)
}

func (c *ClientWithResponses) TagsDeleteWithResponse(ctx context.Context, body TagsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsDeleteResponse, error) {
	rsp, err := c.TagsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsDeleteResponse(rsp)
}

// TagsGetWithResponse request returning *TagsGetResponse
func (c *ClientWithResponses) TagsGetWithResponse(ctx context.Context, params *TagsGetParams, reqEditors ...RequestEditorFn) (*TagsGetResponse, error) {
	rsp, err := c.TagsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsGetResponse(rsp)
}

// TagsGetPostWithBodyWithResponse request with arbitrary body returning *TagsGetPostResponse
func (c *ClientWithResponses) TagsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsGetPostResponse, error) {
	rsp, err := c.TagsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsGetPostResponse(rsp)
}

func (c *ClientWithResponses) TagsGetPostWithResponse(ctx context.Context, body TagsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsGetPostResponse, error) {
	rsp, err := c.TagsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsGetPostResponse(rsp)
}

// TagsListWithResponse request returning *TagsListResponse
func (c *ClientWithResponses) TagsListWithResponse(ctx context.Context, params *TagsListParams, reqEditors ...RequestEditorFn) (*TagsListResponse, error) {
	rsp, err := c.TagsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListResponse(rsp)
}

// TagsListPostWithBodyWithResponse request with arbitrary body returning *TagsListPostResponse
func (c *ClientWithResponses) TagsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsListPostResponse, error) {
	rsp, err := c.TagsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListPostResponse(rsp)
}

func (c *ClientWithResponses) TagsListPostWithResponse(ctx context.Context, body TagsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsListPostResponse, error) {
	rsp, err := c.TagsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListPostResponse(rsp)
}

// TagsUpdateWithBodyWithResponse request with arbitrary body returning *TagsUpdateResponse
func (c *ClientWithResponses) TagsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsUpdateResponse, error) {
	rsp, err := c.TagsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsUpdateResponse(rsp)
}

func (c *ClientWithResponses) TagsUpdateWithResponse(ctx context.Context, body TagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsUpdateResponse, error) {
	rsp, err := c.TagsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsUpdateResponse(rsp)
}

// TimelineEntriesCreateWithBodyWithResponse request with arbitrary body returning *TimelineEntriesCreateResponse
func (c *ClientWithResponses) TimelineEntriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesCreateResponse, error) {
	rsp, err := c.TimelineEntriesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesCreateResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesCreateWithResponse(ctx context.Context, body TimelineEntriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesCreateResponse, error) {
	rsp, err := c.TimelineEntriesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesCreateResponse(rsp)
}

// TimelineEntriesDeleteWithBodyWithResponse request with arbitrary body returning *TimelineEntriesDeleteResponse
func (c *ClientWithResponses) TimelineEntriesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesDeleteResponse, error) {
	rsp, err := c.TimelineEntriesDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesDeleteResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesDeleteWithResponse(ctx context.Context, body TimelineEntriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesDeleteResponse, error) {
	rsp, err := c.TimelineEntriesDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesDeleteResponse(rsp)
}

// TimelineEntriesGetWithResponse request returning *TimelineEntriesGetResponse
func (c *ClientWithResponses) TimelineEntriesGetWithResponse(ctx context.Context, params *TimelineEntriesGetParams, reqEditors ...RequestEditorFn) (*TimelineEntriesGetResponse, error) {
	rsp, err := c.TimelineEntriesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesGetResponse(rsp)
}

// TimelineEntriesGetPostWithBodyWithResponse request with arbitrary body returning *TimelineEntriesGetPostResponse
func (c *ClientWithResponses) TimelineEntriesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesGetPostResponse, error) {
	rsp, err := c.TimelineEntriesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesGetPostResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesGetPostWithResponse(ctx context.Context, body TimelineEntriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesGetPostResponse, error) {
	rsp, err := c.TimelineEntriesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesGetPostResponse(rsp)
}

// TimelineEntriesListWithResponse request returning *TimelineEntriesListResponse
func (c *ClientWithResponses) TimelineEntriesListWithResponse(ctx context.Context, params *TimelineEntriesListParams, reqEditors ...RequestEditorFn) (*TimelineEntriesListResponse, error) {
	rsp, err := c.TimelineEntriesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesListResponse(rsp)
}

// TimelineEntriesListPostWithBodyWithResponse request with arbitrary body returning *TimelineEntriesListPostResponse
func (c *ClientWithResponses) TimelineEntriesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesListPostResponse, error) {
	rsp, err := c.TimelineEntriesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesListPostResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesListPostWithResponse(ctx context.Context, body TimelineEntriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesListPostResponse, error) {
	rsp, err := c.TimelineEntriesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesListPostResponse(rsp)
}

// TimelineEntriesUpdateWithBodyWithResponse request with arbitrary body returning *TimelineEntriesUpdateResponse
func (c *ClientWithResponses) TimelineEntriesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesUpdateResponse, error) {
	rsp, err := c.TimelineEntriesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesUpdateResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesUpdateWithResponse(ctx context.Context, body TimelineEntriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesUpdateResponse, error) {
	rsp, err := c.TimelineEntriesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesUpdateResponse(rsp)
}

// WebCrawlerJobsControlWithBodyWithResponse request with arbitrary body returning *WebCrawlerJobsControlResponse
func (c *ClientWithResponses) WebCrawlerJobsControlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebCrawlerJobsControlResponse, error) {
	rsp, err := c.WebCrawlerJobsControlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebCrawlerJobsControlResponse(rsp)
}

func (c *ClientWithResponses) WebCrawlerJobsControlWithResponse(ctx context.Context, body WebCrawlerJobsControlJSONRequestBody, reqEditors ...RequestEditorFn) (*WebCrawlerJobsControlResponse, error) {
	rsp, err := c.WebCrawlerJobsControl(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebCrawlerJobsControlResponse(rsp)
}

// CreateWebCrawlerJobWithBodyWithResponse request with arbitrary body returning *CreateWebCrawlerJobResponse
func (c *ClientWithResponses) CreateWebCrawlerJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebCrawlerJobResponse, error) {
	rsp, err := c.CreateWebCrawlerJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebCrawlerJobResponse(rsp)
}

func (c *ClientWithResponses) CreateWebCrawlerJobWithResponse(ctx context.Context, body CreateWebCrawlerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebCrawlerJobResponse, error) {
	rsp, err := c.CreateWebCrawlerJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebCrawlerJobResponse(rsp)
}

// GetWebCrawlerJobWithResponse request returning *GetWebCrawlerJobResponse
func (c *ClientWithResponses) GetWebCrawlerJobWithResponse(ctx context.Context, params *GetWebCrawlerJobParams, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobResponse, error) {
	rsp, err := c.GetWebCrawlerJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebCrawlerJobResponse(rsp)
}

// GetWebCrawlerJobPostWithBodyWithResponse request with arbitrary body returning *GetWebCrawlerJobPostResponse
func (c *ClientWithResponses) GetWebCrawlerJobPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobPostResponse, error) {
	rsp, err := c.GetWebCrawlerJobPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebCrawlerJobPostResponse(rsp)
}

func (c *ClientWithResponses) GetWebCrawlerJobPostWithResponse(ctx context.Context, body GetWebCrawlerJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobPostResponse, error) {
	rsp, err := c.GetWebCrawlerJobPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebCrawlerJobPostResponse(rsp)
}

// ListWebCrawlerJobsWithResponse request returning *ListWebCrawlerJobsResponse
func (c *ClientWithResponses) ListWebCrawlerJobsWithResponse(ctx context.Context, params *ListWebCrawlerJobsParams, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsResponse, error) {
	rsp, err := c.ListWebCrawlerJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebCrawlerJobsResponse(rsp)
}

// ListWebCrawlerJobsPostWithBodyWithResponse request with arbitrary body returning *ListWebCrawlerJobsPostResponse
func (c *ClientWithResponses) ListWebCrawlerJobsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsPostResponse, error) {
	rsp, err := c.ListWebCrawlerJobsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebCrawlerJobsPostResponse(rsp)
}

func (c *ClientWithResponses) ListWebCrawlerJobsPostWithResponse(ctx context.Context, body ListWebCrawlerJobsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsPostResponse, error) {
	rsp, err := c.ListWebCrawlerJobsPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebCrawlerJobsPostResponse(rsp)
}

// WebhooksCreateWithBodyWithResponse request with arbitrary body returning *WebhooksCreateResponse
func (c *ClientWithResponses) WebhooksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error) {
	rsp, err := c.WebhooksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksCreateResponse(rsp)
}

func (c *ClientWithResponses) WebhooksCreateWithResponse(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error) {
	rsp, err := c.WebhooksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksCreateResponse(rsp)
}

// WebhooksDeleteWithBodyWithResponse request with arbitrary body returning *WebhooksDeleteResponse
func (c *ClientWithResponses) WebhooksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error) {
	rsp, err := c.WebhooksDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksDeleteResponse(rsp)
}

func (c *ClientWithResponses) WebhooksDeleteWithResponse(ctx context.Context, body WebhooksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error) {
	rsp, err := c.WebhooksDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksDeleteResponse(rsp)
}

// WebhooksEventWithBodyWithResponse request with arbitrary body returning *WebhooksEventResponse
func (c *ClientWithResponses) WebhooksEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksEventResponse, error) {
	rsp, err := c.WebhooksEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksEventResponse(rsp)
}

func (c *ClientWithResponses) WebhooksEventWithResponse(ctx context.Context, body WebhooksEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksEventResponse, error) {
	rsp, err := c.WebhooksEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksEventResponse(rsp)
}

// WebhooksGetWithResponse request returning *WebhooksGetResponse
func (c *ClientWithResponses) WebhooksGetWithResponse(ctx context.Context, params *WebhooksGetParams, reqEditors ...RequestEditorFn) (*WebhooksGetResponse, error) {
	rsp, err := c.WebhooksGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksGetResponse(rsp)
}

// WebhooksGetPostWithBodyWithResponse request with arbitrary body returning *WebhooksGetPostResponse
func (c *ClientWithResponses) WebhooksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksGetPostResponse, error) {
	rsp, err := c.WebhooksGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksGetPostResponse(rsp)
}

func (c *ClientWithResponses) WebhooksGetPostWithResponse(ctx context.Context, body WebhooksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksGetPostResponse, error) {
	rsp, err := c.WebhooksGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksGetPostResponse(rsp)
}

// WebhooksListWithResponse request returning *WebhooksListResponse
func (c *ClientWithResponses) WebhooksListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WebhooksListResponse, error) {
	rsp, err := c.WebhooksList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListResponse(rsp)
}

// WebhooksListPostWithBodyWithResponse request with arbitrary body returning *WebhooksListPostResponse
func (c *ClientWithResponses) WebhooksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksListPostResponse, error) {
	rsp, err := c.WebhooksListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListPostResponse(rsp)
}

func (c *ClientWithResponses) WebhooksListPostWithResponse(ctx context.Context, body WebhooksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksListPostResponse, error) {
	rsp, err := c.WebhooksListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListPostResponse(rsp)
}

// WebhooksUpdateWithBodyWithResponse request with arbitrary body returning *WebhooksUpdateResponse
func (c *ClientWithResponses) WebhooksUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error) {
	rsp, err := c.WebhooksUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksUpdateResponse(rsp)
}

func (c *ClientWithResponses) WebhooksUpdateWithResponse(ctx context.Context, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error) {
	rsp, err := c.WebhooksUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksUpdateResponse(rsp)
}

// WorksCreateWithBodyWithResponse request with arbitrary body returning *WorksCreateResponse
func (c *ClientWithResponses) WorksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksCreateResponse, error) {
	rsp, err := c.WorksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksCreateResponse(rsp)
}

func (c *ClientWithResponses) WorksCreateWithResponse(ctx context.Context, body WorksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksCreateResponse, error) {
	rsp, err := c.WorksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksCreateResponse(rsp)
}

// WorksDeleteWithBodyWithResponse request with arbitrary body returning *WorksDeleteResponse
func (c *ClientWithResponses) WorksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksDeleteResponse, error) {
	rsp, err := c.WorksDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksDeleteResponse(rsp)
}

func (c *ClientWithResponses) WorksDeleteWithResponse(ctx context.Context, body WorksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksDeleteResponse, error) {
	rsp, err := c.WorksDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksDeleteResponse(rsp)
}

// WorksExportWithResponse request returning *WorksExportResponse
func (c *ClientWithResponses) WorksExportWithResponse(ctx context.Context, params *WorksExportParams, reqEditors ...RequestEditorFn) (*WorksExportResponse, error) {
	rsp, err := c.WorksExport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksExportResponse(rsp)
}

// WorksExportPostWithBodyWithResponse request with arbitrary body returning *WorksExportPostResponse
func (c *ClientWithResponses) WorksExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksExportPostResponse, error) {
	rsp, err := c.WorksExportPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksExportPostResponse(rsp)
}

func (c *ClientWithResponses) WorksExportPostWithResponse(ctx context.Context, body WorksExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksExportPostResponse, error) {
	rsp, err := c.WorksExportPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksExportPostResponse(rsp)
}

// WorksGetWithResponse request returning *WorksGetResponse
func (c *ClientWithResponses) WorksGetWithResponse(ctx context.Context, params *WorksGetParams, reqEditors ...RequestEditorFn) (*WorksGetResponse, error) {
	rsp, err := c.WorksGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksGetResponse(rsp)
}

// WorksGetPostWithBodyWithResponse request with arbitrary body returning *WorksGetPostResponse
func (c *ClientWithResponses) WorksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksGetPostResponse, error) {
	rsp, err := c.WorksGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksGetPostResponse(rsp)
}

func (c *ClientWithResponses) WorksGetPostWithResponse(ctx context.Context, body WorksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksGetPostResponse, error) {
	rsp, err := c.WorksGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksGetPostResponse(rsp)
}

// WorksListWithResponse request returning *WorksListResponse
func (c *ClientWithResponses) WorksListWithResponse(ctx context.Context, params *WorksListParams, reqEditors ...RequestEditorFn) (*WorksListResponse, error) {
	rsp, err := c.WorksList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksListResponse(rsp)
}

// WorksListPostWithBodyWithResponse request with arbitrary body returning *WorksListPostResponse
func (c *ClientWithResponses) WorksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksListPostResponse, error) {
	rsp, err := c.WorksListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksListPostResponse(rsp)
}

func (c *ClientWithResponses) WorksListPostWithResponse(ctx context.Context, body WorksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksListPostResponse, error) {
	rsp, err := c.WorksListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksListPostResponse(rsp)
}

// WorksUpdateWithBodyWithResponse request with arbitrary body returning *WorksUpdateResponse
func (c *ClientWithResponses) WorksUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksUpdateResponse, error) {
	rsp, err := c.WorksUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksUpdateResponse(rsp)
}

func (c *ClientWithResponses) WorksUpdateWithResponse(ctx context.Context, body WorksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksUpdateResponse, error) {
	rsp, err := c.WorksUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksUpdateResponse(rsp)
}

// ParseAccountsCreateResponse parses an HTTP response from a AccountsCreateWithResponse call
func ParseAccountsCreateResponse(rsp *http.Response) (*AccountsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccountsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsDeleteResponse parses an HTTP response from a AccountsDeleteWithResponse call
func ParseAccountsDeleteResponse(rsp *http.Response) (*AccountsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsExportResponse parses an HTTP response from a AccountsExportWithResponse call
func ParseAccountsExportResponse(rsp *http.Response) (*AccountsExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsExportPostResponse parses an HTTP response from a AccountsExportPostWithResponse call
func ParseAccountsExportPostResponse(rsp *http.Response) (*AccountsExportPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsExportPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsGetResponse parses an HTTP response from a AccountsGetWithResponse call
func ParseAccountsGetResponse(rsp *http.Response) (*AccountsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsGetPostResponse parses an HTTP response from a AccountsGetPostWithResponse call
func ParseAccountsGetPostResponse(rsp *http.Response) (*AccountsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsListResponse parses an HTTP response from a AccountsListWithResponse call
func ParseAccountsListResponse(rsp *http.Response) (*AccountsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsListPostResponse parses an HTTP response from a AccountsListPostWithResponse call
func ParseAccountsListPostResponse(rsp *http.Response) (*AccountsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsMergeResponse parses an HTTP response from a AccountsMergeWithResponse call
func ParseAccountsMergeResponse(rsp *http.Response) (*AccountsMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsMergeResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsUpdateResponse parses an HTTP response from a AccountsUpdateWithResponse call
func ParseAccountsUpdateResponse(rsp *http.Response) (*AccountsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateArticleResponse parses an HTTP response from a CreateArticleWithResponse call
func ParseCreateArticleResponse(rsp *http.Response) (*CreateArticleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ArticlesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteArticleResponse parses an HTTP response from a DeleteArticleWithResponse call
func ParseDeleteArticleResponse(rsp *http.Response) (*DeleteArticleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetArticleResponse parses an HTTP response from a GetArticleWithResponse call
func ParseGetArticleResponse(rsp *http.Response) (*GetArticleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetArticlePostResponse parses an HTTP response from a GetArticlePostWithResponse call
func ParseGetArticlePostResponse(rsp *http.Response) (*GetArticlePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArticlePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListArticlesResponse parses an HTTP response from a ListArticlesWithResponse call
func ParseListArticlesResponse(rsp *http.Response) (*ListArticlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListArticlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListArticlesPostResponse parses an HTTP response from a ListArticlesPostWithResponse call
func ParseListArticlesPostResponse(rsp *http.Response) (*ListArticlesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListArticlesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateArticleResponse parses an HTTP response from a UpdateArticleWithResponse call
func ParseUpdateArticleResponse(rsp *http.Response) (*UpdateArticleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsGetResponse parses an HTTP response from a ArtifactsGetWithResponse call
func ParseArtifactsGetResponse(rsp *http.Response) (*ArtifactsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsGetPostResponse parses an HTTP response from a ArtifactsGetPostWithResponse call
func ParseArtifactsGetPostResponse(rsp *http.Response) (*ArtifactsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsListResponse parses an HTTP response from a ArtifactsListWithResponse call
func ParseArtifactsListResponse(rsp *http.Response) (*ArtifactsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsListPostResponse parses an HTTP response from a ArtifactsListPostWithResponse call
func ParseArtifactsListPostResponse(rsp *http.Response) (*ArtifactsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsLocateResponse parses an HTTP response from a ArtifactsLocateWithResponse call
func ParseArtifactsLocateResponse(rsp *http.Response) (*ArtifactsLocateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsLocateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsLocateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsLocatePostResponse parses an HTTP response from a ArtifactsLocatePostWithResponse call
func ParseArtifactsLocatePostResponse(rsp *http.Response) (*ArtifactsLocatePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsLocatePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsLocateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsPrepareResponse parses an HTTP response from a ArtifactsPrepareWithResponse call
func ParseArtifactsPrepareResponse(rsp *http.Response) (*ArtifactsPrepareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsPrepareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsPrepareResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsHardDeleteVersionResponse parses an HTTP response from a ArtifactsHardDeleteVersionWithResponse call
func ParseArtifactsHardDeleteVersionResponse(rsp *http.Response) (*ArtifactsHardDeleteVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsHardDeleteVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsHardDeleteVersionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsVersionsPrepareResponse parses an HTTP response from a ArtifactsVersionsPrepareWithResponse call
func ParseArtifactsVersionsPrepareResponse(rsp *http.Response) (*ArtifactsVersionsPrepareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsVersionsPrepareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsVersionsPrepareResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAtomsGetResponse parses an HTTP response from a AtomsGetWithResponse call
func ParseAtomsGetResponse(rsp *http.Response) (*AtomsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AtomsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AtomsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAtomsGetPostResponse parses an HTTP response from a AtomsGetPostWithResponse call
func ParseAtomsGetPostResponse(rsp *http.Response) (*AtomsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AtomsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AtomsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensCreateResponse parses an HTTP response from a AuthTokensCreateWithResponse call
func ParseAuthTokensCreateResponse(rsp *http.Response) (*AuthTokensCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthTokensCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensDeleteResponse parses an HTTP response from a AuthTokensDeleteWithResponse call
func ParseAuthTokensDeleteResponse(rsp *http.Response) (*AuthTokensDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensGetResponse parses an HTTP response from a AuthTokensGetWithResponse call
func ParseAuthTokensGetResponse(rsp *http.Response) (*AuthTokensGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensGetPostResponse parses an HTTP response from a AuthTokensGetPostWithResponse call
func ParseAuthTokensGetPostResponse(rsp *http.Response) (*AuthTokensGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensInfoResponse parses an HTTP response from a AuthTokensInfoWithResponse call
func ParseAuthTokensInfoResponse(rsp *http.Response) (*AuthTokensInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensInfoResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensInfoPostResponse parses an HTTP response from a AuthTokensInfoPostWithResponse call
func ParseAuthTokensInfoPostResponse(rsp *http.Response) (*AuthTokensInfoPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensInfoPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensInfoResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensListResponse parses an HTTP response from a AuthTokensListWithResponse call
func ParseAuthTokensListResponse(rsp *http.Response) (*AuthTokensListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensListPostResponse parses an HTTP response from a AuthTokensListPostWithResponse call
func ParseAuthTokensListPostResponse(rsp *http.Response) (*AuthTokensListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensSelfDeleteResponse parses an HTTP response from a AuthTokensSelfDeleteWithResponse call
func ParseAuthTokensSelfDeleteResponse(rsp *http.Response) (*AuthTokensSelfDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensSelfDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensUpdateResponse parses an HTTP response from a AuthTokensUpdateWithResponse call
func ParseAuthTokensUpdateResponse(rsp *http.Response) (*AuthTokensUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseChatsCreateResponse parses an HTTP response from a ChatsCreateWithResponse call
func ParseChatsCreateResponse(rsp *http.Response) (*ChatsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseChatsGetResponse parses an HTTP response from a ChatsGetWithResponse call
func ParseChatsGetResponse(rsp *http.Response) (*ChatsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseChatsGetPostResponse parses an HTTP response from a ChatsGetPostWithResponse call
func ParseChatsGetPostResponse(rsp *http.Response) (*ChatsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseChatsUpdateResponse parses an HTTP response from a ChatsUpdateWithResponse call
func ParseChatsUpdateResponse(rsp *http.Response) (*ChatsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesCreateResponse parses an HTTP response from a CodeChangesCreateWithResponse call
func ParseCodeChangesCreateResponse(rsp *http.Response) (*CodeChangesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesDeleteResponse parses an HTTP response from a CodeChangesDeleteWithResponse call
func ParseCodeChangesDeleteResponse(rsp *http.Response) (*CodeChangesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesGetResponse parses an HTTP response from a CodeChangesGetWithResponse call
func ParseCodeChangesGetResponse(rsp *http.Response) (*CodeChangesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesGetPostResponse parses an HTTP response from a CodeChangesGetPostWithResponse call
func ParseCodeChangesGetPostResponse(rsp *http.Response) (*CodeChangesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesListResponse parses an HTTP response from a CodeChangesListWithResponse call
func ParseCodeChangesListResponse(rsp *http.Response) (*CodeChangesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesListPostResponse parses an HTTP response from a CodeChangesListPostWithResponse call
func ParseCodeChangesListPostResponse(rsp *http.Response) (*CodeChangesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesUpdateResponse parses an HTTP response from a CodeChangesUpdateWithResponse call
func ParseCodeChangesUpdateResponse(rsp *http.Response) (*CodeChangesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsCreateResponse parses an HTTP response from a CommandsCreateWithResponse call
func ParseCommandsCreateResponse(rsp *http.Response) (*CommandsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsGetResponse parses an HTTP response from a CommandsGetWithResponse call
func ParseCommandsGetResponse(rsp *http.Response) (*CommandsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsGetPostResponse parses an HTTP response from a CommandsGetPostWithResponse call
func ParseCommandsGetPostResponse(rsp *http.Response) (*CommandsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsListResponse parses an HTTP response from a CommandsListWithResponse call
func ParseCommandsListResponse(rsp *http.Response) (*CommandsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsListPostResponse parses an HTTP response from a CommandsListPostWithResponse call
func ParseCommandsListPostResponse(rsp *http.Response) (*CommandsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsUpdateResponse parses an HTTP response from a CommandsUpdateWithResponse call
func ParseCommandsUpdateResponse(rsp *http.Response) (*CommandsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsCreateResponse parses an HTTP response from a ConversationsCreateWithResponse call
func ParseConversationsCreateResponse(rsp *http.Response) (*ConversationsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsDeleteResponse parses an HTTP response from a ConversationsDeleteWithResponse call
func ParseConversationsDeleteResponse(rsp *http.Response) (*ConversationsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsGetResponse parses an HTTP response from a ConversationsGetWithResponse call
func ParseConversationsGetResponse(rsp *http.Response) (*ConversationsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsGetPostResponse parses an HTTP response from a ConversationsGetPostWithResponse call
func ParseConversationsGetPostResponse(rsp *http.Response) (*ConversationsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsListResponse parses an HTTP response from a ConversationsListWithResponse call
func ParseConversationsListResponse(rsp *http.Response) (*ConversationsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsListPostResponse parses an HTTP response from a ConversationsListPostWithResponse call
func ParseConversationsListPostResponse(rsp *http.Response) (*ConversationsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsUpdateResponse parses an HTTP response from a ConversationsUpdateWithResponse call
func ParseConversationsUpdateResponse(rsp *http.Response) (*ConversationsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsCreateResponse parses an HTTP response from a DevOrgAuthConnectionsCreateWithResponse call
func ParseDevOrgAuthConnectionsCreateResponse(rsp *http.Response) (*DevOrgAuthConnectionsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DevOrgAuthConnectionsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsDeleteResponse parses an HTTP response from a DevOrgAuthConnectionsDeleteWithResponse call
func ParseDevOrgAuthConnectionsDeleteResponse(rsp *http.Response) (*DevOrgAuthConnectionsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsGetResponse parses an HTTP response from a DevOrgAuthConnectionsGetWithResponse call
func ParseDevOrgAuthConnectionsGetResponse(rsp *http.Response) (*DevOrgAuthConnectionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgAuthConnectionsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsGetPostResponse parses an HTTP response from a DevOrgAuthConnectionsGetPostWithResponse call
func ParseDevOrgAuthConnectionsGetPostResponse(rsp *http.Response) (*DevOrgAuthConnectionsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgAuthConnectionsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsListResponse parses an HTTP response from a DevOrgAuthConnectionsListWithResponse call
func ParseDevOrgAuthConnectionsListResponse(rsp *http.Response) (*DevOrgAuthConnectionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgAuthConnectionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsListPostResponse parses an HTTP response from a DevOrgAuthConnectionsListPostWithResponse call
func ParseDevOrgAuthConnectionsListPostResponse(rsp *http.Response) (*DevOrgAuthConnectionsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgAuthConnectionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsToggleResponse parses an HTTP response from a DevOrgAuthConnectionsToggleWithResponse call
func ParseDevOrgAuthConnectionsToggleResponse(rsp *http.Response) (*DevOrgAuthConnectionsToggleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsToggleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsUpdateResponse parses an HTTP response from a DevOrgAuthConnectionsUpdateWithResponse call
func ParseDevOrgAuthConnectionsUpdateResponse(rsp *http.Response) (*DevOrgAuthConnectionsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DevOrgAuthConnectionsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgsGetResponse parses an HTTP response from a DevOrgsGetWithResponse call
func ParseDevOrgsGetResponse(rsp *http.Response) (*DevOrgsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgsGetPostResponse parses an HTTP response from a DevOrgsGetPostWithResponse call
func ParseDevOrgsGetPostResponse(rsp *http.Response) (*DevOrgsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersActivateResponse parses an HTTP response from a DevUsersActivateWithResponse call
func ParseDevUsersActivateResponse(rsp *http.Response) (*DevUsersActivateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersActivateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersActivateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersCreateResponse parses an HTTP response from a DevUsersCreateWithResponse call
func ParseDevUsersCreateResponse(rsp *http.Response) (*DevUsersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DevUsersCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersDeactivateResponse parses an HTTP response from a DevUsersDeactivateWithResponse call
func ParseDevUsersDeactivateResponse(rsp *http.Response) (*DevUsersDeactivateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersDeactivateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersDeactivateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersGetResponse parses an HTTP response from a DevUsersGetWithResponse call
func ParseDevUsersGetResponse(rsp *http.Response) (*DevUsersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersGetPostResponse parses an HTTP response from a DevUsersGetPostWithResponse call
func ParseDevUsersGetPostResponse(rsp *http.Response) (*DevUsersGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersIdentitiesLinkResponse parses an HTTP response from a DevUsersIdentitiesLinkWithResponse call
func ParseDevUsersIdentitiesLinkResponse(rsp *http.Response) (*DevUsersIdentitiesLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersIdentitiesLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersIdentitiesLinkResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersIdentitiesUnlinkResponse parses an HTTP response from a DevUsersIdentitiesUnlinkWithResponse call
func ParseDevUsersIdentitiesUnlinkResponse(rsp *http.Response) (*DevUsersIdentitiesUnlinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersIdentitiesUnlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersIdentitiesUnlinkResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersListResponse parses an HTTP response from a DevUsersListWithResponse call
func ParseDevUsersListResponse(rsp *http.Response) (*DevUsersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersListPostResponse parses an HTTP response from a DevUsersListPostWithResponse call
func ParseDevUsersListPostResponse(rsp *http.Response) (*DevUsersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersMergeResponse parses an HTTP response from a DevUsersMergeWithResponse call
func ParseDevUsersMergeResponse(rsp *http.Response) (*DevUsersMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersMergeResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersSelfResponse parses an HTTP response from a DevUsersSelfWithResponse call
func ParseDevUsersSelfResponse(rsp *http.Response) (*DevUsersSelfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersSelfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersSelfResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersSelfPostResponse parses an HTTP response from a DevUsersSelfPostWithResponse call
func ParseDevUsersSelfPostResponse(rsp *http.Response) (*DevUsersSelfPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersSelfPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersSelfResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersSelfUpdateResponse parses an HTTP response from a DevUsersSelfUpdateWithResponse call
func ParseDevUsersSelfUpdateResponse(rsp *http.Response) (*DevUsersSelfUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersSelfUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersUpdateResponse parses an HTTP response from a DevUsersUpdateWithResponse call
func ParseDevUsersUpdateResponse(rsp *http.Response) (*DevUsersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesCountResponse parses an HTTP response from a DirectoriesCountWithResponse call
func ParseDirectoriesCountResponse(rsp *http.Response) (*DirectoriesCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesCountPostResponse parses an HTTP response from a DirectoriesCountPostWithResponse call
func ParseDirectoriesCountPostResponse(rsp *http.Response) (*DirectoriesCountPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesCountPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesCreateResponse parses an HTTP response from a DirectoriesCreateWithResponse call
func ParseDirectoriesCreateResponse(rsp *http.Response) (*DirectoriesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DirectoriesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesDeleteResponse parses an HTTP response from a DirectoriesDeleteWithResponse call
func ParseDirectoriesDeleteResponse(rsp *http.Response) (*DirectoriesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesGetResponse parses an HTTP response from a DirectoriesGetWithResponse call
func ParseDirectoriesGetResponse(rsp *http.Response) (*DirectoriesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesGetPostResponse parses an HTTP response from a DirectoriesGetPostWithResponse call
func ParseDirectoriesGetPostResponse(rsp *http.Response) (*DirectoriesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesListResponse parses an HTTP response from a DirectoriesListWithResponse call
func ParseDirectoriesListResponse(rsp *http.Response) (*DirectoriesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesListPostResponse parses an HTTP response from a DirectoriesListPostWithResponse call
func ParseDirectoriesListPostResponse(rsp *http.Response) (*DirectoriesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesUpdateResponse parses an HTTP response from a DirectoriesUpdateWithResponse call
func ParseDirectoriesUpdateResponse(rsp *http.Response) (*DirectoriesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsCreateResponse parses an HTTP response from a GroupsCreateWithResponse call
func ParseGroupsCreateResponse(rsp *http.Response) (*GroupsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GroupsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsGetResponse parses an HTTP response from a GroupsGetWithResponse call
func ParseGroupsGetResponse(rsp *http.Response) (*GroupsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsGetPostResponse parses an HTTP response from a GroupsGetPostWithResponse call
func ParseGroupsGetPostResponse(rsp *http.Response) (*GroupsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsListResponse parses an HTTP response from a GroupsListWithResponse call
func ParseGroupsListResponse(rsp *http.Response) (*GroupsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsListPostResponse parses an HTTP response from a GroupsListPostWithResponse call
func ParseGroupsListPostResponse(rsp *http.Response) (*GroupsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupMembersAddResponse parses an HTTP response from a GroupMembersAddWithResponse call
func ParseGroupMembersAddResponse(rsp *http.Response) (*GroupMembersAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupMembersAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMembersAddResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupMembersListResponse parses an HTTP response from a GroupMembersListWithResponse call
func ParseGroupMembersListResponse(rsp *http.Response) (*GroupMembersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupMembersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMembersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupMembersListPostResponse parses an HTTP response from a GroupMembersListPostWithResponse call
func ParseGroupMembersListPostResponse(rsp *http.Response) (*GroupMembersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupMembersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMembersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupMembersRemoveResponse parses an HTTP response from a GroupMembersRemoveWithResponse call
func ParseGroupMembersRemoveResponse(rsp *http.Response) (*GroupMembersRemoveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupMembersRemoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMembersRemoveResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsUpdateResponse parses an HTTP response from a GroupsUpdateWithResponse call
func ParseGroupsUpdateResponse(rsp *http.Response) (*GroupsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseKeyringsCreateCallbackResponse parses an HTTP response from a KeyringsCreateCallbackWithResponse call
func ParseKeyringsCreateCallbackResponse(rsp *http.Response) (*KeyringsCreateCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &KeyringsCreateCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseKeyringsCreateCallbackPostResponse parses an HTTP response from a KeyringsCreateCallbackPostWithResponse call
func ParseKeyringsCreateCallbackPostResponse(rsp *http.Response) (*KeyringsCreateCallbackPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &KeyringsCreateCallbackPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksCreateResponse parses an HTTP response from a LinksCreateWithResponse call
func ParseLinksCreateResponse(rsp *http.Response) (*LinksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LinksCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksDeleteResponse parses an HTTP response from a LinksDeleteWithResponse call
func ParseLinksDeleteResponse(rsp *http.Response) (*LinksDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksGetResponse parses an HTTP response from a LinksGetWithResponse call
func ParseLinksGetResponse(rsp *http.Response) (*LinksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksGetPostResponse parses an HTTP response from a LinksGetPostWithResponse call
func ParseLinksGetPostResponse(rsp *http.Response) (*LinksGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksListResponse parses an HTTP response from a LinksListWithResponse call
func ParseLinksListResponse(rsp *http.Response) (*LinksListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksListPostResponse parses an HTTP response from a LinksListPostWithResponse call
func ParseLinksListPostResponse(rsp *http.Response) (*LinksListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksReplaceResponse parses an HTTP response from a LinksReplaceWithResponse call
func ParseLinksReplaceResponse(rsp *http.Response) (*LinksReplaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksReplaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LinksReplaceResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsCountResponse parses an HTTP response from a MeetingsCountWithResponse call
func ParseMeetingsCountResponse(rsp *http.Response) (*MeetingsCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsCountPostResponse parses an HTTP response from a MeetingsCountPostWithResponse call
func ParseMeetingsCountPostResponse(rsp *http.Response) (*MeetingsCountPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsCountPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsCreateResponse parses an HTTP response from a MeetingsCreateWithResponse call
func ParseMeetingsCreateResponse(rsp *http.Response) (*MeetingsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MeetingsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsDeleteResponse parses an HTTP response from a MeetingsDeleteWithResponse call
func ParseMeetingsDeleteResponse(rsp *http.Response) (*MeetingsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsGetResponse parses an HTTP response from a MeetingsGetWithResponse call
func ParseMeetingsGetResponse(rsp *http.Response) (*MeetingsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsGetPostResponse parses an HTTP response from a MeetingsGetPostWithResponse call
func ParseMeetingsGetPostResponse(rsp *http.Response) (*MeetingsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsListResponse parses an HTTP response from a MeetingsListWithResponse call
func ParseMeetingsListResponse(rsp *http.Response) (*MeetingsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsListPostResponse parses an HTTP response from a MeetingsListPostWithResponse call
func ParseMeetingsListPostResponse(rsp *http.Response) (*MeetingsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsUpdateResponse parses an HTTP response from a MeetingsUpdateWithResponse call
func ParseMeetingsUpdateResponse(rsp *http.Response) (*MeetingsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricActionExecuteResponse parses an HTTP response from a MetricActionExecuteWithResponse call
func ParseMetricActionExecuteResponse(rsp *http.Response) (*MetricActionExecuteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricActionExecuteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricActionExecuteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsCreateResponse parses an HTTP response from a MetricDefinitionsCreateWithResponse call
func ParseMetricDefinitionsCreateResponse(rsp *http.Response) (*MetricDefinitionsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MetricDefinitionsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsDeleteResponse parses an HTTP response from a MetricDefinitionsDeleteWithResponse call
func ParseMetricDefinitionsDeleteResponse(rsp *http.Response) (*MetricDefinitionsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest MetricDefinitionsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsGetResponse parses an HTTP response from a MetricDefinitionsGetWithResponse call
func ParseMetricDefinitionsGetResponse(rsp *http.Response) (*MetricDefinitionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsGetPostResponse parses an HTTP response from a MetricDefinitionsGetPostWithResponse call
func ParseMetricDefinitionsGetPostResponse(rsp *http.Response) (*MetricDefinitionsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsListResponse parses an HTTP response from a MetricDefinitionsListWithResponse call
func ParseMetricDefinitionsListResponse(rsp *http.Response) (*MetricDefinitionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsListPostResponse parses an HTTP response from a MetricDefinitionsListPostWithResponse call
func ParseMetricDefinitionsListPostResponse(rsp *http.Response) (*MetricDefinitionsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsUpdateResponse parses an HTTP response from a MetricDefinitionsUpdateWithResponse call
func ParseMetricDefinitionsUpdateResponse(rsp *http.Response) (*MetricDefinitionsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricTrackersGetResponse parses an HTTP response from a MetricTrackersGetWithResponse call
func ParseMetricTrackersGetResponse(rsp *http.Response) (*MetricTrackersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricTrackersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricTrackersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricTrackersGetPostResponse parses an HTTP response from a MetricTrackersGetPostWithResponse call
func ParseMetricTrackersGetPostResponse(rsp *http.Response) (*MetricTrackersGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricTrackersGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricTrackersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgScheduleFragmentsCreateResponse parses an HTTP response from a OrgScheduleFragmentsCreateWithResponse call
func ParseOrgScheduleFragmentsCreateResponse(rsp *http.Response) (*OrgScheduleFragmentsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgScheduleFragmentsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OrgScheduleFragmentsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgScheduleFragmentsGetResponse parses an HTTP response from a OrgScheduleFragmentsGetWithResponse call
func ParseOrgScheduleFragmentsGetResponse(rsp *http.Response) (*OrgScheduleFragmentsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgScheduleFragmentsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgScheduleFragmentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgScheduleFragmentsGetPostResponse parses an HTTP response from a OrgScheduleFragmentsGetPostWithResponse call
func ParseOrgScheduleFragmentsGetPostResponse(rsp *http.Response) (*OrgScheduleFragmentsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgScheduleFragmentsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgScheduleFragmentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgScheduleFragmentsTransitionResponse parses an HTTP response from a OrgScheduleFragmentsTransitionWithResponse call
func ParseOrgScheduleFragmentsTransitionResponse(rsp *http.Response) (*OrgScheduleFragmentsTransitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgScheduleFragmentsTransitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgScheduleFragmentsTransitionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesCreateResponse parses an HTTP response from a OrgSchedulesCreateWithResponse call
func ParseOrgSchedulesCreateResponse(rsp *http.Response) (*OrgSchedulesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OrgSchedulesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesEvaluateResponse parses an HTTP response from a OrgSchedulesEvaluateWithResponse call
func ParseOrgSchedulesEvaluateResponse(rsp *http.Response) (*OrgSchedulesEvaluateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesEvaluateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesEvaluateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesEvaluatePostResponse parses an HTTP response from a OrgSchedulesEvaluatePostWithResponse call
func ParseOrgSchedulesEvaluatePostResponse(rsp *http.Response) (*OrgSchedulesEvaluatePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesEvaluatePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesEvaluateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesGetResponse parses an HTTP response from a OrgSchedulesGetWithResponse call
func ParseOrgSchedulesGetResponse(rsp *http.Response) (*OrgSchedulesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesGetPostResponse parses an HTTP response from a OrgSchedulesGetPostWithResponse call
func ParseOrgSchedulesGetPostResponse(rsp *http.Response) (*OrgSchedulesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesListResponse parses an HTTP response from a OrgSchedulesListWithResponse call
func ParseOrgSchedulesListResponse(rsp *http.Response) (*OrgSchedulesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesListPostResponse parses an HTTP response from a OrgSchedulesListPostWithResponse call
func ParseOrgSchedulesListPostResponse(rsp *http.Response) (*OrgSchedulesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesSetFutureResponse parses an HTTP response from a OrgSchedulesSetFutureWithResponse call
func ParseOrgSchedulesSetFutureResponse(rsp *http.Response) (*OrgSchedulesSetFutureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesSetFutureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesSetFutureResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesTransitionResponse parses an HTTP response from a OrgSchedulesTransitionWithResponse call
func ParseOrgSchedulesTransitionResponse(rsp *http.Response) (*OrgSchedulesTransitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesTransitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesTransitionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesUpdateResponse parses an HTTP response from a OrgSchedulesUpdateWithResponse call
func ParseOrgSchedulesUpdateResponse(rsp *http.Response) (*OrgSchedulesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OrgSchedulesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsCreateResponse parses an HTTP response from a PartsCreateWithResponse call
func ParsePartsCreateResponse(rsp *http.Response) (*PartsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PartsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsDeleteResponse parses an HTTP response from a PartsDeleteWithResponse call
func ParsePartsDeleteResponse(rsp *http.Response) (*PartsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsGetResponse parses an HTTP response from a PartsGetWithResponse call
func ParsePartsGetResponse(rsp *http.Response) (*PartsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsGetPostResponse parses an HTTP response from a PartsGetPostWithResponse call
func ParsePartsGetPostResponse(rsp *http.Response) (*PartsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsListResponse parses an HTTP response from a PartsListWithResponse call
func ParsePartsListResponse(rsp *http.Response) (*PartsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsListPostResponse parses an HTTP response from a PartsListPostWithResponse call
func ParsePartsListPostResponse(rsp *http.Response) (*PartsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsUpdateResponse parses an HTTP response from a PartsUpdateWithResponse call
func ParsePartsUpdateResponse(rsp *http.Response) (*PartsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseReactionsListResponse parses an HTTP response from a ReactionsListWithResponse call
func ParseReactionsListResponse(rsp *http.Response) (*ReactionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReactionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseReactionsListPostResponse parses an HTTP response from a ReactionsListPostWithResponse call
func ParseReactionsListPostResponse(rsp *http.Response) (*ReactionsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReactionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseReactionsUpdateResponse parses an HTTP response from a ReactionsUpdateWithResponse call
func ParseReactionsUpdateResponse(rsp *http.Response) (*ReactionsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReactionsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsCreateResponse parses an HTTP response from a RevOrgsCreateWithResponse call
func ParseRevOrgsCreateResponse(rsp *http.Response) (*RevOrgsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RevOrgsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsDeleteResponse parses an HTTP response from a RevOrgsDeleteWithResponse call
func ParseRevOrgsDeleteResponse(rsp *http.Response) (*RevOrgsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsGetResponse parses an HTTP response from a RevOrgsGetWithResponse call
func ParseRevOrgsGetResponse(rsp *http.Response) (*RevOrgsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsGetPostResponse parses an HTTP response from a RevOrgsGetPostWithResponse call
func ParseRevOrgsGetPostResponse(rsp *http.Response) (*RevOrgsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsListResponse parses an HTTP response from a RevOrgsListWithResponse call
func ParseRevOrgsListResponse(rsp *http.Response) (*RevOrgsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsListPostResponse parses an HTTP response from a RevOrgsListPostWithResponse call
func ParseRevOrgsListPostResponse(rsp *http.Response) (*RevOrgsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsUpdateResponse parses an HTTP response from a RevOrgsUpdateWithResponse call
func ParseRevOrgsUpdateResponse(rsp *http.Response) (*RevOrgsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersCreateResponse parses an HTTP response from a RevUsersCreateWithResponse call
func ParseRevUsersCreateResponse(rsp *http.Response) (*RevUsersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RevUsersCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersDeleteResponse parses an HTTP response from a RevUsersDeleteWithResponse call
func ParseRevUsersDeleteResponse(rsp *http.Response) (*RevUsersDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersGetResponse parses an HTTP response from a RevUsersGetWithResponse call
func ParseRevUsersGetResponse(rsp *http.Response) (*RevUsersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersGetPostResponse parses an HTTP response from a RevUsersGetPostWithResponse call
func ParseRevUsersGetPostResponse(rsp *http.Response) (*RevUsersGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersListResponse parses an HTTP response from a RevUsersListWithResponse call
func ParseRevUsersListResponse(rsp *http.Response) (*RevUsersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersListPostResponse parses an HTTP response from a RevUsersListPostWithResponse call
func ParseRevUsersListPostResponse(rsp *http.Response) (*RevUsersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersMergeResponse parses an HTTP response from a RevUsersMergeWithResponse call
func ParseRevUsersMergeResponse(rsp *http.Response) (*RevUsersMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersMergeResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersScanResponse parses an HTTP response from a RevUsersScanWithResponse call
func ParseRevUsersScanResponse(rsp *http.Response) (*RevUsersScanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersScanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersScanResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersScanPostResponse parses an HTTP response from a RevUsersScanPostWithResponse call
func ParseRevUsersScanPostResponse(rsp *http.Response) (*RevUsersScanPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersScanPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersScanResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersUpdateResponse parses an HTTP response from a RevUsersUpdateWithResponse call
func ParseRevUsersUpdateResponse(rsp *http.Response) (*RevUsersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseServiceAccountsCreateResponse parses an HTTP response from a ServiceAccountsCreateWithResponse call
func ParseServiceAccountsCreateResponse(rsp *http.Response) (*ServiceAccountsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServiceAccountsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseServiceAccountsGetResponse parses an HTTP response from a ServiceAccountsGetWithResponse call
func ParseServiceAccountsGetResponse(rsp *http.Response) (*ServiceAccountsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServiceAccountsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseServiceAccountsGetPostResponse parses an HTTP response from a ServiceAccountsGetPostWithResponse call
func ParseServiceAccountsGetPostResponse(rsp *http.Response) (*ServiceAccountsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServiceAccountsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlaTrackersGetResponse parses an HTTP response from a SlaTrackersGetWithResponse call
func ParseSlaTrackersGetResponse(rsp *http.Response) (*SlaTrackersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaTrackersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlaTrackersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlaTrackersGetPostResponse parses an HTTP response from a SlaTrackersGetPostWithResponse call
func ParseSlaTrackersGetPostResponse(rsp *http.Response) (*SlaTrackersGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaTrackersGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlaTrackersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlaTrackersListResponse parses an HTTP response from a SlaTrackersListWithResponse call
func ParseSlaTrackersListResponse(rsp *http.Response) (*SlaTrackersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaTrackersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlaTrackersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlaTrackersListPostResponse parses an HTTP response from a SlaTrackersListPostWithResponse call
func ParseSlaTrackersListPostResponse(rsp *http.Response) (*SlaTrackersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaTrackersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlaTrackersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasAssignResponse parses an HTTP response from a SlasAssignWithResponse call
func ParseSlasAssignResponse(rsp *http.Response) (*SlasAssignResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasAssignResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasAssignResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasCreateResponse parses an HTTP response from a SlasCreateWithResponse call
func ParseSlasCreateResponse(rsp *http.Response) (*SlasCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SlasCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasGetResponse parses an HTTP response from a SlasGetWithResponse call
func ParseSlasGetResponse(rsp *http.Response) (*SlasGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasGetPostResponse parses an HTTP response from a SlasGetPostWithResponse call
func ParseSlasGetPostResponse(rsp *http.Response) (*SlasGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasListResponse parses an HTTP response from a SlasListWithResponse call
func ParseSlasListResponse(rsp *http.Response) (*SlasListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasListPostResponse parses an HTTP response from a SlasListPostWithResponse call
func ParseSlasListPostResponse(rsp *http.Response) (*SlasListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasTransitionResponse parses an HTTP response from a SlasTransitionWithResponse call
func ParseSlasTransitionResponse(rsp *http.Response) (*SlasTransitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasTransitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasTransitionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasUpdateResponse parses an HTTP response from a SlasUpdateWithResponse call
func ParseSlasUpdateResponse(rsp *http.Response) (*SlasUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SlasUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSnapKitActionExecuteDeferredResponse parses an HTTP response from a SnapKitActionExecuteDeferredWithResponse call
func ParseSnapKitActionExecuteDeferredResponse(rsp *http.Response) (*SnapKitActionExecuteDeferredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapKitActionExecuteDeferredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapKitActionExecuteDeferredResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSnapWidgetsCreateResponse parses an HTTP response from a SnapWidgetsCreateWithResponse call
func ParseSnapWidgetsCreateResponse(rsp *http.Response) (*SnapWidgetsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapWidgetsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SnapWidgetsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysCreateResponse parses an HTTP response from a SurveysCreateWithResponse call
func ParseSurveysCreateResponse(rsp *http.Response) (*SurveysCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SurveysCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysDeleteResponse parses an HTTP response from a SurveysDeleteWithResponse call
func ParseSurveysDeleteResponse(rsp *http.Response) (*SurveysDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysGetResponse parses an HTTP response from a SurveysGetWithResponse call
func ParseSurveysGetResponse(rsp *http.Response) (*SurveysGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysGetPostResponse parses an HTTP response from a SurveysGetPostWithResponse call
func ParseSurveysGetPostResponse(rsp *http.Response) (*SurveysGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysListResponse parses an HTTP response from a SurveysListWithResponse call
func ParseSurveysListResponse(rsp *http.Response) (*SurveysListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysListPostResponse parses an HTTP response from a SurveysListPostWithResponse call
func ParseSurveysListPostResponse(rsp *http.Response) (*SurveysListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysResponsesListResponse parses an HTTP response from a SurveysResponsesListWithResponse call
func ParseSurveysResponsesListResponse(rsp *http.Response) (*SurveysResponsesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysResponsesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysResponsesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysResponsesListPostResponse parses an HTTP response from a SurveysResponsesListPostWithResponse call
func ParseSurveysResponsesListPostResponse(rsp *http.Response) (*SurveysResponsesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysResponsesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysResponsesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysResponsesUpdateResponse parses an HTTP response from a SurveysResponsesUpdateWithResponse call
func ParseSurveysResponsesUpdateResponse(rsp *http.Response) (*SurveysResponsesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysResponsesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SurveysResponsesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysSendResponse parses an HTTP response from a SurveysSendWithResponse call
func ParseSurveysSendResponse(rsp *http.Response) (*SurveysSendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysSendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysSendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysSubmitResponse parses an HTTP response from a SurveysSubmitWithResponse call
func ParseSurveysSubmitResponse(rsp *http.Response) (*SurveysSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SurveysSubmitResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysUpdateResponse parses an HTTP response from a SurveysUpdateWithResponse call
func ParseSurveysUpdateResponse(rsp *http.Response) (*SurveysUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSysUsersListResponse parses an HTTP response from a SysUsersListWithResponse call
func ParseSysUsersListResponse(rsp *http.Response) (*SysUsersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SysUsersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SysUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSysUsersListPostResponse parses an HTTP response from a SysUsersListPostWithResponse call
func ParseSysUsersListPostResponse(rsp *http.Response) (*SysUsersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SysUsersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SysUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSysUsersUpdateResponse parses an HTTP response from a SysUsersUpdateWithResponse call
func ParseSysUsersUpdateResponse(rsp *http.Response) (*SysUsersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SysUsersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SysUsersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsCreateResponse parses an HTTP response from a TagsCreateWithResponse call
func ParseTagsCreateResponse(rsp *http.Response) (*TagsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TagsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsDeleteResponse parses an HTTP response from a TagsDeleteWithResponse call
func ParseTagsDeleteResponse(rsp *http.Response) (*TagsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsGetResponse parses an HTTP response from a TagsGetWithResponse call
func ParseTagsGetResponse(rsp *http.Response) (*TagsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsGetPostResponse parses an HTTP response from a TagsGetPostWithResponse call
func ParseTagsGetPostResponse(rsp *http.Response) (*TagsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsListResponse parses an HTTP response from a TagsListWithResponse call
func ParseTagsListResponse(rsp *http.Response) (*TagsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsListPostResponse parses an HTTP response from a TagsListPostWithResponse call
func ParseTagsListPostResponse(rsp *http.Response) (*TagsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsUpdateResponse parses an HTTP response from a TagsUpdateWithResponse call
func ParseTagsUpdateResponse(rsp *http.Response) (*TagsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesCreateResponse parses an HTTP response from a TimelineEntriesCreateWithResponse call
func ParseTimelineEntriesCreateResponse(rsp *http.Response) (*TimelineEntriesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TimelineEntriesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesDeleteResponse parses an HTTP response from a TimelineEntriesDeleteWithResponse call
func ParseTimelineEntriesDeleteResponse(rsp *http.Response) (*TimelineEntriesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesGetResponse parses an HTTP response from a TimelineEntriesGetWithResponse call
func ParseTimelineEntriesGetResponse(rsp *http.Response) (*TimelineEntriesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesGetPostResponse parses an HTTP response from a TimelineEntriesGetPostWithResponse call
func ParseTimelineEntriesGetPostResponse(rsp *http.Response) (*TimelineEntriesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesListResponse parses an HTTP response from a TimelineEntriesListWithResponse call
func ParseTimelineEntriesListResponse(rsp *http.Response) (*TimelineEntriesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesListPostResponse parses an HTTP response from a TimelineEntriesListPostWithResponse call
func ParseTimelineEntriesListPostResponse(rsp *http.Response) (*TimelineEntriesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesUpdateResponse parses an HTTP response from a TimelineEntriesUpdateWithResponse call
func ParseTimelineEntriesUpdateResponse(rsp *http.Response) (*TimelineEntriesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebCrawlerJobsControlResponse parses an HTTP response from a WebCrawlerJobsControlWithResponse call
func ParseWebCrawlerJobsControlResponse(rsp *http.Response) (*WebCrawlerJobsControlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebCrawlerJobsControlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsControlResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateWebCrawlerJobResponse parses an HTTP response from a CreateWebCrawlerJobWithResponse call
func ParseCreateWebCrawlerJobResponse(rsp *http.Response) (*CreateWebCrawlerJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebCrawlerJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebCrawlerJobsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetWebCrawlerJobResponse parses an HTTP response from a GetWebCrawlerJobWithResponse call
func ParseGetWebCrawlerJobResponse(rsp *http.Response) (*GetWebCrawlerJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebCrawlerJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetWebCrawlerJobPostResponse parses an HTTP response from a GetWebCrawlerJobPostWithResponse call
func ParseGetWebCrawlerJobPostResponse(rsp *http.Response) (*GetWebCrawlerJobPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebCrawlerJobPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListWebCrawlerJobsResponse parses an HTTP response from a ListWebCrawlerJobsWithResponse call
func ParseListWebCrawlerJobsResponse(rsp *http.Response) (*ListWebCrawlerJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebCrawlerJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListWebCrawlerJobsPostResponse parses an HTTP response from a ListWebCrawlerJobsPostWithResponse call
func ParseListWebCrawlerJobsPostResponse(rsp *http.Response) (*ListWebCrawlerJobsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebCrawlerJobsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksCreateResponse parses an HTTP response from a WebhooksCreateWithResponse call
func ParseWebhooksCreateResponse(rsp *http.Response) (*WebhooksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebhooksCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksDeleteResponse parses an HTTP response from a WebhooksDeleteWithResponse call
func ParseWebhooksDeleteResponse(rsp *http.Response) (*WebhooksDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksEventResponse parses an HTTP response from a WebhooksEventWithResponse call
func ParseWebhooksEventResponse(rsp *http.Response) (*WebhooksEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookEventResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksGetResponse parses an HTTP response from a WebhooksGetWithResponse call
func ParseWebhooksGetResponse(rsp *http.Response) (*WebhooksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksGetPostResponse parses an HTTP response from a WebhooksGetPostWithResponse call
func ParseWebhooksGetPostResponse(rsp *http.Response) (*WebhooksGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksListResponse parses an HTTP response from a WebhooksListWithResponse call
func ParseWebhooksListResponse(rsp *http.Response) (*WebhooksListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksListPostResponse parses an HTTP response from a WebhooksListPostWithResponse call
func ParseWebhooksListPostResponse(rsp *http.Response) (*WebhooksListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksUpdateResponse parses an HTTP response from a WebhooksUpdateWithResponse call
func ParseWebhooksUpdateResponse(rsp *http.Response) (*WebhooksUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksCreateResponse parses an HTTP response from a WorksCreateWithResponse call
func ParseWorksCreateResponse(rsp *http.Response) (*WorksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WorksCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksDeleteResponse parses an HTTP response from a WorksDeleteWithResponse call
func ParseWorksDeleteResponse(rsp *http.Response) (*WorksDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksExportResponse parses an HTTP response from a WorksExportWithResponse call
func ParseWorksExportResponse(rsp *http.Response) (*WorksExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksExportPostResponse parses an HTTP response from a WorksExportPostWithResponse call
func ParseWorksExportPostResponse(rsp *http.Response) (*WorksExportPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksExportPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksGetResponse parses an HTTP response from a WorksGetWithResponse call
func ParseWorksGetResponse(rsp *http.Response) (*WorksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksGetPostResponse parses an HTTP response from a WorksGetPostWithResponse call
func ParseWorksGetPostResponse(rsp *http.Response) (*WorksGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksListResponse parses an HTTP response from a WorksListWithResponse call
func ParseWorksListResponse(rsp *http.Response) (*WorksListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksListPostResponse parses an HTTP response from a WorksListPostWithResponse call
func ParseWorksListPostResponse(rsp *http.Response) (*WorksListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksUpdateResponse parses an HTTP response from a WorksUpdateWithResponse call
func ParseWorksUpdateResponse(rsp *http.Response) (*WorksUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
