// Package beta provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package beta

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Auth_tokenScopes = "auth_token.Scopes"
)

// Defines values for AccessLevel.
const (
	AccessLevelExternal   AccessLevel = "external"
	AccessLevelInternal   AccessLevel = "internal"
	AccessLevelPrivate    AccessLevel = "private"
	AccessLevelPublic     AccessLevel = "public"
	AccessLevelRestricted AccessLevel = "restricted"
)

// Defines values for AggregationDetailAggregationType.
const (
	AggregationDetailAggregationTypeDuration     AggregationDetailAggregationType = "duration"
	AggregationDetailAggregationTypeLatest       AggregationDetailAggregationType = "latest"
	AggregationDetailAggregationTypeMaximum      AggregationDetailAggregationType = "maximum"
	AggregationDetailAggregationTypeMinimum      AggregationDetailAggregationType = "minimum"
	AggregationDetailAggregationTypeOldest       AggregationDetailAggregationType = "oldest"
	AggregationDetailAggregationTypeRunningTotal AggregationDetailAggregationType = "running_total"
	AggregationDetailAggregationTypeSum          AggregationDetailAggregationType = "sum"
	AggregationDetailAggregationTypeUniqueCount  AggregationDetailAggregationType = "unique_count"
)

// Defines values for AiAgentEventExecuteProgressProgressState.
const (
	SkillExecuted  AiAgentEventExecuteProgressProgressState = "skill_executed"
	SkillTriggered AiAgentEventExecuteProgressProgressState = "skill_triggered"
)

// Defines values for AiAgentEventsExecuteAsyncRequestTarget.
const (
	EventSourceTarget AiAgentEventsExecuteAsyncRequestTarget = "event_source_target"
	WebhookTarget     AiAgentEventsExecuteAsyncRequestTarget = "webhook_target"
)

// Defines values for ArticleContentFormat.
const (
	Drdfv2 ArticleContentFormat = "drdfv2"
	Rt     ArticleContentFormat = "rt"
)

// Defines values for ArticleStatus.
const (
	ArticleStatusArchived     ArticleStatus = "archived"
	ArticleStatusDraft        ArticleStatus = "draft"
	ArticleStatusPublished    ArticleStatus = "published"
	ArticleStatusReviewNeeded ArticleStatus = "review_needed"
)

// Defines values for ArticleType.
const (
	ArticleTypeArticle      ArticleType = "article"
	ArticleTypeContentBlock ArticleType = "content_block"
	ArticleTypePage         ArticleType = "page"
)

// Defines values for ArtifactConfigurationSet.
const (
	ArtifactConfigurationSetArticleMedia           ArtifactConfigurationSet = "article_media"
	ArtifactConfigurationSetDefault                ArtifactConfigurationSet = "default"
	ArtifactConfigurationSetEmailMedia             ArtifactConfigurationSet = "email_media"
	ArtifactConfigurationSetJobData                ArtifactConfigurationSet = "job_data"
	ArtifactConfigurationSetMarketplaceListingIcon ArtifactConfigurationSet = "marketplace_listing_icon"
	ArtifactConfigurationSetMarketplaceMedia       ArtifactConfigurationSet = "marketplace_media"
	ArtifactConfigurationSetOrgLogo                ArtifactConfigurationSet = "org_logo"
	ArtifactConfigurationSetPlugSetting            ArtifactConfigurationSet = "plug_setting"
	ArtifactConfigurationSetPlugSettingBannerCard  ArtifactConfigurationSet = "plug_setting_banner_card"
	ArtifactConfigurationSetPortalCss              ArtifactConfigurationSet = "portal_css"
	ArtifactConfigurationSetSnapInFunctionsCode    ArtifactConfigurationSet = "snap_in_functions_code"
	ArtifactConfigurationSetSnapWidget             ArtifactConfigurationSet = "snap_widget"
	ArtifactConfigurationSetUserProfilePicture     ArtifactConfigurationSet = "user_profile_picture"
	ArtifactConfigurationSetWork                   ArtifactConfigurationSet = "work"
)

// Defines values for AssociatedToType.
const (
	AssociatedToTypeAccount AssociatedToType = "account"
	AssociatedToTypeRevOrg  AssociatedToType = "rev_org"
)

// Defines values for AtomType.
const (
	AtomTypeAccount             AtomType = "account"
	AtomTypeAppFragment         AtomType = "app_fragment"
	AtomTypeAuthToken           AtomType = "auth_token"
	AtomTypeCapability          AtomType = "capability"
	AtomTypeCodeChange          AtomType = "code_change"
	AtomTypeCommand             AtomType = "command"
	AtomTypeConversation        AtomType = "conversation"
	AtomTypeCustomObject        AtomType = "custom_object"
	AtomTypeCustomTypeFragment  AtomType = "custom_type_fragment"
	AtomTypeDevOrg              AtomType = "dev_org"
	AtomTypeDevUser             AtomType = "dev_user"
	AtomTypeDm                  AtomType = "dm"
	AtomTypeEngagement          AtomType = "engagement"
	AtomTypeEnhancement         AtomType = "enhancement"
	AtomTypeFeature             AtomType = "feature"
	AtomTypeGroup               AtomType = "group"
	AtomTypeIncident            AtomType = "incident"
	AtomTypeIssue               AtomType = "issue"
	AtomTypeLink                AtomType = "link"
	AtomTypeLinkable            AtomType = "linkable"
	AtomTypeMeeting             AtomType = "meeting"
	AtomTypeObjectMember        AtomType = "object_member"
	AtomTypeOpportunity         AtomType = "opportunity"
	AtomTypeProduct             AtomType = "product"
	AtomTypeQuestionAnswer      AtomType = "question_answer"
	AtomTypeRevOrg              AtomType = "rev_org"
	AtomTypeRevUser             AtomType = "rev_user"
	AtomTypeRunnable            AtomType = "runnable"
	AtomTypeServiceAccount      AtomType = "service_account"
	AtomTypeSla                 AtomType = "sla"
	AtomTypeSlaTracker          AtomType = "sla_tracker"
	AtomTypeSnapIn              AtomType = "snap_in"
	AtomTypeSnapInVersion       AtomType = "snap_in_version"
	AtomTypeSysUser             AtomType = "sys_user"
	AtomTypeTag                 AtomType = "tag"
	AtomTypeTask                AtomType = "task"
	AtomTypeTenantFragment      AtomType = "tenant_fragment"
	AtomTypeTicket              AtomType = "ticket"
	AtomTypeTimelineChangeEvent AtomType = "timeline_change_event"
	AtomTypeTimelineComment     AtomType = "timeline_comment"
	AtomTypeUom                 AtomType = "uom"
	AtomTypeUserPreferences     AtomType = "user_preferences"
	AtomTypeWebhook             AtomType = "webhook"
	AtomTypeWidget              AtomType = "widget"
)

// Defines values for AuthConnectionToggle.
const (
	Disable AuthConnectionToggle = "disable"
	Enable  AuthConnectionToggle = "enable"
)

// Defines values for AuthConnectionType.
const (
	AuthConnectionTypeGoogleApps AuthConnectionType = "google_apps"
	AuthConnectionTypeOidc       AuthConnectionType = "oidc"
	AuthConnectionTypeOkta       AuthConnectionType = "okta"
	AuthConnectionTypeSamlp      AuthConnectionType = "samlp"
	AuthConnectionTypeSocial     AuthConnectionType = "social"
	AuthConnectionTypeWaad       AuthConnectionType = "waad"
)

// Defines values for AuthTokenGrantType.
const (
	UrnDevrevParamsOauthGrantTypeTokenIssue  AuthTokenGrantType = "urn:devrev:params:oauth:grant-type:token-issue"
	UrnIetfParamsOauthGrantTypeTokenExchange AuthTokenGrantType = "urn:ietf:params:oauth:grant-type:token-exchange"
)

// Defines values for AuthTokenRequestedTokenType.
const (
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeAat             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:aat"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeAatActAs        AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:aat:act-as"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeAatPublic       AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:aat:public"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeDev             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:dev"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeDevConnect      AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:dev:connect"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeGat             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:gat"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypePat             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:pat"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypePatActAs        AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:pat:act-as"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeRat             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:rat"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeRev             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:rev"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSession         AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:session"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSessionDev0     AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:session:dev0"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSessionOnetime  AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:session:onetime"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSessionRevActAs AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:session:rev:act-as"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSuper           AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:super"
	AuthTokenRequestedTokenTypeUrnDevrevParamsOauthTokenTypeSys             AuthTokenRequestedTokenType = "urn:devrev:params:oauth:token-type:sys"
	AuthTokenRequestedTokenTypeUrnIetfParamsOauthTokenTypeJwt               AuthTokenRequestedTokenType = "urn:ietf:params:oauth:token-type:jwt"
)

// Defines values for AuthTokenStatus.
const (
	AuthTokenStatusActive  AuthTokenStatus = "active"
	AuthTokenStatusExpired AuthTokenStatus = "expired"
	AuthTokenStatusRevoked AuthTokenStatus = "revoked"
)

// Defines values for AuthTokenSubjectTokenType.
const (
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeJwtAuth0 AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:jwt:auth0"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeJwtDev   AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:jwt:dev"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeRat      AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:rat"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeRev      AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:rev"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeRevinfo  AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:revinfo"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeSession  AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:session"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeSysu     AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:sysu"
	AuthTokenSubjectTokenTypeUrnDevrevParamsOauthTokenTypeUserinfo AuthTokenSubjectTokenType = "urn:devrev:params:oauth:token-type:userinfo"
	AuthTokenSubjectTokenTypeUrnIetfParamsOauthTokenTypeJwt        AuthTokenSubjectTokenType = "urn:ietf:params:oauth:token-type:jwt"
)

// Defines values for AuthTokenTokenType.
const (
	Bearer AuthTokenTokenType = "bearer"
)

// Defines values for BooleanExpressionType.
const (
	And       BooleanExpressionType = "and"
	Not       BooleanExpressionType = "not"
	Or        BooleanExpressionType = "or"
	Primitive BooleanExpressionType = "primitive"
)

// Defines values for ChatCompletionsRequestMessageRole.
const (
	ChatCompletionsRequestMessageRoleAssistant ChatCompletionsRequestMessageRole = "assistant"
	ChatCompletionsRequestMessageRoleSystem    ChatCompletionsRequestMessageRole = "system"
	ChatCompletionsRequestMessageRoleUser      ChatCompletionsRequestMessageRole = "user"
)

// Defines values for ChatType.
const (
	ChatTypeDm ChatType = "dm"
)

// Defines values for CodeChangeSource.
const (
	CodeChangeSourceAzureDevops CodeChangeSource = "azure_devops"
	CodeChangeSourceBitbucket   CodeChangeSource = "bitbucket"
	CodeChangeSourceGithub      CodeChangeSource = "github"
	CodeChangeSourceGitlab      CodeChangeSource = "gitlab"
)

// Defines values for CommandActionExecutorType.
const (
	CommandActionExecutorTypeRego     CommandActionExecutorType = "rego"
	CommandActionExecutorTypeWorkflow CommandActionExecutorType = "workflow"
)

// Defines values for CommandActionTemplateType.
const (
	DevrevV1 CommandActionTemplateType = "devrev_v1"
)

// Defines values for CommandStatus.
const (
	CommandStatusDisabled CommandStatus = "disabled"
	CommandStatusDraft    CommandStatus = "draft"
	CommandStatusEnabled  CommandStatus = "enabled"
)

// Defines values for CommandSurfaceObjectTypes.
const (
	CommandSurfaceObjectTypesAccount         CommandSurfaceObjectTypes = "account"
	CommandSurfaceObjectTypesAiAssistantChat CommandSurfaceObjectTypes = "ai_assistant_chat"
	CommandSurfaceObjectTypesArticle         CommandSurfaceObjectTypes = "article"
	CommandSurfaceObjectTypesConversation    CommandSurfaceObjectTypes = "conversation"
	CommandSurfaceObjectTypesCustomObject    CommandSurfaceObjectTypes = "custom_object"
	CommandSurfaceObjectTypesDm              CommandSurfaceObjectTypes = "dm"
	CommandSurfaceObjectTypesEngagement      CommandSurfaceObjectTypes = "engagement"
	CommandSurfaceObjectTypesFlow            CommandSurfaceObjectTypes = "flow"
	CommandSurfaceObjectTypesIncident        CommandSurfaceObjectTypes = "incident"
	CommandSurfaceObjectTypesIssue           CommandSurfaceObjectTypes = "issue"
	CommandSurfaceObjectTypesOpportunity     CommandSurfaceObjectTypes = "opportunity"
	CommandSurfaceObjectTypesPart            CommandSurfaceObjectTypes = "part"
	CommandSurfaceObjectTypesRevOrg          CommandSurfaceObjectTypes = "rev_org"
	CommandSurfaceObjectTypesRevUser         CommandSurfaceObjectTypes = "rev_user"
	CommandSurfaceObjectTypesSnapIn          CommandSurfaceObjectTypes = "snap_in"
	CommandSurfaceObjectTypesTicket          CommandSurfaceObjectTypes = "ticket"
)

// Defines values for CommandSurfaceSurface.
const (
	CommandSurfaceSurfaceCustomerChat CommandSurfaceSurface = "customer_chat"
	CommandSurfaceSurfaceDiscussions  CommandSurfaceSurface = "discussions"
)

// Defines values for ConversationsCreateRequestTypeValue.
const (
	ConversationsCreateRequestTypeValueSupport ConversationsCreateRequestTypeValue = "support"
)

// Defines values for CustomSchemaFragmentFragmentType.
const (
	App        CustomSchemaFragmentFragmentType = "app"
	CustomType CustomSchemaFragmentFragmentType = "custom_type"
	Tenant     CustomSchemaFragmentFragmentType = "tenant"
)

// Defines values for CustomSchemaFragmentType.
const (
	CustomSchemaFragmentTypeAppFragment        CustomSchemaFragmentType = "app_fragment"
	CustomSchemaFragmentTypeCustomTypeFragment CustomSchemaFragmentType = "custom_type_fragment"
	CustomSchemaFragmentTypeTenantFragment     CustomSchemaFragmentType = "tenant_fragment"
)

// Defines values for CustomSchemaFragmentsListRequestPrune.
const (
	CustomSchemaFragmentsListRequestPruneFields CustomSchemaFragmentsListRequestPrune = "fields"
)

// Defines values for CustomSchemaFragmentsSetRequestType.
const (
	CustomSchemaFragmentsSetRequestTypeAppFragment        CustomSchemaFragmentsSetRequestType = "app_fragment"
	CustomSchemaFragmentsSetRequestTypeCustomTypeFragment CustomSchemaFragmentsSetRequestType = "custom_type_fragment"
	CustomSchemaFragmentsSetRequestTypeTenantFragment     CustomSchemaFragmentsSetRequestType = "tenant_fragment"
)

// Defines values for DateFilterType.
const (
	Preset DateFilterType = "preset"
	Range  DateFilterType = "range"
)

// Defines values for DateTimePresetType.
const (
	LastNDays DateTimePresetType = "last_n_days"
	NextNDays DateTimePresetType = "next_n_days"
)

// Defines values for Definedness.
const (
	Immutable Definedness = "immutable"
	Mutable   Definedness = "mutable"
	Undefined Definedness = "undefined"
)

// Defines values for DevOrgAuthConnectionsCreateRequestType.
const (
	DevOrgAuthConnectionsCreateRequestTypeGoogleApps DevOrgAuthConnectionsCreateRequestType = "google_apps"
	DevOrgAuthConnectionsCreateRequestTypeOidc       DevOrgAuthConnectionsCreateRequestType = "oidc"
	DevOrgAuthConnectionsCreateRequestTypeOkta       DevOrgAuthConnectionsCreateRequestType = "okta"
	DevOrgAuthConnectionsCreateRequestTypeSamlp      DevOrgAuthConnectionsCreateRequestType = "samlp"
	DevOrgAuthConnectionsCreateRequestTypeWaad       DevOrgAuthConnectionsCreateRequestType = "waad"
)

// Defines values for DevOrgAuthConnectionsUpdateRequestType.
const (
	GoogleApps DevOrgAuthConnectionsUpdateRequestType = "google_apps"
	None       DevOrgAuthConnectionsUpdateRequestType = "none"
	Oidc       DevOrgAuthConnectionsUpdateRequestType = "oidc"
	Okta       DevOrgAuthConnectionsUpdateRequestType = "okta"
	Samlp      DevOrgAuthConnectionsUpdateRequestType = "samlp"
	Waad       DevOrgAuthConnectionsUpdateRequestType = "waad"
)

// Defines values for DevUserJobTitle.
const (
	DevUserJobTitleCustomerSuccessManager DevUserJobTitle = "customer_success_manager"
	DevUserJobTitleCxo                    DevUserJobTitle = "cxo"
	DevUserJobTitleDesigner               DevUserJobTitle = "designer"
	DevUserJobTitleDeveloper              DevUserJobTitle = "developer"
	DevUserJobTitleHeadOfSupport          DevUserJobTitle = "head_of_support"
	DevUserJobTitleOperations             DevUserJobTitle = "operations"
	DevUserJobTitleOthers                 DevUserJobTitle = "others"
	DevUserJobTitleProductManager         DevUserJobTitle = "product_manager"
	DevUserJobTitleQa                     DevUserJobTitle = "qa"
	DevUserJobTitleRevenueLeader          DevUserJobTitle = "revenue_leader"
	DevUserJobTitleSupport                DevUserJobTitle = "support"
	DevUserJobTitleTechLead               DevUserJobTitle = "tech_lead"
)

// Defines values for DevUsersCreateRequestStateEnumValue.
const (
	DevUsersCreateRequestStateEnumValueShadow DevUsersCreateRequestStateEnumValue = "shadow"
)

// Defines values for EngagementType.
const (
	EngagementTypeCall         EngagementType = "call"
	EngagementTypeConversation EngagementType = "conversation"
	EngagementTypeCustom       EngagementType = "custom"
	EngagementTypeDefault      EngagementType = "default"
	EngagementTypeEmail        EngagementType = "email"
	EngagementTypeLinkedIn     EngagementType = "linked_in"
	EngagementTypeMeeting      EngagementType = "meeting"
	EngagementTypeOffline      EngagementType = "offline"
	EngagementTypeSurvey       EngagementType = "survey"
)

// Defines values for EngagementsCreateRequestEngagementType.
const (
	EngagementsCreateRequestEngagementTypeCall     EngagementsCreateRequestEngagementType = "call"
	EngagementsCreateRequestEngagementTypeDefault  EngagementsCreateRequestEngagementType = "default"
	EngagementsCreateRequestEngagementTypeEmail    EngagementsCreateRequestEngagementType = "email"
	EngagementsCreateRequestEngagementTypeLinkedIn EngagementsCreateRequestEngagementType = "linked_in"
	EngagementsCreateRequestEngagementTypeOffline  EngagementsCreateRequestEngagementType = "offline"
)

// Defines values for EnhancementRevScoreTier.
const (
	EnhancementRevScoreTierHigh   EnhancementRevScoreTier = "high"
	EnhancementRevScoreTierLow    EnhancementRevScoreTier = "low"
	EnhancementRevScoreTierMedium EnhancementRevScoreTier = "medium"
)

// Defines values for ErrorBadRequestCustomizationValidationErrorSubtype.
const (
	BadIdType            ErrorBadRequestCustomizationValidationErrorSubtype = "bad_id_type"
	DateParseError       ErrorBadRequestCustomizationValidationErrorSubtype = "date_parse_error"
	EnumOutOfRange       ErrorBadRequestCustomizationValidationErrorSubtype = "enum_out_of_range"
	ExpressionParseError ErrorBadRequestCustomizationValidationErrorSubtype = "expression_parse_error"
	FieldDropped         ErrorBadRequestCustomizationValidationErrorSubtype = "field_dropped"
	FieldImmutable       ErrorBadRequestCustomizationValidationErrorSubtype = "field_immutable"
	FieldNotInSchema     ErrorBadRequestCustomizationValidationErrorSubtype = "field_not_in_schema"
	FieldRequired        ErrorBadRequestCustomizationValidationErrorSubtype = "field_required"
	FragmentNotFound     ErrorBadRequestCustomizationValidationErrorSubtype = "fragment_not_found"
	IdParseError         ErrorBadRequestCustomizationValidationErrorSubtype = "id_parse_error"
	IdTypeNotAllowed     ErrorBadRequestCustomizationValidationErrorSubtype = "id_type_not_allowed"
	InvalidArgument      ErrorBadRequestCustomizationValidationErrorSubtype = "invalid_argument"
	TimestampParseError  ErrorBadRequestCustomizationValidationErrorSubtype = "timestamp_parse_error"
	UnknownError         ErrorBadRequestCustomizationValidationErrorSubtype = "unknown_error"
	UnsupportedType      ErrorBadRequestCustomizationValidationErrorSubtype = "unsupported_type"
	WrongType            ErrorBadRequestCustomizationValidationErrorSubtype = "wrong_type"
)

// Defines values for ErrorBadRequestMergeWorksErrorErrorSubtype.
const (
	AlreadyMerged           ErrorBadRequestMergeWorksErrorErrorSubtype = "already_merged"
	Closed                  ErrorBadRequestMergeWorksErrorErrorSubtype = "closed"
	DifferentReporters      ErrorBadRequestMergeWorksErrorErrorSubtype = "different_reporters"
	DifferentWorkspace      ErrorBadRequestMergeWorksErrorErrorSubtype = "different_workspace"
	InvalidStageTransition  ErrorBadRequestMergeWorksErrorErrorSubtype = "invalid_stage_transition"
	Locked                  ErrorBadRequestMergeWorksErrorErrorSubtype = "locked"
	StageNotFoundForSubtype ErrorBadRequestMergeWorksErrorErrorSubtype = "stage_not_found_for_subtype"
)

// Defines values for ErrorBadRequestType.
const (
	ErrorBadRequestTypeArtifactAlreadyAttachedToAParent  ErrorBadRequestType = "artifact_already_attached_to_a_parent"
	ErrorBadRequestTypeBadRequest                        ErrorBadRequestType = "bad_request"
	ErrorBadRequestTypeCustomizationValidationError      ErrorBadRequestType = "customization_validation_error"
	ErrorBadRequestTypeInvalidApiVersion                 ErrorBadRequestType = "invalid_api_version"
	ErrorBadRequestTypeInvalidEnumValue                  ErrorBadRequestType = "invalid_enum_value"
	ErrorBadRequestTypeInvalidField                      ErrorBadRequestType = "invalid_field"
	ErrorBadRequestTypeInvalidId                         ErrorBadRequestType = "invalid_id"
	ErrorBadRequestTypeMergeWorksError                   ErrorBadRequestType = "merge_works_error"
	ErrorBadRequestTypeMissingDependency                 ErrorBadRequestType = "missing_dependency"
	ErrorBadRequestTypeMissingRequiredField              ErrorBadRequestType = "missing_required_field"
	ErrorBadRequestTypeParseError                        ErrorBadRequestType = "parse_error"
	ErrorBadRequestTypeStaleSchemaFragments              ErrorBadRequestType = "stale_schema_fragments"
	ErrorBadRequestTypeUnexpectedIdType                  ErrorBadRequestType = "unexpected_id_type"
	ErrorBadRequestTypeUnexpectedJsonType                ErrorBadRequestType = "unexpected_json_type"
	ErrorBadRequestTypeValueNotPermitted                 ErrorBadRequestType = "value_not_permitted"
	ErrorBadRequestTypeWorkflowComponentValidationErrors ErrorBadRequestType = "workflow_component_validation_errors"
)

// Defines values for ErrorBadRequestUnexpectedJsonTypeType.
const (
	ErrorBadRequestUnexpectedJsonTypeTypeArray  ErrorBadRequestUnexpectedJsonTypeType = "array"
	ErrorBadRequestUnexpectedJsonTypeTypeBool   ErrorBadRequestUnexpectedJsonTypeType = "bool"
	ErrorBadRequestUnexpectedJsonTypeTypeNull   ErrorBadRequestUnexpectedJsonTypeType = "null"
	ErrorBadRequestUnexpectedJsonTypeTypeNumber ErrorBadRequestUnexpectedJsonTypeType = "number"
	ErrorBadRequestUnexpectedJsonTypeTypeObject ErrorBadRequestUnexpectedJsonTypeType = "object"
	ErrorBadRequestUnexpectedJsonTypeTypeString ErrorBadRequestUnexpectedJsonTypeType = "string"
)

// Defines values for ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType.
const (
	ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationTypeField        ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType = "field"
	ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationTypeOperation    ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType = "operation"
	ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationTypeWorkflow     ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType = "workflow"
	ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationTypeWorkflowStep ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType = "workflow_step"
)

// Defines values for ErrorConflictType.
const (
	ErrorConflictTypeConflict ErrorConflictType = "conflict"
)

// Defines values for ErrorForbiddenType.
const (
	ErrorForbiddenTypeForbidden ErrorForbiddenType = "forbidden"
)

// Defines values for ErrorInternalServerErrorType.
const (
	InternalError ErrorInternalServerErrorType = "internal_error"
)

// Defines values for ErrorNotFoundType.
const (
	ErrorNotFoundTypeNotFound ErrorNotFoundType = "not_found"
)

// Defines values for ErrorServiceUnavailableType.
const (
	ErrorServiceUnavailableTypeServiceUnavailable ErrorServiceUnavailableType = "service_unavailable"
)

// Defines values for ErrorTooManyRequestsType.
const (
	ErrorTooManyRequestsTypeTooManyRequests ErrorTooManyRequestsType = "too_many_requests"
)

// Defines values for ErrorUnauthorizedType.
const (
	Unauthenticated ErrorUnauthorizedType = "unauthenticated"
)

// Defines values for EventAiAgentResponseAgentResponse.
const (
	EventAiAgentResponseAgentResponseError                    EventAiAgentResponseAgentResponse = "error"
	EventAiAgentResponseAgentResponseMessage                  EventAiAgentResponseAgentResponse = "message"
	EventAiAgentResponseAgentResponseMessageGenerationStarted EventAiAgentResponseAgentResponse = "message_generation_started"
	EventAiAgentResponseAgentResponseProgress                 EventAiAgentResponseAgentResponse = "progress"
	EventAiAgentResponseAgentResponseSuggestions              EventAiAgentResponseAgentResponse = "suggestions"
)

// Defines values for EventFetchedResult.
const (
	EventFetchedResultForbidden EventFetchedResult = "forbidden"
	EventFetchedResultNotFound  EventFetchedResult = "not_found"
	EventFetchedResultOk        EventFetchedResult = "ok"
)

// Defines values for EventSourceStatus.
const (
	EventSourceStatusActive  EventSourceStatus = "active"
	EventSourceStatusBlocked EventSourceStatus = "blocked"
	EventSourceStatusPaused  EventSourceStatus = "paused"
)

// Defines values for EventTimelineEntryUpdatedReactionAction.
const (
	Added   EventTimelineEntryUpdatedReactionAction = "added"
	Removed EventTimelineEntryUpdatedReactionAction = "removed"
)

// Defines values for ExternalSystemType.
const (
	ExternalSystemTypeAdaas             ExternalSystemType = "adaas"
	ExternalSystemTypeConfluence        ExternalSystemType = "confluence"
	ExternalSystemTypeGithub            ExternalSystemType = "github"
	ExternalSystemTypeHubspot           ExternalSystemType = "hubspot"
	ExternalSystemTypeJira              ExternalSystemType = "jira"
	ExternalSystemTypeLinear            ExternalSystemType = "linear"
	ExternalSystemTypeRocketlane        ExternalSystemType = "rocketlane"
	ExternalSystemTypeSalesforceSales   ExternalSystemType = "salesforce_sales"
	ExternalSystemTypeSalesforceService ExternalSystemType = "salesforce_service"
	ExternalSystemTypeServicenow        ExternalSystemType = "servicenow"
	ExternalSystemTypeZendesk           ExternalSystemType = "zendesk"
)

// Defines values for FieldValueType.
const (
	FieldValueTypeBool           FieldValueType = "bool"
	FieldValueTypeBoolList       FieldValueType = "bool_list"
	FieldValueTypeComposite      FieldValueType = "composite"
	FieldValueTypeCompositeList  FieldValueType = "composite_list"
	FieldValueTypeDate           FieldValueType = "date"
	FieldValueTypeDateList       FieldValueType = "date_list"
	FieldValueTypeDateTime       FieldValueType = "date_time"
	FieldValueTypeDateTimeList   FieldValueType = "date_time_list"
	FieldValueTypeDouble         FieldValueType = "double"
	FieldValueTypeDoubleList     FieldValueType = "double_list"
	FieldValueTypeId             FieldValueType = "id"
	FieldValueTypeIdList         FieldValueType = "id_list"
	FieldValueTypeInt            FieldValueType = "int"
	FieldValueTypeIntList        FieldValueType = "int_list"
	FieldValueTypeStage          FieldValueType = "stage"
	FieldValueTypeString         FieldValueType = "string"
	FieldValueTypeStringList     FieldValueType = "string_list"
	FieldValueTypeTagSummary     FieldValueType = "tag_summary"
	FieldValueTypeTagSummaryList FieldValueType = "tag_summary_list"
)

// Defines values for GenericNotificationEventType.
const (
	GenericNotificationEventTypeAlert      GenericNotificationEventType = "alert"
	GenericNotificationEventTypeAssignment GenericNotificationEventType = "assignment"
	GenericNotificationEventTypeMention    GenericNotificationEventType = "mention"
	GenericNotificationEventTypeReminder   GenericNotificationEventType = "reminder"
	GenericNotificationEventTypeUpdate     GenericNotificationEventType = "update"
)

// Defines values for GroupIngestionSource.
const (
	Airdrop GroupIngestionSource = "airdrop"
	Scim    GroupIngestionSource = "scim"
)

// Defines values for GroupMemberType.
const (
	GroupMemberTypeDevUser GroupMemberType = "dev_user"
	GroupMemberTypeRevUser GroupMemberType = "rev_user"
)

// Defines values for GroupType.
const (
	GroupTypeDynamic GroupType = "dynamic"
	GroupTypeStatic  GroupType = "static"
)

// Defines values for GroupedVistaFlavor.
const (
	Nnl          GroupedVistaFlavor = "nnl"
	SprintBoard  GroupedVistaFlavor = "sprint_board"
	SupportInbox GroupedVistaFlavor = "support_inbox"
)

// Defines values for IssuePriority.
const (
	IssuePriorityP0 IssuePriority = "p0"
	IssuePriorityP1 IssuePriority = "p1"
	IssuePriorityP2 IssuePriority = "p2"
	IssuePriorityP3 IssuePriority = "p3"
)

// Defines values for KanbanVisualizationCardAttributePosition.
const (
	Body   KanbanVisualizationCardAttributePosition = "body"
	Footer KanbanVisualizationCardAttributePosition = "footer"
)

// Defines values for LinkEndpointType.
const (
	LinkEndpointTypeAccount      LinkEndpointType = "account"
	LinkEndpointTypeCapability   LinkEndpointType = "capability"
	LinkEndpointTypeCodeChange   LinkEndpointType = "code_change"
	LinkEndpointTypeConversation LinkEndpointType = "conversation"
	LinkEndpointTypeCustomObject LinkEndpointType = "custom_object"
	LinkEndpointTypeDevUser      LinkEndpointType = "dev_user"
	LinkEndpointTypeEnhancement  LinkEndpointType = "enhancement"
	LinkEndpointTypeFeature      LinkEndpointType = "feature"
	LinkEndpointTypeIncident     LinkEndpointType = "incident"
	LinkEndpointTypeIssue        LinkEndpointType = "issue"
	LinkEndpointTypeLinkable     LinkEndpointType = "linkable"
	LinkEndpointTypeMeeting      LinkEndpointType = "meeting"
	LinkEndpointTypeOpportunity  LinkEndpointType = "opportunity"
	LinkEndpointTypeProduct      LinkEndpointType = "product"
	LinkEndpointTypeRevOrg       LinkEndpointType = "rev_org"
	LinkEndpointTypeRevUser      LinkEndpointType = "rev_user"
	LinkEndpointTypeRunnable     LinkEndpointType = "runnable"
	LinkEndpointTypeTask         LinkEndpointType = "task"
	LinkEndpointTypeTicket       LinkEndpointType = "ticket"
	LinkEndpointTypeWidget       LinkEndpointType = "widget"
)

// Defines values for LinkType.
const (
	CustomLink    LinkType = "custom_link"
	DevelopedWith LinkType = "developed_with"
	Imports       LinkType = "imports"
	IsAnalyzedBy  LinkType = "is_analyzed_by"
	IsConvertedTo LinkType = "is_converted_to"
	IsDependentOn LinkType = "is_dependent_on"
	IsDuplicateOf LinkType = "is_duplicate_of"
	IsFollowUpOf  LinkType = "is_follow_up_of"
	IsMergedInto  LinkType = "is_merged_into"
	IsParentOf    LinkType = "is_parent_of"
	IsPartOf      LinkType = "is_part_of"
	IsRelatedTo   LinkType = "is_related_to"
	Serves        LinkType = "serves"
)

// Defines values for LinksDirection.
const (
	IsSource LinksDirection = "is_source"
	IsTarget LinksDirection = "is_target"
)

// Defines values for ListMode.
const (
	After  ListMode = "after"
	Before ListMode = "before"
)

// Defines values for MeerkatWidgetColumnFunctionType.
const (
	MeerkatWidgetColumnFunctionTypeAvg           MeerkatWidgetColumnFunctionType = "avg"
	MeerkatWidgetColumnFunctionTypeCount         MeerkatWidgetColumnFunctionType = "count"
	MeerkatWidgetColumnFunctionTypeCountDistinct MeerkatWidgetColumnFunctionType = "count_distinct"
	MeerkatWidgetColumnFunctionTypeMax           MeerkatWidgetColumnFunctionType = "max"
	MeerkatWidgetColumnFunctionTypeMedian        MeerkatWidgetColumnFunctionType = "median"
	MeerkatWidgetColumnFunctionTypeMin           MeerkatWidgetColumnFunctionType = "min"
	MeerkatWidgetColumnFunctionTypeSum           MeerkatWidgetColumnFunctionType = "sum"
)

// Defines values for MeerkatWidgetColumnProjectionTimestampRollup.
const (
	Day   MeerkatWidgetColumnProjectionTimestampRollup = "day"
	Hour  MeerkatWidgetColumnProjectionTimestampRollup = "hour"
	Month MeerkatWidgetColumnProjectionTimestampRollup = "month"
	Week  MeerkatWidgetColumnProjectionTimestampRollup = "week"
	Year  MeerkatWidgetColumnProjectionTimestampRollup = "year"
)

// Defines values for MeerkatWidgetColumnProjectionType.
const (
	MeerkatWidgetColumnProjectionTypeBoolean     MeerkatWidgetColumnProjectionType = "boolean"
	MeerkatWidgetColumnProjectionTypeNumber      MeerkatWidgetColumnProjectionType = "number"
	MeerkatWidgetColumnProjectionTypeNumberArray MeerkatWidgetColumnProjectionType = "number_array"
	MeerkatWidgetColumnProjectionTypeString      MeerkatWidgetColumnProjectionType = "string"
	MeerkatWidgetColumnProjectionTypeStringArray MeerkatWidgetColumnProjectionType = "string_array"
	MeerkatWidgetColumnProjectionTypeTime        MeerkatWidgetColumnProjectionType = "time"
)

// Defines values for MeetingChannel.
const (
	MeetingChannelAmazonConnect MeetingChannel = "amazon_connect"
	MeetingChannelGoogleMeet    MeetingChannel = "google_meet"
	MeetingChannelOffline       MeetingChannel = "offline"
	MeetingChannelOther         MeetingChannel = "other"
	MeetingChannelTeams         MeetingChannel = "teams"
	MeetingChannelZoom          MeetingChannel = "zoom"
)

// Defines values for MeetingState.
const (
	MeetingStateCanceled    MeetingState = "canceled"
	MeetingStateCompleted   MeetingState = "completed"
	MeetingStateNoShow      MeetingState = "no_show"
	MeetingStateOngoing     MeetingState = "ongoing"
	MeetingStateRejected    MeetingState = "rejected"
	MeetingStateRescheduled MeetingState = "rescheduled"
	MeetingStateScheduled   MeetingState = "scheduled"
	MeetingStateWaiting     MeetingState = "waiting"
)

// Defines values for MemberType.
const (
	MemberTypeDevUser MemberType = "dev_user"
	MemberTypeGroup   MemberType = "group"
	MemberTypeRevUser MemberType = "rev_user"
	MemberTypeSysUser MemberType = "sys_user"
)

// Defines values for MetricActionExecuteRequestAction.
const (
	MetricActionExecuteRequestActionComplete MetricActionExecuteRequestAction = "complete"
	MetricActionExecuteRequestActionPause    MetricActionExecuteRequestAction = "pause"
	MetricActionExecuteRequestActionRestart  MetricActionExecuteRequestAction = "restart"
	MetricActionExecuteRequestActionResume   MetricActionExecuteRequestAction = "resume"
	MetricActionExecuteRequestActionStart    MetricActionExecuteRequestAction = "start"
)

// Defines values for MetricDefinitionAppliesTo.
const (
	MetricDefinitionAppliesToConversation MetricDefinitionAppliesTo = "conversation"
	MetricDefinitionAppliesToIssue        MetricDefinitionAppliesTo = "issue"
	MetricDefinitionAppliesToTicket       MetricDefinitionAppliesTo = "ticket"
)

// Defines values for MetricDefinitionMetricType.
const (
	MetricDefinitionMetricTypeTime  MetricDefinitionMetricType = "time"
	MetricDefinitionMetricTypeValue MetricDefinitionMetricType = "value"
)

// Defines values for MetricDefinitionStatus.
const (
	MetricDefinitionStatusActive   MetricDefinitionStatus = "active"
	MetricDefinitionStatusInactive MetricDefinitionStatus = "inactive"
)

// Defines values for OpportunityForecastCategory.
const (
	Commit       OpportunityForecastCategory = "commit"
	Omitted      OpportunityForecastCategory = "omitted"
	Pipeline     OpportunityForecastCategory = "pipeline"
	StrongUpside OpportunityForecastCategory = "strong_upside"
	Upside       OpportunityForecastCategory = "upside"
	Won          OpportunityForecastCategory = "won"
)

// Defines values for OpportunityPriority.
const (
	OpportunityPriorityP0 OpportunityPriority = "p0"
	OpportunityPriorityP1 OpportunityPriority = "p1"
	OpportunityPriorityP2 OpportunityPriority = "p2"
	OpportunityPriorityP3 OpportunityPriority = "p3"
)

// Defines values for OrgEnvironment.
const (
	Production OrgEnvironment = "production"
	Staging    OrgEnvironment = "staging"
	Test       OrgEnvironment = "test"
)

// Defines values for OrgScheduleFragmentStatus.
const (
	OrgScheduleFragmentStatusArchived  OrgScheduleFragmentStatus = "archived"
	OrgScheduleFragmentStatusDraft     OrgScheduleFragmentStatus = "draft"
	OrgScheduleFragmentStatusPublished OrgScheduleFragmentStatus = "published"
)

// Defines values for OrgScheduleStatus.
const (
	OrgScheduleStatusArchived  OrgScheduleStatus = "archived"
	OrgScheduleStatusDraft     OrgScheduleStatus = "draft"
	OrgScheduleStatusPublished OrgScheduleStatus = "published"
)

// Defines values for OrgType.
const (
	OrgTypeAccount OrgType = "account"
	OrgTypeDevOrg  OrgType = "dev_org"
	OrgTypeRevOrg  OrgType = "rev_org"
)

// Defines values for PartType.
const (
	PartTypeCapability  PartType = "capability"
	PartTypeEnhancement PartType = "enhancement"
	PartTypeFeature     PartType = "feature"
	PartTypeLinkable    PartType = "linkable"
	PartTypeProduct     PartType = "product"
	PartTypeRunnable    PartType = "runnable"
)

// Defines values for PreferencesType.
const (
	PreferencesTypeUserPreferences PreferencesType = "user_preferences"
)

// Defines values for QuestionAnswerStatus.
const (
	QuestionAnswerStatusArchived     QuestionAnswerStatus = "archived"
	QuestionAnswerStatusDiscarded    QuestionAnswerStatus = "discarded"
	QuestionAnswerStatusDraft        QuestionAnswerStatus = "draft"
	QuestionAnswerStatusPublished    QuestionAnswerStatus = "published"
	QuestionAnswerStatusReviewNeeded QuestionAnswerStatus = "review_needed"
)

// Defines values for ReactionsUpdateRequestAction.
const (
	Add    ReactionsUpdateRequestAction = "add"
	Remove ReactionsUpdateRequestAction = "remove"
)

// Defines values for RecordTemplateState.
const (
	RecordTemplateStateActive         RecordTemplateState = "active"
	RecordTemplateStateDraft          RecordTemplateState = "draft"
	RecordTemplateStateInactive       RecordTemplateState = "inactive"
	RecordTemplateStateNeedsAttention RecordTemplateState = "needs_attention"
)

// Defines values for RolePrivileges.
const (
	RolePrivilegesCreate  RolePrivileges = "create"
	RolePrivilegesDelete  RolePrivileges = "delete"
	RolePrivilegesExecute RolePrivileges = "execute"
	RolePrivilegesRead    RolePrivileges = "read"
	RolePrivilegesUpdate  RolePrivileges = "update"
)

// Defines values for RoleTarget.
const (
	RoleTargetArticle      RoleTarget = "article"
	RoleTargetArtifact     RoleTarget = "artifact"
	RoleTargetCapability   RoleTarget = "capability"
	RoleTargetConversation RoleTarget = "conversation"
	RoleTargetDevUser      RoleTarget = "dev_user"
	RoleTargetFeature      RoleTarget = "feature"
	RoleTargetGroup        RoleTarget = "group"
	RoleTargetIssue        RoleTarget = "issue"
	RoleTargetLinkable     RoleTarget = "linkable"
	RoleTargetMeeting      RoleTarget = "meeting"
	RoleTargetOpportunity  RoleTarget = "opportunity"
	RoleTargetProduct      RoleTarget = "product"
	RoleTargetRevUser      RoleTarget = "rev_user"
	RoleTargetRunnable     RoleTarget = "runnable"
	RoleTargetTicket       RoleTarget = "ticket"
)

// Defines values for SchemaFieldDescriptorArrayTypeBaseType.
const (
	SchemaFieldDescriptorArrayTypeBaseTypeBool      SchemaFieldDescriptorArrayTypeBaseType = "bool"
	SchemaFieldDescriptorArrayTypeBaseTypeComposite SchemaFieldDescriptorArrayTypeBaseType = "composite"
	SchemaFieldDescriptorArrayTypeBaseTypeDate      SchemaFieldDescriptorArrayTypeBaseType = "date"
	SchemaFieldDescriptorArrayTypeBaseTypeDouble    SchemaFieldDescriptorArrayTypeBaseType = "double"
	SchemaFieldDescriptorArrayTypeBaseTypeEnum      SchemaFieldDescriptorArrayTypeBaseType = "enum"
	SchemaFieldDescriptorArrayTypeBaseTypeId        SchemaFieldDescriptorArrayTypeBaseType = "id"
	SchemaFieldDescriptorArrayTypeBaseTypeInt       SchemaFieldDescriptorArrayTypeBaseType = "int"
	SchemaFieldDescriptorArrayTypeBaseTypeJsonValue SchemaFieldDescriptorArrayTypeBaseType = "json_value"
	SchemaFieldDescriptorArrayTypeBaseTypeRichText  SchemaFieldDescriptorArrayTypeBaseType = "rich_text"
	SchemaFieldDescriptorArrayTypeBaseTypeStruct    SchemaFieldDescriptorArrayTypeBaseType = "struct"
	SchemaFieldDescriptorArrayTypeBaseTypeText      SchemaFieldDescriptorArrayTypeBaseType = "text"
	SchemaFieldDescriptorArrayTypeBaseTypeTimestamp SchemaFieldDescriptorArrayTypeBaseType = "timestamp"
	SchemaFieldDescriptorArrayTypeBaseTypeTokens    SchemaFieldDescriptorArrayTypeBaseType = "tokens"
	SchemaFieldDescriptorArrayTypeBaseTypeUenum     SchemaFieldDescriptorArrayTypeBaseType = "uenum"
)

// Defines values for SchemaFieldDescriptorFieldType.
const (
	SchemaFieldDescriptorFieldTypeArray     SchemaFieldDescriptorFieldType = "array"
	SchemaFieldDescriptorFieldTypeBool      SchemaFieldDescriptorFieldType = "bool"
	SchemaFieldDescriptorFieldTypeComposite SchemaFieldDescriptorFieldType = "composite"
	SchemaFieldDescriptorFieldTypeDate      SchemaFieldDescriptorFieldType = "date"
	SchemaFieldDescriptorFieldTypeDouble    SchemaFieldDescriptorFieldType = "double"
	SchemaFieldDescriptorFieldTypeEnum      SchemaFieldDescriptorFieldType = "enum"
	SchemaFieldDescriptorFieldTypeId        SchemaFieldDescriptorFieldType = "id"
	SchemaFieldDescriptorFieldTypeInt       SchemaFieldDescriptorFieldType = "int"
	SchemaFieldDescriptorFieldTypeJsonValue SchemaFieldDescriptorFieldType = "json_value"
	SchemaFieldDescriptorFieldTypeRichText  SchemaFieldDescriptorFieldType = "rich_text"
	SchemaFieldDescriptorFieldTypeStruct    SchemaFieldDescriptorFieldType = "struct"
	SchemaFieldDescriptorFieldTypeText      SchemaFieldDescriptorFieldType = "text"
	SchemaFieldDescriptorFieldTypeTimestamp SchemaFieldDescriptorFieldType = "timestamp"
	SchemaFieldDescriptorFieldTypeTokens    SchemaFieldDescriptorFieldType = "tokens"
	SchemaFieldDescriptorFieldTypeUenum     SchemaFieldDescriptorFieldType = "uenum"
	SchemaFieldDescriptorFieldTypeUnknown   SchemaFieldDescriptorFieldType = "unknown"
)

// Defines values for SchemasSubtypePrepareUpdateGetResponseConflictType.
const (
	AbsentInNew      SchemasSubtypePrepareUpdateGetResponseConflictType = "absent_in_new"
	AbsentInOld      SchemasSubtypePrepareUpdateGetResponseConflictType = "absent_in_old"
	IncompatibleType SchemasSubtypePrepareUpdateGetResponseConflictType = "incompatible_type"
)

// Defines values for SearchHybridNamespace.
const (
	SearchHybridNamespaceAccount        SearchHybridNamespace = "account"
	SearchHybridNamespaceArticle        SearchHybridNamespace = "article"
	SearchHybridNamespaceCapability     SearchHybridNamespace = "capability"
	SearchHybridNamespaceComponent      SearchHybridNamespace = "component"
	SearchHybridNamespaceConversation   SearchHybridNamespace = "conversation"
	SearchHybridNamespaceCustomObject   SearchHybridNamespace = "custom_object"
	SearchHybridNamespaceCustomPart     SearchHybridNamespace = "custom_part"
	SearchHybridNamespaceCustomWork     SearchHybridNamespace = "custom_work"
	SearchHybridNamespaceDashboard      SearchHybridNamespace = "dashboard"
	SearchHybridNamespaceDataset        SearchHybridNamespace = "dataset"
	SearchHybridNamespaceDevUser        SearchHybridNamespace = "dev_user"
	SearchHybridNamespaceEnhancement    SearchHybridNamespace = "enhancement"
	SearchHybridNamespaceFeature        SearchHybridNamespace = "feature"
	SearchHybridNamespaceGroup          SearchHybridNamespace = "group"
	SearchHybridNamespaceIncident       SearchHybridNamespace = "incident"
	SearchHybridNamespaceIssue          SearchHybridNamespace = "issue"
	SearchHybridNamespaceLinkable       SearchHybridNamespace = "linkable"
	SearchHybridNamespaceMicroservice   SearchHybridNamespace = "microservice"
	SearchHybridNamespaceObjectMember   SearchHybridNamespace = "object_member"
	SearchHybridNamespaceOpportunity    SearchHybridNamespace = "opportunity"
	SearchHybridNamespacePart           SearchHybridNamespace = "part"
	SearchHybridNamespaceProduct        SearchHybridNamespace = "product"
	SearchHybridNamespaceProject        SearchHybridNamespace = "project"
	SearchHybridNamespaceQuestionAnswer SearchHybridNamespace = "question_answer"
	SearchHybridNamespaceRevOrg         SearchHybridNamespace = "rev_org"
	SearchHybridNamespaceRevUser        SearchHybridNamespace = "rev_user"
	SearchHybridNamespaceRunnable       SearchHybridNamespace = "runnable"
	SearchHybridNamespaceServiceAccount SearchHybridNamespace = "service_account"
	SearchHybridNamespaceSysUser        SearchHybridNamespace = "sys_user"
	SearchHybridNamespaceTag            SearchHybridNamespace = "tag"
	SearchHybridNamespaceTask           SearchHybridNamespace = "task"
	SearchHybridNamespaceTicket         SearchHybridNamespace = "ticket"
	SearchHybridNamespaceVista          SearchHybridNamespace = "vista"
	SearchHybridNamespaceWidget         SearchHybridNamespace = "widget"
	SearchHybridNamespaceWork           SearchHybridNamespace = "work"
)

// Defines values for SearchNamespace.
const (
	SearchNamespaceAccount        SearchNamespace = "account"
	SearchNamespaceArticle        SearchNamespace = "article"
	SearchNamespaceCapability     SearchNamespace = "capability"
	SearchNamespaceComponent      SearchNamespace = "component"
	SearchNamespaceConversation   SearchNamespace = "conversation"
	SearchNamespaceCustomObject   SearchNamespace = "custom_object"
	SearchNamespaceCustomPart     SearchNamespace = "custom_part"
	SearchNamespaceCustomWork     SearchNamespace = "custom_work"
	SearchNamespaceDashboard      SearchNamespace = "dashboard"
	SearchNamespaceDevUser        SearchNamespace = "dev_user"
	SearchNamespaceEnhancement    SearchNamespace = "enhancement"
	SearchNamespaceFeature        SearchNamespace = "feature"
	SearchNamespaceGroup          SearchNamespace = "group"
	SearchNamespaceIssue          SearchNamespace = "issue"
	SearchNamespaceLinkable       SearchNamespace = "linkable"
	SearchNamespaceMicroservice   SearchNamespace = "microservice"
	SearchNamespaceObjectMember   SearchNamespace = "object_member"
	SearchNamespaceOperation      SearchNamespace = "operation"
	SearchNamespaceOpportunity    SearchNamespace = "opportunity"
	SearchNamespaceProduct        SearchNamespace = "product"
	SearchNamespaceProject        SearchNamespace = "project"
	SearchNamespaceQuestionAnswer SearchNamespace = "question_answer"
	SearchNamespaceRevOrg         SearchNamespace = "rev_org"
	SearchNamespaceRevUser        SearchNamespace = "rev_user"
	SearchNamespaceRunnable       SearchNamespace = "runnable"
	SearchNamespaceServiceAccount SearchNamespace = "service_account"
	SearchNamespaceSysUser        SearchNamespace = "sys_user"
	SearchNamespaceTag            SearchNamespace = "tag"
	SearchNamespaceTask           SearchNamespace = "task"
	SearchNamespaceTicket         SearchNamespace = "ticket"
	SearchNamespaceVista          SearchNamespace = "vista"
	SearchNamespaceWorkflow       SearchNamespace = "workflow"
)

// Defines values for SearchResultType.
const (
	SearchResultTypeAccount        SearchResultType = "account"
	SearchResultTypeArticle        SearchResultType = "article"
	SearchResultTypeArtifact       SearchResultType = "artifact"
	SearchResultTypeConversation   SearchResultType = "conversation"
	SearchResultTypeCustomObject   SearchResultType = "custom_object"
	SearchResultTypeDashboard      SearchResultType = "dashboard"
	SearchResultTypeGroup          SearchResultType = "group"
	SearchResultTypeLink           SearchResultType = "link"
	SearchResultTypeObjectMember   SearchResultType = "object_member"
	SearchResultTypeOperation      SearchResultType = "operation"
	SearchResultTypeOrg            SearchResultType = "org"
	SearchResultTypePart           SearchResultType = "part"
	SearchResultTypeQuestionAnswer SearchResultType = "question_answer"
	SearchResultTypeTag            SearchResultType = "tag"
	SearchResultTypeUser           SearchResultType = "user"
	SearchResultTypeVista          SearchResultType = "vista"
	SearchResultTypeWork           SearchResultType = "work"
	SearchResultTypeWorkflow       SearchResultType = "workflow"
)

// Defines values for SearchSortByParam.
const (
	CreatedDate  SearchSortByParam = "created_date"
	ModifiedDate SearchSortByParam = "modified_date"
	Relevance    SearchSortByParam = "relevance"
)

// Defines values for SearchSortOrderParam.
const (
	Asc  SearchSortOrderParam = "asc"
	Desc SearchSortOrderParam = "desc"
)

// Defines values for SendNotificationGenericNotificationEntryNotificationActionType.
const (
	ClickableAction SendNotificationGenericNotificationEntryNotificationActionType = "clickable_action"
)

// Defines values for SendNotificationGenericNotificationEntryNotificationActionClickableActionType.
const (
	Object SendNotificationGenericNotificationEntryNotificationActionClickableActionType = "object"
	Url    SendNotificationGenericNotificationEntryNotificationActionClickableActionType = "url"
)

// Defines values for SendNotificationType.
const (
	GenericNotification SendNotificationType = "generic_notification"
)

// Defines values for SlaAppliesTo.
const (
	SlaAppliesToConversation SlaAppliesTo = "conversation"
	SlaAppliesToIssue        SlaAppliesTo = "issue"
	SlaAppliesToTicket       SlaAppliesTo = "ticket"
)

// Defines values for SlaEvaluationPeriod.
const (
	Monthly   SlaEvaluationPeriod = "monthly"
	Quarterly SlaEvaluationPeriod = "quarterly"
	Weekly    SlaEvaluationPeriod = "weekly"
	Yearly    SlaEvaluationPeriod = "yearly"
)

// Defines values for SlaSelectorAppliesTo.
const (
	SlaSelectorAppliesToConversation SlaSelectorAppliesTo = "conversation"
	SlaSelectorAppliesToIssue        SlaSelectorAppliesTo = "issue"
	SlaSelectorAppliesToTicket       SlaSelectorAppliesTo = "ticket"
)

// Defines values for SlaSelectorPriority.
const (
	SlaSelectorPriorityP0 SlaSelectorPriority = "p0"
	SlaSelectorPriorityP1 SlaSelectorPriority = "p1"
	SlaSelectorPriorityP2 SlaSelectorPriority = "p2"
)

// Defines values for SlaSelectorSeverity.
const (
	SlaSelectorSeverityBlocker SlaSelectorSeverity = "blocker"
	SlaSelectorSeverityHigh    SlaSelectorSeverity = "high"
	SlaSelectorSeverityLow     SlaSelectorSeverity = "low"
	SlaSelectorSeverityMedium  SlaSelectorSeverity = "medium"
)

// Defines values for SlaStatus.
const (
	SlaStatusArchived  SlaStatus = "archived"
	SlaStatusDraft     SlaStatus = "draft"
	SlaStatusPublished SlaStatus = "published"
)

// Defines values for SlaSummaryStage.
const (
	SlaSummaryStageBreached  SlaSummaryStage = "breached"
	SlaSummaryStageCompleted SlaSummaryStage = "completed"
	SlaSummaryStagePaused    SlaSummaryStage = "paused"
	SlaSummaryStageRunning   SlaSummaryStage = "running"
	SlaSummaryStageWarning   SlaSummaryStage = "warning"
)

// Defines values for SlaTrackerAppliesToType.
const (
	SlaTrackerAppliesToTypeConversation SlaTrackerAppliesToType = "conversation"
	SlaTrackerAppliesToTypeIssue        SlaTrackerAppliesToType = "issue"
	SlaTrackerAppliesToTypeTicket       SlaTrackerAppliesToType = "ticket"
)

// Defines values for SlaType.
const (
	SlaTypeExternal SlaType = "external"
	SlaTypeInternal SlaType = "internal"
)

// Defines values for SlasFilterAppliesToOperatorType.
const (
	All SlasFilterAppliesToOperatorType = "all"
	Any SlasFilterAppliesToOperatorType = "any"
)

// Defines values for SnapKitActionRequestElementTypeValue.
const (
	Button SnapKitActionRequestElementTypeValue = "button"
	Form   SnapKitActionRequestElementTypeValue = "form"
)

// Defines values for SnapWidgetClickInteractionClickAction.
const (
	OpenPlugWidget    SnapWidgetClickInteractionClickAction = "open_plug_widget"
	OpenUrl           SnapWidgetClickInteractionClickAction = "open_url"
	StartConversation SnapWidgetClickInteractionClickAction = "start_conversation"
)

// Defines values for SnapWidgetInteractionType.
const (
	Click      SnapWidgetInteractionType = "click"
	EmailInput SnapWidgetInteractionType = "email_input"
)

// Defines values for SnapWidgetNamespace.
const (
	SnapWidgetNamespaceAiAssistantMessage       SnapWidgetNamespace = "ai_assistant_message"
	SnapWidgetNamespaceCommentSuggestionReplies SnapWidgetNamespace = "comment_suggestion_replies"
	SnapWidgetNamespaceEmailPreview             SnapWidgetNamespace = "email_preview"
	SnapWidgetNamespaceLinkPreview              SnapWidgetNamespace = "link_preview"
	SnapWidgetNamespaceMeetingPreview           SnapWidgetNamespace = "meeting_preview"
	SnapWidgetNamespacePlugNudge                SnapWidgetNamespace = "plug_nudge"
)

// Defines values for SnapWidgetStatus.
const (
	Draft     SnapWidgetStatus = "draft"
	Published SnapWidgetStatus = "published"
)

// Defines values for SnapWidgetType.
const (
	SnapWidgetTypeEmailPreview        SnapWidgetType = "email_preview"
	SnapWidgetTypeStarterMessageNudge SnapWidgetType = "starter_message_nudge"
)

// Defines values for SnapWidgetsCreateRequestType.
const (
	EmailPreview        SnapWidgetsCreateRequestType = "email_preview"
	StarterMessageNudge SnapWidgetsCreateRequestType = "starter_message_nudge"
)

// Defines values for StageValidationOptionForCreate.
const (
	AllowNonStart StageValidationOptionForCreate = "allow_non_start"
)

// Defines values for StageValidationOptionForUpdate.
const (
	AllowInvalidTransition StageValidationOptionForUpdate = "allow_invalid_transition"
)

// Defines values for StockSchemaFragmentsListRequestFilterPreset.
const (
	CustomizableTypesPreset StockSchemaFragmentsListRequestFilterPreset = "customizable_types_preset"
	NoPreset                StockSchemaFragmentsListRequestFilterPreset = "no_preset"
)

// Defines values for StockSchemaFragmentsListRequestPrune.
const (
	StockSchemaFragmentsListRequestPruneCompositeSchemas StockSchemaFragmentsListRequestPrune = "composite_schemas"
	StockSchemaFragmentsListRequestPruneFields           StockSchemaFragmentsListRequestPrune = "fields"
)

// Defines values for SyncInStatus.
const (
	SyncInStatusFailed    SyncInStatus = "failed"
	SyncInStatusModified  SyncInStatus = "modified"
	SyncInStatusStaged    SyncInStatus = "staged"
	SyncInStatusSucceeded SyncInStatus = "succeeded"
)

// Defines values for SyncMetadataFilterSyncInFilterStatus.
const (
	SyncMetadataFilterSyncInFilterStatusFailed    SyncMetadataFilterSyncInFilterStatus = "failed"
	SyncMetadataFilterSyncInFilterStatusModified  SyncMetadataFilterSyncInFilterStatus = "modified"
	SyncMetadataFilterSyncInFilterStatusStaged    SyncMetadataFilterSyncInFilterStatus = "staged"
	SyncMetadataFilterSyncInFilterStatusSucceeded SyncMetadataFilterSyncInFilterStatus = "succeeded"
)

// Defines values for SyncMetadataFilterSyncOutFilterStatus.
const (
	SyncMetadataFilterSyncOutFilterStatusFailed    SyncMetadataFilterSyncOutFilterStatus = "failed"
	SyncMetadataFilterSyncOutFilterStatusModified  SyncMetadataFilterSyncOutFilterStatus = "modified"
	SyncMetadataFilterSyncOutFilterStatusSucceeded SyncMetadataFilterSyncOutFilterStatus = "succeeded"
)

// Defines values for SyncOutStatus.
const (
	SyncOutStatusFailed    SyncOutStatus = "failed"
	SyncOutStatusModified  SyncOutStatus = "modified"
	SyncOutStatusSucceeded SyncOutStatus = "succeeded"
)

// Defines values for SyncProgressState.
const (
	SyncProgressStateCompleted                          SyncProgressState = "completed"
	SyncProgressStateDeleteInProgress                   SyncProgressState = "delete_in_progress"
	SyncProgressStateDeleted                            SyncProgressState = "deleted"
	SyncProgressStateDeletionError                      SyncProgressState = "deletion_error"
	SyncProgressStateExtractAttachments                 SyncProgressState = "extract_attachments"
	SyncProgressStateExtractAttachmentsError            SyncProgressState = "extract_attachments_error"
	SyncProgressStateExtraction                         SyncProgressState = "extraction"
	SyncProgressStateExtractionError                    SyncProgressState = "extraction_error"
	SyncProgressStateLoading                            SyncProgressState = "loading"
	SyncProgressStateLoadingAttachments                 SyncProgressState = "loading_attachments"
	SyncProgressStateLoadingAttachmentsError            SyncProgressState = "loading_attachments_error"
	SyncProgressStateLoadingError                       SyncProgressState = "loading_error"
	SyncProgressStateRecipeDiscovery                    SyncProgressState = "recipe_discovery"
	SyncProgressStateRecipeDiscoveryError               SyncProgressState = "recipe_discovery_error"
	SyncProgressStateRecipeDiscoveryWaitingForUserInput SyncProgressState = "recipe_discovery_waiting_for_user_input"
	SyncProgressStateStarting                           SyncProgressState = "starting"
	SyncProgressStateTransformation                     SyncProgressState = "transformation"
	SyncProgressStateTransformationError                SyncProgressState = "transformation_error"
)

// Defines values for SyncRunMode.
const (
	Initial        SyncRunMode = "initial"
	SyncFromDevrev SyncRunMode = "sync_from_devrev"
	SyncToDevrev   SyncRunMode = "sync_to_devrev"
)

// Defines values for SyncRunProgressState.
const (
	SyncRunProgressStateCompleted SyncRunProgressState = "completed"
	SyncRunProgressStateFailed    SyncRunProgressState = "failed"
)

// Defines values for SyncRunStartedBy.
const (
	SyncRunStartedByPeriodicSyncScheduler SyncRunStartedBy = "periodic_sync_scheduler"
	SyncRunStartedByUser                  SyncRunStartedBy = "user"
)

// Defines values for SyncUnitSyncType.
const (
	Manual   SyncUnitSyncType = "manual"
	Periodic SyncUnitSyncType = "periodic"
)

// Defines values for TableVisualizationColumnLockPosition.
const (
	TableVisualizationColumnLockPositionLeft  TableVisualizationColumnLockPosition = "left"
	TableVisualizationColumnLockPositionRight TableVisualizationColumnLockPosition = "right"
)

// Defines values for TableVisualizationColumnPinPosition.
const (
	TableVisualizationColumnPinPositionLeft  TableVisualizationColumnPinPosition = "left"
	TableVisualizationColumnPinPositionRight TableVisualizationColumnPinPosition = "right"
)

// Defines values for TaskPriority.
const (
	TaskPriorityP0 TaskPriority = "p0"
	TaskPriorityP1 TaskPriority = "p1"
	TaskPriorityP2 TaskPriority = "p2"
	TaskPriorityP3 TaskPriority = "p3"
)

// Defines values for TicketChannels.
const (
	Email     TicketChannels = "email"
	Plug      TicketChannels = "plug"
	Slack     TicketChannels = "slack"
	Twilio    TicketChannels = "twilio"
	TwilioSms TicketChannels = "twilio_sms"
)

// Defines values for TicketSeverity.
const (
	Blocker TicketSeverity = "blocker"
	High    TicketSeverity = "high"
	Low     TicketSeverity = "low"
	Medium  TicketSeverity = "medium"
)

// Defines values for TimelineChangeEventEventType.
const (
	Annotated TimelineChangeEventEventType = "annotated"
	Created   TimelineChangeEventEventType = "created"
	Deleted   TimelineChangeEventEventType = "deleted"
	Linked    TimelineChangeEventEventType = "linked"
	Updated   TimelineChangeEventEventType = "updated"
)

// Defines values for TimelineCommentBodyType.
const (
	TimelineCommentBodyTypeData       TimelineCommentBodyType = "data"
	TimelineCommentBodyTypeSnapKit    TimelineCommentBodyType = "snap_kit"
	TimelineCommentBodyTypeSnapWidget TimelineCommentBodyType = "snap_widget"
	TimelineCommentBodyTypeText       TimelineCommentBodyType = "text"
)

// Defines values for TimelineEntriesCollection.
const (
	TimelineEntriesCollectionDiscussions TimelineEntriesCollection = "discussions"
	TimelineEntriesCollectionEvents      TimelineEntriesCollection = "events"
)

// Defines values for TimelineEntriesCreateRequestType.
const (
	TimelineEntriesCreateRequestTypeTimelineComment TimelineEntriesCreateRequestType = "timeline_comment"
)

// Defines values for TimelineEntriesUpdateRequestType.
const (
	TimelineEntriesUpdateRequestTypeTimelineComment TimelineEntriesUpdateRequestType = "timeline_comment"
)

// Defines values for TimelineEntryObjectType.
const (
	TimelineEntryObjectTypeAccount             TimelineEntryObjectType = "account"
	TimelineEntryObjectTypeCapability          TimelineEntryObjectType = "capability"
	TimelineEntryObjectTypeCodeChange          TimelineEntryObjectType = "code_change"
	TimelineEntryObjectTypeConversation        TimelineEntryObjectType = "conversation"
	TimelineEntryObjectTypeCustomObject        TimelineEntryObjectType = "custom_object"
	TimelineEntryObjectTypeDm                  TimelineEntryObjectType = "dm"
	TimelineEntryObjectTypeEngagement          TimelineEntryObjectType = "engagement"
	TimelineEntryObjectTypeEnhancement         TimelineEntryObjectType = "enhancement"
	TimelineEntryObjectTypeFeature             TimelineEntryObjectType = "feature"
	TimelineEntryObjectTypeIncident            TimelineEntryObjectType = "incident"
	TimelineEntryObjectTypeIssue               TimelineEntryObjectType = "issue"
	TimelineEntryObjectTypeLinkable            TimelineEntryObjectType = "linkable"
	TimelineEntryObjectTypeMeeting             TimelineEntryObjectType = "meeting"
	TimelineEntryObjectTypeOpportunity         TimelineEntryObjectType = "opportunity"
	TimelineEntryObjectTypeProduct             TimelineEntryObjectType = "product"
	TimelineEntryObjectTypeRevOrg              TimelineEntryObjectType = "rev_org"
	TimelineEntryObjectTypeRevUser             TimelineEntryObjectType = "rev_user"
	TimelineEntryObjectTypeRunnable            TimelineEntryObjectType = "runnable"
	TimelineEntryObjectTypeSnapIn              TimelineEntryObjectType = "snap_in"
	TimelineEntryObjectTypeTask                TimelineEntryObjectType = "task"
	TimelineEntryObjectTypeTicket              TimelineEntryObjectType = "ticket"
	TimelineEntryObjectTypeTimelineChangeEvent TimelineEntryObjectType = "timeline_change_event"
	TimelineEntryObjectTypeTimelineComment     TimelineEntryObjectType = "timeline_comment"
)

// Defines values for TimelineEntryPanel.
const (
	Alerts       TimelineEntryPanel = "alerts"
	Broadcasts   TimelineEntryPanel = "broadcasts"
	CustomerChat TimelineEntryPanel = "customer_chat"
	Discussions  TimelineEntryPanel = "discussions"
	Events       TimelineEntryPanel = "events"
)

// Defines values for TimelineEntryType.
const (
	TimelineEntryTypeTimelineChangeEvent TimelineEntryType = "timeline_change_event"
	TimelineEntryTypeTimelineComment     TimelineEntryType = "timeline_comment"
)

// Defines values for TimelineEntryVisibility.
const (
	External TimelineEntryVisibility = "external"
	Internal TimelineEntryVisibility = "internal"
	Private  TimelineEntryVisibility = "private"
	Public   TimelineEntryVisibility = "public"
)

// Defines values for TuringSourcesType.
const (
	TuringSourcesTypeArticle        TuringSourcesType = "article"
	TuringSourcesTypeQuestionAnswer TuringSourcesType = "question_answer"
)

// Defines values for UnitType.
const (
	Boolean UnitType = "boolean"
	Number  UnitType = "number"
)

// Defines values for UomMetricScope.
const (
	UomMetricScopeOrg  UomMetricScope = "org"
	UomMetricScopeUser UomMetricScope = "user"
)

// Defines values for UserState.
const (
	UserStateActive      UserState = "active"
	UserStateDeactivated UserState = "deactivated"
	UserStateDeleted     UserState = "deleted"
	UserStateLocked      UserState = "locked"
	UserStateShadow      UserState = "shadow"
	UserStateUnassigned  UserState = "unassigned"
)

// Defines values for UserType.
const (
	UserTypeDevUser        UserType = "dev_user"
	UserTypeRevUser        UserType = "rev_user"
	UserTypeServiceAccount UserType = "service_account"
	UserTypeSysUser        UserType = "sys_user"
)

// Defines values for VistaGroupItemState.
const (
	VistaGroupItemStateActive    VistaGroupItemState = "active"
	VistaGroupItemStateCompleted VistaGroupItemState = "completed"
	VistaGroupItemStatePlanned   VistaGroupItemState = "planned"
)

// Defines values for VistaGroupItemType.
const (
	VistaGroupItemTypeCurated VistaGroupItemType = "curated"
	VistaGroupItemTypeDynamic VistaGroupItemType = "dynamic"
)

// Defines values for VistaType.
const (
	Curated VistaType = "curated"
	Dynamic VistaType = "dynamic"
	Grouped VistaType = "grouped"
)

// Defines values for VisualizationAxisColorType.
const (
	KeyLookup VisualizationAxisColorType = "key_lookup"
	Static    VisualizationAxisColorType = "static"
)

// Defines values for WebCrawlerJobState.
const (
	WebCrawlerJobStateAborted   WebCrawlerJobState = "aborted"
	WebCrawlerJobStateCompleted WebCrawlerJobState = "completed"
	WebCrawlerJobStateRunning   WebCrawlerJobState = "running"
	WebCrawlerJobStateScheduled WebCrawlerJobState = "scheduled"
	WebCrawlerJobStateSuspended WebCrawlerJobState = "suspended"
)

// Defines values for WebCrawlerJobsControlRequestAction.
const (
	WebCrawlerJobsControlRequestActionAbort  WebCrawlerJobsControlRequestAction = "abort"
	WebCrawlerJobsControlRequestActionPause  WebCrawlerJobsControlRequestAction = "pause"
	WebCrawlerJobsControlRequestActionResume WebCrawlerJobsControlRequestAction = "resume"
)

// Defines values for WebhookEventType.
const (
	AccountCreated        WebhookEventType = "account_created"
	AccountDeleted        WebhookEventType = "account_deleted"
	AccountUpdated        WebhookEventType = "account_updated"
	AiAgentResponse       WebhookEventType = "ai_agent_response"
	ConversationCreated   WebhookEventType = "conversation_created"
	ConversationDeleted   WebhookEventType = "conversation_deleted"
	ConversationUpdated   WebhookEventType = "conversation_updated"
	DashboardCreated      WebhookEventType = "dashboard_created"
	DashboardDeleted      WebhookEventType = "dashboard_deleted"
	DashboardUpdated      WebhookEventType = "dashboard_updated"
	DevUserCreated        WebhookEventType = "dev_user_created"
	DevUserDeleted        WebhookEventType = "dev_user_deleted"
	DevUserUpdated        WebhookEventType = "dev_user_updated"
	GroupCreated          WebhookEventType = "group_created"
	GroupDeleted          WebhookEventType = "group_deleted"
	GroupMemberAdded      WebhookEventType = "group_member_added"
	GroupMemberRemoved    WebhookEventType = "group_member_removed"
	GroupUpdated          WebhookEventType = "group_updated"
	IncidentCreated       WebhookEventType = "incident_created"
	IncidentDeleted       WebhookEventType = "incident_deleted"
	IncidentUpdated       WebhookEventType = "incident_updated"
	JobCreated            WebhookEventType = "job_created"
	JobDeleted            WebhookEventType = "job_deleted"
	JobUpdated            WebhookEventType = "job_updated"
	LinkCreated           WebhookEventType = "link_created"
	LinkDeleted           WebhookEventType = "link_deleted"
	LinkUpdated           WebhookEventType = "link_updated"
	PartCreated           WebhookEventType = "part_created"
	PartDeleted           WebhookEventType = "part_deleted"
	PartUpdated           WebhookEventType = "part_updated"
	QuestionAnswerCreated WebhookEventType = "question_answer_created"
	QuestionAnswerDeleted WebhookEventType = "question_answer_deleted"
	QuestionAnswerUpdated WebhookEventType = "question_answer_updated"
	RevOrgCreated         WebhookEventType = "rev_org_created"
	RevOrgDeleted         WebhookEventType = "rev_org_deleted"
	RevOrgUpdated         WebhookEventType = "rev_org_updated"
	RevUserCreated        WebhookEventType = "rev_user_created"
	RevUserDeleted        WebhookEventType = "rev_user_deleted"
	RevUserUpdated        WebhookEventType = "rev_user_updated"
	SlaTrackerCreated     WebhookEventType = "sla_tracker_created"
	SlaTrackerDeleted     WebhookEventType = "sla_tracker_deleted"
	SlaTrackerFetched     WebhookEventType = "sla_tracker_fetched"
	SlaTrackerUpdated     WebhookEventType = "sla_tracker_updated"
	SurveyCreated         WebhookEventType = "survey_created"
	SurveyDeleted         WebhookEventType = "survey_deleted"
	SurveyResponseCreated WebhookEventType = "survey_response_created"
	SurveyResponseDeleted WebhookEventType = "survey_response_deleted"
	SurveyResponseUpdated WebhookEventType = "survey_response_updated"
	SurveyUpdated         WebhookEventType = "survey_updated"
	SyncHistoryCreated    WebhookEventType = "sync_history_created"
	SyncHistoryDeleted    WebhookEventType = "sync_history_deleted"
	SyncHistoryUpdated    WebhookEventType = "sync_history_updated"
	SyncUnitUpdated       WebhookEventType = "sync_unit_updated"
	TagCreated            WebhookEventType = "tag_created"
	TagDeleted            WebhookEventType = "tag_deleted"
	TagUpdated            WebhookEventType = "tag_updated"
	TimelineEntryCreated  WebhookEventType = "timeline_entry_created"
	TimelineEntryDeleted  WebhookEventType = "timeline_entry_deleted"
	TimelineEntryUpdated  WebhookEventType = "timeline_entry_updated"
	Verify                WebhookEventType = "verify"
	WebhookCreated        WebhookEventType = "webhook_created"
	WebhookDeleted        WebhookEventType = "webhook_deleted"
	WebhookUpdated        WebhookEventType = "webhook_updated"
	WidgetCreated         WebhookEventType = "widget_created"
	WidgetDeleted         WebhookEventType = "widget_deleted"
	WidgetUpdated         WebhookEventType = "widget_updated"
	WorkCreated           WebhookEventType = "work_created"
	WorkDeleted           WebhookEventType = "work_deleted"
	WorkFetched           WebhookEventType = "work_fetched"
	WorkUpdated           WebhookEventType = "work_updated"
)

// Defines values for WebhookStatus.
const (
	Active     WebhookStatus = "active"
	Inactive   WebhookStatus = "inactive"
	Unverified WebhookStatus = "unverified"
)

// Defines values for WebhooksUpdateAction.
const (
	Activate   WebhooksUpdateAction = "activate"
	Deactivate WebhooksUpdateAction = "deactivate"
)

// Defines values for WidgetColumnProjectionType.
const (
	CustomField WidgetColumnProjectionType = "custom_field"
	Native      WidgetColumnProjectionType = "native"
)

// Defines values for WidgetDataSourceType.
const (
	Api                WidgetDataSourceType = "api"
	DataSource         WidgetDataSourceType = "data_source"
	DataView           WidgetDataSourceType = "data_view"
	ExternalDataSource WidgetDataSourceType = "external_data_source"
	Oasis              WidgetDataSourceType = "oasis"
)

// Defines values for WidgetQueryOrderByDirection.
const (
	Ascending  WidgetQueryOrderByDirection = "ascending"
	Descending WidgetQueryOrderByDirection = "descending"
)

// Defines values for WidgetVisualizationType.
const (
	Bar          WidgetVisualizationType = "bar"
	Column       WidgetVisualizationType = "column"
	Combination  WidgetVisualizationType = "combination"
	Donut        WidgetVisualizationType = "donut"
	Heatmap      WidgetVisualizationType = "heatmap"
	Kanban       WidgetVisualizationType = "kanban"
	Line         WidgetVisualizationType = "line"
	Metric       WidgetVisualizationType = "metric"
	PackedBubble WidgetVisualizationType = "packed_bubble"
	Pie          WidgetVisualizationType = "pie"
	RichText     WidgetVisualizationType = "rich_text"
	Scatter      WidgetVisualizationType = "scatter"
	Table        WidgetVisualizationType = "table"
)

// Defines values for WorkType.
const (
	WorkTypeIssue       WorkType = "issue"
	WorkTypeOpportunity WorkType = "opportunity"
	WorkTypeTask        WorkType = "task"
	WorkTypeTicket      WorkType = "ticket"
)

// AccessLevel defines model for access-level.
type AccessLevel string

// Account defines model for account.
type Account struct {
	// Artifacts The artifacts attached to the Account.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`
	CreatedBy *UserSummary       `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// Description Description of the corresponding Account.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Domains Company's domain names. Example - 'devrev.ai'.
	Domains *[]string `json:"domains,omitempty"`

	// ExternalRefs External refs are unique identifiers from your customer system of
	// records, stored as a list.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy List of Dev user IDs owning this Account.
	OwnedBy        []UserSummary   `json:"owned_by"`
	PrimaryAccount *AccountSummary `json:"primary_account,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// Tags Tags associated with an object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// Tier The Tier of the corresponding Account.
	Tier *string `json:"tier,omitempty"`

	// Websites Company's website links. Filling in this property will also fill in
	// domain. Example - 'www.devrev.ai'.
	Websites *[]string `json:"websites,omitempty"`
}

// AccountSearchSummary defines model for account-search-summary.
type AccountSearchSummary struct {
	Account AccountSummary `json:"account"`

	// Comments Comments on the work.
	Comments *[]CommentSearchSummary `json:"comments,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// AccountSummary defines model for account-summary.
type AccountSummary = OrgBaseSummary

// AccountsCreateRequest Request object to create a new account in the Dev organization.
type AccountsCreateRequest struct {
	// Artifacts The IDs of the artifacts to associate with the account.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description Description of the account.
	Description *string `json:"description,omitempty"`

	// DisplayName Name of the account.
	DisplayName string `json:"display_name"`

	// Domains List of company's domain names. Example - ['devrev.ai'].
	Domains *[]string `json:"domains,omitempty"`

	// ExternalRefs External refs are unique identifiers from your customer system of
	// records, stored as a list.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// OwnedBy List of Dev users owning this account.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// SchemaFragmentIds Schema fragment IDs associated with this account SOR.
	// Deprecated:
	SchemaFragmentIds *[]string `json:"schema_fragment_ids,omitempty"`

	// Tags Tags associated with the account.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Tier The tier of the account.
	Tier *string `json:"tier,omitempty"`

	// Websites List of company websites. Example - ['www.devrev.ai',
	// 'www.marketplace.devrev.ai'].
	Websites *[]string `json:"websites,omitempty"`
}

// AccountsCreateResponseBody The response to creating a new account.
type AccountsCreateResponseBody struct {
	Account       Account `json:"account"`
	DefaultRevOrg RevOrg  `json:"default_rev_org"`
}

// AccountsDeleteRequest Request object to delete an account.
type AccountsDeleteRequest struct {
	// Id The ID of account to delete.
	Id string `json:"id"`
}

// AccountsDeleteResponseBody The response to deleting an account.
type AccountsDeleteResponseBody = map[string]interface{}

// AccountsExportRequest The request to export a collection of accounts.
type AccountsExportRequest struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `json:"display_name,omitempty"`

	// Domains Domains for accounts to be filtered.
	Domains *[]string `json:"domains,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// First The number of accounts to return. The default is '50'.
	First        *int32          `json:"first,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for accounts owned by the specified user(s).
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// SortBy Fields to sort the accounts by and the direction to sort them in.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `json:"stage,omitempty"`

	// Subtype Subtypes of the accounts to be filtered.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `json:"tags,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `json:"websites,omitempty"`
}

// AccountsExportResponseBody The response to exporting a collection of accounts.
type AccountsExportResponseBody struct {
	// Accounts The exported accounts.
	Accounts []Account `json:"accounts"`
}

// AccountsFilters defines model for accounts-filters.
type AccountsFilters struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `json:"display_name,omitempty"`

	// Domains Domains for accounts to be filtered.
	Domains *[]string `json:"domains,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string       `json:"external_refs,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for accounts owned by the specified user(s).
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `json:"stage,omitempty"`

	// Subtype Subtypes of the accounts to be filtered.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `json:"tags,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `json:"websites,omitempty"`
}

// AccountsGetRequest Request object to get an account's information.
type AccountsGetRequest struct {
	// Id The ID of the account to be retrieved.
	Id string `json:"id"`
}

// AccountsGetResponseBody The returned account.
type AccountsGetResponseBody struct {
	Account Account `json:"account"`
}

// AccountsListRequest List the accounts.
type AccountsListRequest struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `json:"display_name,omitempty"`

	// Domains Domains for accounts to be filtered.
	Domains *[]string `json:"domains,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// Limit The maximum number of accounts to return per page. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for accounts owned by the specified user(s).
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// SortBy Fields to sort the accounts by and the direction to sort them in.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `json:"stage,omitempty"`

	// Subtype Subtypes of the accounts to be filtered.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `json:"tags,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `json:"websites,omitempty"`
}

// AccountsListResponseBody The response to listing all accounts matching the filter criteria.
type AccountsListResponseBody struct {
	// Accounts List containing all the accounts
	Accounts []Account `json:"accounts"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// AccountsMergeRequest Request object to merge two accounts.
type AccountsMergeRequest struct {
	// PrimaryAccount The ID of the primary account, which will be retained post merge.
	PrimaryAccount string `json:"primary_account"`

	// SecondaryAccount The ID of the secondary account, which will be merged into the
	// primary account.
	SecondaryAccount string `json:"secondary_account"`
}

// AccountsMergeResponseBody The response to merging an account.
type AccountsMergeResponseBody = map[string]interface{}

// AccountsUpdateRequest Request to update details of the account.
type AccountsUpdateRequest struct {
	Artifacts *AccountsUpdateRequestArtifacts `json:"artifacts,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description Updated description of the account.
	Description *string `json:"description,omitempty"`

	// DisplayName Updated display name for the account.
	DisplayName *string `json:"display_name,omitempty"`

	// Domains Updated list of company's domain names. Example - ['devrev.ai'].
	Domains *[]string `json:"domains,omitempty"`

	// ExternalRefs Updated External Refs of account.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// Id The ID of account to update.
	Id string `json:"id"`

	// OwnedBy Updated list of the users owning this account.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// SchemaFragmentIds Schema fragment IDs associated with this account SOR.
	// Deprecated:
	SchemaFragmentIds *[]string `json:"schema_fragment_ids,omitempty"`

	// Tags Updated tags list associated with the account.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Tier Updated tier of the account.
	Tier     *string                        `json:"tier"`
	Websites *AccountsUpdateRequestWebsites `json:"websites,omitempty"`
}

// AccountsUpdateRequestArtifacts defines model for accounts-update-request-artifacts.
type AccountsUpdateRequestArtifacts struct {
	// Set Sets the IDs to the provided artifact IDs.
	Set *[]string `json:"set,omitempty"`
}

// AccountsUpdateRequestWebsites defines model for accounts-update-request-websites.
type AccountsUpdateRequestWebsites struct {
	// Set Sets the websites field of the account.
	Set *[]string `json:"set,omitempty"`
}

// AccountsUpdateResponseBody Updated account object.
type AccountsUpdateResponseBody struct {
	Account Account `json:"account"`
}

// AddTagWithValue defines model for add-tag-with-value.
type AddTagWithValue struct {
	// Id The ID of the tag.
	Id string `json:"id"`

	// Value The value for the object's association with the tag. If specified,
	// the value must be one that's specified in the tag's allowed values.
	Value *string `json:"value,omitempty"`
}

// AggregatedSchema List of custom fields from multiple source fragments.
type AggregatedSchema struct {
	// Conditions The conditions associated with the fields.
	Conditions *[]CustomSchemaFragmentCondition `json:"conditions,omitempty"`

	// StockFieldOverrides The stock field overrides.
	StockFieldOverrides *[]StockFieldOverride `json:"stock_field_overrides,omitempty"`
}

// AggregatedSchemaGetRequest defines model for aggregated-schema-get-request.
type AggregatedSchemaGetRequest struct {
	// CustomSchemaFragmentIds The list of custom schema fragment DONs which are to be aggregated.
	CustomSchemaFragmentIds *[]string `json:"custom_schema_fragment_ids,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers
	CustomSchemaSpec *CustomSchemaSpecForRead `json:"custom_schema_spec,omitempty"`

	// IsCustomLeafType Whether the leaf type corresponds to a custom object.
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// LeafType The leaf type. Used for inferring the default stage diagram and
	// tenant fragment ID.
	LeafType *string `json:"leaf_type,omitempty"`

	// PerObjectSchema Per object schema, if associated with the leaf type.
	PerObjectSchema *[]FieldDescriptor `json:"per_object_schema,omitempty"`

	// StockSchemaFragmentId The stock schema fragment which is to be aggregated.
	StockSchemaFragmentId *string `json:"stock_schema_fragment_id,omitempty"`
}

// AggregatedSchemaGetResponseBody defines model for aggregated-schema-get-response.
type AggregatedSchemaGetResponseBody struct {
	// Schema List of custom fields from multiple source fragments.
	Schema AggregatedSchema `json:"schema"`
}

// AggregationDetail Stores aggregation type and dimension information.
type AggregationDetail struct {
	// AggregationType Aggregation type to be used while aggregating the metering data for the
	// UOM. 1] Sum - sum of all the values for the meter in a given period Ex.
	// { M1:2, M1:4 } => {M1:6} 2] Minimum - min of all the values for the
	// meter in a given period Ex. { M1:2, M1:4 } => {M1:2} 3] Maximum - max
	// of all the values for the meter in a given period Ex. { M1:2, M1:4 } =>
	// {M1:4} 4] Unique Count - Sum of distinct unique dimension observed for
	// the meter in the given period (not considering the data from the
	// previous billing period) Ex. January {M1:{VM:VM0}}, February
	// {M1:{VM:VM1}, M1:{VM:VM2}, M1:{VM:VM1}} => {M1:2} 5] Running Total -
	// Sum of distinct active unique dimension observed for a meter in the
	// given period, taking into consideration the active data from the
	// previous billing cycle Ex. January {M1:{VM:VM0,on}, {M1:{VM:VM1,off}
	// February {M1:{VM:VM2, on}, M1:{VM:VM2, off}, M1:{VM:VM3, on}} => {M1:3}
	// 6] Duration - Sum of distinct active unique dimension duration for a
	// meter in the given period, taking into consideration the active data
	// from the previous month Ex. January15 {M1:{VM:VM0,on, 4}} February15
	// {M1:{VM:VM0,off}, February18 {M1:{VM:VM1,on,5} => M1->
	// 30*4*charge_per_day + 10*5*charge_per_day 7] Latest - consider the
	// latest/last meter in the given period 8] Oldest - consider the
	// oldest/first record in the given period.
	AggregationType AggregationDetailAggregationType `json:"aggregation_type"`

	// UniqueDimension Unique dimension if provided to be considered for grouping metering
	// data for the UOM.
	UniqueDimension *string `json:"unique_dimension,omitempty"`
}

// AggregationDetailAggregationType Aggregation type to be used while aggregating the metering data for the
// UOM. 1] Sum - sum of all the values for the meter in a given period Ex.
// { M1:2, M1:4 } => {M1:6} 2] Minimum - min of all the values for the
// meter in a given period Ex. { M1:2, M1:4 } => {M1:2} 3] Maximum - max
// of all the values for the meter in a given period Ex. { M1:2, M1:4 } =>
// {M1:4} 4] Unique Count - Sum of distinct unique dimension observed for
// the meter in the given period (not considering the data from the
// previous billing period) Ex. January {M1:{VM:VM0}}, February
// {M1:{VM:VM1}, M1:{VM:VM2}, M1:{VM:VM1}} => {M1:2} 5] Running Total -
// Sum of distinct active unique dimension observed for a meter in the
// given period, taking into consideration the active data from the
// previous billing cycle Ex. January {M1:{VM:VM0,on}, {M1:{VM:VM1,off}
// February {M1:{VM:VM2, on}, M1:{VM:VM2, off}, M1:{VM:VM3, on}} => {M1:3}
// 6] Duration - Sum of distinct active unique dimension duration for a
// meter in the given period, taking into consideration the active data
// from the previous month Ex. January15 {M1:{VM:VM0,on, 4}} February15
// {M1:{VM:VM0,off}, February18 {M1:{VM:VM1,on,5} => M1->
// 30*4*charge_per_day + 10*5*charge_per_day 7] Latest - consider the
// latest/last meter in the given period 8] Oldest - consider the
// oldest/first record in the given period.
type AggregationDetailAggregationType string

// AggregationDetailSummary Stores aggregation type and dimension information.
type AggregationDetailSummary = map[string]interface{}

// AiAgentEvent An event to be processed by an AI agent.
type AiAgentEvent struct {
	// InputMessage Text input message for the AI agent event. Could be human or agent
	// message.
	InputMessage AiAgentEventInputMessage `json:"input_message"`
}

// AiAgentEventContext Additional metadata to be used by the AI agent for the event.
type AiAgentEventContext struct {
	// Additional The additional context for the AI agent event. This will be used on
	// per event basis.
	Additional *string `json:"additional,omitempty"`

	// Initial The initial context for the AI agent event. This will be used at
	// the start of Agent Session
	Initial *string `json:"initial,omitempty"`
}

// AiAgentEventExecuteError An error object providing the error message for the AI agent event
// execution.
type AiAgentEventExecuteError struct {
	// Error The error message for the AI agent event execution.
	Error string `json:"error"`
}

// AiAgentEventExecuteProgress A progress object providing the status of the AI agent event execution.
type AiAgentEventExecuteProgress struct {
	ProgressState *AiAgentEventExecuteProgressProgressState `json:"progress_state,omitempty"`

	// SkillExecuted The progress for the AI agent event execution indicating that the skill
	// has been executed.
	SkillExecuted *AiAgentEventExecuteProgressSkillExecuted `json:"skill_executed,omitempty"`

	// SkillTriggered The progress for the AI agent event execution indicating that the skill
	// has been triggered.
	SkillTriggered *AiAgentEventExecuteProgressSkillTriggered `json:"skill_triggered,omitempty"`
}

// AiAgentEventExecuteProgressProgressState defines model for AiAgentEventExecuteProgress.ProgressState.
type AiAgentEventExecuteProgressProgressState string

// AiAgentEventExecuteProgressSkillExecuted The progress for the AI agent event execution indicating that the skill
// has been executed.
type AiAgentEventExecuteProgressSkillExecuted struct {
	// Args The arguments for the skill call.
	Args *map[string]interface{} `json:"args,omitempty"`

	// Metadata The metadata of the skill call. The fields depend on the skill that
	// was executed.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Output The output of the skill call.
	Output map[string]interface{} `json:"output"`

	// SkillName The name of the skill.
	SkillName string `json:"skill_name"`
}

// AiAgentEventExecuteProgressSkillTriggered The progress for the AI agent event execution indicating that the skill
// has been triggered.
type AiAgentEventExecuteProgressSkillTriggered struct {
	// Args The arguments for the skill call.
	Args map[string]interface{} `json:"args"`

	// SkillName The name of the skill.
	SkillName string `json:"skill_name"`

	// Thought The thought explaining why the skill was called.
	Thought     *string             `json:"thought,omitempty"`
	Workflow    *WorkflowSummary    `json:"workflow,omitempty"`
	WorkflowRun *WorkflowRunSummary `json:"workflow_run,omitempty"`
}

// AiAgentEventInputMessage Text input message for the AI agent event. Could be human or agent
// message.
type AiAgentEventInputMessage struct {
	// Message The text message of the AI agent event.
	Message string `json:"message"`
}

// AiAgentEventSourceTarget The source of the event to send notifications to, of asynchronous
// execution progress.
type AiAgentEventSourceTarget struct {
	// EventSource The ID of the target to send the events to.
	EventSource string `json:"event_source"`
}

// AiAgentEventSuggestions A list of suggestions generated for the AI agent event.
type AiAgentEventSuggestions struct {
	// Suggestions The suggestions generated for the AI agent event.
	Suggestions []AiAgentSuggestion `json:"suggestions"`
}

// AiAgentEventsExecuteAsyncRequest Request object to consume an input event and execute asynchronously.
type AiAgentEventsExecuteAsyncRequest struct {
	// Agent The ID of the AI agent that will consume the event.
	Agent string `json:"agent"`

	// ClientMetadata The metadata to be sent to the client with the notifications of
	// execution progress.
	ClientMetadata *map[string]interface{} `json:"client_metadata,omitempty"`

	// Context Additional metadata to be used by the AI agent for the event.
	Context *AiAgentEventContext `json:"context,omitempty"`

	// Event An event to be processed by an AI agent.
	Event AiAgentEvent `json:"event"`

	// EventSourceTarget The source of the event to send notifications to, of asynchronous
	// execution progress.
	EventSourceTarget *AiAgentEventSourceTarget `json:"event_source_target,omitempty"`

	// SessionObject An identifier of a session with an AI agent.
	SessionObject string                                  `json:"session_object"`
	Target        *AiAgentEventsExecuteAsyncRequestTarget `json:"target,omitempty"`

	// WebhookTarget The source of the event to send notifications to, of asynchronous
	// execution progress.
	WebhookTarget *AiAgentWebhookTarget `json:"webhook_target,omitempty"`
}

// AiAgentEventsExecuteAsyncRequestTarget defines model for AiAgentEventsExecuteAsyncRequest.Target.
type AiAgentEventsExecuteAsyncRequestTarget string

// AiAgentEventsExecuteAsyncResponseBody Response object to provide final response after asynchronous execution
// of input event to AI agent.
type AiAgentEventsExecuteAsyncResponseBody struct {
	Session AiAgentSessionSummary `json:"session"`
}

// AiAgentMessageGenerationStarted Additional metadata to indicate that the message generation has
// started.
type AiAgentMessageGenerationStarted struct {
	// RequestId The request ID contains an UUID to fetch the partial message
	// generation.
	RequestId string `json:"request_id"`
}

// AiAgentSessionSummary defines model for ai-agent-session-summary.
type AiAgentSessionSummary = AtomBaseSummary

// AiAgentSuggestion A suggestion generated for the AI agent event.
type AiAgentSuggestion struct {
	// Suggestion The text of the suggestion.
	Suggestion string `json:"suggestion"`
}

// AiAgentWebhookTarget The source of the event to send notifications to, of asynchronous
// execution progress.
type AiAgentWebhookTarget struct {
	// Webhook The ID of the webhook to send the events to.
	Webhook string `json:"webhook"`
}

// AirdropSyncUnitsGetRequest Request to get a sync unit.
type AirdropSyncUnitsGetRequest struct {
	// Id Requested sync unit ID.
	Id string `json:"id"`
}

// AirdropSyncUnitsGetResponseBody Response containing the requested sync unit.
type AirdropSyncUnitsGetResponseBody struct {
	SyncUnit SyncUnit `json:"sync_unit"`
}

// AirdropSyncUnitsHistoryFilter defines model for airdrop-sync-units-history-filter.
type AirdropSyncUnitsHistoryFilter struct {
	// EndedAt Provides ways to specify date ranges on objects.
	EndedAt *DateFilter `json:"ended_at,omitempty"`

	// HasErrorsOrWarnings Filter for sync runs that have errors.
	HasErrorsOrWarnings *bool `json:"has_errors_or_warnings,omitempty"`

	// Mode Mode of the sync run.
	Mode *[]SyncRunMode `json:"mode,omitempty"`

	// StartedBy User who started the sync run.
	StartedBy *[]SyncRunStartedBy `json:"started_by,omitempty"`

	// State State of the sync run.
	State *[]SyncRunProgressState `json:"state,omitempty"`
}

// AirdropSyncUnitsHistoryRequest Request to list sync unit history.
type AirdropSyncUnitsHistoryRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string                        `json:"cursor,omitempty"`
	Filter *AirdropSyncUnitsHistoryFilter `json:"filter,omitempty"`

	// Id Sync unit that will be used for sync history listing.
	Id string `json:"id"`

	// Limit The maximum number of items to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`
}

// AirdropSyncUnitsHistoryResponseBody List sync history response.
type AirdropSyncUnitsHistoryResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// SyncHistory Historical records of syncs.
	SyncHistory []SyncHistory `json:"sync_history"`
}

// AppFragment defines model for app-fragment.
type AppFragment struct {
	// App App this fragment applies to.
	App *string `json:"app,omitempty"`

	// AppDisplayName The display name of the app.
	AppDisplayName *string `json:"app_display_name,omitempty"`

	// Conditions The conditions associated with the fields.
	Conditions *[]CustomSchemaFragmentCondition `json:"conditions,omitempty"`
	CreatedBy  *UserSummary                     `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Deprecated Indicates if the fragment has been deprecated. Modifications to
	// this field are done in-place and don't result in creation of a new
	// fragment in chain.
	Deprecated *bool `json:"deprecated,omitempty"`

	// Description Description of the custom schema fragment.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Fields List of all fields in this custom schema fragment.
	Fields *[]SchemaFieldDescriptor `json:"fields,omitempty"`

	// FragmentType Type of the custom schema fragment.
	FragmentType *CustomSchemaFragmentFragmentType `json:"fragment_type,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsDeprecated Indicates if the fragment is deprecated. Modifications to this
	// field are done in-place and don't result in creation of a new
	// fragment in chain.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// LeafType Leaf type this fragment applies to.
	LeafType   *string      `json:"leaf_type,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate   *time.Time                   `json:"modified_date,omitempty"`
	NewFragmentRef *CustomSchemaFragmentSummary `json:"new_fragment_ref,omitempty"`
	OldFragmentRef *CustomSchemaFragmentSummary `json:"old_fragment_ref,omitempty"`
}

// AppFragmentSummary defines model for app-fragment-summary.
type AppFragmentSummary = CustomSchemaFragmentBaseSummary

// ArchetypeMetricTarget Metric with corresponding target values.
type ArchetypeMetricTarget struct {
	// BreachedAt For breached metrics the time they entered into breach. This is the
	// same as what the target date was, unless the breach happened due to
	// a different policy starting to apply.
	BreachedAt *time.Time `json:"breached_at,omitempty"`

	// CompletedAt The time at which the metric completed at.
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CompletedIn For completed metrics the time (in minutes) it took to complete
	// them. (Taking into account the schedule if any).
	CompletedIn *int32 `json:"completed_in,omitempty"`

	// InPolicy If true, the metric is part of the applied policy.
	InPolicy *bool `json:"in_policy,omitempty"`

	// IsOutOfSchedule If true, the schedule attached to this metric is out of schedule at
	// the time of the query. It is not set for metrics in *completed*
	// stage.
	IsOutOfSchedule  *bool                   `json:"is_out_of_schedule,omitempty"`
	MetricDefinition MetricDefinitionSummary `json:"metric_definition"`

	// NextScheduleTransition The next time the schedule will change its state, if such is known.
	NextScheduleTransition *time.Time          `json:"next_schedule_transition,omitempty"`
	OrgSchedule            *OrgScheduleSummary `json:"org_schedule,omitempty"`

	// RemainingTime Time in minutes that remains on a paused metric.
	RemainingTime *int32 `json:"remaining_time,omitempty"`

	// Stage Metric stage corresponding to the applicable SLA.
	Stage string `json:"stage"`

	// Status It is an indicator of whether the metric has ever been breached
	// (missed). If not, it shows whether the metric is completed, in
	// progress, or not part of the applied policy.
	Status *string `json:"status,omitempty"`

	// TargetTime Time at which the metric would breach SLA if no action taken.
	TargetTime *time.Time `json:"target_time,omitempty"`

	// WarningTargetTime Time at which the metric would reach the SLA warning limit if no
	// action taken.
	WarningTargetTime *time.Time `json:"warning_target_time,omitempty"`
}

// ArchetypeSlaSummary SLA summary for the object.
type ArchetypeSlaSummary struct {
	// ClosestToBreachMetric The name of the metric which is closest to breach.
	ClosestToBreachMetric *string             `json:"closest_to_breach_metric,omitempty"`
	OrgSchedule           *OrgScheduleSummary `json:"org_schedule,omitempty"`

	// RemainingTime The remaining time (in minutes) for the closest_to_breach_metric if
	// it is paused. A paused metric will only be closest to breach if no
	// metrics are running (running, warning and breached stage).
	RemainingTime *int32      `json:"remaining_time,omitempty"`
	SlaTracker    *SlaTracker `json:"sla_tracker,omitempty"`

	// Stage The stage of the SLA. This is the metric stage which is closest to
	// breach.
	Stage *SlaSummaryStage `json:"stage,omitempty"`

	// TargetTime The target time to avoid SLA breach. This is the target time of the
	// metric which is closest to breach.
	TargetTime *time.Time `json:"target_time,omitempty"`
}

// Article defines model for article.
type Article struct {
	// AppliesToParts Parts relevant to the article.
	AppliesToParts *[]PartSummary `json:"applies_to_parts,omitempty"`

	// ArticleType Type of the article.
	ArticleType *ArticleType `json:"article_type,omitempty"`

	// AuthoredBy Users that authored the article.
	AuthoredBy *[]UserSummary `json:"authored_by,omitempty"`
	CreatedBy  *UserSummary   `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the article.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ExtractedContent Extracted content of the article.
	ExtractedContent *[]ArtifactSummary `json:"extracted_content,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// NumDownvotes Number of downvotes on the article.
	NumDownvotes *int32 `json:"num_downvotes,omitempty"`

	// NumUpvotes Number of upvotes on the article.
	NumUpvotes *int32 `json:"num_upvotes,omitempty"`

	// OwnedBy Users that own the article.
	OwnedBy []UserSummary     `json:"owned_by"`
	Parent  *DirectorySummary `json:"parent,omitempty"`

	// Rank Rank of the article.
	Rank *string `json:"rank,omitempty"`

	// Resource Resource details.
	Resource *Resource `json:"resource,omitempty"`

	// Scope The properties of an enum value.
	Scope *EnumValue `json:"scope,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Title Title of the article.
	Title *string `json:"title,omitempty"`
}

// ArticleContentFormat Content format of the article.
type ArticleContentFormat string

// ArticleDataSourceCreate defines model for article-data-source-create.
type ArticleDataSourceCreate struct {
	// IsCustomLeafType Indicates if the leaf type is custom.
	IsCustomLeafType bool `json:"is_custom_leaf_type"`

	// IsDefault Indicates if the data source is default.
	IsDefault bool `json:"is_default"`

	// LeafType The object's type.
	LeafType string `json:"leaf_type"`

	// Object The ID of the object powering article.
	Object string `json:"object"`

	// ReferenceId The reference ID of the data source.
	ReferenceId string `json:"reference_id"`
}

// ArticleSearchSummary defines model for article-search-summary.
type ArticleSearchSummary struct {
	Article ArticleSummary `json:"article"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// ArticleStatus Status of the article.
type ArticleStatus string

// ArticleSummary defines model for article-summary.
type ArticleSummary struct {
	// ArticleType Type of the article.
	ArticleType *ArticleType `json:"article_type,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Resource Resource details.
	Resource *ResourceSummary `json:"resource,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`

	// Title Title of the article.
	Title *string `json:"title,omitempty"`
}

// ArticleType Type of the article.
type ArticleType string

// ArticlesCountRequest defines model for articles-count-request.
type ArticlesCountRequest struct {
	// Ancestor The ancestor directory of the articles.
	Ancestor *string `json:"ancestor,omitempty"`

	// AppliesToParts Filters for articles belonging to any of the provided parts.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// ArticleType Filter for the type of articles. If this is not provided, then
	// articles that are not content blocks are returned.
	ArticleType *[]ArticleType `json:"article_type,omitempty"`

	// AuthoredBy Filters for articles authored by any of the provided users.
	AuthoredBy *[]string `json:"authored_by,omitempty"`

	// Brands Filters for articles belonging to any of the provided brands.
	Brands *[]string `json:"brands,omitempty"`

	// CreatedBy Filters for articles created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// ModifiedBy Filters for articles modified by any of the provided users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`

	// OwnedBy Filters for articles owned by any of the provided users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// Scope Filter for the scope of the articles.
	Scope *[]int64 `json:"scope,omitempty"`

	// SharedWith Filter for articles based on intended audience.
	SharedWith *[]SharedWithMembershipFilter `json:"shared_with,omitempty"`

	// Tags Filters for article with any of the provided tags.
	Tags *[]string `json:"tags,omitempty"`
}

// ArticlesCountResponseBody defines model for articles-count-response.
type ArticlesCountResponseBody struct {
	// Count The total number of articles matching the filter.
	Count int32 `json:"count"`
}

// ArticlesCreateRequest The request to create an article.
type ArticlesCreateRequest struct {
	AccessLevel *AccessLevel `json:"access_level,omitempty"`

	// Aliases The aliases of the article.
	Aliases *[]string `json:"aliases,omitempty"`

	// AppliesToParts The parts that the article applies to.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// ArticleType Type of the article.
	ArticleType *ArticleType `json:"article_type,omitempty"`

	// AuthoredBy The authors of the article.
	AuthoredBy *[]string `json:"authored_by,omitempty"`

	// Brand The brand associated with the article.
	Brand *string `json:"brand,omitempty"`

	// ContentFormat Content format of the article.
	ContentFormat *ArticleContentFormat `json:"content_format,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// DataSources Data sources provide the backing data for the article.
	DataSources *[]ArticleDataSourceCreate `json:"data_sources,omitempty"`

	// Description Description for the article.
	Description *string `json:"description,omitempty"`

	// ExtractedContent ID of the extracted content artifact.
	ExtractedContent *[]string `json:"extracted_content,omitempty"`

	// Language Language of the article.
	Language *string `json:"language,omitempty"`

	// Notify Whether to notify the users when the article is published.
	Notify *bool `json:"notify,omitempty"`

	// OwnedBy The users that own the article.
	OwnedBy []string `json:"owned_by"`

	// Parent The parent directory of the article.
	Parent *string `json:"parent,omitempty"`

	// PublishedAt The published date of the article.
	PublishedAt *time.Time `json:"published_at,omitempty"`

	// ReleaseNotes The release notes of the article.
	ReleaseNotes *string                       `json:"release_notes,omitempty"`
	Resource     ArticlesCreateRequestResource `json:"resource"`

	// Scope The scope of the article.
	Scope *int64 `json:"scope,omitempty"`

	// SharedWith Information about the role the member receives due to the share.
	SharedWith *[]SetSharedWithMembership `json:"shared_with,omitempty"`

	// Status Status of the article.
	Status *ArticleStatus `json:"status,omitempty"`

	// Tags Tags associated with the article.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Title Name of the article.
	Title string `json:"title"`
}

// ArticlesCreateRequestResource defines model for articles-create-request-resource.
type ArticlesCreateRequestResource struct {
	// Artifacts IDs of the artifacts.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// ContentBlocks List of content blocks used in the article.
	ContentBlocks *[]string `json:"content_blocks,omitempty"`

	// PublishedVersion The latest published version.
	PublishedVersion *string `json:"published_version,omitempty"`

	// Url URL of the external article.
	Url *string `json:"url,omitempty"`
}

// ArticlesCreateResponseBody Create article response.
type ArticlesCreateResponseBody struct {
	Article Article `json:"article"`
}

// ArticlesDeleteRequest The request to delete an article.
type ArticlesDeleteRequest struct {
	// Id The ID of the article to delete.
	Id string `json:"id"`
}

// ArticlesDeleteResponseBody defines model for articles-delete-response.
type ArticlesDeleteResponseBody = map[string]interface{}

// ArticlesGetRequest The request to get an article.
type ArticlesGetRequest struct {
	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `json:"dev_org,omitempty"`

	// Id The ID of the required article.
	Id string `json:"id"`
}

// ArticlesGetResponseBody Get article response.
type ArticlesGetResponseBody struct {
	Article Article `json:"article"`
}

// ArticlesListRequest The request to list articles.
type ArticlesListRequest struct {
	// AppliesToParts Filters for articles belonging to any of the provided parts.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// ArticleType Filter for the type of articles. If this is not provided, then
	// articles that are not content blocks are returned.
	ArticleType *[]ArticleType `json:"article_type,omitempty"`

	// AuthoredBy Filters for articles authored by any of the provided users.
	AuthoredBy *[]string `json:"authored_by,omitempty"`

	// Brands Filters for articles belonging to any of the provided brands.
	Brands *[]string `json:"brands,omitempty"`

	// CreatedBy Filters for articles created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `json:"dev_org,omitempty"`

	// Limit The maximum number of articles to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedBy Filters for articles modified by any of the provided users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`

	// OwnedBy Filters for articles owned by any of the provided users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// Scope Filter for the scope of the articles.
	Scope *[]int64 `json:"scope,omitempty"`

	// SharedWith Filter for articles based on intended audience.
	SharedWith *[]SharedWithMembershipFilter `json:"shared_with,omitempty"`

	// Tags Filters for article with any of the provided tags.
	Tags *[]string `json:"tags,omitempty"`
}

// ArticlesListResponseBody List articles response.
type ArticlesListResponseBody struct {
	// Articles The article entries matching the request.
	Articles []Article `json:"articles"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Total Total number of article items for the request.
	Total int32 `json:"total"`
}

// ArticlesUpdateRequest The request to update an article.
type ArticlesUpdateRequest struct {
	AccessLevel    *AccessLevel                         `json:"access_level,omitempty"`
	Aliases        *ArticlesUpdateRequestAliases        `json:"aliases,omitempty"`
	AppliesToParts *ArticlesUpdateRequestAppliesToParts `json:"applies_to_parts,omitempty"`
	Artifacts      *ArticlesUpdateRequestArtifacts      `json:"artifacts,omitempty"`
	AuthoredBy     *ArticlesUpdateRequestAuthoredBy     `json:"authored_by,omitempty"`

	// Brand The updated brand of the article.
	Brand         *string                             `json:"brand"`
	ContentBlocks *ArticlesUpdateRequestContentBlocks `json:"content_blocks,omitempty"`

	// ContentFormat Content format of the article.
	ContentFormat *ArticleContentFormat `json:"content_format,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec                             `json:"custom_schema_spec,omitempty"`
	DataSources      *ArticlesUpdateRequestArticleDataSourceUpdate `json:"data_sources,omitempty"`

	// Description Updated description of the article object, or unchanged if not
	// provided.
	Description      *string                                `json:"description,omitempty"`
	ExtractedContent *ArticlesUpdateRequestExtractedContent `json:"extracted_content,omitempty"`

	// Id The article's ID.
	Id string `json:"id"`

	// Language Updates the language of the article.
	Language *string `json:"language,omitempty"`

	// Notify Whether to notify the users when the article is published.
	Notify  *bool                         `json:"notify,omitempty"`
	OwnedBy *ArticlesUpdateRequestOwnedBy `json:"owned_by,omitempty"`

	// Parent The updated parent directory for the article.
	Parent *string `json:"parent"`

	// PublishedVersion Updates the the latest published version.
	PublishedVersion *string `json:"published_version,omitempty"`

	// ReleaseNotes Updates the release notes of the article.
	ReleaseNotes *string                          `json:"release_notes,omitempty"`
	Reorder      *ArticlesUpdateRequestReorder    `json:"reorder,omitempty"`
	SharedWith   *ArticlesUpdateRequestSharedWith `json:"shared_with,omitempty"`

	// Status Status of the article.
	Status *ArticleStatus             `json:"status,omitempty"`
	Tags   *ArticlesUpdateRequestTags `json:"tags,omitempty"`

	// Title Updated title of the article object, or unchanged if not provided.
	Title *string `json:"title,omitempty"`

	// Url Updates the URL of the external article.
	Url *string `json:"url,omitempty"`
}

// ArticlesUpdateRequestAliases defines model for articles-update-request-aliases.
type ArticlesUpdateRequestAliases struct {
	// Set Updates the aliases of the article.
	Set []string `json:"set"`
}

// ArticlesUpdateRequestAppliesToParts defines model for articles-update-request-applies-to-parts.
type ArticlesUpdateRequestAppliesToParts struct {
	// Set Updates the parts that the article applies to.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestArticleDataSourceUpdate defines model for articles-update-request-article-data-source-update.
type ArticlesUpdateRequestArticleDataSourceUpdate struct {
	// Set Updates data sources provide the backing data for the article.
	Set *[]ArticleDataSourceCreate `json:"set,omitempty"`
}

// ArticlesUpdateRequestArtifacts defines model for articles-update-request-artifacts.
type ArticlesUpdateRequestArtifacts struct {
	// Set Updates IDs of the artifacts.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestAuthoredBy defines model for articles-update-request-authored-by.
type ArticlesUpdateRequestAuthoredBy struct {
	// Set Sets the users that authored the article.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestContentBlocks defines model for articles-update-request-content-blocks.
type ArticlesUpdateRequestContentBlocks struct {
	// Set Updates IDs of the content blocks.
	Set []string `json:"set"`
}

// ArticlesUpdateRequestExtractedContent defines model for articles-update-request-extracted-content.
type ArticlesUpdateRequestExtractedContent struct {
	// Set Update the ID of the extracted content.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestOwnedBy defines model for articles-update-request-owned-by.
type ArticlesUpdateRequestOwnedBy struct {
	// Set Sets the owner IDs to the provided user IDs. This must not be
	// empty.
	Set *[]string `json:"set,omitempty"`
}

// ArticlesUpdateRequestReorder defines model for articles-update-request-reorder.
type ArticlesUpdateRequestReorder struct {
	// After The article after which the reordered article is placed.
	After *string `json:"after,omitempty"`

	// Before The article before which the reordered article is placed.
	Before *string `json:"before,omitempty"`
}

// ArticlesUpdateRequestSharedWith defines model for articles-update-request-shared-with.
type ArticlesUpdateRequestSharedWith struct {
	// Set Sets the field to the provided membership list.
	Set *[]SetSharedWithMembership `json:"set,omitempty"`
}

// ArticlesUpdateRequestTags defines model for articles-update-request-tags.
type ArticlesUpdateRequestTags struct {
	// Set Sets the provided tags on the article.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// ArticlesUpdateResponseBody defines model for articles-update-response.
type ArticlesUpdateResponseBody struct {
	Article Article `json:"article"`
}

// Artifact defines model for artifact.
type Artifact struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// File Defines a file object.
	File *ArtifactFile `json:"file,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// ArtifactConfigurationSet Represents a set of configuration to be used with the artifacts object.
type ArtifactConfigurationSet string

// ArtifactFile Defines a file object.
type ArtifactFile struct {
	// Name Name of the file.
	Name *string `json:"name,omitempty"`

	// Size Size of the file in bytes.
	Size *int32 `json:"size,omitempty"`

	// Type Type of the file.
	Type *string `json:"type,omitempty"`
}

// ArtifactFileSummary Defines a file object.
type ArtifactFileSummary struct {
	// Name Name of the file.
	Name *string `json:"name,omitempty"`

	// Size Size of the file in bytes.
	Size *int32 `json:"size,omitempty"`

	// Type Type of the file.
	Type *string `json:"type,omitempty"`
}

// ArtifactSearchSummary defines model for artifact-search-summary.
type ArtifactSearchSummary struct {
	Artifact ArtifactSummary `json:"artifact"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// ArtifactSummary defines model for artifact-summary.
type ArtifactSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// File Defines a file object.
	File *ArtifactFileSummary `json:"file,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`
}

// ArtifactVersion The version of the artifact.
type ArtifactVersion struct {
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// Timestamp The timestamp at which the version was created.
	Timestamp time.Time `json:"timestamp"`

	// Version The version of the artifact.
	Version string `json:"version"`
}

// ArtifactsGetRequest The request to get an artifact's information.
type ArtifactsGetRequest struct {
	// Id The requested artifact's ID.
	Id string `json:"id"`

	// Version The version of the artifact that needs to be fetched.
	Version *string `json:"version,omitempty"`
}

// ArtifactsGetResponseBody The response to getting an artifact's information.
type ArtifactsGetResponseBody struct {
	Artifact Artifact `json:"artifact"`

	// Version The version of the artifact.
	Version ArtifactVersion `json:"version"`
}

// ArtifactsHardDeleteVersionRequest The request to permnanently delete an artifact's version.
type ArtifactsHardDeleteVersionRequest struct {
	// Id The ID of the artifact to delete the version for.
	Id string `json:"id"`

	// Version The version of the artifact that needs to be deleted.
	Version *string `json:"version,omitempty"`
}

// ArtifactsHardDeleteVersionResponseBody defines model for artifacts-hard-delete-version-response.
type ArtifactsHardDeleteVersionResponseBody = map[string]interface{}

// ArtifactsListRequest The request to list artifacts attached to an object.
type ArtifactsListRequest struct {
	// ParentId The ID of the object to filter artifacts.
	ParentId *string `json:"parent_id,omitempty"`
}

// ArtifactsListResponseBody The response to list artifacts attached to an object.
type ArtifactsListResponseBody struct {
	// Artifacts The artifact's information.
	Artifacts []Artifact `json:"artifacts"`
}

// ArtifactsLocateRequest The request to get an artifact's download URL.
type ArtifactsLocateRequest struct {
	// Id The ID of the artifact to get the URL for.
	Id string `json:"id"`

	// Version The version of the artifact that needs to be fetched.
	Version *string `json:"version,omitempty"`
}

// ArtifactsLocateResponseBody The response to getting an artifact's download URL.
type ArtifactsLocateResponseBody struct {
	// ExpiresAt The expiration timestamp of the URL.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Url The artifact's download URL.
	Url string `json:"url"`
}

// ArtifactsPrepareRequest The request to prepare a URL to upload a file.
type ArtifactsPrepareRequest struct {
	// ConfigurationSet Represents a set of configuration to be used with the artifacts object.
	ConfigurationSet *ArtifactConfigurationSet `json:"configuration_set,omitempty"`

	// FileName The name of the file that's being uploaded.
	FileName string `json:"file_name"`

	// FileType The type of file that's being uploaded.
	FileType *string `json:"file_type,omitempty"`
}

// ArtifactsPrepareResponseBody The response to preparing a URL to upload a file.
type ArtifactsPrepareResponseBody struct {
	// FormData The POST policy form data.
	FormData []ArtifactsPrepareResponseFormData `json:"form_data"`

	// Id The generated artifact's ID.
	Id string `json:"id"`

	// Url The URL that the file's data should be uploaded to.
	Url string `json:"url"`
}

// ArtifactsPrepareResponseFormData defines model for artifacts-prepare-response-form-data.
type ArtifactsPrepareResponseFormData struct {
	// Key Key of the form field.
	Key string `json:"key"`

	// Value Value corresponding to the key.
	Value string `json:"value"`
}

// ArtifactsVersionsPrepareRequest The request to prepare a new version of an artifact.
type ArtifactsVersionsPrepareRequest struct {
	// Id The ID of the artifact to prepare a new version for.
	Id string `json:"id"`
}

// ArtifactsVersionsPrepareResponseBody The response to preparing a new artifact version.
type ArtifactsVersionsPrepareResponseBody struct {
	// FormData The POST policy form data.
	FormData []ArtifactsVersionsPrepareResponseFormData `json:"form_data"`

	// Url The URL that the file's data should be uploaded to.
	Url string `json:"url"`
}

// ArtifactsVersionsPrepareResponseFormData defines model for artifacts-versions-prepare-response-form-data.
type ArtifactsVersionsPrepareResponseFormData struct {
	// Key Key of the form field.
	Key string `json:"key"`

	// Value Value corresponding to the key.
	Value string `json:"value"`
}

// AssociatedToSummary defines model for associated-to-summary.
type AssociatedToSummary struct {
	Type  AssociatedToType `json:"type"`
	union json.RawMessage
}

// AssociatedToType defines model for associated-to-type.
type AssociatedToType string

// Atom defines model for atom.
type Atom struct {
	Type  AtomType `json:"type"`
	union json.RawMessage
}

// AtomBase defines model for atom-base.
type AtomBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// AtomBaseSummary defines model for atom-base-summary.
type AtomBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`
}

// AtomSummary defines model for atom-summary.
type AtomSummary struct {
	Type  AtomType `json:"type"`
	union json.RawMessage
}

// AtomType defines model for atom-type.
type AtomType string

// AtomsGetRequest defines model for atoms-get-request.
type AtomsGetRequest struct {
	// Id The ID of the object to get.
	Id string `json:"id"`
}

// AtomsGetResponseBody defines model for atoms-get-response.
type AtomsGetResponseBody struct {
	Atom Atom `json:"atom"`
}

// AuthConnection Connection object that specifies the configuration for an
// authentication connection that is set up for a Dev organization.
type AuthConnection struct {
	// DisplayName Display name of the authentication connection. This name will be
	// visible to all the users when they sign in to this Dev
	// organization. For example, if the display_name is 'abclogin', then
	// it would appear on the login button as 'Log in to abclogin'.
	DisplayName string `json:"display_name"`

	// Enabled Whether the authentication connection is enabled or disabled. If
	// set to false, the authentication connection will not show up on the
	// login screen as a login option.
	Enabled bool `json:"enabled"`

	// Id ID of the authentication connection.
	Id string `json:"id"`

	// Type Defines the type for the authentication connection. The configuration
	// for each authentication connection will depend on the type value.
	Type  AuthConnectionType `json:"type"`
	union json.RawMessage
}

// AuthConnectionOptionsAzureAd Object encapsulating the configuration parameters for an Azure AD
// authentication connection.
type AuthConnectionOptionsAzureAd struct {
	// ClientId Client ID for the Azure authentication connection.
	ClientId string `json:"client_id"`

	// Domain Domain URL of the Azure authentication connection.
	Domain string `json:"domain"`
}

// AuthConnectionOptionsGoogleApps Object encapsulating the configuration parameters for a Google Apps
// authentication connection.
type AuthConnectionOptionsGoogleApps struct {
	// ClientId Client ID for the Google Apps authentication connection.
	ClientId string `json:"client_id"`

	// TenantDomain Tenant domain URL of the Google Apps authentication connection.
	TenantDomain string `json:"tenant_domain"`
}

// AuthConnectionOptionsOidc Object encapsulating the configuration parameters for an OIDC
// authentication connection.
type AuthConnectionOptionsOidc struct {
	// ClientId Client ID for the OIDC authentication connection.
	ClientId string `json:"client_id"`

	// Issuer Issuer URL of the OIDC authentication connection.
	Issuer string `json:"issuer"`
}

// AuthConnectionOptionsOkta Object encapsulating the configuration parameters for an Okta
// authentication connection.
type AuthConnectionOptionsOkta struct {
	// ClientId Client ID for the Okta authentication connection.
	ClientId string `json:"client_id"`

	// Domain Domain URL of the Okta authentication connection.
	Domain string `json:"domain"`
}

// AuthConnectionOptionsSaml Object encapsulating the configuration parameters for a SAML
// authentication connection.
type AuthConnectionOptionsSaml struct {
	// ConnectionName Connection name for the SAML authentication connection. Must match
	// the `connection` query parameter specified in the sign on URL
	// during SAML configuration in your identity provider.
	ConnectionName *string                 `json:"connection_name,omitempty"`
	FieldsMap      SamlConnectionFieldsMap `json:"fields_map"`

	// SignInEndpoint Sign In endpoint for the SAML authentication connection.
	SignInEndpoint string `json:"sign_in_endpoint"`
}

// AuthConnectionOptionsSocial defines model for auth-connection-options-social.
type AuthConnectionOptionsSocial = map[string]interface{}

// AuthConnectionToggle defines model for auth-connection-toggle.
type AuthConnectionToggle string

// AuthConnectionType Defines the type for the authentication connection. The configuration
// for each authentication connection will depend on the type value.
type AuthConnectionType string

// AuthToken defines model for auth-token.
type AuthToken struct {
	// ClientId An identifier that represents the application that requested the
	// token. Only applicable for application access tokens.
	ClientId  *string      `json:"client_id,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ExpiresAt The time at which the token expires.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IssuedAt The time at which the token was issued.
	IssuedAt   *time.Time   `json:"issued_at,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// RequestedTokenType The type of the requested token.
	RequestedTokenType *AuthTokenRequestedTokenType `json:"requested_token_type,omitempty"`

	// Scopes The scopes associated with the issued token.
	Scopes *[]string `json:"scopes,omitempty"`

	// Status The status of the token.
	Status *AuthTokenStatus `json:"status,omitempty"`

	// Subject The subject of the token.
	Subject *string `json:"subject,omitempty"`

	// TokenHint A hint that identifies the token.
	TokenHint *string `json:"token_hint,omitempty"`
}

// AuthTokenGrantType Specifies the process of obtaining a token.
type AuthTokenGrantType string

// AuthTokenRequestedTokenType The type of the requested token.
type AuthTokenRequestedTokenType string

// AuthTokenStatus The status of the token.
type AuthTokenStatus string

// AuthTokenSubjectTokenType The type of the subject token.
type AuthTokenSubjectTokenType string

// AuthTokenSummary defines model for auth-token-summary.
type AuthTokenSummary = AtomBaseSummary

// AuthTokenTokenType The type of the issued token. Bearer is the only supported token type.
type AuthTokenTokenType string

// AuthTokensAccountTraits Carries account info.
type AuthTokensAccountTraits struct {
	// DisplayName The display name of the account.
	DisplayName *string `json:"display_name,omitempty"`

	// Domains List of company's domain names on accounts. Example -
	// ['devrev.ai'].
	Domains *[]string `json:"domains,omitempty"`
}

// AuthTokensCreateRequest A request to create a new token corresponding to the requested token
// type.
type AuthTokensCreateRequest struct {
	// ActAs The unique ID of the Dev user or the service account to
	// impersonate.
	ActAs *string `json:"act_as,omitempty"`

	// Aud The expected audience values with respect to the token.
	Aud *[]string `json:"aud,omitempty"`

	// ClientId An identifier that represents the application which is requesting
	// the token. If no client_id is present in the request to generate an
	// application access token (AAT), DevRev will generate a client_id.
	// This client_id is only associated with an AAT.
	ClientId *string `json:"client_id,omitempty"`

	// ExpiresIn The expected validity lifetime of the token in number of days. In
	// practice, the value should be based on the usage of the token.
	ExpiresIn *int `json:"expires_in,omitempty"`

	// GrantType Specifies the process of obtaining a token.
	GrantType *AuthTokenGrantType `json:"grant_type,omitempty"`

	// RequestedTokenType The type of the requested token.
	RequestedTokenType *AuthTokenRequestedTokenType `json:"requested_token_type,omitempty"`

	// RevInfo Carries info corresponding to the Rev user to be provisioned and/or
	// issue a Rev session token.
	RevInfo *AuthTokensRevInfo `json:"rev_info,omitempty"`

	// Scope The requested set of scopes associated with the issued token. A
	// space-delimited list of values in which the order of values does
	// not matter.
	Scope *string `json:"scope,omitempty"`

	// SubjectToken Represents the entity that requests the token. Not required when
	// requesting an application access token (AAT).
	SubjectToken *string `json:"subject_token,omitempty"`

	// SubjectTokenType The type of the subject token.
	SubjectTokenType *AuthTokenSubjectTokenType `json:"subject_token_type,omitempty"`

	// TokenHint A hint that identifies the token.
	TokenHint *string `json:"token_hint,omitempty"`
}

// AuthTokensCreateResponseBody Response for the request to create a new token corresponding to the
// requested token type.
type AuthTokensCreateResponseBody struct {
	// AccessToken The issued JSON Web Token (JWT) corresponding to the requested
	// token type.
	AccessToken string `json:"access_token"`

	// ClientId An identifier that represents the application which is requesting
	// the token. Only present in a response corresponding to an
	// application access token (AAT).
	ClientId *string `json:"client_id,omitempty"`

	// ExpiresIn The validity lifetime of the token specified in seconds since Unix
	// epoch.
	ExpiresIn int64 `json:"expires_in"`

	// RefreshToken A token to refresh the issued token.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope The scopes associated with the issued token. A space-delimited list
	// of values in which the order of values does not matter.
	Scope *string `json:"scope,omitempty"`

	// TokenType The type of the issued token. Bearer is the only supported token type.
	TokenType AuthTokenTokenType `json:"token_type"`
}

// AuthTokensDeleteRequest The request to revoke the token.
type AuthTokensDeleteRequest struct {
	// TokenId The unique identifier for the token under a given Dev organization.
	// If no token ID is provided, then the token ID will be set from the
	// JTI claim of the token in the authorization header.
	TokenId *string `json:"token_id,omitempty"`
}

// AuthTokensGetRequest The request to get the token metadata.
type AuthTokensGetRequest struct {
	// TokenId The unique identifier of the token under a given Dev organization.
	TokenId string `json:"token_id"`
}

// AuthTokensGetResponseBody The response to get the token metadata.
type AuthTokensGetResponseBody struct {
	Token AuthToken `json:"token"`
}

// AuthTokensInfoRequest The request to get the Dev organization, user and token attributes
// extracted from the auth token.
type AuthTokensInfoRequest = map[string]interface{}

// AuthTokensInfoResponseBody The Dev organization, user and token attributes extracted from the auth
// token.
type AuthTokensInfoResponseBody struct {
	// Organization The Dev organization attributes extracted from the auth token.
	Organization AuthTokensOrgAttributes `json:"organization"`

	// Token The token attributes extracted from the auth token.
	Token AuthTokensTokenAttributes `json:"token"`

	// User The user attributes extracted from the auth token.
	User AuthTokensUserAttributes `json:"user"`
}

// AuthTokensListRequest A request to list the token metadata.
type AuthTokensListRequest struct {
	// ClientId An identifier that represents the application, which requested the
	// token. Only relevant for application access tokens.
	ClientId *string `json:"client_id,omitempty"`

	// RequestedTokenType The type of the requested token.
	RequestedTokenType *AuthTokenRequestedTokenType `json:"requested_token_type,omitempty"`

	// Subject The subject associated with the token. In the absence of this
	// parameter, the ID of the authenticated entity is treated as the
	// subject.
	Subject *string `json:"subject,omitempty"`
}

// AuthTokensListResponseBody The response to list the token metadata.
type AuthTokensListResponseBody struct {
	// Tokens The list of token metadata.
	Tokens []AuthToken `json:"tokens"`
}

// AuthTokensOrgAttributes The Dev organization attributes extracted from the auth token.
type AuthTokensOrgAttributes struct {
	// DisplayId The display ID of the Dev organization.
	DisplayId string `json:"display_id"`

	// Id The ID of the the Dev organization.
	Id string `json:"id"`

	// Slug The slug of the Dev organization.
	Slug *string `json:"slug,omitempty"`
}

// AuthTokensOrgTraits Carries Rev org info.
type AuthTokensOrgTraits struct {
	// CustomFields Application-defined custom fields of the Rev org.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Description The description of the Rev org.
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the Rev org.
	DisplayName *string `json:"display_name,omitempty"`

	// Domain The domain of the Rev org.
	// Deprecated:
	Domain *string `json:"domain,omitempty"`

	// PhoneNumbers Phone numbers of the Rev org.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`

	// Tier The tier of the Rev org.
	Tier *string `json:"tier,omitempty"`
}

// AuthTokensRevInfo Carries info corresponding to the Rev user to be provisioned and/or
// issue a Rev session token.
type AuthTokensRevInfo struct {
	// AccountRef An identifier which uniquely identifies an account.
	AccountRef *string `json:"account_ref,omitempty"`

	// AccountTraits Carries account info.
	AccountTraits *AuthTokensAccountTraits `json:"account_traits,omitempty"`

	// OrgRef An identifier which uniquely identifies a Rev org.
	// Deprecated:
	OrgRef *string `json:"org_ref,omitempty"`

	// OrgTraits Carries Rev org info.
	OrgTraits *AuthTokensOrgTraits `json:"org_traits,omitempty"`

	// UserId The unique ID of the Rev user.
	UserId *string `json:"user_id,omitempty"`

	// UserRef An identifier which uniquely identifies a Rev user.
	UserRef *string `json:"user_ref,omitempty"`

	// UserTraits Carries Rev user info.
	UserTraits *AuthTokensUserTraits `json:"user_traits,omitempty"`

	// WorkspaceRef An identifier which uniquely identifies a workspace.
	WorkspaceRef *string `json:"workspace_ref,omitempty"`

	// WorkspaceTraits Carries Rev org info.
	WorkspaceTraits *AuthTokensOrgTraits `json:"workspace_traits,omitempty"`
}

// AuthTokensSelfDeleteRequest The request to delete all the tokens created by the authenticated user,
// that match with the provided token type.
type AuthTokensSelfDeleteRequest struct {
	// RequestedTokenType The type of the requested token.
	RequestedTokenType *AuthTokenRequestedTokenType `json:"requested_token_type,omitempty"`
}

// AuthTokensTokenAttributes The token attributes extracted from the auth token.
type AuthTokensTokenAttributes struct {
	// Expiry The expiry (exp) of the token in seconds from Unix epoch.
	Expiry int64 `json:"expiry"`

	// IssuedAt The issued at (iat) time of the token in seconds from Unix epoch.
	IssuedAt int64 `json:"issued_at"`

	// Issuer The issuer ID (iss) of the token.
	Issuer string `json:"issuer"`

	// Subject The subject (sub) of the token.
	Subject string `json:"subject"`
}

// AuthTokensUpdateRequest A request to update the token metadata.
type AuthTokensUpdateRequest struct {
	// TokenHint A hint that identifies the token.
	TokenHint string `json:"token_hint"`

	// TokenId The unique identifier of the token under a given Dev organization.
	TokenId string `json:"token_id"`
}

// AuthTokensUpdateResponseBody Response for the request to update the token metadata.
type AuthTokensUpdateResponseBody struct {
	Token AuthToken `json:"token"`
}

// AuthTokensUserAttributes The user attributes extracted from the auth token.
type AuthTokensUserAttributes struct {
	// DisplayId The display ID of the user.
	DisplayId string `json:"display_id"`

	// DisplayName The display name of the user.
	DisplayName *string `json:"display_name,omitempty"`

	// Email The email address of the user.
	Email *string `json:"email,omitempty"`

	// FullName The full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id The ID of the user.
	Id   string   `json:"id"`
	Type UserType `json:"type"`
}

// AuthTokensUserTraits Carries Rev user info.
type AuthTokensUserTraits struct {
	// CustomFields Application-defined custom fields of the Rev user.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Description The description of the Rev user.
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the Rev user.
	DisplayName *string `json:"display_name,omitempty"`

	// Email The email address of the Rev user.
	Email *string `json:"email,omitempty"`

	// FullName The full name of the Rev user.
	// Deprecated:
	FullName *string `json:"full_name,omitempty"`

	// PhoneNumbers Phone numbers of the Rev user.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`
}

// AvailabilityPreferencesGroup Preferences group for Availability.
type AvailabilityPreferencesGroup struct {
	// ManualAway Manually set presence to away.
	ManualAway *bool `json:"manual_away,omitempty"`
}

// BarVisualizationXAxis The X-axis for a bar visualization.
type BarVisualizationXAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// BarVisualizationYAxis The Y-axis for a bar visualization.
type BarVisualizationYAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// BarWidgetVisualization A bar chart visualization configuration. Includes metadata specific to
// bar charts.
type BarWidgetVisualization struct {
	// IsStacked Whether the bar should be stacked.
	IsStacked *bool `json:"is_stacked,omitempty"`

	// Scrollbar The scrollbar configuration for chart.
	Scrollbar *VisualizationScrollbar `json:"scrollbar,omitempty"`

	// ShowDataLabels Whether to show data labels.
	ShowDataLabels *bool `json:"show_data_labels,omitempty"`

	// X The configuration for the X-axis.
	X []BarVisualizationXAxis `json:"x"`

	// Y The configuration for the Y-axes.
	Y []BarVisualizationYAxis `json:"y"`
}

// BooleanExpression Boolean expression.
type BooleanExpression struct {
	Type  BooleanExpressionType `json:"type"`
	union json.RawMessage
}

// BooleanExpressionAndExpression All the expressions would be 'and'ed together.
type BooleanExpressionAndExpression struct {
	Expressions []BooleanExpression `json:"expressions"`
}

// BooleanExpressionNotExpression The expression would be negated.
type BooleanExpressionNotExpression struct {
	// Expression Boolean expression.
	Expression BooleanExpression `json:"expression"`
}

// BooleanExpressionOrExpression All the expressions would be 'or'ed together.
type BooleanExpressionOrExpression struct {
	Expressions []BooleanExpression `json:"expressions"`
}

// BooleanExpressionPrimitiveExpression The primitive expression type.
type BooleanExpressionPrimitiveExpression = map[string]interface{}

// BooleanExpressionType defines model for boolean-expression-type.
type BooleanExpressionType string

// Brand defines model for brand.
type Brand struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description The description of the brand.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name The name of the brand.
	Name *string `json:"name,omitempty"`
}

// BrandsCreateRequest Request object to create a new brand.
type BrandsCreateRequest struct {
	// Description Description of the brand to be created.
	Description *string `json:"description,omitempty"`

	// Name Name of the brand to be created.
	Name string `json:"name"`
}

// BrandsCreateResponseBody Response object for creating a new brand.
type BrandsCreateResponseBody struct {
	Brand Brand `json:"brand"`
}

// BrandsDeleteRequest Request object to delete a brand.
type BrandsDeleteRequest struct {
	// Id The ID of the brand to be deleted.
	Id string `json:"id"`
}

// BrandsDeleteResponseBody defines model for brands-delete-response.
type BrandsDeleteResponseBody = map[string]interface{}

// BrandsGetRequest Request object to get a brands information.
type BrandsGetRequest struct {
	// Id The ID of the brand to be retrieved.
	Id string `json:"id"`
}

// BrandsGetResponseBody Response object for getting a brand.
type BrandsGetResponseBody struct {
	Brand Brand `json:"brand"`
}

// BrandsListRequest Request object to list brands.
type BrandsListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`
}

// BrandsListResponseBody Response object for listing all brands.
type BrandsListResponseBody struct {
	// Brands List of brands.
	Brands []Brand `json:"brands"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// BrandsUpdateRequest Request object to update a brand.
type BrandsUpdateRequest struct {
	// Description Description of the brand to be updated.
	Description *string `json:"description,omitempty"`

	// Id The ID of the brand to be updated.
	Id string `json:"id"`

	// Name Name of the brand to be updated.
	Name *string `json:"name,omitempty"`
}

// BrandsUpdateResponseBody Response object for updating a brand.
type BrandsUpdateResponseBody struct {
	Brand Brand `json:"brand"`
}

// Capability defines model for capability.
type Capability = PartBase

// CapabilitySummary defines model for capability-summary.
type CapabilitySummary = PartBaseSummary

// Chat defines model for chat.
type Chat struct {
	Type  ChatType `json:"type"`
	union json.RawMessage
}

// ChatBase defines model for chat-base.
type ChatBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Title The title given to the chat.
	Title *string `json:"title,omitempty"`
}

// ChatBaseSummary defines model for chat-base-summary.
type ChatBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`

	// Title The title given to the chat.
	Title *string `json:"title,omitempty"`
}

// ChatCompletionsRequest The request to complete a chat conversation.
type ChatCompletionsRequest struct {
	// MaxTokens The maximum number of tokens that can be generated in the chat
	// completion.
	MaxTokens *int32 `json:"max_tokens,omitempty"`

	// Messages A list of messages comprising the conversation so far.
	Messages []ChatCompletionsRequestMessage `json:"messages"`

	// StopSequences Sequences where the API will stop generating further tokens.
	// Maximum of 4 sequences are supported. Defaults to none.
	StopSequences *[]string `json:"stop_sequences,omitempty"`

	// Stream If set, partial message deltas will be sent. Defaults to false.
	Stream *bool `json:"stream,omitempty"`

	// Temperature What sampling temperature to use. Value can be between 0 and 2 and
	// defaults to 1.0. Higher values like 0.8 will make the output more
	// random, while lower values like 0.2 will make it more focused and
	// deterministic.
	Temperature *float32 `json:"temperature,omitempty"`

	// TopP An alternative to sampling with temperature, called nucleus
	// sampling, where the model considers the results of the tokens with
	// top_p probability mass. So 0.1 means only the tokens comprising the
	// top 10% probability mass are considered. For openai: Between 0 and
	// 1. Defaults to 1.0.
	TopP *float32 `json:"top_p,omitempty"`
}

// ChatCompletionsRequestMessage defines model for chat-completions-request-message.
type ChatCompletionsRequestMessage struct {
	// Content Text content of the message.
	Content string `json:"content"`

	// Role The role of the entity that is creating the message.
	Role ChatCompletionsRequestMessageRole `json:"role"`
}

// ChatCompletionsRequestMessageRole The role of the entity that is creating the message.
type ChatCompletionsRequestMessageRole string

// ChatCompletionsResponseBody The response for the generated chat completion.
type ChatCompletionsResponseBody struct {
	// TextResponse Text response generated for the chat.
	TextResponse *string `json:"text_response,omitempty"`
}

// ChatType defines model for chat-type.
type ChatType string

// ChatsCreateRequest defines model for chats-create-request.
type ChatsCreateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// GetIfConflict If true and a chat already exists with unique properties that
	// conflict with the chat creation, then the existing chat is returned
	// without error, otherwise if false, a conflict error is returned.
	GetIfConflict *bool `json:"get_if_conflict,omitempty"`

	// Title The title for the chat.
	Title *string  `json:"title,omitempty"`
	Type  ChatType `json:"type"`
	union json.RawMessage
}

// ChatsCreateRequestDm defines model for chats-create-request-dm.
type ChatsCreateRequestDm struct {
	// IsDefault Whether this is the default DM for messaging the constituent users.
	// If true, then this DM is always returned when opening a DM for the
	// users. Note only one DM may be the default for a given set of
	// users. By Default, this is true.
	IsDefault *bool `json:"is_default,omitempty"`

	// Records The associated records for this DM.
	Records *[]string `json:"records,omitempty"`

	// Users The users to send direct messages to. The authenticated user must
	// be included in this list.
	Users []string `json:"users"`
}

// ChatsCreateResponseBody defines model for chats-create-response.
type ChatsCreateResponseBody struct {
	Chat Chat `json:"chat"`
}

// ChatsGetRequest defines model for chats-get-request.
type ChatsGetRequest struct {
	// Id The chat's ID.
	Id    *string   `json:"id,omitempty"`
	Type  *ChatType `json:"type,omitempty"`
	union json.RawMessage
}

// ChatsGetRequestDm defines model for chats-get-request-dm.
type ChatsGetRequestDm struct {
	// Users The users to send direct messages to. Note the authenticated user
	// must be included in this list.
	Users []string `json:"users"`
}

// ChatsGetResponseBody defines model for chats-get-response.
type ChatsGetResponseBody struct {
	Chat Chat `json:"chat"`
}

// ChatsUpdateRequest defines model for chats-update-request.
type ChatsUpdateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Id The chat's ID.
	Id string `json:"id"`

	// Title The updated title for the chat, or unchanged if not provided.
	Title *string   `json:"title,omitempty"`
	Type  *ChatType `json:"type,omitempty"`
	union json.RawMessage
}

// ChatsUpdateRequestDm defines model for chats-update-request-dm.
type ChatsUpdateRequestDm struct {
	Records *ChatsUpdateRequestDmRecords `json:"records,omitempty"`
	Users   *ChatsUpdateRequestDmUsers   `json:"users,omitempty"`
}

// ChatsUpdateRequestDmRecords defines model for chats-update-request-dm-records.
type ChatsUpdateRequestDmRecords struct {
	// Set The associated records to set for this DM.
	Set *[]string `json:"set,omitempty"`
}

// ChatsUpdateRequestDmUsers defines model for chats-update-request-dm-users.
type ChatsUpdateRequestDmUsers struct {
	// Set The updated list of users to send direct messages to. The
	// authenticated user must be included in this list.
	Set []string `json:"set"`
}

// ChatsUpdateResponseBody defines model for chats-update-response.
type ChatsUpdateResponseBody struct {
	Chat Chat `json:"chat"`
}

// ClientContext Properties of client to be used in track API.
type ClientContext struct {
	// Browser Properties of client's browser to be used in track API.
	Browser *ClientContextBrowser `json:"browser,omitempty"`

	// Cpu Properties of client's CPU to be used in track API.
	Cpu *ClientContextCpu `json:"cpu,omitempty"`

	// Device Properties of client's device to be used in track API.
	Device *ClientContextDevice `json:"device,omitempty"`

	// Engine Properties of client's engine to be used in track API.
	Engine *ClientContextEngine `json:"engine,omitempty"`

	// Ip IP address of the client.
	Ip *string `json:"ip,omitempty"`

	// Locale The client's locale, example: en-US.
	Locale *string `json:"locale,omitempty"`

	// Os Properties of client's OS to be used in track API.
	Os *ClientContextOs `json:"os,omitempty"`

	// Page Properties of client's page to be used in track API.
	Page *ClientContextPage `json:"page,omitempty"`

	// Timezone The client's timezone, example: Asia/Kolkata.
	Timezone *string `json:"timezone,omitempty"`

	// UserAgent User agent of the client, example: Mozilla/5.0 (Macintosh; Intel
	// Mac OS X.
	UserAgent *string `json:"user_agent,omitempty"`
}

// ClientContextBrowser Properties of client's browser to be used in track API.
type ClientContextBrowser struct {
	// Name The browser's name, example: Chrome, Safari.
	Name *string `json:"name,omitempty"`

	// Version The browser's version, example: 53.0.2785.143.
	Version *string `json:"version,omitempty"`
}

// ClientContextCpu Properties of client's CPU to be used in track API.
type ClientContextCpu struct {
	// Architecture CPU architecture, example: amd64.
	Architecture *string `json:"architecture,omitempty"`
}

// ClientContextDevice Properties of client's device to be used in track API.
type ClientContextDevice struct {
	// Manufacturer Device manufacturer, example: Apple.
	Manufacturer *string `json:"manufacturer,omitempty"`

	// Model Device model, example: iphone 6s.
	Model *string `json:"model,omitempty"`

	// Type Device type, example: mobile, tablet, desktop.
	Type *string `json:"type,omitempty"`
}

// ClientContextEngine Properties of client's engine to be used in track API.
type ClientContextEngine struct {
	// Name The engine's name, example: Blink, WebKit.
	Name *string `json:"name,omitempty"`

	// Version The engine's version, example: 537.36.
	Version *string `json:"version,omitempty"`
}

// ClientContextOs Properties of client's OS to be used in track API.
type ClientContextOs struct {
	// Name The OS's name, example : Windows, Mac OS X.
	Name *string `json:"name,omitempty"`

	// Version The OS's version, example : 10.11.1.
	Version *string `json:"version,omitempty"`
}

// ClientContextPage Properties of client's page to be used in track API.
type ClientContextPage struct {
	// Domain Page domain, example: devrev.ai
	Domain *string `json:"domain,omitempty"`

	// Path Page path, example: /pricing
	Path *string `json:"path,omitempty"`

	// Referrer Page referrer, example: https://devrev.ai
	Referrer *string `json:"referrer,omitempty"`

	// Title Page title, example: Pricing
	Title *string `json:"title,omitempty"`

	// Url Page URL, example: https://devrev.ai/pricing
	Url *string `json:"url,omitempty"`
}

// ClientOverride UI hint overrides for a client.
type ClientOverride struct {
	// ClientName The name of the client.
	ClientName *string `json:"client_name,omitempty"`

	// DisplayName The display name of the field.
	DisplayName *string `json:"display_name,omitempty"`

	// IsGroupable Whether the field is groupable in the UI.
	IsGroupable *bool `json:"is_groupable,omitempty"`

	// IsHidden Whether the field is hidden in the UI.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsRequired Whether the field is mandatory.
	IsRequired *bool `json:"is_required,omitempty"`

	// Placeholder A placeholder for the field.
	Placeholder *string `json:"placeholder,omitempty"`

	// Tooltip Tooltip for the field.
	Tooltip *string `json:"tooltip,omitempty"`

	// ViewOverrides The view overrides for the client.
	ViewOverrides *[]ViewOverride `json:"view_overrides,omitempty"`
}

// CodeChange defines model for code-change.
type CodeChange struct {
	// Branch Name of the code branch in the repo.
	Branch *string `json:"branch,omitempty"`

	// ClosedDate Time at which the code change corresponding to this object reached
	// a closed or merged stage. For example, the time at which a Pull
	// Request was either closed without merging or successfully merged.
	ClosedDate *time.Time `json:"closed_date,omitempty"`

	// CommitId Commit ID of the merged commit in the target branch.
	CommitId  *string      `json:"commit_id,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Detailed description of the contents of this change.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ExternalIdentifier Unique external identifier for this change.e.g Pull Request URL.
	ExternalIdentifier *string `json:"external_identifier,omitempty"`

	// FilteredLoc Details of lines of code in this code change.
	FilteredLoc *LinesOfCode `json:"filtered_loc,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// RepoUrl URL pointing to the repo this change was on.
	RepoUrl *string `json:"repo_url,omitempty"`

	// Source Source of the code change object.
	Source *CodeChangeSource `json:"source,omitempty"`

	// TargetBranch Name of the target branch in the repo.
	TargetBranch *string `json:"target_branch,omitempty"`

	// Title Title describing in brief the contents of this change.
	Title *string `json:"title,omitempty"`

	// TotalLoc Details of lines of code in this code change.
	TotalLoc *LinesOfCode `json:"total_loc,omitempty"`
}

// CodeChangeSource Source of the code change object.
type CodeChangeSource string

// CodeChangeSummary defines model for code-change-summary.
type CodeChangeSummary = AtomBaseSummary

// CodeChangesCreateRequest defines model for code-changes-create-request.
type CodeChangesCreateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`
}

// CodeChangesCreateResponseBody defines model for code-changes-create-response.
type CodeChangesCreateResponseBody struct {
	CodeChange CodeChange `json:"code_change"`
}

// CodeChangesDeleteRequest defines model for code-changes-delete-request.
type CodeChangesDeleteRequest struct {
	// Id ID of the code change object which is to be deleted.
	Id string `json:"id"`
}

// CodeChangesDeleteResponseBody defines model for code-changes-delete-response.
type CodeChangesDeleteResponseBody = map[string]interface{}

// CodeChangesGetRequest defines model for code-changes-get-request.
type CodeChangesGetRequest struct {
	// Id The code change object ID.
	Id string `json:"id"`
}

// CodeChangesGetResponseBody defines model for code-changes-get-response.
type CodeChangesGetResponseBody struct {
	CodeChange CodeChange `json:"code_change"`
}

// CodeChangesListRequest defines model for code-changes-list-request.
type CodeChangesListRequest struct {
	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of code change objects to return. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`
}

// CodeChangesListResponseBody defines model for code-changes-list-response.
type CodeChangesListResponseBody struct {
	// CodeChanges The list of requested code change objects.
	CodeChanges []CodeChange `json:"code_changes"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// CodeChangesUpdateRequest defines model for code-changes-update-request.
type CodeChangesUpdateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Id The ID of the code change object to be updated.
	Id string `json:"id"`
}

// CodeChangesUpdateResponseBody defines model for code-changes-update-response.
type CodeChangesUpdateResponseBody struct {
	CodeChange CodeChange `json:"code_change"`
}

// ColumnVisualizationXAxis The X-axis for a column visualization.
type ColumnVisualizationXAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// ColumnVisualizationYAxis The Y-axis for a column visualization.
type ColumnVisualizationYAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// ColumnWidgetVisualization A column chart visualization configuration. Includes metadata specific
// to column charts.
type ColumnWidgetVisualization struct {
	// IsStacked Whether the columns should be stacked.
	IsStacked *bool `json:"is_stacked,omitempty"`

	// Scrollbar The scrollbar configuration for chart.
	Scrollbar *VisualizationScrollbar `json:"scrollbar,omitempty"`

	// ShowDataLabels Whether to show data labels.
	ShowDataLabels *bool `json:"show_data_labels,omitempty"`

	// X The configuration for the X-axis.
	X []ColumnVisualizationXAxis `json:"x"`

	// Y The configuration for the Y-axes.
	Y []ColumnVisualizationYAxis `json:"y"`
}

// Command defines model for command.
type Command struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the command.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Display name of the command.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Name of the command.
	Name *string `json:"name,omitempty"`

	// Namespace Namespace of the command.
	Namespace *string `json:"namespace,omitempty"`

	// SharedWith The list of users, groups and audiences with whom the command is
	// shared.
	SharedWith *[]SharedWithMembership `json:"shared_with,omitempty"`

	// Status Status of the command.
	Status *CommandStatus `json:"status,omitempty"`

	// Surfaces Surfaces where this command can be invoked.
	Surfaces *[]CommandSurface `json:"surfaces,omitempty"`

	// UsageHint A user friendly description of the parameters which can be passed
	// to the command.
	UsageHint *string `json:"usage_hint,omitempty"`
}

// CommandActionExecutorType Specifies how the action is defined.
type CommandActionExecutorType string

// CommandActionTemplateType The template engine for resolving message.
type CommandActionTemplateType string

// CommandCreateRequest The request to create a command.
type CommandCreateRequest struct {
	Action *CreateCommandAction `json:"action,omitempty"`

	// Description Description of the command.
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the command.
	DisplayName *string `json:"display_name,omitempty"`

	// Name Name of the command.
	Name string `json:"name"`

	// Namespace Namespace of the command.
	Namespace string `json:"namespace"`

	// SharedWith The list of users, groups and audiences with whom the command is
	// shared.
	SharedWith *[]SetSharedWithMembership `json:"shared_with,omitempty"`

	// Source ID of the source which created this command.
	Source *string `json:"source,omitempty"`

	// Status Status of the command.
	Status *CommandStatus `json:"status,omitempty"`

	// Surfaces Surfaces where this command can be invoked.
	Surfaces *[]CreateCommandSurface `json:"surfaces,omitempty"`

	// UsageHint A user friendly description of the parameters which can be passed
	// to the command.
	UsageHint *string `json:"usage_hint,omitempty"`
}

// CommandCreateResponseBody defines model for command-create-response.
type CommandCreateResponseBody struct {
	Command Command `json:"command"`
}

// CommandGetRequest The request to get a command.
type CommandGetRequest struct {
	// Id The command's ID.
	Id string `json:"id"`
}

// CommandGetResponseBody defines model for command-get-response.
type CommandGetResponseBody struct {
	Command Command `json:"command"`
}

// CommandStatus Status of the command.
type CommandStatus string

// CommandSummary defines model for command-summary.
type CommandSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Name of the command.
	Name *string `json:"name,omitempty"`
}

// CommandSurface Metadata defining which surfaces this command can be executed on.
type CommandSurface struct {
	// ObjectTypes Objects types on which a command can be invoked.
	ObjectTypes *[]CommandSurfaceObjectTypes `json:"object_types,omitempty"`

	// Surface Surfaces from where this command can be invoked.
	Surface *CommandSurfaceSurface `json:"surface,omitempty"`
}

// CommandSurfaceObjectTypes Objects types on which a command can be invoked.
type CommandSurfaceObjectTypes string

// CommandSurfaceSurface Surfaces from where this command can be invoked.
type CommandSurfaceSurface string

// CommandUpdateRequest The request to update a command.
type CommandUpdateRequest struct {
	Action *UpdateCommandAction `json:"action,omitempty"`

	// Description Description of the command.
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the command.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The ID of the command to update.
	Id string `json:"id"`

	// Name Name of the command.
	Name *string `json:"name,omitempty"`

	// Namespace Namespace of the command.
	Namespace *string `json:"namespace,omitempty"`

	// SharedWith The list of users, groups and audiences with whom the command is
	// shared.
	SharedWith *[]SetSharedWithMembership `json:"shared_with,omitempty"`

	// Source ID of the source which created this command.
	Source *string `json:"source,omitempty"`

	// Status Status of the command.
	Status *CommandStatus `json:"status,omitempty"`

	// Surfaces Surfaces where this command can be invoked.
	Surfaces *[]UpdateCommandSurface `json:"surfaces,omitempty"`

	// UsageHint A user friendly description of the parameters which can be passed
	// to the command.
	UsageHint *string `json:"usage_hint,omitempty"`
}

// CommandUpdateResponseBody defines model for command-update-response.
type CommandUpdateResponseBody struct {
	Command Command `json:"command"`
}

// CommandsListRequest defines model for commands-list-request.
type CommandsListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// ExecutorType Filtering based on executor_type.
	ExecutorType *[]CommandActionExecutorType `json:"executor_type,omitempty"`

	// Limit The maximum number of commands to return per page. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Namespace Filter commands based on namespace.
	Namespace *[]string `json:"namespace,omitempty"`

	// SortBy List of fields to sort the commands items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// SourceObjectId ID of the object where command is invoked (work/part/conversation).
	SourceObjectId *string `json:"source_object_id,omitempty"`

	// Status Filter commands based on status.
	Status *[]CommandStatus `json:"status,omitempty"`
}

// CommandsListResponseBody defines model for commands-list-response.
type CommandsListResponseBody struct {
	// Commands List of commands.
	Commands []Command `json:"commands"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// CommentSearchSummary defines model for comment-search-summary.
type CommentSearchSummary struct {
	Comment   *TimelineCommentSummary `json:"comment,omitempty"`
	CreatedBy *UserSummary            `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the comment was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Object The object that the Timeline entry belongs to.
	Object *string `json:"object,omitempty"`

	// Panels Display panels for the comment entry.
	Panels *[]TimelineEntryPanel `json:"panels,omitempty"`

	// References The objects referenced in the comment.
	References *[]AtomSummary `json:"references,omitempty"`

	// Snippet Text snippet where the search hit occurred.
	Snippet *string `json:"snippet,omitempty"`
}

// ContentTemplate defines model for content-template.
type ContentTemplate struct {
	Type ContentTemplateType `json:"type"`
}

// ContentTemplateCreateRequest The request to create a new content template.
type ContentTemplateCreateRequest struct {
	// InputFieldsSchema Input fields schema. The fields will be used to replace variables
	// present in the content template.
	InputFieldsSchema *[]SchemaFieldDescriptor `json:"input_fields_schema,omitempty"`

	// Name The name of the content template. The name must be unique for each
	// creator of the content template.
	Name  string              `json:"name"`
	Type  ContentTemplateType `json:"type"`
	union json.RawMessage
}

// ContentTemplateCreateRequestNotificationContentTemplate defines model for content-template-create-request-notification-content-template.
type ContentTemplateCreateRequestNotificationContentTemplate struct {
	// Defaults Default notification template per language. Only one is permitted
	// per language. These will be used to replace the notification
	// content on basis of language preferences of the user. Default is
	// EN(US).
	Defaults []ContentTemplateCreateRequestNotificationContentTemplateDefaultNotificationContentTemplate `json:"defaults"`
}

// ContentTemplateCreateRequestNotificationContentTemplateDefaultNotificationContentTemplate defines model for content-template-create-request-notification-content-template-default-notification-content-template.
type ContentTemplateCreateRequestNotificationContentTemplateDefaultNotificationContentTemplate struct {
	// Body Body for the notification. In order to use fields from input fields
	// schema, use {field_name} in the body.
	Body string `json:"body"`

	// Title Title for the notification. In order to use fields from input
	// fields schema, use {field_name} in the title.
	Title string `json:"title"`
}

// ContentTemplateCreateRequestNotificationContentTemplateTranslation defines model for content-template-create-request-notification-content-template-translation.
type ContentTemplateCreateRequestNotificationContentTemplateTranslation struct {
	// BodyTranslations Content data for the notification. The key is the language code and
	// the value is the content.
	BodyTranslations map[string]string `json:"body_translations"`

	// TitleTranslations Content data for the notification. The key is the language code and
	// the value is the content.
	TitleTranslations map[string]string `json:"title_translations"`
}

// ContentTemplateCreateResponseBody defines model for content-template-create-response.
type ContentTemplateCreateResponseBody struct {
	ContentTemplate ContentTemplate `json:"content_template"`
}

// ContentTemplateGetRequest defines model for content-template-get-request.
type ContentTemplateGetRequest struct {
	// Id The content template's ID.
	Id string `json:"id"`
}

// ContentTemplateGetResponseBody defines model for content-template-get-response.
type ContentTemplateGetResponseBody struct {
	ContentTemplate ContentTemplate `json:"content_template"`
}

// ContentTemplateListRequest defines model for content-template-list-request.
type ContentTemplateListRequest struct {
	// CreatedBy Filters for content template created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of content template to return. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Name Filters for content template based on name.
	Name *[]string `json:"name,omitempty"`

	// SortBy Fields to sort the content template by and the direction to sort
	// them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Type Filters for content template of the provided types.
	Type *[]ContentTemplateType `json:"type,omitempty"`
}

// ContentTemplateListResponseBody defines model for content-template-list-response.
type ContentTemplateListResponseBody struct {
	// ContentTemplate The list of content templates.
	ContentTemplate []ContentTemplate `json:"content_template"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// ContentTemplateType defines model for content-template-type.
type ContentTemplateType = string

// Conversation defines model for conversation.
type Conversation struct {
	// ActualCloseDate Timestamp when the conversation was actually completed.
	ActualCloseDate *time.Time `json:"actual_close_date,omitempty"`

	// Channels Channel IDs of the conversation.
	Channels  *[]ExternalCommunicationChannelSummary `json:"channels,omitempty"`
	CreatedBy *UserSummary                           `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// Description Description of the conversation object.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string       `json:"display_id,omitempty"`
	Group     *GroupSummary `json:"group,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Members The users in the conversation.
	Members []UserSummary `json:"members"`

	// Messages The latest messages on the conversation.
	Messages *[]TimelineEntry `json:"messages,omitempty"`

	// Metadata Metadata on conversation.
	Metadata   *ConversationMetadata `json:"metadata,omitempty"`
	ModifiedBy *UserSummary          `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy Owner IDs for the conversation.
	OwnedBy *[]UserSummary `json:"owned_by,omitempty"`

	// SlaSummary SLA summary for the object.
	SlaSummary *ArchetypeSlaSummary `json:"sla_summary,omitempty"`
	SlaTracker *SlaTrackerSummary   `json:"sla_tracker,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStage `json:"stage,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// Title Title of the conversation object.
	Title *string `json:"title,omitempty"`
}

// ConversationMetadata Metadata on conversation.
type ConversationMetadata struct {
	// UrlContext URL from which the conversation was created if the conversation was
	// created via PLuG.
	UrlContext *string `json:"url_context,omitempty"`
}

// ConversationSearchSummary defines model for conversation-search-summary.
type ConversationSearchSummary struct {
	// Comments Comments on the work.
	Comments     *[]CommentSearchSummary `json:"comments,omitempty"`
	Conversation ConversationSummary     `json:"conversation"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// ConversationSummary defines model for conversation-summary.
type ConversationSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`

	// Title Title of the conversation object.
	Title *string `json:"title,omitempty"`
}

// ConversationsCreateRequest The request to create a new conversation.
type ConversationsCreateRequest struct {
	// Brand The brand associated with the conversation.
	Brand *string `json:"brand,omitempty"`

	// Channels Channel IDs of the conversation.
	Channels *[]string `json:"channels,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description Description for the conversation.
	Description *string `json:"description,omitempty"`

	// Group The group that the conversation is associated with.
	Group *string `json:"group,omitempty"`

	// IsSpam Whether the conversation is spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// Members The users in the conversation.
	Members *[]string `json:"members,omitempty"`

	// Messages Initial messages on the conversation.
	Messages *[]ConversationsCreateRequestMessage `json:"messages,omitempty"`
	Metadata *ConversationsCreateRequestMetadata  `json:"metadata,omitempty"`

	// OwnedBy The users that own the conversation.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// SourceChannel Whether the conversation is from a source channel.
	SourceChannel *string `json:"source_channel,omitempty"`

	// SourceChannelV2 Source channel ID of the conversation.
	SourceChannelV2 *string `json:"source_channel_v2,omitempty"`

	// Stage Sets an object's initial stage.
	Stage *StageInit `json:"stage,omitempty"`

	// Tags Tags associated with the conversation.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Title The title for the conversation.
	Title *string                             `json:"title,omitempty"`
	Type  ConversationsCreateRequestTypeValue `json:"type"`

	// UserSessions The IDs of user sessions associated with the conversation.
	UserSessions *[]string `json:"user_sessions,omitempty"`
}

// ConversationsCreateRequestMessage defines model for conversations-create-request-message.
type ConversationsCreateRequestMessage struct {
	// Artifacts The IDs of the artifacts to the message.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Body The message's body.
	Body *string `json:"body,omitempty"`
}

// ConversationsCreateRequestMetadata defines model for conversations-create-request-metadata.
type ConversationsCreateRequestMetadata struct {
	UrlContext *string `json:"url_context,omitempty"`
}

// ConversationsCreateRequestTypeValue defines model for conversations-create-request-type-value.
type ConversationsCreateRequestTypeValue string

// ConversationsCreateResponseBody The response to creating a new conversation.
type ConversationsCreateResponseBody struct {
	Conversation Conversation `json:"conversation"`
}

// ConversationsDeleteRequest The request to delete a conversation.
type ConversationsDeleteRequest struct {
	// Id The ID of the conversation to delete.
	Id string `json:"id"`
}

// ConversationsDeleteResponseBody The response for deleting a conversation.
type ConversationsDeleteResponseBody = map[string]interface{}

// ConversationsExportRequest defines model for conversations-export-request.
type ConversationsExportRequest struct {
	// ActualCloseDate Provides ways to specify date ranges on objects.
	ActualCloseDate *DateFilter `json:"actual_close_date,omitempty"`

	// AppliesToParts Filters for conversations belonging to any of the provided parts.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// Brand Filters for tickets that are associated with any of the brands.
	Brand *[]string `json:"brand,omitempty"`

	// Channels Filters for conversations that are associated with any of the
	// channels.
	Channels *[]string `json:"channels,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// First The number of conversation items to return. The default is '50',
	// the maximum is '5000'.
	First *int32 `json:"first,omitempty"`

	// Group Filters for conversation that belong to the given groups.
	Group *[]string `json:"group,omitempty"`

	// IsCreatorVerified Filters for conversations that are created by verified users.
	IsCreatorVerified *bool `json:"is_creator_verified,omitempty"`

	// IsFrozen Filters for conversations that are frozen.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// IsSpam Filters for conversations that are spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// Members Filters for conversations where these users are participants.
	Members      *[]string       `json:"members,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for conversations owned by any of these users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// RevOrg Filters for conversations that are associated with any of the
	// provided Rev organizations.
	// Deprecated:
	RevOrg *[]string `json:"rev_org,omitempty"`

	// RevOrgs Filters for conversations that are associated with any of the
	// provided Rev organizations.
	RevOrgs *[]string `json:"rev_orgs,omitempty"`

	// SlaSummary The filter for SLA summary.
	SlaSummary *SlaSummaryFilter `json:"sla_summary,omitempty"`

	// SourceChannel Filters for conversations with any of the provided source channels.
	SourceChannel *[]string `json:"source_channel,omitempty"`

	// SourceChannelV2 Filters for conversations that are associated with the source
	// channel.
	SourceChannelV2 *[]string `json:"source_channel_v2,omitempty"`

	// SourceChannels Filters for conversations with any of the provided source channels.
	// Deprecated:
	SourceChannels *[]string `json:"source_channels,omitempty"`

	// Stage The filter for stages.
	Stage *StageFilter `json:"stage,omitempty"`

	// State Filters for conversations with any of the provided states.
	State *[]string `json:"state,omitempty"`

	// Subtype Filters for conversation with any of the provided subtypes.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags Filters for conversations with any of the provided tags.
	// Deprecated:
	Tags *[]string `json:"tags,omitempty"`

	// TagsV2 Filters for conversations with any of the provided tags with value.
	TagsV2 *[]TagWithValueFilter `json:"tags_v2,omitempty"`
}

// ConversationsExportResponseBody defines model for conversations-export-response.
type ConversationsExportResponseBody struct {
	// Conversations The resulting collection of conversation items.
	Conversations []Conversation `json:"conversations"`
}

// ConversationsGetRequest The request to get a conversation's information.
type ConversationsGetRequest struct {
	// Id The requested conversation's ID.
	Id string `json:"id"`
}

// ConversationsGetResponseBody The response to getting a conversation's information.
type ConversationsGetResponseBody struct {
	Conversation Conversation `json:"conversation"`
}

// ConversationsListRequest The request to get information about a list of conversations.
type ConversationsListRequest struct {
	// ActualCloseDate Provides ways to specify date ranges on objects.
	ActualCloseDate *DateFilter `json:"actual_close_date,omitempty"`

	// AppliesToParts Filters for conversations belonging to any of the provided parts.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// Brand Filters for tickets that are associated with any of the brands.
	Brand *[]string `json:"brand,omitempty"`

	// Channels Filters for conversations that are associated with any of the
	// channels.
	Channels *[]string `json:"channels,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Group Filters for conversation that belong to the given groups.
	Group *[]string `json:"group,omitempty"`

	// IsCreatorVerified Filters for conversations that are created by verified users.
	IsCreatorVerified *bool `json:"is_creator_verified,omitempty"`

	// IsFrozen Filters for conversations that are frozen.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// IsSpam Filters for conversations that are spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// Limit The maximum number of conversations to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Members Filters for conversations where these users are participants.
	Members *[]string `json:"members,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for conversations owned by any of these users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// RevOrg Filters for conversations that are associated with any of the
	// provided Rev organizations.
	// Deprecated:
	RevOrg *[]string `json:"rev_org,omitempty"`

	// RevOrgs Filters for conversations that are associated with any of the
	// provided Rev organizations.
	RevOrgs *[]string `json:"rev_orgs,omitempty"`

	// SlaSummary The filter for SLA summary.
	SlaSummary *SlaSummaryFilter `json:"sla_summary,omitempty"`

	// SourceChannel Filters for conversations with any of the provided source channels.
	SourceChannel *[]string `json:"source_channel,omitempty"`

	// SourceChannelV2 Filters for conversations that are associated with the source
	// channel.
	SourceChannelV2 *[]string `json:"source_channel_v2,omitempty"`

	// SourceChannels Filters for conversations with any of the provided source channels.
	// Deprecated:
	SourceChannels *[]string `json:"source_channels,omitempty"`

	// Stage The filter for stages.
	Stage *StageFilter `json:"stage,omitempty"`

	// State Filters for conversations with any of the provided states.
	State *[]string `json:"state,omitempty"`

	// Subtype Filters for conversation with any of the provided subtypes.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags Filters for conversations with any of the provided tags.
	// Deprecated:
	Tags *[]string `json:"tags,omitempty"`

	// TagsV2 Filters for conversations with any of the provided tags with value.
	TagsV2 *[]TagWithValueFilter `json:"tags_v2,omitempty"`
}

// ConversationsListResponseBody The response to listing the conversations.
type ConversationsListResponseBody struct {
	// Conversations The list of conversations.
	Conversations []Conversation `json:"conversations"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// ConversationsUpdateRequest The request to update a conversation.
type ConversationsUpdateRequest struct {
	AppliesToParts *ConversationsUpdateRequestAppliesToParts `json:"applies_to_parts,omitempty"`

	// Brand The brand associated with the conversation.
	Brand    *string                             `json:"brand,omitempty"`
	Channels *ConversationsUpdateRequestChannels `json:"channels,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description The updated description for the conversation.
	Description *string `json:"description,omitempty"`

	// Group The group that the conversation is associated with.
	Group *string `json:"group,omitempty"`

	// Id The ID of the conversation to update.
	Id string `json:"id"`

	// IsFrozen Whether the conversation is frozen.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// IsSpam Whether the conversation is spam.
	IsSpam   *bool                               `json:"is_spam,omitempty"`
	Members  *ConversationsUpdateRequestMembers  `json:"members,omitempty"`
	Metadata *ConversationsUpdateRequestMetadata `json:"metadata,omitempty"`
	OwnedBy  *ConversationsUpdateRequestOwnedBy  `json:"owned_by,omitempty"`

	// SourceChannelV2 Source channel ID of the conversation.
	SourceChannelV2 *string `json:"source_channel_v2,omitempty"`

	// Stage Updates an object's stage.
	Stage *StageUpdate `json:"stage,omitempty"`

	// Status The updated status of the conversation.
	Status *string                         `json:"status,omitempty"`
	Tags   *ConversationsUpdateRequestTags `json:"tags,omitempty"`

	// Title The updated title of the conversation.
	Title        *string                                 `json:"title,omitempty"`
	UserSessions *ConversationsUpdateRequestUserSessions `json:"user_sessions,omitempty"`
}

// ConversationsUpdateRequestAppliesToParts defines model for conversations-update-request-applies-to-parts.
type ConversationsUpdateRequestAppliesToParts struct {
	// Set Updates the parts that the conversation applies to.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateRequestChannels defines model for conversations-update-request-channels.
type ConversationsUpdateRequestChannels struct {
	// Set Sets the channel IDs of the conversation.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateRequestMembers defines model for conversations-update-request-members.
type ConversationsUpdateRequestMembers struct {
	// Set Sets the member IDs to the provided user IDs.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateRequestMetadata defines model for conversations-update-request-metadata.
type ConversationsUpdateRequestMetadata struct {
	UrlContext *string `json:"url_context,omitempty"`
}

// ConversationsUpdateRequestOwnedBy defines model for conversations-update-request-owned-by.
type ConversationsUpdateRequestOwnedBy struct {
	// Set Sets the owner IDs to the provided user IDs.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateRequestTags defines model for conversations-update-request-tags.
type ConversationsUpdateRequestTags struct {
	// Add Adds the provided tags on the conversation.
	Add *[]AddTagWithValue `json:"add,omitempty"`

	// Remove Removes the provided tags on the conversation.
	Remove *[]RemoveTagWithValue `json:"remove,omitempty"`

	// Set Sets the tag IDs to the provided tags.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// ConversationsUpdateRequestUserSessions defines model for conversations-update-request-user-sessions.
type ConversationsUpdateRequestUserSessions struct {
	// Set The updated user sessions that the conversation is associated with.
	Set *[]string `json:"set,omitempty"`
}

// ConversationsUpdateResponseBody The response for updating a conversation.
type ConversationsUpdateResponseBody struct {
	Conversation Conversation `json:"conversation"`
}

// CreateAssociation Association of Rev users with Rev orgs or accounts. A Rev user can be
// associated with 0 or more accounts and Rev orgs. A Rev org association
// automatically adds an account association.
type CreateAssociation struct {
	// AssociatedTo ID of the Rev org or account to which Rev user is to be associated.
	AssociatedTo *string `json:"associated_to,omitempty"`
}

// CreateCommandAction defines model for create-command-action.
type CreateCommandAction struct {
	ActionDetails *CreateCommandActionDetails `json:"action_details,omitempty"`

	// Artifacts IDs of the new artifact items
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Code The raw code to execute, defined in the language specified by
	// executor
	Code *string `json:"code,omitempty"`

	// ExecutorConfig Executor specific config
	ExecutorConfig *map[string]interface{} `json:"executor_config,omitempty"`

	// ExecutorType Specifies how the action is defined.
	ExecutorType CommandActionExecutorType `json:"executor_type"`

	// Message The message to populate in discussion box, when the command is
	// selected to execute.
	Message *string `json:"message,omitempty"`

	// SnapInFunctionId Function containing logic for the command. If function ID is
	// specified the executor config is ignored and command is executed by
	// functions.
	SnapInFunctionId *string `json:"snap_in_function_id,omitempty"`

	// TemplateType The template engine for resolving message.
	TemplateType *CommandActionTemplateType `json:"template_type,omitempty"`
}

// CreateCommandActionDetails defines model for create-command-action-details.
type CreateCommandActionDetails struct {
	// ObjectUpdatePayload The payload to update the object in context upon command execution.
	ObjectUpdatePayload *map[string]interface{} `json:"object_update_payload,omitempty"`
}

// CreateCommandSurface defines model for create-command-surface.
type CreateCommandSurface struct {
	// ObjectTypes Objects types on which a command can be invoked
	ObjectTypes *[]CommandSurfaceObjectTypes `json:"object_types,omitempty"`

	// Surface Surfaces from where this command can be invoked.
	Surface CommandSurfaceSurface `json:"surface"`
}

// CreateEmailInfo Information related to an email.
type CreateEmailInfo struct {
	// Address The address of the email address.
	Address string `json:"address"`

	// Name The name of the email address.
	Name *string `json:"name,omitempty"`

	// User The ID of the user associated with the email address.
	User *string `json:"user,omitempty"`
}

// CreateEmailInlineAttachment An inline attachment.
type CreateEmailInlineAttachment struct {
	// Artifact The artifact of the attachment.
	Artifact *string `json:"artifact,omitempty"`

	// ContentId The content id of the attachment.
	ContentId *string `json:"content_id,omitempty"`
}

// CreateEmailPreviewWidget An email preview widget.
type CreateEmailPreviewWidget struct {
	// Bcc The list of bcc addresses.
	Bcc *[]CreateEmailInfo `json:"bcc,omitempty"`

	// Cc The list of cc addresses.
	Cc *[]CreateEmailInfo `json:"cc,omitempty"`

	// From The list of from addresses.
	From *[]CreateEmailInfo `json:"from,omitempty"`

	// HtmlBody The html body of the email.
	HtmlBody *string `json:"html_body,omitempty"`

	// InReplyTo The in reply to of the email.
	InReplyTo *string `json:"in_reply_to,omitempty"`

	// Inlines The list of inline attachments.
	Inlines *[]CreateEmailInlineAttachment `json:"inlines,omitempty"`

	// IsSpam Whether the email is spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// MessageId The message id of the email.
	MessageId *string `json:"message_id,omitempty"`

	// RawEmailArtifact The raw email artifact.
	RawEmailArtifact *string `json:"raw_email_artifact,omitempty"`

	// References The list of references in the email.
	References *[]string `json:"references,omitempty"`

	// ReplyTo The list of reply to addresses.
	ReplyTo *[]CreateEmailInfo `json:"reply_to,omitempty"`

	// SentTimestamp The time the email was sent.
	SentTimestamp *time.Time `json:"sent_timestamp,omitempty"`

	// Subject The subject of the email.
	Subject *string `json:"subject,omitempty"`

	// TextBody The text body of the email.
	TextBody *string `json:"text_body,omitempty"`

	// To The list of to addresses.
	To *[]CreateEmailInfo `json:"to,omitempty"`
}

// CreateExternalSourceDataComp defines model for create-external-source-data-comp.
type CreateExternalSourceDataComp struct {
	// ClosedDate Timestamp when the object was closed in the source system.
	ClosedDate *time.Time `json:"closed_date,omitempty"`

	// CreatedDate Timestamp when the object was created in the source system.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// ModifiedDate Timestamp when the object was modified in the source system.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// CreateImpactedCustomerDetails defines model for create-impacted-customer-details.
type CreateImpactedCustomerDetails struct {
	// Count Count of customers impacted.
	Count *int64 `json:"count,omitempty"`

	// CustomerIds List of customers impacted due to the incident.
	CustomerIds *[]string `json:"customer_ids,omitempty"`
}

// CreateOrgScheduleInterval defines model for create-org-schedule-interval.
type CreateOrgScheduleInterval struct {
	// From Date (inclusive) on which the interval begins.
	From time.Time `json:"from"`

	// IsExcluded If true, no organization schedule is looked up for these days and
	// they are marked as holidays.
	IsExcluded *bool `json:"is_excluded,omitempty"`

	// Name The name of the period, for example the event or holiday it
	// represents.
	Name string `json:"name"`

	// To Date (exclusive) on which the interval ends. If omitted, it is a
	// single day interval.
	To *time.Time `json:"to,omitempty"`
}

// CreateStage Create object for stage.
type CreateStage struct {
	// Notes Notes relevant to the stage
	Notes *string `json:"notes,omitempty"`

	// Stage DON of the stage.
	Stage string `json:"stage"`
}

// CreateStageNode defines model for create-stage-node.
type CreateStageNode struct {
	// IsDeprecated Whether this stage is deprecated.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// IsStart Whether this is the start stage.
	IsStart *bool `json:"is_start,omitempty"`

	// StageId The ID of the stage.
	StageId string `json:"stage_id"`

	// Transitions List of transitions from this stage.
	Transitions *[]CreateStageTransition `json:"transitions,omitempty"`
}

// CreateStageTransition defines model for create-stage-transition.
type CreateStageTransition struct {
	// TargetStageId The ID of the target stage.
	TargetStageId string                 `json:"target_stage_id"`
	Ui            *CreateStageUiMetadata `json:"ui,omitempty"`
}

// CreateStageUiMetadata defines model for create-stage-ui-metadata.
type CreateStageUiMetadata struct {
	// IsHidden Whether the stage is hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`
}

// CreateStagedInfo Create object for staged_info.
type CreateStagedInfo struct {
	// IsStaged Whether the record is staged and requires confirmation before
	// further processing
	IsStaged *bool `json:"is_staged,omitempty"`

	// SyncInUnresolvedFields A list of fields that have not been resolved while syncing from
	// external system of records to DevRev
	SyncInUnresolvedFields *[]CreateStagedUnresolvedField `json:"sync_in_unresolved_fields,omitempty"`

	// SyncOutUnresolvedFields A list of fields that have not been resolved while syncing from
	// DevRev to external system of records
	SyncOutUnresolvedFields *[]CreateStagedUnresolvedField `json:"sync_out_unresolved_fields,omitempty"`

	// UnresolvedFields A list of fields that have not been resolved, which is causing the
	// record to be staged
	UnresolvedFields *[]string `json:"unresolved_fields,omitempty"`
}

// CreateStagedUnresolvedField Create object for staged_unresolved_field.
type CreateStagedUnresolvedField struct {
	// DevrevFieldName DevRev field name of the object's attribute.
	DevrevFieldName *string `json:"devrev_field_name,omitempty"`

	// ExternalDisplayName External field name as seen by the end user.
	ExternalDisplayName *string `json:"external_display_name,omitempty"`

	// ExternalFieldName Api name of the external object's field.
	ExternalFieldName *string `json:"external_field_name,omitempty"`
}

// CreateStarterMessageNudgeWidget A starter message nudge widget.
type CreateStarterMessageNudgeWidget struct {
	StarterMessageNudgeType CreateStarterMessageNudgeWidgetStarterMessageNudgeType `json:"starter_message_nudge_type"`
}

// CreateStarterMessageNudgeWidgetStarterMessageNudgeType defines model for create-starter-message-nudge-widget-starter-message-nudge-type.
type CreateStarterMessageNudgeWidgetStarterMessageNudgeType = string

// CreateSyncIn defines model for create-sync-in.
type CreateSyncIn struct {
	// Status Status of the sync for the object.
	Status *SyncInStatus `json:"status,omitempty"`

	// SyncDate Timestamp when the object was synced in/from DevRev.
	SyncDate *time.Time `json:"sync_date,omitempty"`

	// SyncHistory Id of the sync_history when the object was synced.
	SyncHistory *string `json:"sync_history,omitempty"`

	// SyncUnit Id of the sync_unit to which the object belongs.
	SyncUnit *string `json:"sync_unit,omitempty"`
}

// CreateSyncMetadata defines model for create-sync-metadata.
type CreateSyncMetadata struct {
	// ExternalReference External record URL.
	ExternalReference *string        `json:"external_reference,omitempty"`
	LastSyncIn        *CreateSyncIn  `json:"last_sync_in,omitempty"`
	LastSyncOut       *CreateSyncOut `json:"last_sync_out,omitempty"`

	// OriginSystem Where the record was first created.
	OriginSystem *string `json:"origin_system,omitempty"`
}

// CreateSyncOut defines model for create-sync-out.
type CreateSyncOut struct {
	// Status Status of the sync for the object.
	Status *SyncOutStatus `json:"status,omitempty"`

	// SyncDate Timestamp when the object was synced in/from DevRev.
	SyncDate *time.Time `json:"sync_date,omitempty"`

	// SyncHistory Id of the sync_history when the object was synced.
	SyncHistory *string `json:"sync_history,omitempty"`

	// SyncUnit Id of the sync_unit to which the object belongs.
	SyncUnit *string `json:"sync_unit,omitempty"`
}

// CreateTagWithValue Create object for tag_summary.
type CreateTagWithValue struct {
	// TagId ID of the referenced tag
	TagId string `json:"tag_id"`

	// Value Value associated with the tag for the object.
	Value *string `json:"value,omitempty"`
}

// CreateWeeklyOrgScheduleInterval defines model for create-weekly-org-schedule-interval.
type CreateWeeklyOrgScheduleInterval struct {
	// From Duration in minutes of the week when the interval starts. 0 is
	// Sunday midnight, when Sunday ends and Monday begins.
	From int64 `json:"from"`

	// To Duration in minutes of the week when the interval ends (must be
	// larger than 'from'). 0 is Sunday midnight, when Sunday ends and
	// Monday begins.
	To int64 `json:"to"`
}

// CuratedVistaSummary defines model for curated-vista-summary.
type CuratedVistaSummary = VistaBaseSummary

// CustomFieldWidgetColumnProjection A custom field widget column projection.
type CustomFieldWidgetColumnProjection struct {
	// LeafType The leaf type of the custom field.
	LeafType string `json:"leaf_type"`

	// Name The name of the custom field.
	Name string `json:"name"`

	// Subtype The subtype of the custom field.
	Subtype *string `json:"subtype,omitempty"`
}

// CustomLinkType defines model for custom-link-type.
type CustomLinkType struct {
	// BackwardName Human readable name of the link from target to source.
	BackwardName *string      `json:"backward_name,omitempty"`
	CreatedBy    *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ForwardName Human readable name of the link from source to target.
	ForwardName *string `json:"forward_name,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsDeprecated True if this link type is deprecated.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// MaxHops Max hops sets the limit on how many hierarchical levels can be
	// traversed for a given link type, considering both forward and
	// backward directions. For example, if max_hops is set to 1, a link
	// from 'issue-1' to 'ticket-1' is allowed, but extending the chain to
	// 'issue-2' -> 'issue-1' -> 'ticket-1' would exceed the limit and is
	// not allowed.
	MaxHops    *int32       `json:"max_hops,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name The human readable name of the link type.
	Name *string `json:"name,omitempty"`

	// SourceTypes Types from which this link type can originate.
	SourceTypes []LinkTargetDescriptor `json:"source_types"`

	// TargetTypes Types to which this link type can go.
	TargetTypes []LinkTargetDescriptor `json:"target_types"`

	// Tooltip Additional information about the link type.
	Tooltip *string `json:"tooltip,omitempty"`
}

// CustomLinkTypeCreateRequest defines model for custom-link-type-create-request.
type CustomLinkTypeCreateRequest struct {
	// BackwardName The name of the link in the backward direction.
	BackwardName string `json:"backward_name"`

	// Deprecated Whether the link type is deprecated.
	// Deprecated:
	Deprecated *bool `json:"deprecated,omitempty"`

	// ForwardName The name of the link in the forward direction.
	ForwardName string `json:"forward_name"`

	// IsDeprecated Whether the link type is deprecated.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// Name The name of the custom link type.
	Name string `json:"name"`

	// SourceTypes Types from which the link can be made from.
	SourceTypes []LinkTargetDescriptor `json:"source_types"`

	// TargetTypes Types to which the link can be made to.
	TargetTypes []LinkTargetDescriptor `json:"target_types"`

	// Tooltip The tooltip of the custom link type.
	Tooltip *string `json:"tooltip,omitempty"`
}

// CustomLinkTypeCreateResponseBody defines model for custom-link-type-create-response.
type CustomLinkTypeCreateResponseBody struct {
	CustomLinkType CustomLinkType `json:"custom_link_type"`
}

// CustomLinkTypeGetRequest defines model for custom-link-type-get-request.
type CustomLinkTypeGetRequest struct {
	// Id The ID of the custom link type to get.
	Id string `json:"id"`
}

// CustomLinkTypeGetResponseBody defines model for custom-link-type-get-response.
type CustomLinkTypeGetResponseBody struct {
	CustomLinkType CustomLinkType `json:"custom_link_type"`
}

// CustomLinkTypeListRequest defines model for custom-link-type-list-request.
type CustomLinkTypeListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Deprecated Whether only deprecated link types should be filtered.
	// Deprecated:
	Deprecated *bool `json:"deprecated,omitempty"`

	// IsDeprecated Whether only deprecated link types should be filtered.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Name The list of link type names.
	Name *[]string `json:"name,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// SourceTypesV2 Types from which a link can be made.
	SourceTypesV2 *[]LinkTargetDescriptor `json:"source_types_v2,omitempty"`

	// TargetTypesV2 Types to which a link can be made.
	TargetTypesV2 *[]LinkTargetDescriptor `json:"target_types_v2,omitempty"`
}

// CustomLinkTypeListResponseBody defines model for custom-link-type-list-response.
type CustomLinkTypeListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Result The custom link types.
	Result []CustomLinkType `json:"result"`
}

// CustomLinkTypeSummary defines model for custom-link-type-summary.
type CustomLinkTypeSummary = AtomBaseSummary

// CustomLinkTypeUpdateRequest defines model for custom-link-type-update-request.
type CustomLinkTypeUpdateRequest struct {
	// BackwardName The updated name of the link in the backward direction.
	BackwardName *string `json:"backward_name,omitempty"`

	// Deprecated Whether the link type is deprecated.
	// Deprecated:
	Deprecated *bool `json:"deprecated,omitempty"`

	// ForwardName The updated name of the link in the forward direction.
	ForwardName *string `json:"forward_name,omitempty"`

	// Id The ID of the custom link type to update.
	Id string `json:"id"`

	// IsDeprecated Whether the link type is deprecated.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// Name The updated name of the custom link type.
	Name *string `json:"name,omitempty"`

	// SourceTypesV2 Types from which a link can be made.
	SourceTypesV2 *[]LinkTargetDescriptor `json:"source_types_v2,omitempty"`

	// TargetTypesV2 Types to which a link can be made.
	TargetTypesV2 *[]LinkTargetDescriptor `json:"target_types_v2,omitempty"`

	// Tooltip The updated tooltip of the custom link type.
	Tooltip *string `json:"tooltip,omitempty"`
}

// CustomLinkTypeUpdateResponseBody defines model for custom-link-type-update-response.
type CustomLinkTypeUpdateResponseBody struct {
	CustomLinkType CustomLinkType `json:"custom_link_type"`
}

// CustomObject defines model for custom-object.
type CustomObject struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`
}

// CustomObjectSearchSummary defines model for custom-object-search-summary.
type CustomObjectSearchSummary struct {
	CustomObject CustomObjectSummary `json:"custom_object"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// CustomObjectSummary defines model for custom-object-summary.
type CustomObjectSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`
}

// CustomObjectsCountRequest defines model for custom-objects-count-request.
type CustomObjectsCountRequest struct {
	// Filters List of filters to apply.
	Filters *[]interface{} `json:"filters,omitempty"`

	// LeafType Leaf type to filter.
	LeafType string `json:"leaf_type"`
}

// CustomObjectsCountResponseBody defines model for custom-objects-count-response.
type CustomObjectsCountResponseBody struct {
	// Count The count of custom objects.
	Count int64 `json:"count"`
}

// CustomObjectsCreateRequest defines model for custom-objects-create-request.
type CustomObjectsCreateRequest struct {
	// CustomFields Custom fields of the custom object.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// LeafType Leaf type of the custom object.
	LeafType string `json:"leaf_type"`

	// Stage The stage of the custom object.
	Stage *string `json:"stage,omitempty"`

	// StageValidationOptions The type of stage validations options when creating a custom
	// object.
	StageValidationOptions *[]StageValidationOptionForCreate `json:"stage_validation_options,omitempty"`

	// Title Title of the custom object.
	Title *string `json:"title,omitempty"`

	// UniqueKey The unique key of the custom object.This can be used to hold an
	// external reference to another object.
	UniqueKey string `json:"unique_key"`
}

// CustomObjectsCreateResponseBody defines model for custom-objects-create-response.
type CustomObjectsCreateResponseBody struct {
	CustomObject CustomObject `json:"custom_object"`
}

// CustomObjectsDeleteRequest defines model for custom-objects-delete-request.
type CustomObjectsDeleteRequest struct {
	// Id The ID of the custom object to get.
	Id string `json:"id"`
}

// CustomObjectsDeleteResponseBody defines model for custom-objects-delete-response.
type CustomObjectsDeleteResponseBody = map[string]interface{}

// CustomObjectsGetRequest defines model for custom-objects-get-request.
type CustomObjectsGetRequest struct {
	// Id The ID of the custom object to get.
	Id *string `json:"id,omitempty"`
}

// CustomObjectsGetResponseBody defines model for custom-objects-get-response.
type CustomObjectsGetResponseBody struct {
	CustomObject CustomObject `json:"custom_object"`
}

// CustomObjectsListRequest defines model for custom-objects-list-request.
type CustomObjectsListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Filter List of filters to apply.
	Filter *[]interface{} `json:"filter,omitempty"`

	// Filters List of filters to apply.
	Filters *[]interface{} `json:"filters,omitempty"`

	// LeafType Leaf type to filter.
	LeafType string `json:"leaf_type"`

	// Limit The maximum number of items.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// CustomObjectsListResponseBody The response to listing all custom objects matching the filter
// criteria.
type CustomObjectsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Result The custom objects.
	Result []CustomObject `json:"result"`
}

// CustomObjectsUpdateRequest defines model for custom-objects-update-request.
type CustomObjectsUpdateRequest struct {
	// CustomFields Custom fields of the custom object.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Id The ID of the custom object to update.
	Id string `json:"id"`

	// Stage Updates the stage of the custom object.
	Stage *string `json:"stage"`

	// StageValidationOptions The type of stage validations options when updating the stage or
	// the stage diagram of a custom object.
	StageValidationOptions *[]StageValidationOptionForUpdate `json:"stage_validation_options,omitempty"`

	// Title Updates the title of the custom object.
	Title *string `json:"title"`
}

// CustomObjectsUpdateResponseBody defines model for custom-objects-update-response.
type CustomObjectsUpdateResponseBody struct {
	CustomObject CustomObject `json:"custom_object"`
}

// CustomSchemaFragment defines model for custom-schema-fragment.
type CustomSchemaFragment struct {
	Type  CustomSchemaFragmentType `json:"type"`
	union json.RawMessage
}

// CustomSchemaFragmentBase defines model for custom-schema-fragment-base.
type CustomSchemaFragmentBase struct {
	// Conditions The conditions associated with the fields.
	Conditions *[]CustomSchemaFragmentCondition `json:"conditions,omitempty"`
	CreatedBy  *UserSummary                     `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Deprecated Indicates if the fragment has been deprecated. Modifications to
	// this field are done in-place and don't result in creation of a new
	// fragment in chain.
	Deprecated *bool `json:"deprecated,omitempty"`

	// Description Description of the custom schema fragment.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Fields List of all fields in this custom schema fragment.
	Fields *[]SchemaFieldDescriptor `json:"fields,omitempty"`

	// FragmentType Type of the custom schema fragment.
	FragmentType *CustomSchemaFragmentFragmentType `json:"fragment_type,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsDeprecated Indicates if the fragment is deprecated. Modifications to this
	// field are done in-place and don't result in creation of a new
	// fragment in chain.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// LeafType Leaf type this fragment applies to.
	LeafType   *string      `json:"leaf_type,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate   *time.Time                   `json:"modified_date,omitempty"`
	NewFragmentRef *CustomSchemaFragmentSummary `json:"new_fragment_ref,omitempty"`
	OldFragmentRef *CustomSchemaFragmentSummary `json:"old_fragment_ref,omitempty"`
}

// CustomSchemaFragmentBaseSummary defines model for custom-schema-fragment-base-summary.
type CustomSchemaFragmentBaseSummary = AtomBaseSummary

// CustomSchemaFragmentCondition The condition associated with a field.
type CustomSchemaFragmentCondition struct {
	// Effects The linked effects when the expression evaluates to true.
	Effects *[]CustomSchemaFragmentEffect `json:"effects,omitempty"`

	// Expression The expression to evaluate.
	Expression *string `json:"expression,omitempty"`
}

// CustomSchemaFragmentEffect An effect associated with a condition.
type CustomSchemaFragmentEffect struct {
	// AllowedValues Allowed values for the fields based on the condition. This takes
	// precedence over allowed_values in field_descriptor.
	AllowedValues *[]string `json:"allowed_values,omitempty"`

	// Fields The fields which are affected by the condition.
	Fields []string `json:"fields"`

	// Immutable Whether the fields should be made immutable or not based on the
	// condition.
	Immutable *bool `json:"immutable,omitempty"`

	// Invalid Whether the field values are invalid based on the condition.
	Invalid *bool `json:"invalid,omitempty"`

	// Require Whether the fields are required or not based on the condition. This
	// takes precedence over is_required in field_descriptor.
	Require *bool `json:"require,omitempty"`

	// Show Whether the fields are shown or not based on the condition.
	Show *bool `json:"show,omitempty"`
}

// CustomSchemaFragmentFragmentType Type of the custom schema fragment.
type CustomSchemaFragmentFragmentType string

// CustomSchemaFragmentSummary defines model for custom-schema-fragment-summary.
type CustomSchemaFragmentSummary struct {
	Type  CustomSchemaFragmentType `json:"type"`
	union json.RawMessage
}

// CustomSchemaFragmentType defines model for custom-schema-fragment-type.
type CustomSchemaFragmentType string

// CustomSchemaFragmentsGetRequest defines model for custom-schema-fragments-get-request.
type CustomSchemaFragmentsGetRequest struct {
	// Id The ID of the custom schema fragment.
	Id string `json:"id"`
}

// CustomSchemaFragmentsGetResponseBody defines model for custom-schema-fragments-get-response.
type CustomSchemaFragmentsGetResponseBody struct {
	Fragment CustomSchemaFragment `json:"fragment"`
}

// CustomSchemaFragmentsListRequest defines model for custom-schema-fragments-list-request.
type CustomSchemaFragmentsListRequest struct {
	// App The list of app names.
	App *[]string `json:"app,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Deprecated Whether only deprecated fragments should be filtered.
	// Deprecated:
	Deprecated *bool `json:"deprecated,omitempty"`

	// IsCustomLeafType Whether the leaf type corresponds to a custom object
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// IsDeprecated Whether the fragment has been deprecated.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// LeafType The list of leaf types.
	LeafType *[]string `json:"leaf_type,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Prune List of fields which are not required in the payload and can be
	// pruned away.
	Prune *[]CustomSchemaFragmentsListRequestPrune `json:"prune,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Subtype The list of subtypes.
	Subtype *[]string `json:"subtype,omitempty"`

	// Types Filters for custom schema fragment of the provided types.
	Types *[]CustomSchemaFragmentType `json:"types,omitempty"`
}

// CustomSchemaFragmentsListRequestPrune defines model for custom-schema-fragments-list-request-prune.
type CustomSchemaFragmentsListRequestPrune string

// CustomSchemaFragmentsListResponseBody defines model for custom-schema-fragments-list-response.
type CustomSchemaFragmentsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Result The custom schema fragments.
	Result []CustomSchemaFragment `json:"result"`
}

// CustomSchemaFragmentsSetRequest defines model for custom-schema-fragments-set-request.
type CustomSchemaFragmentsSetRequest struct {
	// CompositeSchemas List of all composite schemas used in this fragment.
	CompositeSchemas *[]CustomSchemaFragmentsSetRequestCompositeSchema `json:"composite_schemas,omitempty"`

	// Conditions List of conditions for this fragment.
	Conditions *[]CustomSchemaFragmentCondition `json:"conditions,omitempty"`

	// DeletedFields List of field names which are being dropped.
	DeletedFields *[]string `json:"deleted_fields,omitempty"`

	// Deprecated Whether this fragment has been deprecated.
	// Deprecated:
	Deprecated *bool `json:"deprecated,omitempty"`

	// Description The description of the custom schema fragment.
	Description string `json:"description"`

	// Fields List of all fields in this fragment.
	Fields *[]SchemaFieldDescriptor `json:"fields,omitempty"`

	// IsCustomLeafType Whether the leaf type corresponds to a custom object
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// IsDeprecated Whether this fragment has been deprecated.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// LeafType The leaf type this fragment applies to.
	LeafType string                              `json:"leaf_type"`
	Type     CustomSchemaFragmentsSetRequestType `json:"type"`
	union    json.RawMessage
}

// CustomSchemaFragmentsSetRequestAppFragment defines model for custom-schema-fragments-set-request-app-fragment.
type CustomSchemaFragmentsSetRequestAppFragment struct {
	// App The app this fragment applies to.
	App string `json:"app"`

	// AppDisplayName The display name of the app.
	AppDisplayName *string `json:"app_display_name,omitempty"`
}

// CustomSchemaFragmentsSetRequestCompositeSchema defines model for custom-schema-fragments-set-request-composite-schema.
type CustomSchemaFragmentsSetRequestCompositeSchema struct {
	// Description Description of this composite type.
	Description *string `json:"description,omitempty"`

	// Fields List of fields in this composite type.
	Fields []SchemaFieldDescriptor `json:"fields"`

	// Name The name of this composite type.
	Name *string `json:"name,omitempty"`
}

// CustomSchemaFragmentsSetRequestCustomTypeFragment defines model for custom-schema-fragments-set-request-custom-type-fragment.
type CustomSchemaFragmentsSetRequestCustomTypeFragment struct {
	// Path Path components used to display available custom types in tree
	// form.
	Path *[]CustomTypePathComponent `json:"path,omitempty"`

	// StageDiagram The ID of the associated custom stage diagram.
	StageDiagram *string `json:"stage_diagram,omitempty"`

	// StockFieldOverrides List of Per-DevOrg stock field overrides.
	StockFieldOverrides *[]StockFieldOverride `json:"stock_field_overrides,omitempty"`

	// Subtype The string used to populate the subtype in the leaf type.
	Subtype string `json:"subtype"`

	// SubtypeDisplayName The display name of the subtype.
	SubtypeDisplayName *string `json:"subtype_display_name,omitempty"`
}

// CustomSchemaFragmentsSetRequestTenantFragment defines model for custom-schema-fragments-set-request-tenant-fragment.
type CustomSchemaFragmentsSetRequestTenantFragment struct {
	// IdPrefix The display ID prefix for the custom object.
	IdPrefix *string `json:"id_prefix,omitempty"`

	// StockFieldOverrides List of Per-DevOrg stock field overrides.
	StockFieldOverrides *[]StockFieldOverride `json:"stock_field_overrides,omitempty"`
}

// CustomSchemaFragmentsSetRequestType defines model for custom-schema-fragments-set-request-type.
type CustomSchemaFragmentsSetRequestType string

// CustomSchemaFragmentsSetResponseBody defines model for custom-schema-fragments-set-response.
type CustomSchemaFragmentsSetResponseBody struct {
	// Id The ID of the custom schema fragment.
	Id string `json:"id"`
}

// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
// request must have the corresponding schema specified; omission results
// in a Bad Request error. If a custom schema is not included in the
// specifier, it remains unchanged. For surfaces with human interactors,
// it is recommended to provide tenant_fragment: true and
// validate_required_fields: true.
type CustomSchemaSpec struct {
	// Apps List of apps.
	Apps *[]string             `json:"apps,omitempty"`
	Drop *CustomSchemaSpecDrop `json:"drop,omitempty"`

	// Subtype Name of the subtype.
	Subtype *string `json:"subtype,omitempty"`

	// TenantFragment Whether the tenant schema is requested.
	TenantFragment *bool `json:"tenant_fragment,omitempty"`

	// ValidateRequiredFields Whether to enforce required fields validation.
	ValidateRequiredFields *bool `json:"validate_required_fields,omitempty"`
}

// CustomSchemaSpecDrop defines model for custom-schema-spec-drop.
type CustomSchemaSpecDrop struct {
	// Apps List of apps to be dropped from the object. Note: The apps field in
	// the custom schema specifier should not contain any of these apps.
	Apps *[]string `json:"apps,omitempty"`

	// Subtype Whether the subtype is to be dropped. Note: If set, the subtype
	// field in the custom schema specifier should be nil
	Subtype *bool `json:"subtype,omitempty"`
}

// CustomSchemaSpecForRead Custom schemas described using identifiers
type CustomSchemaSpecForRead struct {
	// Apps List of apps.
	Apps *[]string `json:"apps,omitempty"`

	// Subtype Name of the subtype.
	Subtype *string `json:"subtype,omitempty"`
}

// CustomStage defines model for custom-stage.
type CustomStage struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name The human readable name of the stage.
	Name *string `json:"name,omitempty"`

	// Ordinal Ordinal used to sort/group stages.
	Ordinal *int32              `json:"ordinal,omitempty"`
	State   *CustomStateSummary `json:"state,omitempty"`
}

// CustomStageSummary defines model for custom-stage-summary.
type CustomStageSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name The human readable name of the stage.
	Name *string `json:"name,omitempty"`
}

// CustomStagesCreateRequest defines model for custom-stages-create-request.
type CustomStagesCreateRequest struct {
	// MarketplaceRef A reference to the marketplace item from which this stage was
	// imported.
	MarketplaceRef *string `json:"marketplace_ref,omitempty"`

	// Name The name of the custom stage.
	Name string `json:"name"`

	// Ordinal The ordinal of the custom stage used for ordering.
	Ordinal int32 `json:"ordinal"`

	// State The state ID.
	State string `json:"state"`
}

// CustomStagesCreateResponseBody defines model for custom-stages-create-response.
type CustomStagesCreateResponseBody struct {
	CustomStage CustomStage `json:"custom_stage"`
}

// CustomStagesGetRequest defines model for custom-stages-get-request.
type CustomStagesGetRequest struct {
	// Id The ID of the custom stage to get.
	Id string `json:"id"`
}

// CustomStagesGetResponseBody defines model for custom-stages-get-response.
type CustomStagesGetResponseBody struct {
	CustomStage CustomStage `json:"custom_stage"`
}

// CustomStagesListRequest defines model for custom-stages-list-request.
type CustomStagesListRequest struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided,
	// then iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `json:"limit,omitempty"`

	// Name The list of stage names.
	Name *[]string `json:"name,omitempty"`

	// Ordinal The list of stage ordinals.
	Ordinal *[]int32 `json:"ordinal,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// CustomStagesListResponseBody defines model for custom-stages-list-response.
type CustomStagesListResponseBody struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided,
	// then iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Result The custom stages.
	Result []CustomStage `json:"result"`
}

// CustomStagesUpdateRequest defines model for custom-stages-update-request.
type CustomStagesUpdateRequest struct {
	// Id The ID of the custom stage to update.
	Id string `json:"id"`

	// Name The updated name of the custom stage.
	Name *string `json:"name,omitempty"`

	// Ordinal The ordinal of the custom stage.
	Ordinal *int32 `json:"ordinal,omitempty"`

	// StateId The state ID.
	StateId *string `json:"state_id,omitempty"`
}

// CustomStagesUpdateResponseBody defines model for custom-stages-update-response.
type CustomStagesUpdateResponseBody struct {
	CustomStage CustomStage `json:"custom_stage"`
}

// CustomState defines model for custom-state.
type CustomState struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsFinal True if this is a final state.
	IsFinal    *bool        `json:"is_final,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name The human readable name of the state.
	Name *string `json:"name,omitempty"`

	// Ordinal Ordinal used to identify system states.
	Ordinal *int32 `json:"ordinal,omitempty"`
}

// CustomStateSummary defines model for custom-state-summary.
type CustomStateSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsFinal True if this is a final state.
	IsFinal *bool `json:"is_final,omitempty"`

	// Name The human readable name of the state.
	Name *string `json:"name,omitempty"`
}

// CustomStatesCreateRequest defines model for custom-states-create-request.
type CustomStatesCreateRequest struct {
	// IsFinal Whether this is a final state.
	IsFinal *bool `json:"is_final,omitempty"`

	// Name The name of the custom state.
	Name string `json:"name"`

	// Ordinal Ordinal of the custom state used to identify system states.
	Ordinal int32 `json:"ordinal"`
}

// CustomStatesCreateResponseBody defines model for custom-states-create-response.
type CustomStatesCreateResponseBody struct {
	CustomState CustomState `json:"custom_state"`
}

// CustomStatesGetRequest defines model for custom-states-get-request.
type CustomStatesGetRequest struct {
	// Id The ID of the custom state to get.
	Id string `json:"id"`
}

// CustomStatesGetResponseBody defines model for custom-states-get-response.
type CustomStatesGetResponseBody struct {
	CustomState CustomState `json:"custom_state"`
}

// CustomStatesListRequest defines model for custom-states-list-request.
type CustomStatesListRequest struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided,
	// then iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// IsFinal Whether only final states should be filtered.
	IsFinal *bool `json:"is_final,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `json:"limit,omitempty"`

	// Name The list of state names.
	Name *[]string `json:"name,omitempty"`

	// Ordinal The list of state ordinals.
	Ordinal *[]int32 `json:"ordinal,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// CustomStatesListResponseBody defines model for custom-states-list-response.
type CustomStatesListResponseBody struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided,
	// then iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Result The custom states.
	Result []CustomState `json:"result"`
}

// CustomStatesUpdateRequest defines model for custom-states-update-request.
type CustomStatesUpdateRequest struct {
	// Id The ID of the custom state to update.
	Id string `json:"id"`

	// IsFinal Whether this is a final state.
	IsFinal *bool `json:"is_final,omitempty"`

	// Name The name of the custom state.
	Name *string `json:"name,omitempty"`

	// Ordinal Ordinal of the custom state used to identify system states.
	Ordinal *int32 `json:"ordinal,omitempty"`
}

// CustomStatesUpdateResponseBody defines model for custom-states-update-response.
type CustomStatesUpdateResponseBody struct {
	CustomState CustomState `json:"custom_state"`
}

// CustomTypeFragment defines model for custom-type-fragment.
type CustomTypeFragment struct {
	// Conditions The conditions associated with the fields.
	Conditions *[]CustomSchemaFragmentCondition `json:"conditions,omitempty"`
	CreatedBy  *UserSummary                     `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Deprecated Indicates if the fragment has been deprecated. Modifications to
	// this field are done in-place and don't result in creation of a new
	// fragment in chain.
	Deprecated *bool `json:"deprecated,omitempty"`

	// Description Description of the custom schema fragment.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Fields List of all fields in this custom schema fragment.
	Fields *[]SchemaFieldDescriptor `json:"fields,omitempty"`

	// FragmentType Type of the custom schema fragment.
	FragmentType *CustomSchemaFragmentFragmentType `json:"fragment_type,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsDeprecated Indicates if the fragment is deprecated. Modifications to this
	// field are done in-place and don't result in creation of a new
	// fragment in chain.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// LeafType Leaf type this fragment applies to.
	LeafType   *string      `json:"leaf_type,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate   *time.Time                   `json:"modified_date,omitempty"`
	NewFragmentRef *CustomSchemaFragmentSummary `json:"new_fragment_ref,omitempty"`
	OldFragmentRef *CustomSchemaFragmentSummary `json:"old_fragment_ref,omitempty"`

	// Path Path components used to display available custom types in tree
	// form.
	Path         *[]CustomTypePathComponent `json:"path,omitempty"`
	StageDiagram *StageDiagramSummary       `json:"stage_diagram,omitempty"`

	// StockFieldOverrides The stock field overrides.
	StockFieldOverrides *[]StockFieldOverride `json:"stock_field_overrides,omitempty"`

	// Subtype The string used to populate the subtype in the leaf type.
	Subtype *string `json:"subtype,omitempty"`

	// SubtypeDisplayName Display name of the subtype. Modifications to this field are done
	// in-place and don't result in creation of a new fragment in chain.
	SubtypeDisplayName *string `json:"subtype_display_name,omitempty"`
}

// CustomTypeFragmentSummary defines model for custom-type-fragment-summary.
type CustomTypeFragmentSummary = CustomSchemaFragmentBaseSummary

// CustomTypePathComponent Path component for rendering custom type lists in tree form.
type CustomTypePathComponent = map[string]interface{}

// Dashboard defines model for dashboard.
type Dashboard = AtomBase

// DashboardFilter A dashboard filter is a filter that can be applied to tabs, sections,
// and widgets.
type DashboardFilter = map[string]interface{}

// DashboardSearchSummary defines model for dashboard-search-summary.
type DashboardSearchSummary struct {
	Dashboard DashboardSummary `json:"dashboard"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// DashboardSummary defines model for dashboard-summary.
type DashboardSummary = AtomBaseSummary

// DataSourceJoin A list of possible joins for the data source. Follows foreign key
// semantics.
type DataSourceJoin = map[string]interface{}

// DateFilter Provides ways to specify date ranges on objects.
type DateFilter struct {
	// Type Type of date filter.
	Type  DateFilterType `json:"type"`
	union json.RawMessage
}

// DateFilterType Type of date filter.
type DateFilterType string

// DateTimeFilter defines model for date-time-filter.
type DateTimeFilter struct {
	// After Filters for objects created after the provided timestamp
	// (inclusive).
	After *time.Time `json:"after,omitempty"`

	// Before Filters for objects created before the provided timestamp
	// (inclusive).
	Before *time.Time `json:"before,omitempty"`
}

// DateTimePreset Provides preset types for date filter.
type DateTimePreset struct {
	// PresetType Type of date preset.
	PresetType DateTimePresetType `json:"preset_type"`
	union      json.RawMessage
}

// DateTimePresetLastNDays defines model for date-time-preset-last-n-days.
type DateTimePresetLastNDays struct {
	// Days The range starts from the current timestamp and continues for the
	// past n days.
	Days int `json:"days"`
}

// DateTimePresetNextNDays defines model for date-time-preset-next-n-days.
type DateTimePresetNextNDays struct {
	// Days The range starts from the current timestamp and continues for the
	// next n days.
	Days int `json:"days"`
}

// DateTimePresetType Type of date preset.
type DateTimePresetType string

// Definedness Indicates whether this evaluation can change in the future.
type Definedness string

// DeleteRevUsersPersonalDataRequest Request object to delete a contact's information.
type DeleteRevUsersPersonalDataRequest struct {
	// Email Email of the contact.
	Email string `json:"email"`
}

// DeleteRevUsersPersonalDataResponseBody Response for the contacts personal data delete request. Response is
// empty as the process is asynchronous. Upon completion, the user will be
// notified.
type DeleteRevUsersPersonalDataResponseBody = map[string]interface{}

// DevOrg defines model for dev-org.
type DevOrg struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DevSlug Customer chosen URL slug for the DevOrg.
	DevSlug string `json:"dev_slug"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// DevOrgAuthConnectionsCreateRequest Request to create a new enterprise authentication connection.
type DevOrgAuthConnectionsCreateRequest struct {
	// DisplayName Display name of the authentication connection. This name will be
	// visible to all the users when they sign in to this Dev
	// organization. For example, if the display_name is 'abclogin', then
	// it would appear on the login button as 'Log in to abclogin'.
	DisplayName *string `json:"display_name,omitempty"`

	// Type Defines the type for the authentication connection. Different types of
	// authentication connections have different configuration parameters.
	Type  DevOrgAuthConnectionsCreateRequestType `json:"type"`
	union json.RawMessage
}

// DevOrgAuthConnectionsCreateRequestAzureAdOptions Object encapsulating the configuration parameters for an Azure AD
// authentication connection.
type DevOrgAuthConnectionsCreateRequestAzureAdOptions struct {
	// ClientId Client ID for the Azure authentication connection.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret for the Azure authentication connection.
	ClientSecret string `json:"client_secret"`

	// Domain Domain URL of the Azure authentication connection.
	Domain string `json:"domain"`
}

// DevOrgAuthConnectionsCreateRequestGoogleAppsOptions Object encapsulating the configuration parameters for a Google Apps
// authentication connection.
type DevOrgAuthConnectionsCreateRequestGoogleAppsOptions struct {
	// ClientId Client ID for the Google Apps authentication connection.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret for the Google Apps authentication connection.
	ClientSecret string `json:"client_secret"`

	// TenantDomain Tenant domain URL of the Google Apps authentication connection.
	TenantDomain string `json:"tenant_domain"`
}

// DevOrgAuthConnectionsCreateRequestOidcOptions Object encapsulating the configuration parameters for an OIDC
// authentication connection.
type DevOrgAuthConnectionsCreateRequestOidcOptions struct {
	// ClientId Client ID for the OIDC authentication connection.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret for the OIDC authentication connection.
	ClientSecret string `json:"client_secret"`

	// Issuer Issuer URL of the OIDC authentication connection.
	Issuer string `json:"issuer"`
}

// DevOrgAuthConnectionsCreateRequestOktaOptions Object encapsulating the configuration parameters for an Okta
// authentication connection.
type DevOrgAuthConnectionsCreateRequestOktaOptions struct {
	// ClientId Client ID for the Okta authentication connection.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret for the Okta authentication connection.
	ClientSecret string `json:"client_secret"`

	// Domain Domain URL of the Okta authentication connection.
	Domain string `json:"domain"`
}

// DevOrgAuthConnectionsCreateRequestSamlOptions Object encapsulating the configuration parameters for a SAML
// authentication connection.
type DevOrgAuthConnectionsCreateRequestSamlOptions struct {
	// ConnectionName Connection name for the SAML authentication connection. Must match
	// the `connection` query parameter specified in the sign on URL
	// during SAML configuration in your identity provider.
	ConnectionName *string                  `json:"connection_name,omitempty"`
	FieldsMap      *SamlConnectionFieldsMap `json:"fields_map,omitempty"`

	// SignInEndpoint Sign In endpoint for the SAML authentication connection.
	SignInEndpoint string `json:"sign_in_endpoint"`

	// SigningCert Signing certificate for the SAML authentication connection.
	SigningCert string `json:"signing_cert"`
}

// DevOrgAuthConnectionsCreateRequestType Defines the type for the authentication connection. Different types of
// authentication connections have different configuration parameters.
type DevOrgAuthConnectionsCreateRequestType string

// DevOrgAuthConnectionsCreateResponseBody Response for the request to create a new enterprise authentication
// connection.
type DevOrgAuthConnectionsCreateResponseBody struct {
	// AuthConnection Connection object that specifies the configuration for an
	// authentication connection that is set up for a Dev organization.
	AuthConnection AuthConnection `json:"auth_connection"`
}

// DevOrgAuthConnectionsDeleteRequest Request to delete an enterprise authentication connection for a Dev
// organization. A default connection and a connection which is currently
// enabled cannot be deleted.
type DevOrgAuthConnectionsDeleteRequest struct {
	// Id ID of the authentication connection to be deleted.
	Id string `json:"id"`
}

// DevOrgAuthConnectionsGetRequest Request to get configuration details of organization's authentication
// Connection.
type DevOrgAuthConnectionsGetRequest struct {
	// Id ID of the authentication connection.
	Id string `json:"id"`
}

// DevOrgAuthConnectionsGetResponseBody Response object encapsulating the configuration details of an
// authentication connection.
type DevOrgAuthConnectionsGetResponseBody struct {
	// AuthConnection Connection object that specifies the configuration for an
	// authentication connection that is set up for a Dev organization.
	AuthConnection AuthConnection `json:"auth_connection"`
}

// DevOrgAuthConnectionsListResponseBody Response object for the request to list all the social and enterprise
// authentication connections configured for a Dev organization.
type DevOrgAuthConnectionsListResponseBody struct {
	// AuthConnections List of all the authentication connections currently configured for
	// a Dev organization.
	AuthConnections []AuthConnection `json:"auth_connections"`
}

// DevOrgAuthConnectionsToggleRequest Request to enable or disable an authentication connection for a Dev
// organization.
type DevOrgAuthConnectionsToggleRequest struct {
	// Id ID of the authentication connection to be toggled.
	Id     string                `json:"id"`
	Toggle *AuthConnectionToggle `json:"toggle,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequest Request to update an enterprise authentication connection for a Dev
// organization.
type DevOrgAuthConnectionsUpdateRequest struct {
	// DisplayName New display name of the authentication connection. This name will
	// be visible to all the users when they sign in to this Dev
	// organization. For example, if the display_name is 'abclogin', then
	// it would appear on the login button as 'Log in to abclogin'.
	DisplayName *string `json:"display_name,omitempty"`

	// Id ID of the authentication connection which is to be updated.
	Id string `json:"id"`

	// Type Specifies the type for the authentication connection. Different types
	// of authentication connections have different configuration parameters
	// that can be updated.
	Type  *DevOrgAuthConnectionsUpdateRequestType `json:"type,omitempty"`
	union json.RawMessage
}

// DevOrgAuthConnectionsUpdateRequestAzureAdOptions Object encapsulating the configuration parameters for an Azure AD
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestAzureAdOptions struct {
	// ClientId Client ID for the Azure authentication connection.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for the Azure authentication connection.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Domain Domain URL of the Azure authentication connection.
	Domain *string `json:"domain,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions Object encapsulating the configuration parameters for a Google Apps
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions struct {
	// ClientId Client ID for the Google Apps authentication connection.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for the Google Apps authentication connection.
	ClientSecret *string `json:"client_secret,omitempty"`

	// TenantDomain Tenant domain URL of the Google Apps authentication connection.
	TenantDomain *string `json:"tenant_domain,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestOidcOptions Object encapsulating the configuration parameters for an OIDC
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestOidcOptions struct {
	// ClientId Client ID for the OIDC authentication connection.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for the OIDC authentication connection.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Issuer Issuer URL of the OIDC authentication connection.
	Issuer *string `json:"issuer,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestOktaOptions Object encapsulating the configuration parameters for an Okta
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestOktaOptions struct {
	// ClientId Client ID for the Okta authentication connection.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for the Okta authentication connection.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Domain Domain URL of the Okta authentication connection.
	Domain *string `json:"domain,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestSamlOptions Object encapsulating the configuration parameters for a SAML
// authentication connection.
type DevOrgAuthConnectionsUpdateRequestSamlOptions struct {
	FieldsMap *SamlConnectionFieldsMap `json:"fields_map,omitempty"`

	// SignInEndpoint Sign In endpoint for the SAML authentication connection.
	SignInEndpoint *string `json:"sign_in_endpoint,omitempty"`

	// SigningCert Signing certificate for the SAML authentication connection.
	SigningCert *string `json:"signing_cert,omitempty"`
}

// DevOrgAuthConnectionsUpdateRequestType Specifies the type for the authentication connection. Different types
// of authentication connections have different configuration parameters
// that can be updated.
type DevOrgAuthConnectionsUpdateRequestType string

// DevOrgAuthConnectionsUpdateResponseBody Response for the request to update an enterprise authentication
// connection.
type DevOrgAuthConnectionsUpdateResponseBody struct {
	// AuthConnection Connection object that specifies the configuration for an
	// authentication connection that is set up for a Dev organization.
	AuthConnection AuthConnection `json:"auth_connection"`
}

// DevOrgSummary defines model for dev-org-summary.
type DevOrgSummary struct {
	// DevSlug Customer chosen URL slug for the DevOrg.
	DevSlug string `json:"dev_slug"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`
}

// DevOrgsGetRequest A request to get a Dev organization's information.
type DevOrgsGetRequest = map[string]interface{}

// DevOrgsGetResponseBody The response to get a Dev organization's information.
type DevOrgsGetResponseBody struct {
	DevOrg DevOrg `json:"dev_org"`
}

// DevUser defines model for dev-user.
type DevUser struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// ExperienceStartDate Start date of the user's employment.
	ExperienceStartDate *time.Time `json:"experience_start_date,omitempty"`

	// ExternalIdentities IDs of the Dev User outside the DevRev SOR.
	ExternalIdentities *[]ExternalIdentity `json:"external_identities,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// JobHistory Job history of the user.
	JobHistory *[]JobHistoryItem `json:"job_history,omitempty"`
	ModifiedBy *UserSummary      `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// PhoneNumbers Phone numbers of the user.
	PhoneNumbers    *[]string    `json:"phone_numbers,omitempty"`
	PrimaryIdentity *UserSummary `json:"primary_identity,omitempty"`

	// Skills Array of skills of the user.
	Skills *[]UserSkill `json:"skills,omitempty"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`
}

// DevUserExternalIdentityFilter defines model for dev-user-external-identity-filter.
type DevUserExternalIdentityFilter struct {
	// Id Unique ID of the user in the external source.
	Id *string `json:"id,omitempty"`

	// Issuer Issuer of the external identity of the user.
	Issuer *string `json:"issuer,omitempty"`
}

// DevUserJobTitle Job title of the Dev User.
type DevUserJobTitle string

// DevUserSummary defines model for dev-user-summary.
type DevUserSummary = UserBaseSummary

// DevUsersActivateRequest A request to activate the Dev user.
type DevUsersActivateRequest struct {
	// Groups IDs of the groups assigned to user during activation.
	Groups *[]string `json:"groups,omitempty"`

	// Id The ID for the Dev user.
	Id string `json:"id"`
}

// DevUsersActivateResponseBody The response to activate the Dev user.
type DevUsersActivateResponseBody struct {
	// InviteSent Whether an invitation has been sent to the Dev user.
	InviteSent bool `json:"invite_sent"`
}

// DevUsersCreateRequest Request object to create a new Dev user for a Dev organization.
type DevUsersCreateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Email Email of the Dev user.
	Email string `json:"email"`

	// FullName Full name of the Dev user.
	FullName *string `json:"full_name,omitempty"`

	// ReportsTo The ID of the user that the user reports to.
	ReportsTo *string                             `json:"reports_to,omitempty"`
	State     DevUsersCreateRequestStateEnumValue `json:"state"`
}

// DevUsersCreateRequestStateEnumValue defines model for dev-users-create-request-state-enum-value.
type DevUsersCreateRequestStateEnumValue string

// DevUsersCreateResponseBody Response object for request to create a new Dev user for a Dev
// organization.
type DevUsersCreateResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersDeactivateRequest A request to deactivate the Dev user.
type DevUsersDeactivateRequest struct {
	// Id The ID for the Dev user.
	Id string `json:"id"`
}

// DevUsersDeactivateResponseBody The response to deactivate the Dev user.
type DevUsersDeactivateResponseBody = map[string]interface{}

// DevUsersGetRequest A request to get a Dev user's information.
type DevUsersGetRequest struct {
	// Id User ID of the requested Dev user.
	Id string `json:"id"`
}

// DevUsersGetResponseBody The response to getting the information for the Dev user.
type DevUsersGetResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersIdentitiesLinkRequest Request to link external identity to a Dev user.
type DevUsersIdentitiesLinkRequest struct {
	// DevUser The ID of the Dev user to link the external identity to.
	DevUser string `json:"dev_user"`

	// DisplayName Display name of the Dev user in the external source.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Unique ID of the Dev user in the external source.
	Id string `json:"id"`

	// Issuer Issuer of the external identity of the Dev user.
	Issuer string `json:"issuer"`
}

// DevUsersIdentitiesLinkResponseBody Response for the request to link an external identity to a Dev user.
type DevUsersIdentitiesLinkResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersIdentitiesUnlinkRequest Request to unlink an external identity from a Dev user.
type DevUsersIdentitiesUnlinkRequest struct {
	// DevUser The ID of the Dev user to unlink the external identity from.
	DevUser string `json:"dev_user"`

	// Issuer Issuer that needs to be unlinked from a Dev user.
	Issuer string `json:"issuer"`
}

// DevUsersIdentitiesUnlinkResponseBody Response for the request to unlink an external identity from a Dev
// user.
type DevUsersIdentitiesUnlinkResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersListRequest A request to get the list of Dev user's information.
type DevUsersListRequest struct {
	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Email Filters Dev users based on email addresses.
	Email *[]string `json:"email,omitempty"`

	// ExternalIdentity Filters Dev users based on external identity.
	ExternalIdentity *[]DevUserExternalIdentityFilter `json:"external_identity,omitempty"`

	// Limit The maximum number of Dev users to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// SortBy Fields to sort the Dev users by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// State Filters Dev users based on state.
	State *[]UserState `json:"state,omitempty"`
}

// DevUsersListResponseBody The response to listing the Dev users.
type DevUsersListResponseBody struct {
	// DevUsers The list of Dev users.
	DevUsers []DevUser `json:"dev_users"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// DevUsersMergeRequest Request object for merging Dev users.
type DevUsersMergeRequest struct {
	// PrimaryUser The unique ID of the primary user.
	PrimaryUser string `json:"primary_user"`

	// SecondaryUser The unique ID of the secondary user.
	SecondaryUser string `json:"secondary_user"`
}

// DevUsersMergeResponseBody Response object for request to merge Dev users.
type DevUsersMergeResponseBody = map[string]interface{}

// DevUsersSelfRequest A request to get the authenticated user's information.
type DevUsersSelfRequest = map[string]interface{}

// DevUsersSelfResponseBody The response to getting the information for the authenticated user.
type DevUsersSelfResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DevUsersSelfUpdateRequest A request to update the user's information for the authenticated Dev
// user.
type DevUsersSelfUpdateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// DisplayName The updated display name of the Dev user.
	DisplayName *string `json:"display_name,omitempty"`

	// ExperienceStartDate Start date of Dev user's experience.
	ExperienceStartDate *time.Time `json:"experience_start_date,omitempty"`

	// FullName The updated full name of the Dev user.
	FullName *string `json:"full_name,omitempty"`

	// JobHistory Job history of the Dev user.
	JobHistory *[]DevUsersUpdateJobHistoryItem `json:"job_history,omitempty"`

	// JobTitle Job title of the Dev User.
	JobTitle *DevUserJobTitle `json:"job_title,omitempty"`
}

// DevUsersUpdateJobHistoryItem defines model for dev-users-update-job-history-item.
type DevUsersUpdateJobHistoryItem struct {
	// EmploymentStatus Enum for the employment status of the user.
	EmploymentStatus *int64 `json:"employment_status,omitempty"`

	// EndDate End date of the job.
	EndDate *time.Time `json:"end_date,omitempty"`

	// IsCurrent Is this the current active job for the user.
	IsCurrent *bool `json:"is_current,omitempty"`

	// Location The job location for the user.
	Location *string `json:"location,omitempty"`

	// StartDate Start date of the job.
	StartDate *time.Time `json:"start_date,omitempty"`

	// Title The job title for the user.
	Title *string `json:"title,omitempty"`
}

// DevUsersUpdateRequest A request to update the user's information corresponding to the
// provided Dev user.
type DevUsersUpdateRequest struct {
	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// DisplayName The updated display name of the Dev user.
	DisplayName *string `json:"display_name,omitempty"`

	// ExperienceStartDate Start date of Dev user's experience.
	ExperienceStartDate *time.Time `json:"experience_start_date,omitempty"`

	// FullName The updated full name of the Dev user.
	FullName *string `json:"full_name,omitempty"`

	// Id The ID for the Dev user to be updated.
	Id string `json:"id"`

	// JobHistory Job history of the Dev user.
	JobHistory *[]DevUsersUpdateJobHistoryItem `json:"job_history,omitempty"`

	// JobTitle Job title of the Dev User.
	JobTitle *DevUserJobTitle `json:"job_title,omitempty"`
}

// DevUsersUpdateResponseBody The response to update a Dev user.
type DevUsersUpdateResponseBody struct {
	DevUser DevUser `json:"dev_user"`
}

// DirectoriesCountRequest defines model for directories-count-request.
type DirectoriesCountRequest struct {
	// CreatedBy Filters for directories created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// ModifiedBy Filters for directories modified by any of the provided users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`
}

// DirectoriesCountResponseBody defines model for directories-count-response.
type DirectoriesCountResponseBody struct {
	// Count The total number of directories matching the filter.
	Count int32 `json:"count"`
}

// DirectoriesCreateRequest The request to create a directory.
type DirectoriesCreateRequest struct {
	// Description Description for the directory.
	Description *string `json:"description,omitempty"`

	// Icon Icon for the directory.
	Icon *string `json:"icon,omitempty"`

	// Language Language of the directory.
	Language *string `json:"language,omitempty"`

	// Parent Parent directory of the directory.
	Parent *string `json:"parent,omitempty"`

	// Published Whether the directory is published.
	Published *bool `json:"published,omitempty"`

	// Tags Tags associated with the directory.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Thumbnail ID of the thumbnail artifact.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title Title of the directory.
	Title string `json:"title"`
}

// DirectoriesCreateResponseBody Create directory response.
type DirectoriesCreateResponseBody struct {
	Directory Directory `json:"directory"`
}

// DirectoriesDeleteRequest The request to delete a directory.
type DirectoriesDeleteRequest struct {
	// Id The ID of the directory to delete.
	Id string `json:"id"`
}

// DirectoriesDeleteResponseBody defines model for directories-delete-response.
type DirectoriesDeleteResponseBody = map[string]interface{}

// DirectoriesGetRequest The request to get a directory.
type DirectoriesGetRequest struct {
	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `json:"dev_org,omitempty"`

	// Id The ID of the requested directory.
	Id string `json:"id"`
}

// DirectoriesGetResponseBody Get directory response.
type DirectoriesGetResponseBody struct {
	Directory Directory `json:"directory"`
}

// DirectoriesListRequest The request to list directories.
type DirectoriesListRequest struct {
	// CreatedBy Filters for directories created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `json:"dev_org,omitempty"`

	// Limit The maximum number of directories to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedBy Filters for directories modified by any of the provided users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`
}

// DirectoriesListResponseBody List directory response.
type DirectoriesListResponseBody struct {
	// Directories The list of directories.
	Directories []Directory `json:"directories"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// DirectoriesUpdateRequest The request to update a directory.
type DirectoriesUpdateRequest struct {
	// Description The updated description for the directory.
	Description *string `json:"description,omitempty"`

	// Icon The updated icon for the directory.
	Icon *string `json:"icon,omitempty"`

	// Id The ID of the directory to update.
	Id string `json:"id"`

	// Parent The updated parent directory for the directory.
	Parent *string `json:"parent"`

	// Published Whether the directory is published.
	Published *bool                            `json:"published,omitempty"`
	Reorder   *DirectoriesUpdateRequestReorder `json:"reorder,omitempty"`
	Tags      *DirectoriesUpdateRequestTags    `json:"tags,omitempty"`

	// Thumbnail The updated thumbnail for the directory.
	Thumbnail *string `json:"thumbnail"`

	// Title The updated title for the directory.
	Title *string `json:"title,omitempty"`
}

// DirectoriesUpdateRequestReorder defines model for directories-update-request-reorder.
type DirectoriesUpdateRequestReorder struct {
	// After The directory after which the reordered directory is placed.
	After *string `json:"after,omitempty"`

	// Before The directory before which the reordered directory is placed.
	Before *string `json:"before,omitempty"`
}

// DirectoriesUpdateRequestTags defines model for directories-update-request-tags.
type DirectoriesUpdateRequestTags struct {
	// Set Sets the provided tags on the directory.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// DirectoriesUpdateResponseBody Update directory response.
type DirectoriesUpdateResponseBody struct {
	Directory Directory `json:"directory"`
}

// Directory defines model for directory.
type Directory struct {
	Body      *ArtifactSummary `json:"body,omitempty"`
	CreatedBy *UserSummary     `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the directory.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Icon Icon of the directory.
	Icon *string `json:"icon,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time        `json:"modified_date,omitempty"`
	Parent       *DirectorySummary `json:"parent,omitempty"`

	// Published Whether the directory is published.
	Published *bool `json:"published,omitempty"`

	// Rank Rank of the directory.
	Rank *string `json:"rank,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the directory.
	Tags      *[]TagWithValue  `json:"tags,omitempty"`
	Thumbnail *ArtifactSummary `json:"thumbnail,omitempty"`

	// Title Title of the directory.
	Title *string `json:"title,omitempty"`
}

// DirectorySummary defines model for directory-summary.
type DirectorySummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`
}

// Dm defines model for dm.
type Dm struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Title The title given to the chat.
	Title *string `json:"title,omitempty"`

	// Users The users in the direct message. Only these users have access the
	// chat's history and can send new messages.
	Users []AtomSummary `json:"users"`
}

// DmSummary defines model for dm-summary.
type DmSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`

	// Title The title given to the chat.
	Title *string `json:"title,omitempty"`

	// Users The users in the direct message. Only these users have access the
	// chat's history and can send new messages.
	Users []AtomSummary `json:"users"`
}

// DonutVisualizationXAxis The X-axis for a donut visualization.
type DonutVisualizationXAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// DonutVisualizationYAxis The Y-axis for a donut visualization.
type DonutVisualizationYAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// DonutWidgetVisualization A donut chart visualization configuration. Includes metadata specific
// to donut charts.
type DonutWidgetVisualization struct {
	// X The configuration for the X-axis.
	X []DonutVisualizationXAxis `json:"x"`

	// Y The Y-axis for a donut visualization.
	Y DonutVisualizationYAxis `json:"y"`
}

// DynamicGroupInfo Information to define dynamic groups.
type DynamicGroupInfo = map[string]interface{}

// DynamicVistaSummary defines model for dynamic-vista-summary.
type DynamicVistaSummary = VistaBaseSummary

// EmailInfo defines model for email-info.
type EmailInfo struct {
	// Address The email address.
	Address string `json:"address"`

	// Name The email recipient's name.
	Name *string      `json:"name,omitempty"`
	User *UserSummary `json:"user,omitempty"`
}

// EmailInlineAttachment defines model for email-inline-attachment.
type EmailInlineAttachment struct {
	Artifact *ArtifactSummary `json:"artifact,omitempty"`

	// ContentId The content id of the attachment.
	ContentId *string `json:"content_id,omitempty"`
}

// EmailPreviewWidget defines model for email-preview-widget.
type EmailPreviewWidget struct {
	// Bcc The list of bcc addresses.
	Bcc []EmailInfo `json:"bcc"`

	// Cc The list of cc addresses.
	Cc        []EmailInfo  `json:"cc"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// From The list of from addresses.
	From []EmailInfo `json:"from"`

	// HtmlBody The html body of the email.
	HtmlBody *string `json:"html_body,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// InReplyTo The in-reply-to header of the email.
	InReplyTo *string `json:"in_reply_to,omitempty"`

	// Inlines The list of inline attachments.
	Inlines []EmailInlineAttachment `json:"inlines"`

	// Interactions A list of interactions supported by the widget.
	Interactions *[]SnapWidgetInteraction `json:"interactions,omitempty"`

	// IsSpam Whether the email is spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// MessageId The message id of the email.
	MessageId  *string      `json:"message_id,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name A human readable name for the snap widget.
	Name string `json:"name"`

	// Namespace Logical grouping of snap widgets. Useful for filtering.
	Namespace        *SnapWidgetNamespace `json:"namespace,omitempty"`
	RawEmailArtifact *ArtifactSummary     `json:"raw_email_artifact,omitempty"`

	// References The references header in the email.
	References []string `json:"references"`

	// ReplyTo The list of reply to addresses.
	ReplyTo []EmailInfo `json:"reply_to"`

	// SentTimestamp The time the email was sent.
	SentTimestamp *time.Time `json:"sent_timestamp,omitempty"`

	// Status The status of the snap widget.
	Status SnapWidgetStatus `json:"status"`

	// Subject The subject of the email.
	Subject *string `json:"subject,omitempty"`

	// TextBody The text body of the email.
	TextBody *string `json:"text_body,omitempty"`

	// To The list of to addresses.
	To []EmailInfo `json:"to"`
}

// EmbedLinksCreateRequest The request to create a new link embedded inside another create
// request.
type EmbedLinksCreateRequest struct {
	// LinkType Type of link used to define the relationship.
	LinkType LinkType `json:"link_type"`

	// Source The ID of the source object.
	Source *string `json:"source,omitempty"`

	// Target The ID of the target object.
	Target *string `json:"target,omitempty"`
}

// Empty defines model for empty.
type Empty = map[string]interface{}

// Engagement defines model for engagement.
type Engagement struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the engagement object.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// EngagementSummary defines model for engagement-summary.
type EngagementSummary = AtomBaseSummary

// EngagementType Type of engagement.
type EngagementType string

// EngagementsCountRequest defines model for engagements-count-request.
type EngagementsCountRequest struct {
	// ExternalRef Filters for meetings with the provided external_refs.
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// Members Filters for engagement of the provided members.
	Members *[]string `json:"members,omitempty"`

	// Parent Filters for engagements with the provided parent.
	Parent *[]string `json:"parent,omitempty"`

	// Type Filters for engagement of the provided types.
	Type *[]EngagementType `json:"type,omitempty"`
}

// EngagementsCountResponseBody defines model for engagements-count-response.
type EngagementsCountResponseBody struct {
	// Count The number of engagements matching the filter.
	Count int64 `json:"count"`
}

// EngagementsCreateRequest defines model for engagements-create-request.
type EngagementsCreateRequest struct {
	// Artifacts The IDs of the artifacts to associate with the engagement.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Description The description of the engagement.
	Description *string `json:"description,omitempty"`

	// EngagementType The type of engagement.
	EngagementType *EngagementsCreateRequestEngagementType `json:"engagement_type,omitempty"`

	// ExternalRef External Reference for the engagement.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalUrl External URL for the engagement.
	ExternalUrl *string `json:"external_url,omitempty"`

	// Members IDs of the users that were part of the engagement.
	Members []string `json:"members"`

	// Parent The parent object ID in which the engagement was created.
	// Currently, only accounts and opportunities are supported.
	Parent *string `json:"parent,omitempty"`

	// Parents The parent object IDs to which the engagement is associated.
	// Currently, only accounts and opportunities are supported.
	Parents *[]string `json:"parents,omitempty"`

	// ScheduledDate The date and time when the engagement was scheduled.
	ScheduledDate time.Time `json:"scheduled_date"`

	// Tags Tags associated with the engagement.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Title The title of the engagement.
	Title string `json:"title"`
}

// EngagementsCreateRequestEngagementType The type of engagement.
type EngagementsCreateRequestEngagementType string

// EngagementsCreateResponseBody defines model for engagements-create-response.
type EngagementsCreateResponseBody struct {
	Engagement Engagement `json:"engagement"`
}

// EngagementsDeleteRequest defines model for engagements-delete-request.
type EngagementsDeleteRequest struct {
	// Id The engagement ID.
	Id string `json:"id"`
}

// EngagementsDeleteResponseBody defines model for engagements-delete-response.
type EngagementsDeleteResponseBody = map[string]interface{}

// EngagementsGetRequest defines model for engagements-get-request.
type EngagementsGetRequest struct {
	// Id The engagement ID.
	Id string `json:"id"`
}

// EngagementsGetResponseBody defines model for engagements-get-response.
type EngagementsGetResponseBody struct {
	Engagement Engagement `json:"engagement"`
}

// EngagementsListRequest defines model for engagements-list-request.
type EngagementsListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// ExternalRef Filters for meetings with the provided external_refs.
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// Limit The maximum number of engagements to return.
	Limit *int32 `json:"limit,omitempty"`

	// Members Filters for engagement of the provided members.
	Members *[]string `json:"members,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Parent Filters for engagements with the provided parent.
	Parent *[]string `json:"parent,omitempty"`

	// SortBy Fields to sort the engagements by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Type Filters for engagement of the provided types.
	Type *[]EngagementType `json:"type,omitempty"`
}

// EngagementsListResponseBody defines model for engagements-list-response.
type EngagementsListResponseBody struct {
	// Engagements The list of engagements.
	Engagements []Engagement `json:"engagements"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// EngagementsUpdateRequest defines model for engagements-update-request.
type EngagementsUpdateRequest struct {
	Artifacts *EngagementsUpdateRequestArtifactIds `json:"artifacts,omitempty"`

	// Description Updates the description of the engagement.
	Description *string `json:"description,omitempty"`

	// ExternalRef External Reference for the engagement.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalUrl Updates the external URL for the engagement.
	ExternalUrl *string `json:"external_url,omitempty"`

	// Id The engagement ID.
	Id      string                           `json:"id"`
	Members *EngagementsUpdateRequestMembers `json:"members,omitempty"`
	Parents *EngagementsUpdateRequestParents `json:"parents,omitempty"`

	// ScheduledDate Updates the date and time when the engagement was scheduled.
	ScheduledDate *time.Time                    `json:"scheduled_date"`
	Tags          *EngagementsUpdateRequestTags `json:"tags,omitempty"`

	// Title Updates the title of the engagement.
	Title *string `json:"title,omitempty"`
}

// EngagementsUpdateRequestArtifactIds defines model for engagements-update-request-artifact-ids.
type EngagementsUpdateRequestArtifactIds struct {
	// Set Sets the IDs to the provided artifact IDs.
	Set *[]string `json:"set,omitempty"`
}

// EngagementsUpdateRequestMembers defines model for engagements-update-request-members.
type EngagementsUpdateRequestMembers struct {
	// Set Sets the members to the provided user IDs. If specified, this must
	// not be empty.
	Set *[]string `json:"set,omitempty"`
}

// EngagementsUpdateRequestParents defines model for engagements-update-request-parents.
type EngagementsUpdateRequestParents struct {
	// Set Sets the parent IDs.
	Set *[]string `json:"set,omitempty"`
}

// EngagementsUpdateRequestTags defines model for engagements-update-request-tags.
type EngagementsUpdateRequestTags struct {
	// Set Sets the provided tags on the engagement item.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// EngagementsUpdateResponseBody defines model for engagements-update-response.
type EngagementsUpdateResponseBody struct {
	Engagement Engagement `json:"engagement"`
}

// Enhancement defines model for enhancement.
type Enhancement struct {
	// ActualCloseDate Actual close date for the object.
	ActualCloseDate *time.Time `json:"actual_close_date,omitempty"`

	// ActualStartDate Actual start date for the object.
	ActualStartDate *time.Time `json:"actual_start_date,omitempty"`

	// Artifacts The attached artifacts.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`
	CreatedBy *UserSummary       `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// Description Description of the part.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Name of the part.
	Name string `json:"name"`

	// OwnedBy The users that own the part.
	OwnedBy []UserSummary `json:"owned_by"`

	// StageV2 Describes the current stage of a object.
	StageV2 *Stage `json:"stage_v2,omitempty"`

	// StateV2 State of the object based upon the stage.
	StateV2 *string `json:"state_v2,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Target close date for the object.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// TargetStartDate Target start date for the object.
	TargetStartDate *time.Time `json:"target_start_date,omitempty"`
}

// EnhancementRevScoreTier Rev Score tier of the enhancement.
type EnhancementRevScoreTier string

// EnhancementSummary defines model for enhancement-summary.
type EnhancementSummary = PartBaseSummary

// EnumValue The properties of an enum value.
type EnumValue struct {
	// Id The unique ID of the enum value.
	Id int64 `json:"id"`

	// Label The display label of the enum value.
	Label string `json:"label"`

	// Ordinal Used for determining the relative order of the enum value.
	Ordinal int64 `json:"ordinal"`

	// Value The actual value of the enum value.
	Value *interface{} `json:"value,omitempty"`
}

// EnumValueSummary The properties of an enum value.
type EnumValueSummary struct {
	// Id The unique ID of the enum value.
	Id int64 `json:"id"`

	// Label The display label of the enum value.
	Label string `json:"label"`

	// Ordinal Used for determining the relative order of the enum value.
	Ordinal int64 `json:"ordinal"`
}

// Error defines model for error.
type Error struct {
	// Message Information about the error.
	Message string `json:"message"`

	// Status The corresponding HTTP status code.
	Status int32 `json:"status"`

	// Type The error type.
	Type *string `json:"type,omitempty"`
}

// ErrorBadRequest defines model for error-bad-request.
type ErrorBadRequest struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string             `json:"message,omitempty"`
	Type    ErrorBadRequestType `json:"type"`
	union   json.RawMessage
}

// ErrorBadRequestArtifactAlreadyAttachedToAParent defines model for error-bad-request-artifact-already-attached-to-a-parent.
type ErrorBadRequestArtifactAlreadyAttachedToAParent struct {
	// ExistingParent The existing parent attached to the artifact.
	ExistingParent string `json:"existing_parent"`

	// IsSame Whether the existing parent is the same as the new parent.
	IsSame bool `json:"is_same"`
}

// ErrorBadRequestBadRequest defines model for error-bad-request-bad-request.
type ErrorBadRequestBadRequest = map[string]interface{}

// ErrorBadRequestCustomizationValidationError Describes an error encountered during customization validation.
type ErrorBadRequestCustomizationValidationError struct {
	// FieldName The name of the invalid field.
	FieldName *string `json:"field_name,omitempty"`

	// Reason The reason given for the error.
	Reason  *string                                            `json:"reason,omitempty"`
	Subtype ErrorBadRequestCustomizationValidationErrorSubtype `json:"subtype"`
	union   json.RawMessage
}

// ErrorBadRequestCustomizationValidationErrorBadIdType defines model for error-bad-request-customization-validation-error-bad-id-type.
type ErrorBadRequestCustomizationValidationErrorBadIdType = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorDateParseError defines model for error-bad-request-customization-validation-error-date-parse-error.
type ErrorBadRequestCustomizationValidationErrorDateParseError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorEnumOutOfRange defines model for error-bad-request-customization-validation-error-enum-out-of-range.
type ErrorBadRequestCustomizationValidationErrorEnumOutOfRange = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorExpressionParseError defines model for error-bad-request-customization-validation-error-expression-parse-error.
type ErrorBadRequestCustomizationValidationErrorExpressionParseError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFieldDropped defines model for error-bad-request-customization-validation-error-field-dropped.
type ErrorBadRequestCustomizationValidationErrorFieldDropped = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFieldImmutable defines model for error-bad-request-customization-validation-error-field-immutable.
type ErrorBadRequestCustomizationValidationErrorFieldImmutable = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFieldNotInSchema defines model for error-bad-request-customization-validation-error-field-not-in-schema.
type ErrorBadRequestCustomizationValidationErrorFieldNotInSchema = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFieldRequired defines model for error-bad-request-customization-validation-error-field-required.
type ErrorBadRequestCustomizationValidationErrorFieldRequired = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorFragmentNotFound defines model for error-bad-request-customization-validation-error-fragment-not-found.
type ErrorBadRequestCustomizationValidationErrorFragmentNotFound = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorIdParseError defines model for error-bad-request-customization-validation-error-id-parse-error.
type ErrorBadRequestCustomizationValidationErrorIdParseError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed defines model for error-bad-request-customization-validation-error-id-type-not-allowed.
type ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorInvalidArgument defines model for error-bad-request-customization-validation-error-invalid-argument.
type ErrorBadRequestCustomizationValidationErrorInvalidArgument = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorSubtype defines model for error-bad-request-customization-validation-error-subtype.
type ErrorBadRequestCustomizationValidationErrorSubtype string

// ErrorBadRequestCustomizationValidationErrorTimestampParseError defines model for error-bad-request-customization-validation-error-timestamp-parse-error.
type ErrorBadRequestCustomizationValidationErrorTimestampParseError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorUnknownError defines model for error-bad-request-customization-validation-error-unknown-error.
type ErrorBadRequestCustomizationValidationErrorUnknownError = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorUnsupportedType defines model for error-bad-request-customization-validation-error-unsupported-type.
type ErrorBadRequestCustomizationValidationErrorUnsupportedType = map[string]interface{}

// ErrorBadRequestCustomizationValidationErrorWrongType defines model for error-bad-request-customization-validation-error-wrong-type.
type ErrorBadRequestCustomizationValidationErrorWrongType = map[string]interface{}

// ErrorBadRequestInvalidApiVersion defines model for error-bad-request-invalid-api-version.
type ErrorBadRequestInvalidApiVersion struct {
	// Value The provided API version.
	Value string `json:"value"`
}

// ErrorBadRequestInvalidEnumValue defines model for error-bad-request-invalid-enum-value.
type ErrorBadRequestInvalidEnumValue struct {
	// AllowedValues The allowed values for the field.
	AllowedValues []string `json:"allowed_values"`

	// FieldName The field whose enum value is invalid.
	FieldName string `json:"field_name"`

	// Value The value that was received.
	Value string `json:"value"`
}

// ErrorBadRequestInvalidField defines model for error-bad-request-invalid-field.
type ErrorBadRequestInvalidField struct {
	// FieldName The field name that's invalid.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestInvalidId defines model for error-bad-request-invalid-id.
type ErrorBadRequestInvalidId struct {
	// FieldName The field whose ID is invalid.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestMergeWorksError defines model for error-bad-request-merge-works-error.
type ErrorBadRequestMergeWorksError struct {
	// Errors The errors encountered during the validation of the merge.
	Errors *[]ErrorBadRequestMergeWorksErrorError `json:"errors,omitempty"`
}

// ErrorBadRequestMergeWorksErrorError defines model for error-bad-request-merge-works-error-error.
type ErrorBadRequestMergeWorksErrorError struct {
	AlreadyMerged *ErrorBadRequestMergeWorksErrorErrorAlreadyMerged `json:"already_merged,omitempty"`
	Closed        *ErrorBadRequestMergeWorksErrorErrorClosed        `json:"closed,omitempty"`

	// Details The details of the error.
	Details                 string                                                      `json:"details"`
	DifferentReporters      *ErrorBadRequestMergeWorksErrorErrorDifferentReporters      `json:"different_reporters,omitempty"`
	DifferentWorkspace      *ErrorBadRequestMergeWorksErrorErrorDifferentWorkspace      `json:"different_workspace,omitempty"`
	InvalidStageTransition  *ErrorBadRequestMergeWorksErrorErrorInvalidStageTransition  `json:"invalid_stage_transition,omitempty"`
	Locked                  *ErrorBadRequestMergeWorksErrorErrorLocked                  `json:"locked,omitempty"`
	StageNotFoundForSubtype *ErrorBadRequestMergeWorksErrorErrorStageNotFoundForSubtype `json:"stage_not_found_for_subtype,omitempty"`
	Subtype                 *ErrorBadRequestMergeWorksErrorErrorSubtype                 `json:"subtype,omitempty"`

	// Work The ID of the work which failed the validation.
	Work string `json:"work"`
}

// ErrorBadRequestMergeWorksErrorErrorSubtype defines model for ErrorBadRequestMergeWorksErrorError.Subtype.
type ErrorBadRequestMergeWorksErrorErrorSubtype string

// ErrorBadRequestMergeWorksErrorErrorAlreadyMerged defines model for error-bad-request-merge-works-error-error-already-merged.
type ErrorBadRequestMergeWorksErrorErrorAlreadyMerged struct {
	// MergedInto ID of the work into which the work was merged.
	MergedInto string `json:"merged_into"`
}

// ErrorBadRequestMergeWorksErrorErrorClosed defines model for error-bad-request-merge-works-error-error-closed.
type ErrorBadRequestMergeWorksErrorErrorClosed = map[string]interface{}

// ErrorBadRequestMergeWorksErrorErrorDifferentReporters defines model for error-bad-request-merge-works-error-error-different-reporters.
type ErrorBadRequestMergeWorksErrorErrorDifferentReporters struct {
	// PrimaryReporters The reporters of the primary work.
	PrimaryReporters *[]string `json:"primary_reporters,omitempty"`

	// SecondaryReporters The reporters of the secondary work.
	SecondaryReporters *[]string `json:"secondary_reporters,omitempty"`
}

// ErrorBadRequestMergeWorksErrorErrorDifferentWorkspace defines model for error-bad-request-merge-works-error-error-different-workspace.
type ErrorBadRequestMergeWorksErrorErrorDifferentWorkspace struct {
	// PrimaryWorkspace The workspace of the primary work.
	PrimaryWorkspace *string `json:"primary_workspace,omitempty"`

	// SecondaryWorkspace The workspace of the secondary work.
	SecondaryWorkspace *string `json:"secondary_workspace,omitempty"`
}

// ErrorBadRequestMergeWorksErrorErrorInvalidStageTransition defines model for error-bad-request-merge-works-error-error-invalid-stage-transition.
type ErrorBadRequestMergeWorksErrorErrorInvalidStageTransition struct {
	// CurrentStage The current stage of the work.
	CurrentStage string `json:"current_stage"`

	// RequestedStage The stage to which the transition isn't allowed.
	RequestedStage string `json:"requested_stage"`
}

// ErrorBadRequestMergeWorksErrorErrorLocked defines model for error-bad-request-merge-works-error-error-locked.
type ErrorBadRequestMergeWorksErrorErrorLocked = map[string]interface{}

// ErrorBadRequestMergeWorksErrorErrorStageNotFoundForSubtype defines model for error-bad-request-merge-works-error-error-stage-not-found-for-subtype.
type ErrorBadRequestMergeWorksErrorErrorStageNotFoundForSubtype struct {
	// Subtype The subtype of the work for which stage is not configured.
	Subtype *string `json:"subtype,omitempty"`
}

// ErrorBadRequestMissingDependency defines model for error-bad-request-missing-dependency.
type ErrorBadRequestMissingDependency struct {
	// Dependencies The dependent fields.
	Dependencies *[]ErrorBadRequestMissingDependencyDependency `json:"dependencies,omitempty"`

	// DependentFieldName The field on which the value depends.
	DependentFieldName *string `json:"dependent_field_name,omitempty"`

	// DependentFieldValue The value which needs to be set of the dependent field.
	DependentFieldValue *string `json:"dependent_field_value,omitempty"`

	// ProvidedFieldName The field whose value was received.
	ProvidedFieldName *string `json:"provided_field_name,omitempty"`

	// ProvidedFieldValue The value that was received.
	ProvidedFieldValue *string `json:"provided_field_value,omitempty"`
}

// ErrorBadRequestMissingDependencyDependency defines model for error-bad-request-missing-dependency-dependency.
type ErrorBadRequestMissingDependencyDependency struct {
	// FieldName The dependent field name.
	FieldName string `json:"field_name"`

	// FieldValue The dependent field value.
	FieldValue string `json:"field_value"`
}

// ErrorBadRequestMissingRequiredField defines model for error-bad-request-missing-required-field.
type ErrorBadRequestMissingRequiredField struct {
	// FieldName The missing field's name.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestParseError defines model for error-bad-request-parse-error.
type ErrorBadRequestParseError = map[string]interface{}

// ErrorBadRequestStaleSchemaFragments Error indicating that the request contained one or more stale schema
// fragments, which are schema fragments that have been replaced by a
// newer version and are therefore considered deprecated schema fragments.
// The caller should refresh and use the latest schema fragments in their
// request.
type ErrorBadRequestStaleSchemaFragments = map[string]interface{}

// ErrorBadRequestType defines model for error-bad-request-type.
type ErrorBadRequestType string

// ErrorBadRequestUnexpectedIdType defines model for error-bad-request-unexpected-id-type.
type ErrorBadRequestUnexpectedIdType struct {
	// FieldName The field whose ID type is unexpected.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestUnexpectedJsonType defines model for error-bad-request-unexpected-json-type.
type ErrorBadRequestUnexpectedJsonType struct {
	Actual   ErrorBadRequestUnexpectedJsonTypeType `json:"actual"`
	Expected ErrorBadRequestUnexpectedJsonTypeType `json:"expected"`

	// FieldName The field name that's invalid.
	FieldName string `json:"field_name"`
}

// ErrorBadRequestUnexpectedJsonTypeType defines model for error-bad-request-unexpected-json-type-type.
type ErrorBadRequestUnexpectedJsonTypeType string

// ErrorBadRequestValueNotPermitted defines model for error-bad-request-value-not-permitted.
type ErrorBadRequestValueNotPermitted struct {
	// AllowedValues The allowed values for the field.
	AllowedValues *[]string `json:"allowed_values,omitempty"`

	// FieldName The field whose value is not permitted.
	FieldName string `json:"field_name"`

	// Reason The reason the value isn't permitted.
	Reason *string `json:"reason,omitempty"`
}

// ErrorBadRequestWorkflowComponentValidationError Error indicating that one or more workflow components failed
// validation.
type ErrorBadRequestWorkflowComponentValidationError struct {
	// Code Error code uniquely identifying the validation issue.
	Code string `json:"code"`

	// Field Represents a field with a violation.
	Field    *ErrorBadRequestWorkflowComponentValidationErrorField                                   `json:"field,omitempty"`
	Location *ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType `json:"location,omitempty"`

	// Message Human-readable message describing the issue.
	Message string `json:"message"`

	// Operation Represents an operation with a violation.
	Operation *ErrorBadRequestWorkflowComponentValidationErrorOperation `json:"operation,omitempty"`

	// Workflow Represents a workflow with a violation.
	Workflow *ErrorBadRequestWorkflowComponentValidationErrorWorkflow `json:"workflow,omitempty"`

	// WorkflowStep Represents a workflow step with a violation.
	WorkflowStep *ErrorBadRequestWorkflowComponentValidationErrorWorkflowStep `json:"workflow_step,omitempty"`
}

// ErrorBadRequestWorkflowComponentValidationErrorField Represents a field with a violation.
type ErrorBadRequestWorkflowComponentValidationErrorField struct {
	// FieldPath Path to the field with dot notation.
	FieldPath string `json:"field_path"`

	// ParentId The parent object containing the field.
	ParentId string `json:"parent_id"`
}

// ErrorBadRequestWorkflowComponentValidationErrorOperation Represents an operation with a violation.
type ErrorBadRequestWorkflowComponentValidationErrorOperation struct {
	// Id The ID of the operation with the error.
	Id string `json:"id"`
}

// ErrorBadRequestWorkflowComponentValidationErrorWorkflow Represents a workflow with a violation.
type ErrorBadRequestWorkflowComponentValidationErrorWorkflow struct {
	// Id The ID of the workflow with the error.
	Id string `json:"id"`
}

// ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType defines model for error-bad-request-workflow-component-validation-error-workflow-component-validation-location-type.
type ErrorBadRequestWorkflowComponentValidationErrorWorkflowComponentValidationLocationType string

// ErrorBadRequestWorkflowComponentValidationErrorWorkflowStep Represents a workflow step with a violation.
type ErrorBadRequestWorkflowComponentValidationErrorWorkflowStep struct {
	// Id The ID of the workflow step with the error.
	Id string `json:"id"`
}

// ErrorBadRequestWorkflowComponentValidationErrors defines model for error-bad-request-workflow-component-validation-errors.
type ErrorBadRequestWorkflowComponentValidationErrors struct {
	// Errors Nested validation errors.
	Errors *[]ErrorBadRequestWorkflowComponentValidationError `json:"errors,omitempty"`
}

// ErrorBase defines model for error-base.
type ErrorBase struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string `json:"message,omitempty"`
}

// ErrorConflict defines model for error-conflict.
type ErrorConflict struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string           `json:"message,omitempty"`
	Type    ErrorConflictType `json:"type"`
	union   json.RawMessage
}

// ErrorConflictConflict defines model for error-conflict-conflict.
type ErrorConflictConflict = map[string]interface{}

// ErrorConflictType defines model for error-conflict-type.
type ErrorConflictType string

// ErrorForbidden defines model for error-forbidden.
type ErrorForbidden struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string            `json:"message,omitempty"`
	Type    ErrorForbiddenType `json:"type"`
	union   json.RawMessage
}

// ErrorForbiddenForbidden defines model for error-forbidden-forbidden.
type ErrorForbiddenForbidden = map[string]interface{}

// ErrorForbiddenType defines model for error-forbidden-type.
type ErrorForbiddenType string

// ErrorInternalServerError defines model for error-internal-server-error.
type ErrorInternalServerError struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string `json:"message,omitempty"`

	// ReferenceId A unique ID that's generated for the error that can be used for
	// inquiry.
	ReferenceId *string                      `json:"reference_id,omitempty"`
	Type        ErrorInternalServerErrorType `json:"type"`
	union       json.RawMessage
}

// ErrorInternalServerErrorInternalError defines model for error-internal-server-error-internal-error.
type ErrorInternalServerErrorInternalError = map[string]interface{}

// ErrorInternalServerErrorType defines model for error-internal-server-error-type.
type ErrorInternalServerErrorType string

// ErrorNotFound defines model for error-not-found.
type ErrorNotFound struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string           `json:"message,omitempty"`
	Type    ErrorNotFoundType `json:"type"`
	union   json.RawMessage
}

// ErrorNotFoundNotFound defines model for error-not-found-not-found.
type ErrorNotFoundNotFound = map[string]interface{}

// ErrorNotFoundType defines model for error-not-found-type.
type ErrorNotFoundType string

// ErrorServiceUnavailable defines model for error-service-unavailable.
type ErrorServiceUnavailable struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string                     `json:"message,omitempty"`
	Type    ErrorServiceUnavailableType `json:"type"`
	union   json.RawMessage
}

// ErrorServiceUnavailableServiceUnavailable defines model for error-service-unavailable-service-unavailable.
type ErrorServiceUnavailableServiceUnavailable = map[string]interface{}

// ErrorServiceUnavailableType defines model for error-service-unavailable-type.
type ErrorServiceUnavailableType string

// ErrorTooManyRequests defines model for error-too-many-requests.
type ErrorTooManyRequests struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string `json:"message,omitempty"`

	// RetryAfter The number of seconds after which the client should retry.
	RetryAfter *int64                   `json:"retry_after,omitempty"`
	Type       ErrorTooManyRequestsType `json:"type"`
	union      json.RawMessage
}

// ErrorTooManyRequestsTooManyRequests defines model for error-too-many-requests-too-many-requests.
type ErrorTooManyRequestsTooManyRequests = map[string]interface{}

// ErrorTooManyRequestsType defines model for error-too-many-requests-type.
type ErrorTooManyRequestsType string

// ErrorUnauthorized defines model for error-unauthorized.
type ErrorUnauthorized struct {
	// Detail Error detail information.
	Detail *string `json:"detail,omitempty"`

	// Message The message associated with the error.
	Message *string               `json:"message,omitempty"`
	Type    ErrorUnauthorizedType `json:"type"`
	union   json.RawMessage
}

// ErrorUnauthorizedType defines model for error-unauthorized-type.
type ErrorUnauthorizedType string

// ErrorUnauthorizedUnauthenticated defines model for error-unauthorized-unauthenticated.
type ErrorUnauthorizedUnauthenticated = map[string]interface{}

// EventAccountCreated defines model for event-account-created.
type EventAccountCreated struct {
	Account Account `json:"account"`
}

// EventAccountDeleted defines model for event-account-deleted.
type EventAccountDeleted struct {
	// Id The ID of the account that was deleted.
	Id         string   `json:"id"`
	OldAccount *Account `json:"old_account,omitempty"`
}

// EventAccountUpdated defines model for event-account-updated.
type EventAccountUpdated struct {
	Account    Account  `json:"account"`
	OldAccount *Account `json:"old_account,omitempty"`
}

// EventAiAgentResponseBody defines model for event-ai-agent-response.
type EventAiAgentResponseBody struct {
	// Agent The ID of the AI agent that consumed the event.
	Agent         string                             `json:"agent"`
	AgentResponse *EventAiAgentResponseAgentResponse `json:"agent_response,omitempty"`

	// ClientMetadata The metadata given by client to be passed to the event source.
	ClientMetadata *map[string]interface{} `json:"client_metadata,omitempty"`

	// Error An error object providing the error message for the AI agent event
	// execution.
	Error *AiAgentEventExecuteError `json:"error,omitempty"`

	// Message The final response of asynchronous agent events execution.
	Message *string `json:"message,omitempty"`

	// MessageGenerationStarted Additional metadata to indicate that the message generation has
	// started.
	MessageGenerationStarted *AiAgentMessageGenerationStarted `json:"message_generation_started,omitempty"`

	// Progress A progress object providing the status of the AI agent event execution.
	Progress *AiAgentEventExecuteProgress `json:"progress,omitempty"`

	// Session The agent session ID to track the asynchronous execution of this
	// session.
	Session string `json:"session"`

	// SessionObject An identifier of the session with the AI agent.
	SessionObject string `json:"session_object"`

	// Suggestions A list of suggestions generated for the AI agent event.
	Suggestions *AiAgentEventSuggestions `json:"suggestions,omitempty"`
}

// EventAiAgentResponseAgentResponse defines model for EventAiAgentResponse.AgentResponse.
type EventAiAgentResponseAgentResponse string

// EventConversationCreated defines model for event-conversation-created.
type EventConversationCreated struct {
	Conversation Conversation `json:"conversation"`
}

// EventConversationDeleted defines model for event-conversation-deleted.
type EventConversationDeleted struct {
	// Id The ID of the conversation that was deleted.
	Id              string        `json:"id"`
	OldConversation *Conversation `json:"old_conversation,omitempty"`
}

// EventConversationUpdated defines model for event-conversation-updated.
type EventConversationUpdated struct {
	Conversation    Conversation  `json:"conversation"`
	OldConversation *Conversation `json:"old_conversation,omitempty"`
}

// EventDashboardCreated defines model for event-dashboard-created.
type EventDashboardCreated struct {
	Dashboard Dashboard `json:"dashboard"`
}

// EventDashboardDeleted defines model for event-dashboard-deleted.
type EventDashboardDeleted struct {
	// Id The ID of the dashboard that was deleted.
	Id           string     `json:"id"`
	OldDashboard *Dashboard `json:"old_dashboard,omitempty"`
}

// EventDashboardUpdated defines model for event-dashboard-updated.
type EventDashboardUpdated struct {
	Dashboard    Dashboard  `json:"dashboard"`
	OldDashboard *Dashboard `json:"old_dashboard,omitempty"`
}

// EventDevUserCreated defines model for event-dev-user-created.
type EventDevUserCreated struct {
	DevUser DevUser `json:"dev_user"`
}

// EventDevUserDeleted defines model for event-dev-user-deleted.
type EventDevUserDeleted struct {
	// Id The ID of the Dev user that was deleted.
	Id         string   `json:"id"`
	OldDevUser *DevUser `json:"old_dev_user,omitempty"`
}

// EventDevUserUpdated defines model for event-dev-user-updated.
type EventDevUserUpdated struct {
	DevUser    DevUser  `json:"dev_user"`
	OldDevUser *DevUser `json:"old_dev_user,omitempty"`
}

// EventFetchedResult defines model for event-fetched-result.
type EventFetchedResult string

// EventGroupCreated defines model for event-group-created.
type EventGroupCreated struct {
	Group Group `json:"group"`
}

// EventGroupDeleted defines model for event-group-deleted.
type EventGroupDeleted struct {
	// Id The ID of the group that was deleted.
	Id       string `json:"id"`
	OldGroup *Group `json:"old_group,omitempty"`
}

// EventGroupMemberAdded defines model for event-group-member-added.
type EventGroupMemberAdded struct {
	Group  GroupSummary `json:"group"`
	Member UserSummary  `json:"member"`
}

// EventGroupMemberRemoved defines model for event-group-member-removed.
type EventGroupMemberRemoved struct {
	Group  GroupSummary `json:"group"`
	Member UserSummary  `json:"member"`
}

// EventGroupUpdated defines model for event-group-updated.
type EventGroupUpdated struct {
	Group    Group  `json:"group"`
	OldGroup *Group `json:"old_group,omitempty"`
}

// EventIncidentCreated defines model for event-incident-created.
type EventIncidentCreated struct {
	Incident Incident `json:"incident"`
}

// EventIncidentDeleted defines model for event-incident-deleted.
type EventIncidentDeleted struct {
	// Id The ID of the incident that was deleted.
	Id          string    `json:"id"`
	OldIncident *Incident `json:"old_incident,omitempty"`
}

// EventIncidentUpdated defines model for event-incident-updated.
type EventIncidentUpdated struct {
	Incident    Incident  `json:"incident"`
	OldIncident *Incident `json:"old_incident,omitempty"`
}

// EventLinkCreated defines model for event-link-created.
type EventLinkCreated struct {
	Link Link `json:"link"`
}

// EventLinkDeleted defines model for event-link-deleted.
type EventLinkDeleted struct {
	// Id The ID of the link that was deleted.
	Id string `json:"id"`
}

// EventLinkUpdated defines model for event-link-updated.
type EventLinkUpdated struct {
	Link    Link  `json:"link"`
	OldLink *Link `json:"old_link,omitempty"`
}

// EventPartCreated defines model for event-part-created.
type EventPartCreated struct {
	Part Part `json:"part"`
}

// EventPartDeleted defines model for event-part-deleted.
type EventPartDeleted struct {
	// Id The ID of the part that was deleted.
	Id      string `json:"id"`
	OldPart *Part  `json:"old_part,omitempty"`
}

// EventPartUpdated defines model for event-part-updated.
type EventPartUpdated struct {
	OldPart *Part `json:"old_part,omitempty"`
	Part    Part  `json:"part"`
}

// EventQuestionAnswerCreated defines model for event-question-answer-created.
type EventQuestionAnswerCreated struct {
	QuestionAnswer QuestionAnswer `json:"question_answer"`
}

// EventQuestionAnswerDeleted defines model for event-question-answer-deleted.
type EventQuestionAnswerDeleted struct {
	// Id The ID of the question-answer that was deleted.
	Id                string          `json:"id"`
	OldQuestionAnswer *QuestionAnswer `json:"old_question_answer,omitempty"`
}

// EventQuestionAnswerUpdated defines model for event-question-answer-updated.
type EventQuestionAnswerUpdated struct {
	OldQuestionAnswer *QuestionAnswer `json:"old_question_answer,omitempty"`
	QuestionAnswer    QuestionAnswer  `json:"question_answer"`
}

// EventRevOrgCreated defines model for event-rev-org-created.
type EventRevOrgCreated struct {
	RevOrg RevOrg `json:"rev_org"`
}

// EventRevOrgDeleted defines model for event-rev-org-deleted.
type EventRevOrgDeleted struct {
	// Id The ID of the Rev organization that was deleted.
	Id        string  `json:"id"`
	OldRevOrg *RevOrg `json:"old_rev_org,omitempty"`
}

// EventRevOrgUpdated defines model for event-rev-org-updated.
type EventRevOrgUpdated struct {
	OldRevOrg *RevOrg `json:"old_rev_org,omitempty"`
	RevOrg    RevOrg  `json:"rev_org"`
}

// EventRevUserCreated defines model for event-rev-user-created.
type EventRevUserCreated struct {
	RevUser RevUser `json:"rev_user"`
}

// EventRevUserDeleted defines model for event-rev-user-deleted.
type EventRevUserDeleted struct {
	// Id The ID of the Rev user that was deleted.
	Id         string   `json:"id"`
	OldRevUser *RevUser `json:"old_rev_user,omitempty"`
}

// EventRevUserUpdated defines model for event-rev-user-updated.
type EventRevUserUpdated struct {
	OldRevUser *RevUser `json:"old_rev_user,omitempty"`
	RevUser    RevUser  `json:"rev_user"`
}

// EventSlaTrackerCreated defines model for event-sla-tracker-created.
type EventSlaTrackerCreated struct {
	SlaTracker SlaTracker `json:"sla_tracker"`
}

// EventSlaTrackerDeleted defines model for event-sla-tracker-deleted.
type EventSlaTrackerDeleted struct {
	// Id The ID of the SLA tracker that was deleted.
	Id            string      `json:"id"`
	OldSlaTracker *SlaTracker `json:"old_sla_tracker,omitempty"`
}

// EventSlaTrackerFetched defines model for event-sla-tracker-fetched.
type EventSlaTrackerFetched struct {
	// Id The ID of the SLA tracker that was fetched.
	Id     string             `json:"id"`
	Result EventFetchedResult `json:"result"`
	union  json.RawMessage
}

// EventSlaTrackerFetchedOk defines model for event-sla-tracker-fetched-ok.
type EventSlaTrackerFetchedOk struct {
	SlaTracker *SlaTracker `json:"sla_tracker,omitempty"`
}

// EventSlaTrackerUpdated defines model for event-sla-tracker-updated.
type EventSlaTrackerUpdated struct {
	OldSlaTracker *SlaTracker `json:"old_sla_tracker,omitempty"`
	SlaTracker    SlaTracker  `json:"sla_tracker"`
}

// EventSource defines model for event-source.
type EventSource struct {
	// Config Configuration of the event source. Fields depend on the event
	// source type.
	Config    *map[string]interface{} `json:"config,omitempty"`
	CreatedBy *UserSummary            `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Name of the event source.
	Name *string `json:"name,omitempty"`

	// SetupInstructions Instructions for setting up the event source.
	SetupInstructions *EventSourceSetupInstructions `json:"setup_instructions,omitempty"`

	// Status Status of the event source. Note that paused/blocked event sources
	// return NotFound error on triggering.
	Status *EventSourceStatus `json:"status,omitempty"`

	// TriggerUrl The URL to trigger the event source. Valid only for HTTP
	// based-event sources. This URL supports both GET and POST requests.
	TriggerUrl *string `json:"trigger_url,omitempty"`
}

// EventSourceGetRequest defines model for event-source-get-request.
type EventSourceGetRequest struct {
	// Id The event source's ID.
	Id string `json:"id"`
}

// EventSourceGetResponseBody defines model for event-source-get-response.
type EventSourceGetResponseBody struct {
	EventSource EventSource `json:"event_source"`
}

// EventSourceSetupInstructions Instructions for setting up the event source.
type EventSourceSetupInstructions struct {
	// Content Content of the instructions.
	Content *string `json:"content,omitempty"`
}

// EventSourceStatus Status of the event source. Note that paused/blocked event sources
// return NotFound error on triggering.
type EventSourceStatus string

// EventSourcesDeleteScheduledEventRequest defines model for event-sources-delete-scheduled-event-request.
type EventSourcesDeleteScheduledEventRequest struct {
	// EventKey The event key for the event which we want to delete.
	EventKey string `json:"event_key"`

	// Id The event source's ID.
	Id string `json:"id"`
}

// EventSourcesScheduleEventRequest defines model for event-sources-schedule-event-request.
type EventSourcesScheduleEventRequest struct {
	// EventKey A unique key for this event (scoped to an event source) used for
	// updating/getting/deleting scheduled events.
	EventKey *string `json:"event_key,omitempty"`

	// EventType The type of the event.
	EventType string `json:"event_type"`

	// Id The event source's ID.
	Id string `json:"id"`

	// Payload The raw payload of the event.
	Payload []byte `json:"payload"`

	// PublishAt The timestamp at which the event should be published. The event is
	// guaranteed to be published after this. If omitted, the event is
	// published immediately.
	PublishAt *time.Time `json:"publish_at,omitempty"`

	// UpdateIfExists Whether or not to update an existing scheduled event with the same
	// event key. If this is false, and an event is already scheduled with
	// the same event key, then HTTP 409 Conflict is returned.
	UpdateIfExists *bool `json:"update_if_exists,omitempty"`
}

// EventSourcesScheduleEventResponseBody defines model for event-sources-schedule-event-response.
type EventSourcesScheduleEventResponseBody struct {
	// EventKey The event key for this event. Auto-generated if the caller doesn't
	// specify the event key. This may be empty if the event was published
	// immediately.
	EventKey *string `json:"event_key,omitempty"`
}

// EventSurveyCreated defines model for event-survey-created.
type EventSurveyCreated struct {
	Survey Survey `json:"survey"`
}

// EventSurveyDeleted defines model for event-survey-deleted.
type EventSurveyDeleted struct {
	// Id The ID of the survey that was deleted.
	Id        string  `json:"id"`
	OldSurvey *Survey `json:"old_survey,omitempty"`
}

// EventSurveyResponseCreated defines model for event-survey-response-created.
type EventSurveyResponseCreated struct {
	SurveyResponse SurveyResponse `json:"survey_response"`
}

// EventSurveyResponseDeleted defines model for event-survey-response-deleted.
type EventSurveyResponseDeleted struct {
	// Id The ID of the survey response that was deleted.
	Id                string          `json:"id"`
	OldSurveyResponse *SurveyResponse `json:"old_survey_response,omitempty"`
}

// EventSurveyResponseUpdated defines model for event-survey-response-updated.
type EventSurveyResponseUpdated struct {
	OldSurveyResponse *SurveyResponse `json:"old_survey_response,omitempty"`
	SurveyResponse    SurveyResponse  `json:"survey_response"`
}

// EventSurveyUpdated defines model for event-survey-updated.
type EventSurveyUpdated struct {
	OldSurvey *Survey `json:"old_survey,omitempty"`
	Survey    Survey  `json:"survey"`
}

// EventSyncHistoryCreated defines model for event-sync-history-created.
type EventSyncHistoryCreated struct {
	SyncHistory SyncHistory `json:"sync_history"`
}

// EventSyncHistoryDeleted defines model for event-sync-history-deleted.
type EventSyncHistoryDeleted struct {
	// Id The ID of the sync history that was deleted.
	Id string `json:"id"`
}

// EventSyncHistoryUpdated defines model for event-sync-history-updated.
type EventSyncHistoryUpdated struct {
	OldSyncHistory *SyncHistory `json:"old_sync_history,omitempty"`
	SyncHistory    SyncHistory  `json:"sync_history"`
}

// EventTagCreated defines model for event-tag-created.
type EventTagCreated struct {
	Tag Tag `json:"tag"`
}

// EventTagDeleted defines model for event-tag-deleted.
type EventTagDeleted struct {
	// Id The ID of the tag that was deleted.
	Id     string `json:"id"`
	OldTag *Tag   `json:"old_tag,omitempty"`
}

// EventTagUpdated defines model for event-tag-updated.
type EventTagUpdated struct {
	OldTag *Tag `json:"old_tag,omitempty"`
	Tag    Tag  `json:"tag"`
}

// EventTimelineEntryCreated defines model for event-timeline-entry-created.
type EventTimelineEntryCreated struct {
	Entry TimelineEntry `json:"entry"`
}

// EventTimelineEntryDeleted defines model for event-timeline-entry-deleted.
type EventTimelineEntryDeleted struct {
	// Id The ID of the timeline entry that was deleted.
	Id       string         `json:"id"`
	OldEntry *TimelineEntry `json:"old_entry,omitempty"`
}

// EventTimelineEntryUpdated defines model for event-timeline-entry-updated.
type EventTimelineEntryUpdated struct {
	Entry    TimelineEntry  `json:"entry"`
	OldEntry *TimelineEntry `json:"old_entry,omitempty"`

	// Reactions The reactions that were performed.
	Reactions *[]EventTimelineEntryUpdatedReaction `json:"reactions,omitempty"`
}

// EventTimelineEntryUpdatedReaction defines model for event-timeline-entry-updated-reaction.
type EventTimelineEntryUpdatedReaction struct {
	Action EventTimelineEntryUpdatedReactionAction `json:"action"`

	// Emoji The emoji for the reaction.
	Emoji   string       `json:"emoji"`
	Reactor *UserSummary `json:"reactor,omitempty"`
}

// EventTimelineEntryUpdatedReactionAction defines model for event-timeline-entry-updated-reaction-action.
type EventTimelineEntryUpdatedReactionAction string

// EventWebhookCreated defines model for event-webhook-created.
type EventWebhookCreated struct {
	Webhook Webhook `json:"webhook"`
}

// EventWebhookDeleted defines model for event-webhook-deleted.
type EventWebhookDeleted struct {
	// Id The ID of the webhook that was deleted.
	Id string `json:"id"`
}

// EventWebhookUpdated defines model for event-webhook-updated.
type EventWebhookUpdated struct {
	Webhook Webhook `json:"webhook"`
}

// EventWidgetCreated defines model for event-widget-created.
type EventWidgetCreated struct {
	Widget Widget `json:"widget"`
}

// EventWidgetDeleted defines model for event-widget-deleted.
type EventWidgetDeleted struct {
	// Id The ID of the widget that was deleted.
	Id        string  `json:"id"`
	OldWidget *Widget `json:"old_widget,omitempty"`
}

// EventWidgetUpdated defines model for event-widget-updated.
type EventWidgetUpdated struct {
	OldWidget *Widget `json:"old_widget,omitempty"`
	Widget    Widget  `json:"widget"`
}

// EventWorkCreated defines model for event-work-created.
type EventWorkCreated struct {
	Work Work `json:"work"`
}

// EventWorkDeleted defines model for event-work-deleted.
type EventWorkDeleted struct {
	// Id The ID of the work that was deleted.
	Id      string `json:"id"`
	OldWork *Work  `json:"old_work,omitempty"`
}

// EventWorkFetched defines model for event-work-fetched.
type EventWorkFetched struct {
	// Id The ID of the work that was fetched.
	Id     string             `json:"id"`
	Result EventFetchedResult `json:"result"`
	union  json.RawMessage
}

// EventWorkFetchedOk defines model for event-work-fetched-ok.
type EventWorkFetchedOk struct {
	Work *Work `json:"work,omitempty"`
}

// EventWorkUpdated defines model for event-work-updated.
type EventWorkUpdated struct {
	OldWork *Work `json:"old_work,omitempty"`
	Work    Work  `json:"work"`
}

// ExportAuditLogsRequest Request object to get a log's information.
type ExportAuditLogsRequest struct {
	// From Time from which logs are to be retrieved.
	From time.Time `json:"from"`

	// To Time till which logs are to be retrieved.
	To time.Time `json:"to"`
}

// ExportAuditLogsResponseBody Response for the audit logs export request. Response is empty as the
// process is asynchronous. Upon completion, the user will be notified.
type ExportAuditLogsResponseBody = map[string]interface{}

// ExternalCommunicationChannelSummary defines model for external-communication-channel-summary.
type ExternalCommunicationChannelSummary = AtomBaseSummary

// ExternalIdentity External identity of a user.
type ExternalIdentity struct {
	// DisplayName Display name of the user in the external source.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Unique ID of the user in the external source.
	Id *string `json:"id,omitempty"`

	// IsVerified Whether the external identity is verified or not.
	IsVerified *bool `json:"is_verified,omitempty"`

	// Issuer Issuer of the external identity of the user.
	Issuer *string `json:"issuer,omitempty"`
}

// ExternalSystemType defines model for external-system-type.
type ExternalSystemType string

// Feature defines model for feature.
type Feature = PartBase

// FeatureSummary defines model for feature-summary.
type FeatureSummary = PartBaseSummary

// FieldDelta A field change.
type FieldDelta struct {
	// FieldDescriptor Set of field attributes.
	FieldDescriptor *SchemaFieldDescriptor `json:"field_descriptor,omitempty"`

	// Name The name of the field.
	Name     *string     `json:"name,omitempty"`
	NewValue *FieldValue `json:"new_value,omitempty"`
	OldValue *FieldValue `json:"old_value,omitempty"`
}

// FieldDescriptor Set of field attributes.
type FieldDescriptor = map[string]interface{}

// FieldValue defines model for field-value.
type FieldValue struct {
	Type  FieldValueType `json:"type"`
	union json.RawMessage
}

// FieldValueBool defines model for field-value-bool.
type FieldValueBool struct {
	Value bool `json:"value"`
}

// FieldValueBoolList defines model for field-value-bool-list.
type FieldValueBoolList struct {
	Values []bool `json:"values"`
}

// FieldValueComposite defines model for field-value-composite.
type FieldValueComposite struct {
	Fields map[string]FieldValue `json:"fields"`
}

// FieldValueCompositeList defines model for field-value-composite-list.
type FieldValueCompositeList struct {
	Values []FieldValueComposite `json:"values"`
}

// FieldValueDateList defines model for field-value-date-list.
type FieldValueDateList struct {
	Values []openapi_types.Date `json:"values"`
}

// FieldValueDateTimeList defines model for field-value-date-time-list.
type FieldValueDateTimeList struct {
	Values []time.Time `json:"values"`
}

// FieldValueDateTimeValue defines model for field-value-date-time-value.
type FieldValueDateTimeValue struct {
	Value time.Time `json:"value"`
}

// FieldValueDateValue defines model for field-value-date-value.
type FieldValueDateValue struct {
	Value openapi_types.Date `json:"value"`
}

// FieldValueDouble defines model for field-value-double.
type FieldValueDouble struct {
	Value float64 `json:"value"`
}

// FieldValueDoubleList defines model for field-value-double-list.
type FieldValueDoubleList struct {
	Values []float64 `json:"values"`
}

// FieldValueId defines model for field-value-id.
type FieldValueId struct {
	Value string `json:"value"`
}

// FieldValueIdList defines model for field-value-id-list.
type FieldValueIdList struct {
	Values []string `json:"values"`
}

// FieldValueInt64 defines model for field-value-int64.
type FieldValueInt64 struct {
	Value int64 `json:"value"`
}

// FieldValueInt64List defines model for field-value-int64-list.
type FieldValueInt64List struct {
	Values []int64 `json:"values"`
}

// FieldValueStage defines model for field-value-stage.
type FieldValueStage struct {
	Name  *string `json:"name,omitempty"`
	Notes *string `json:"notes,omitempty"`
}

// FieldValueString defines model for field-value-string.
type FieldValueString struct {
	Value string `json:"value"`
}

// FieldValueStringList defines model for field-value-string-list.
type FieldValueStringList struct {
	Values []string `json:"values"`
}

// FieldValueTagSummary defines model for field-value-tag-summary.
type FieldValueTagSummary struct {
	Name  *string `json:"name,omitempty"`
	Style *string `json:"style,omitempty"`
	TagId string  `json:"tag_id"`
}

// FieldValueTagSummaryList defines model for field-value-tag-summary-list.
type FieldValueTagSummaryList struct {
	Values []FieldValueTagSummary `json:"values"`
}

// FieldValueType defines model for field-value-type.
type FieldValueType string

// GeneralPreferencesGroup Preferences group for General settings.
type GeneralPreferencesGroup struct {
	// Availability Preferences group for Availability.
	Availability *AvailabilityPreferencesGroup `json:"availability,omitempty"`

	// PreferredLocale Preferred locale of the user.
	PreferredLocale *string `json:"preferred_locale,omitempty"`
}

// GenericNotificationEventType Event type of the notification.
type GenericNotificationEventType string

// GetReplyRequest The request to get a reply for a query using an organization's
// knowledge base.
type GetReplyRequest struct {
	// Query The query string.
	Query string `json:"query"`
}

// GetReplyResponseBody The response for the generated reply.
type GetReplyResponseBody struct {
	// Reply The reply generated for the requested query.
	Reply *string `json:"reply,omitempty"`

	// Sources Sources from which the reply is generated.
	Sources *[]TuringSources `json:"sources,omitempty"`
}

// GetRevUsersPersonalDataRequest Request object to get a contact's information.
type GetRevUsersPersonalDataRequest struct {
	// Email Email of the contact.
	Email string `json:"email"`
}

// GetRevUsersPersonalDataResponseBody Response for the contacts personal data export request. Response is
// empty as the process is asynchronous. Upon completion, the user will be
// notified.
type GetRevUsersPersonalDataResponseBody = map[string]interface{}

// GridLayout Grid layout represents the organization of the elements within a
// layout.
type GridLayout struct {
	// Layout Layout of the elements within the current element.
	Layout *[]GridLayout `json:"layout,omitempty"`

	// Position A grid position represents the location and size of a widget or section
	// within  its container (dashboard, tab, or section).
	Position *GridPosition `json:"position,omitempty"`

	// ReferenceId The reference ID for the element to be laid out. It should be an ID
	// of a tab, section, or widget.
	ReferenceId string `json:"reference_id"`
}

// GridPosition A grid position represents the location and size of a widget or section
// within  its container (dashboard, tab, or section).
type GridPosition struct {
	// Height The height of the widget or section, in grid units.
	Height int32 `json:"height"`

	// Width The width of the widget or section, in grid units.
	Width int32 `json:"width"`

	// X The x-coordinate of the top-left corner of the widget or section,
	// based on  a grid system.
	X int32 `json:"x"`

	// Y The y-coordinate of the top-left corner of the widget or section,
	// based on  a grid system.
	Y int32 `json:"y"`
}

// Group defines model for group.
type Group struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the group.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsDefault Whether it is a default group.
	IsDefault bool `json:"is_default"`

	// MemberType Type of the members in the group.
	MemberType *GroupMemberType `json:"member_type,omitempty"`
	ModifiedBy *UserSummary     `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Name of the group.
	Name  *string      `json:"name,omitempty"`
	Owner *UserSummary `json:"owner,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`
}

// GroupIngestionSource Creation source of the group.
type GroupIngestionSource string

// GroupMemberType Type of the members in the group.
type GroupMemberType string

// GroupMembersAddRequest A request to add a new member to a group.
type GroupMembersAddRequest struct {
	// Group ID of the group where the member is being added.
	Group string `json:"group"`

	// Member ID of the member to be added.
	Member string `json:"member"`

	// MemberRevOrg Rev org of the rev user to be added. This should be specified only
	// if the member is a rev user
	MemberRevOrg *string `json:"member_rev_org,omitempty"`
}

// GroupMembersAddResponseBody defines model for group-members-add-response.
type GroupMembersAddResponseBody = map[string]interface{}

// GroupMembersListRequest A request to list group members.
type GroupMembersListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Group ID of the group for which to list members.
	Group string `json:"group"`

	// Limit The maximum number of members to return. If not set, then the
	// default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`
}

// GroupMembersListResponseBody List of group members.
type GroupMembersListResponseBody struct {
	// Members List of members.
	Members []GroupMembersListResponseMember `json:"members"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// GroupMembersListResponseMember A group member.
type GroupMembersListResponseMember struct {
	Member       MemberSummary  `json:"member"`
	MemberRevOrg *RevOrgSummary `json:"member_rev_org,omitempty"`
}

// GroupMembersRemoveRequest A request to remove a group member.
type GroupMembersRemoveRequest struct {
	// Group ID of the group where the member is being removed.
	Group string `json:"group"`

	// Member ID of the member to be removed.
	Member string `json:"member"`

	// MemberRevOrg Rev org of the rev user to be removed. This should be specified
	// only if the member is a rev user
	MemberRevOrg *string `json:"member_rev_org,omitempty"`
}

// GroupMembersRemoveResponseBody defines model for group-members-remove-response.
type GroupMembersRemoveResponseBody = map[string]interface{}

// GroupSearchSummary defines model for group-search-summary.
type GroupSearchSummary struct {
	Group GroupSummary `json:"group"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// GroupSummary defines model for group-summary.
type GroupSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// MemberType Type of the members in the group.
	MemberType *GroupMemberType `json:"member_type,omitempty"`

	// Name Name of the group.
	Name *string `json:"name,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`
}

// GroupType Type of the group.
type GroupType string

// GroupedVistaFlavor Denotes the use case of the grouped vista.
type GroupedVistaFlavor string

// GroupedVistaSummary defines model for grouped-vista-summary.
type GroupedVistaSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Flavor Denotes the use case of the grouped vista.
	Flavor *GroupedVistaFlavor `json:"flavor,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Name of the vista.
	Name string `json:"name"`
}

// GroupsCreateRequest A request to create a new group.
type GroupsCreateRequest struct {
	// Description Description of the group.
	Description string `json:"description"`

	// DynamicGroupInfo Information to define dynamic groups.
	DynamicGroupInfo *DynamicGroupInfo `json:"dynamic_group_info,omitempty"`

	// MemberType Type of the members in the group.
	MemberType *GroupMemberType `json:"member_type,omitempty"`

	// Name Unique name of the group.
	Name string `json:"name"`

	// Owner Owner of the group.
	Owner *string `json:"owner,omitempty"`

	// Type Type of the group.
	Type *GroupType `json:"type,omitempty"`
}

// GroupsCreateResponseBody The response to group creation.
type GroupsCreateResponseBody struct {
	Group Group `json:"group"`
}

// GroupsGetRequest A request to get information about a group.
type GroupsGetRequest struct {
	// Id The ID of the group to get.
	Id string `json:"id"`
}

// GroupsGetResponseBody The response to getting the group.
type GroupsGetResponseBody struct {
	Group Group `json:"group"`
}

// GroupsListRequest A request to get information about a list of groups.
type GroupsListRequest struct {
	// CreatedBy Filters the groups on the basis of creator.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// GroupType Filters the groups based on the group type.
	GroupType *[]GroupType `json:"group_type,omitempty"`

	// IngestionSource Filter groups by ingestion source(s).
	IngestionSource *[]GroupIngestionSource `json:"ingestion_source,omitempty"`

	// IsDefault Whether to fetch default or custom groups.
	IsDefault *bool `json:"is_default,omitempty"`

	// Limit The maximum number of groups to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// MemberType Filters the groups on basis of member type.
	MemberType *[]GroupMemberType `json:"member_type,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Name Filters the groups on the basis of group name.
	Name *[]string `json:"name,omitempty"`

	// SortBy Comma-separated fields to sort the groups by.
	SortBy       *[]string           `json:"sort_by,omitempty"`
	SyncMetadata *SyncMetadataFilter `json:"sync_metadata,omitempty"`
}

// GroupsListResponseBody The response to listing the groups.
type GroupsListResponseBody struct {
	// Groups The list of groups.
	Groups []Group `json:"groups"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// GroupsUpdateRequest A request to update a group.
type GroupsUpdateRequest struct {
	// Description The updated group's description.
	Description      *string                              `json:"description,omitempty"`
	DynamicGroupInfo *GroupsUpdateRequestDynamicGroupInfo `json:"dynamic_group_info,omitempty"`

	// Id The ID of the group to update.
	Id string `json:"id"`

	// Name The updated group's name.
	Name *string `json:"name,omitempty"`

	// Owner The updated group's owner.
	Owner *string `json:"owner"`
}

// GroupsUpdateRequestDynamicGroupInfo defines model for groups-update-request-dynamic-group-info.
type GroupsUpdateRequestDynamicGroupInfo struct {
	// MembershipExpression Boolean expression.
	MembershipExpression BooleanExpression `json:"membership_expression"`
}

// GroupsUpdateResponseBody The response to group update.
type GroupsUpdateResponseBody struct {
	Group Group `json:"group"`
}

// HeatmapVisualizationXAxis The X-axis for a heatmap visualization.
type HeatmapVisualizationXAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// HeatmapVisualizationYAxis The Y-axis for a heatmap visualization.
type HeatmapVisualizationYAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// HeatmapVisualizationZAxis The Z-axis for a heatmap visualization.
type HeatmapVisualizationZAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// HeatmapWidgetVisualization A heatmap chart visualization configuration. Includes metadata specific
// to heatmap charts.
type HeatmapWidgetVisualization struct {
	// Color Color for heatmap.
	Color *string `json:"color,omitempty"`

	// X The X-axis for a heatmap visualization.
	X HeatmapVisualizationXAxis `json:"x"`

	// Y The Y-axis for a heatmap visualization.
	Y HeatmapVisualizationYAxis `json:"y"`

	// Z The Z-axis for a heatmap visualization.
	Z HeatmapVisualizationZAxis `json:"z"`
}

// ImpactedCustomerDetails Details of the impact due to the incident.
type ImpactedCustomerDetails struct {
	// Count The properties of an enum value.
	Count *EnumValue `json:"count,omitempty"`

	// CustomerIds List of customers impacted due to the incident.
	CustomerIds *[]AccountSummary `json:"customer_ids,omitempty"`
}

// Incident defines model for incident.
type Incident struct {
	// AcknowledgedDate Timestamp when the incident was acknowledged.
	AcknowledgedDate *time.Time `json:"acknowledged_date,omitempty"`

	// ActualCloseDate Timestamp when the incident was actually resolved.
	ActualCloseDate *time.Time `json:"actual_close_date,omitempty"`

	// AppliesToParts Parts to which the incident is applicable to.
	AppliesToParts *[]PartSummary `json:"applies_to_parts,omitempty"`

	// Artifacts Artifacts attached to the incident.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body Body of the incident.
	Body      *string      `json:"body,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IdentifiedDate Time when the incident was identified/reported.
	IdentifiedDate *time.Time `json:"identified_date,omitempty"`

	// Impact Details of the impact due to the incident.
	Impact *ImpactedCustomerDetails `json:"impact,omitempty"`

	// MitigatedDate Timestamp when the incident was mitigated.
	MitigatedDate *time.Time   `json:"mitigated_date,omitempty"`
	ModifiedBy    *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy The users that own the incident.
	OwnedBy *[]UserSummary `json:"owned_by,omitempty"`

	// Pia The article ids of the Post-Incident Analysis(PIA) of the incident.
	Pia *[]ArticleSummary `json:"pia,omitempty"`

	// Playbooks The article ids of the playbook(s) associated with the incident.
	Playbooks *[]ArticleSummary `json:"playbooks,omitempty"`

	// ReportedBy The properties of an enum value.
	ReportedBy *EnumValue `json:"reported_by,omitempty"`

	// Severity The properties of an enum value.
	Severity *EnumValue `json:"severity,omitempty"`

	// Source The properties of an enum value.
	Source *EnumValue `json:"source,omitempty"`

	// Stage Describes the current stage of a object.
	Stage *Stage `json:"stage,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the incident is expected to be resolved.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the incident.
	Title string `json:"title"`
}

// IncidentSummary defines model for incident-summary.
type IncidentSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// OwnedBy The users that own the incident.
	OwnedBy *[]UserSummary `json:"owned_by,omitempty"`

	// Severity The properties of an enum value.
	Severity *EnumValueSummary `json:"severity,omitempty"`

	// Stage Describes the current stage of a object.
	Stage *StageSummary `json:"stage,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`

	// Title Title of the incident.
	Title string `json:"title"`
}

// IncidentsCreateRequest defines model for incidents-create-request.
type IncidentsCreateRequest struct {
	// AcknowledgedDate Timestamp when the incident was acknowledged.
	AcknowledgedDate *time.Time `json:"acknowledged_date,omitempty"`

	// AppliesToParts Parts to which the incident is applicable to.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// Artifacts Artifacts attached to the incident.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Body Body of the incident.
	Body *string `json:"body,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec   *CustomSchemaSpec             `json:"custom_schema_spec,omitempty"`
	ExternalSourceData *CreateExternalSourceDataComp `json:"external_source_data,omitempty"`

	// IdentifiedDate Time when the incident was identified/reported.
	IdentifiedDate *time.Time                     `json:"identified_date,omitempty"`
	Impact         *CreateImpactedCustomerDetails `json:"impact,omitempty"`

	// MitigatedDate Timestamp when the incident was mitigated.
	MitigatedDate *time.Time `json:"mitigated_date,omitempty"`

	// OwnedBy User IDs of the users that own the incident.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// Pia The article ids of the Post-Incident Analysis(PIA) of the incident.
	Pia *[]string `json:"pia,omitempty"`

	// Playbooks The article ids of the playbook(s) associated with the incident.
	Playbooks *[]string `json:"playbooks,omitempty"`

	// RelatedDocs The article ids of other documents associated with the incident.
	RelatedDocs *[]string `json:"related_docs,omitempty"`

	// ReportedBy The entity that first reported the incident.
	ReportedBy *int64 `json:"reported_by,omitempty"`

	// Severity Severity of the incident.
	Severity *int64 `json:"severity,omitempty"`

	// Source Source of where the incident was created. Only sys users and
	// service accounts are supposed to set this field.
	// Deprecated:
	Source *int64 `json:"source,omitempty"`

	// Stage Create object for stage.
	Stage *CreateStage `json:"stage,omitempty"`

	// StageValidationOptions The type of stage validations options when creating an incident.
	StageValidationOptions *[]StageValidationOptionForCreate `json:"stage_validation_options,omitempty"`

	// StagedInfo Create object for staged_info.
	StagedInfo   *CreateStagedInfo   `json:"staged_info,omitempty"`
	SyncMetadata *CreateSyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]CreateTagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the incident is expected to be resolved.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the incident.
	Title string `json:"title"`
}

// IncidentsCreateResponseBody defines model for incidents-create-response.
type IncidentsCreateResponseBody struct {
	Incident Incident `json:"incident"`
}

// IncidentsDeleteRequest A request to delete an incident.
type IncidentsDeleteRequest struct {
	// Id ID for the incident.
	Id string `json:"id"`
}

// IncidentsDeleteResponseBody The response to deleting the incident.
type IncidentsDeleteResponseBody = map[string]interface{}

// IncidentsGetRequest defines model for incidents-get-request.
type IncidentsGetRequest struct {
	// Id The ID of the incident to get.
	Id string `json:"id"`
}

// IncidentsGetResponseBody defines model for incidents-get-response.
type IncidentsGetResponseBody struct {
	Incident Incident `json:"incident"`
}

// IncidentsGroup defines model for incidents-group.
type IncidentsGroup struct {
	// Incidents The group of incidents.
	Incidents []Incident `json:"incidents"`
	Key       FieldValue `json:"key"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Total The total number of incidents in the group.
	Total *int32 `json:"total,omitempty"`
}

// IncidentsGroupRequest defines model for incidents-group-request.
type IncidentsGroupRequest struct {
	// AcknowledgedDate Provides ways to specify date ranges on objects.
	AcknowledgedDate *DateFilter `json:"acknowledged_date,omitempty"`

	// ActualCloseDate Provides ways to specify date ranges on objects.
	ActualCloseDate *DateFilter `json:"actual_close_date,omitempty"`

	// AppliesToParts Filters for incidents that apply to any of the provided parts.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// CreatedBy Filters for incidents created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// GroupBy The field to group the incidents by.
	GroupBy string `json:"group_by"`

	// IdentifiedDate Provides ways to specify date ranges on objects.
	IdentifiedDate *DateFilter `json:"identified_date,omitempty"`

	// Limit The maximum number of groups to return. If not set, then the
	// default is '10'.
	Limit *int32 `json:"limit,omitempty"`

	// LimitPerGroup The maximum number of incidents to return for an individual group.
	// The default is '50'.
	LimitPerGroup *int32 `json:"limit_per_group,omitempty"`

	// MitigatedDate Provides ways to specify date ranges on objects.
	MitigatedDate *DateFilter `json:"mitigated_date,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for incidents owned by any of the provided users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// Pia Filters for incidents with any of the provided PIAs.
	Pia *[]string `json:"pia,omitempty"`

	// Playbooks Filters for incidents with any of the provided playbooks.
	Playbooks *[]string `json:"playbooks,omitempty"`

	// RelatedDocs Filters for incidents with any of the provided related docs.
	RelatedDocs *[]string `json:"related_docs,omitempty"`

	// ReportedBy Filters for incidents with any of the provided reporters.
	ReportedBy *[]int64 `json:"reported_by,omitempty"`

	// Severity Filters for incidents containing any of the provided severities.
	Severity *[]int64 `json:"severity,omitempty"`

	// SortBy Comma-separated fields to sort the incidents by.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Source Filters for incidents with any of the provided sources.
	// Deprecated:
	Source *[]int64 `json:"source,omitempty"`

	// Stage Filters for incidents in any of the provided stages.
	Stage      *[]string         `json:"stage,omitempty"`
	StagedInfo *StagedInfoFilter `json:"staged_info,omitempty"`

	// Subtype Filters for incidents with any of the provided subtypes.
	Subtype      *[]string           `json:"subtype,omitempty"`
	SyncMetadata *SyncMetadataFilter `json:"sync_metadata,omitempty"`

	// TargetCloseDate Provides ways to specify date ranges on objects.
	TargetCloseDate *DateFilter `json:"target_close_date,omitempty"`

	// Title Filters for incidents by the provided titles.
	Title *[]string `json:"title,omitempty"`
}

// IncidentsGroupResponseBody defines model for incidents-group-response.
type IncidentsGroupResponseBody struct {
	// Groups The list of groups.
	Groups []IncidentsGroup `json:"groups"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// IncidentsListRequest defines model for incidents-list-request.
type IncidentsListRequest struct {
	// AcknowledgedDate Provides ways to specify date ranges on objects.
	AcknowledgedDate *DateFilter `json:"acknowledged_date,omitempty"`

	// ActualCloseDate Provides ways to specify date ranges on objects.
	ActualCloseDate *DateFilter `json:"actual_close_date,omitempty"`

	// AppliesToParts Filters for incidents that apply to any of the provided parts.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// CreatedBy Filters for incidents created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// IdentifiedDate Provides ways to specify date ranges on objects.
	IdentifiedDate *DateFilter `json:"identified_date,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `json:"limit,omitempty"`

	// MitigatedDate Provides ways to specify date ranges on objects.
	MitigatedDate *DateFilter `json:"mitigated_date,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// OwnedBy Filters for incidents owned by any of the provided users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// Pia Filters for incidents with any of the provided PIAs.
	Pia *[]string `json:"pia,omitempty"`

	// Playbooks Filters for incidents with any of the provided playbooks.
	Playbooks *[]string `json:"playbooks,omitempty"`

	// RelatedDocs Filters for incidents with any of the provided related docs.
	RelatedDocs *[]string `json:"related_docs,omitempty"`

	// ReportedBy Filters for incidents with any of the provided reporters.
	ReportedBy *[]int64 `json:"reported_by,omitempty"`

	// Severity Filters for incidents containing any of the provided severities.
	Severity *[]int64 `json:"severity,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Source Filters for incidents with any of the provided sources.
	// Deprecated:
	Source *[]int64 `json:"source,omitempty"`

	// Stage Filters for incidents in any of the provided stages.
	Stage      *[]string         `json:"stage,omitempty"`
	StagedInfo *StagedInfoFilter `json:"staged_info,omitempty"`

	// Subtype Filters for incidents with any of the provided subtypes.
	Subtype      *[]string           `json:"subtype,omitempty"`
	SyncMetadata *SyncMetadataFilter `json:"sync_metadata,omitempty"`

	// TargetCloseDate Provides ways to specify date ranges on objects.
	TargetCloseDate *DateFilter `json:"target_close_date,omitempty"`

	// Title Filters for incidents by the provided titles.
	Title *[]string `json:"title,omitempty"`
}

// IncidentsListResponseBody defines model for incidents-list-response.
type IncidentsListResponseBody struct {
	// Incidents The matching incidents.
	Incidents []Incident `json:"incidents"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// IncidentsUpdateRequest defines model for incidents-update-request.
type IncidentsUpdateRequest struct {
	// AcknowledgedDate Timestamp when the incident was acknowledged.
	AcknowledgedDate *time.Time                    `json:"acknowledged_date,omitempty"`
	AppliesToParts   *UpdateIncidentAppliesToParts `json:"applies_to_parts,omitempty"`
	Artifacts        *UpdateIncidentArtifacts      `json:"artifacts,omitempty"`

	// Body Body of the incident.
	Body *string `json:"body,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec   *CustomSchemaSpec             `json:"custom_schema_spec,omitempty"`
	ExternalSourceData *UpdateExternalSourceDataComp `json:"external_source_data,omitempty"`

	// Id The ID of the incident to be updated.
	Id string `json:"id"`

	// IdentifiedDate Time when the incident was identified/reported.
	IdentifiedDate *time.Time                     `json:"identified_date,omitempty"`
	Impact         *UpdateImpactedCustomerDetails `json:"impact,omitempty"`

	// MitigatedDate Timestamp when the incident was mitigated.
	MitigatedDate *time.Time                 `json:"mitigated_date,omitempty"`
	OwnedBy       *UpdateIncidentOwnedBy     `json:"owned_by,omitempty"`
	Pia           *UpdateIncidentPia         `json:"pia,omitempty"`
	Playbooks     *UpdateIncidentPlaybooks   `json:"playbooks,omitempty"`
	RelatedDocs   *UpdateIncidentRelatedDocs `json:"related_docs,omitempty"`

	// ReportedBy The entity that first reported the incident.
	ReportedBy *int64 `json:"reported_by,omitempty"`

	// Severity Severity of the incident.
	Severity *int64 `json:"severity,omitempty"`

	// Source Source of where the incident was created. Only sys users and
	// service accounts are supposed to set this field.
	// Deprecated:
	Source *int64 `json:"source,omitempty"`

	// Stage Update object for Stage.
	Stage *UpdateStage `json:"stage,omitempty"`

	// StageValidationOptions The type of stage validations options when updating the stage or
	// the stage diagram of an incident.
	StageValidationOptions *[]StageValidationOptionForUpdate `json:"stage_validation_options,omitempty"`

	// StagedInfo Update object for StagedInfo.
	StagedInfo   *UpdateStagedInfo   `json:"staged_info,omitempty"`
	SyncMetadata *UpdateSyncMetadata `json:"sync_metadata,omitempty"`
	Tags         *UpdateIncidentTags `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the incident is expected to be resolved.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the incident.
	Title *string `json:"title,omitempty"`
}

// IncidentsUpdateResponseBody defines model for incidents-update-response.
type IncidentsUpdateResponseBody struct {
	Incident Incident `json:"incident"`
}

// InstantEvaluation defines model for instant-evaluation.
type InstantEvaluation struct {
	// At The time instant evaluated.
	At time.Time `json:"at"`

	// Definedness Indicates whether this evaluation can change in the future.
	Definedness Definedness `json:"definedness"`

	// IsActive Active state of the organization schedule at the time instant.
	IsActive *bool `json:"is_active,omitempty"`

	// NextTransition Next instant at which the active state of the organization schedule
	// changes, for example, if the schedule is currently off, the next
	// instant at which it will be on.
	NextTransition *time.Time `json:"next_transition,omitempty"`
}

// Issue defines model for issue.
type Issue struct {
	// ActualCloseDate Timestamp when the work was actually completed.
	ActualCloseDate *time.Time `json:"actual_close_date,omitempty"`

	// ActualStartDate Actual start date for the object.
	ActualStartDate *time.Time   `json:"actual_start_date,omitempty"`
	AppliesToPart   *PartSummary `json:"applies_to_part,omitempty"`

	// Artifacts The artifacts attached to the work item.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body Body of the work object.
	Body      *string      `json:"body,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// DevelopedWith Parts associated based on git events.
	DevelopedWith *[]PartSummary `json:"developed_with,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *IssuePriority `json:"priority,omitempty"`

	// PriorityV2 The properties of an enum value.
	PriorityV2 *EnumValue `json:"priority_v2,omitempty"`

	// ReportedBy Users that reported the work.
	ReportedBy *[]UserSummary `json:"reported_by,omitempty"`

	// SlaSummary SLA summary for the object.
	SlaSummary *ArchetypeSlaSummary `json:"sla_summary,omitempty"`
	SlaTracker *SlaTrackerSummary   `json:"sla_tracker,omitempty"`

	// Sprint Vista group item.
	Sprint *VistaGroupItemSummary `json:"sprint,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStage `json:"stage,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// TargetStartDate Target start date for the object.
	TargetStartDate *time.Time `json:"target_start_date,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// IssuePriority Priority of the work based upon impact and criticality.
type IssuePriority string

// IssueSummary defines model for issue-summary.
type IssueSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *IssuePriority `json:"priority,omitempty"`

	// PriorityV2 The properties of an enum value.
	PriorityV2 *EnumValueSummary `json:"priority_v2,omitempty"`

	// Sprint Vista group item.
	Sprint *VistaGroupItemSummary `json:"sprint,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStageSummary `json:"stage,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// JobHistoryItem Defines a job history line item.
type JobHistoryItem struct {
	// EmploymentStatus The properties of an enum value.
	EmploymentStatus *EnumValue `json:"employment_status,omitempty"`

	// EndDate The end date of the job, or not specified if current.
	EndDate *time.Time `json:"end_date,omitempty"`

	// IsCurrent Is this the current active job for the user.
	IsCurrent *bool `json:"is_current,omitempty"`

	// Location The job location for the user.
	Location *string `json:"location,omitempty"`

	// StartDate The start date of the job.
	StartDate *time.Time `json:"start_date,omitempty"`

	// Title The job title for the user.
	Title *string `json:"title,omitempty"`
}

// KanbanVisualizationCardAttribute A card attribute in a kanban visualization.
type KanbanVisualizationCardAttribute struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// Order The order in which the attribute should be displayed in a card.
	Order *int32 `json:"order,omitempty"`

	// Position Whether the attribute should be placed in the body or footer of the
	// kanban.
	Position *KanbanVisualizationCardAttributePosition `json:"position,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// KanbanVisualizationCardAttributePosition Whether the attribute should be placed in the body or footer of the
// kanban.
type KanbanVisualizationCardAttributePosition string

// KanbanWidgetVisualization A kanban visualization configuration. Includes metadata specific to
// kanban.
type KanbanWidgetVisualization struct {
	// CardAttributes The configuration for the card in the kanban.
	CardAttributes []KanbanVisualizationCardAttribute `json:"card_attributes"`

	// GroupBy The group_by configuration in the kanban.
	GroupBy []WidgetGroupByConfig `json:"group_by"`
}

// KeyringsCreateCallbackRequest defines model for keyrings-create-callback-request.
type KeyringsCreateCallbackRequest struct {
	// Code Code to exchange for an access token.
	Code string `json:"code"`

	// State State value given to the authorization request.
	State string `json:"state"`
}

// LegacyStage Describes the current stage of a work item.
type LegacyStage struct {
	// Name Current stage name of the work item.
	Name string `json:"name"`

	// Notes Notes relevant to the stage.
	Notes *string `json:"notes,omitempty"`

	// Ordinal Current stage number of the work item (sortable).
	Ordinal *int32              `json:"ordinal,omitempty"`
	Stage   *CustomStageSummary `json:"stage,omitempty"`
	State   *CustomStateSummary `json:"state,omitempty"`
}

// LegacyStageSummary Describes the current stage of a work item.
type LegacyStageSummary struct {
	// Name Current stage name of the work item.
	Name  string              `json:"name"`
	Stage *CustomStageSummary `json:"stage,omitempty"`
}

// LineVisualizationXAxis The X-axis for a line visualization.
type LineVisualizationXAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// LineVisualizationYAxis The Y-axis for a line visualization.
type LineVisualizationYAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsAreaFilled Whether the area under the line should be filled.
	IsAreaFilled *bool `json:"is_area_filled,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsSpline Whether the line should be a spline.
	IsSpline *bool `json:"is_spline,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// Marker Whether the line have circular marker.
	Marker *bool `json:"marker,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// LineWidgetVisualization A line chart visualization configuration. Includes metadata specific to
// line charts.
type LineWidgetVisualization struct {
	// IsStacked Whether the line should be stacked.
	IsStacked *bool `json:"is_stacked,omitempty"`

	// ShowDataLabels Whether to show data labels.
	ShowDataLabels *bool `json:"show_data_labels,omitempty"`

	// X The configuration for the X-axes.
	X []LineVisualizationXAxis `json:"x"`

	// Y The configuration for the Y-axes.
	Y []LineVisualizationYAxis `json:"y"`
}

// LinesOfCode Details of lines of code in this code change.
type LinesOfCode struct {
	// FileCount Count of files involved in this code change.
	FileCount *int64 `json:"file_count,omitempty"`

	// LinesAdded Number of new lines added in this code change.
	LinesAdded *int64 `json:"lines_added,omitempty"`

	// LinesDeleted Number of lines deleted in this code change.
	LinesDeleted *int64 `json:"lines_deleted,omitempty"`

	// LinesModified Number of lines modified in this code change.
	LinesModified *int64 `json:"lines_modified,omitempty"`
}

// Link defines model for link.
type Link struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate    *time.Time             `json:"created_date,omitempty"`
	CustomLinkType *CustomLinkTypeSummary `json:"custom_link_type,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// LinkType Type of link used to define the relationship.
	LinkType   LinkType     `json:"link_type"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time          `json:"modified_date,omitempty"`
	Source       LinkEndpointSummary `json:"source"`
	Target       LinkEndpointSummary `json:"target"`
}

// LinkEndpointSummary defines model for link-endpoint-summary.
type LinkEndpointSummary struct {
	Type  LinkEndpointType `json:"type"`
	union json.RawMessage
}

// LinkEndpointType defines model for link-endpoint-type.
type LinkEndpointType string

// LinkRevUserToRevOrgRequest Request to link a Rev user to an existing Rev organization.
type LinkRevUserToRevOrgRequest struct {
	// Id The ID of the Rev user.
	Id *string `json:"id,omitempty"`

	// RevOrg The ID of the Rev organization to link the Rev user to.
	RevOrg *string `json:"rev_org,omitempty"`

	// RevOrgDon The don of the rev org to link the rev user to. This is deprecated,
	// use rev_org instead.
	// Deprecated:
	RevOrgDon *string `json:"rev_org_don,omitempty"`

	// UserDon The don of the rev user to link. This is deprecated, use id
	// instead.
	// Deprecated:
	UserDon *string `json:"user_don,omitempty"`
}

// LinkRevUserToRevOrgResponseBody Response for linking a Rev user to an existing Rev organization.
type LinkRevUserToRevOrgResponseBody struct {
	RevUser RevUser `json:"rev_user"`
}

// LinkSearchSummary defines model for link-search-summary.
type LinkSearchSummary struct {
	Link LinkSummary `json:"link"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// LinkSummary defines model for link-summary.
type LinkSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// LinkType Type of link used to define the relationship.
	LinkType LinkType            `json:"link_type"`
	Source   LinkEndpointSummary `json:"source"`
	Target   LinkEndpointSummary `json:"target"`
}

// LinkTargetDescriptor A link target descriptor.
type LinkTargetDescriptor struct {
	// IsCustomLeafType True when the descriptor describes a custom leaf type.
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// LeafOnly Set to true when only the specified leaf type (no subtypes) is
	// allowed as a link target.
	LeafOnly *bool `json:"leaf_only,omitempty"`

	// LeafType Leaf type of the target objects.
	LeafType *string `json:"leaf_type,omitempty"`

	// Subtype Specific subtype of the target objects.
	Subtype *string `json:"subtype,omitempty"`
}

// LinkType Type of link used to define the relationship.
type LinkType string

// Linkable defines model for linkable.
type Linkable = PartBase

// LinkableSummary defines model for linkable-summary.
type LinkableSummary = PartBaseSummary

// LinksCreateRequest The request to create a new link.
type LinksCreateRequest struct {
	// CustomLinkType The ID of the custom link type.
	CustomLinkType *string `json:"custom_link_type,omitempty"`

	// LinkType Type of link used to define the relationship.
	LinkType LinkType `json:"link_type"`

	// Source The ID of the source object.
	Source string `json:"source"`

	// Target The ID of the target object.
	Target string `json:"target"`
}

// LinksCreateResponseBody The response to creating a new link.
type LinksCreateResponseBody struct {
	Link Link `json:"link"`
}

// LinksDeleteRequest The request to delete a link.
type LinksDeleteRequest struct {
	// Id The ID of the link to delete.
	Id string `json:"id"`
}

// LinksDeleteResponseBody The response for deleting a link.
type LinksDeleteResponseBody = map[string]interface{}

// LinksDirection The direction of link, which can either be outbound such that the
// object is the source of the link, otherwise inbound where the object is
// the target of the link.
type LinksDirection string

// LinksGetRequest The request to get a link's information.
type LinksGetRequest struct {
	// Id The requested link's ID.
	Id string `json:"id"`
}

// LinksGetResponseBody The response to getting a link's information.
type LinksGetResponseBody struct {
	Link Link `json:"link"`
}

// LinksListRequest The request to get information about a list of links.
type LinksListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Direction The direction of link, which can either be outbound such that the
	// object is the source of the link, otherwise inbound where the object is
	// the target of the link.
	Direction *LinksDirection `json:"direction,omitempty"`

	// Limit The maximum number of links to return. If not set, then the default
	// is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// LinkType The link type(s) to filter for, otherwise if not present, all link
	// types are included.
	LinkType *[]LinkType `json:"link_type,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Object The ID of the object to list the links for.
	Object string `json:"object"`

	// ObjectTypes The object types to filter for, otherwise if not present, all
	// object types are included.
	ObjectTypes *[]LinkEndpointType `json:"object_types,omitempty"`

	// Types The link types to filter for, otherwise if not present, all link
	// types are included.
	// Deprecated:
	Types *[]LinkType `json:"types,omitempty"`
}

// LinksListResponseBody The response to listing the links.
type LinksListResponseBody struct {
	// Links The list of links.
	Links []Link `json:"links"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// LinksReplaceRequest The request to replace a link.
type LinksReplaceRequest struct {
	// Id The ID of the link to be replaced.
	Id string `json:"id"`

	// LinkType Type of link used to define the relationship.
	LinkType LinkType `json:"link_type"`

	// Source The ID of the source object.
	Source string `json:"source"`

	// Target The ID of the target object.
	Target string `json:"target"`
}

// LinksReplaceResponseBody The response to replacing a link.
type LinksReplaceResponseBody struct {
	Link Link `json:"link"`
}

// ListMode The iteration mode to use. If "after", then entries after the provided
// cursor will be returned, or if no cursor is provided, then from the
// beginning. If "before", then entries before the provided cursor will be
// returned, or if no cursor is provided, then from the end. Entries will
// always be returned in the specified sort-by order.
type ListMode string

// MeerkatWidgetColumnFunction A meerkat specific column function.
type MeerkatWidgetColumnFunction struct {
	// Type The type of the function.
	Type MeerkatWidgetColumnFunctionType `json:"type"`
}

// MeerkatWidgetColumnFunctionType The type of the function.
type MeerkatWidgetColumnFunctionType string

// MeerkatWidgetColumnProjection A meerkat specific column projection.
type MeerkatWidgetColumnProjection struct {
	// Function A meerkat specific column function.
	Function *MeerkatWidgetColumnFunction `json:"function,omitempty"`

	// SqlExpression The SQL expression used to extract or transform the column from the
	// data source.
	SqlExpression string `json:"sql_expression"`

	// TimestampRollup The rollup granularity for the timestamp.
	TimestampRollup *MeerkatWidgetColumnProjectionTimestampRollup `json:"timestamp_rollup,omitempty"`

	// Type The data type of the column generated by the SQL expression.
	Type MeerkatWidgetColumnProjectionType `json:"type"`
}

// MeerkatWidgetColumnProjectionTimestampRollup The rollup granularity for the timestamp.
type MeerkatWidgetColumnProjectionTimestampRollup string

// MeerkatWidgetColumnProjectionType The data type of the column generated by the SQL expression.
type MeerkatWidgetColumnProjectionType string

// Meeting defines model for meeting.
type Meeting struct {
	// Artifacts The artifacts attached to the meeting.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Channel The channel of meeting.
	Channel   *MeetingChannel `json:"channel,omitempty"`
	CreatedBy *UserSummary    `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// Description Description of the meeting.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// EndedDate Time at which meeting ended.
	EndedDate *time.Time `json:"ended_date,omitempty"`

	// ExternalRef External reference of the meeting. This is the identifier from the
	// meeting channel/provider.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalUrl External URL associated with the meeting.
	ExternalUrl *string `json:"external_url,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Members The members in the meeting.
	Members    []UserSummary `json:"members"`
	ModifiedBy *UserSummary  `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time       `json:"modified_date,omitempty"`
	Organizer    *UserSummary     `json:"organizer,omitempty"`
	Parent       *AtomSummary     `json:"parent,omitempty"`
	Recording    *ArtifactSummary `json:"recording,omitempty"`

	// RecordingUrl Recording URL of the meeting.
	RecordingUrl *string `json:"recording_url,omitempty"`

	// ScheduledDate Time at which meeting was scheduled to start.
	ScheduledDate *time.Time `json:"scheduled_date,omitempty"`

	// State The state of meeting.
	State *MeetingState `json:"state,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the meeting.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// Title Title of the meeting object.
	Title      *string          `json:"title,omitempty"`
	Transcript *ArtifactSummary `json:"transcript,omitempty"`
}

// MeetingChannel The channel of meeting.
type MeetingChannel string

// MeetingState The state of meeting.
type MeetingState string

// MeetingSummary defines model for meeting-summary.
type MeetingSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`
}

// MeetingsCountRequest defines model for meetings-count-request.
type MeetingsCountRequest struct {
	// Channel Filters for meeting on specified channels.
	Channel *[]MeetingChannel `json:"channel,omitempty"`

	// CreatedBy Filters for meetings created by the specified user(s).
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// CustomFields Filters for meeting on custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// EndedDate Provides ways to specify date ranges on objects.
	EndedDate *DateFilter `json:"ended_date,omitempty"`

	// ExternalRef Filters for meetings with the provided external_ref(s).
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// Links Filters for links associated with the meeting.
	Links *[]MeetingsFilterLinkSummaryFilter `json:"links,omitempty"`

	// Members Filter for meeting on specified Member Ids.
	Members *[]string `json:"members,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// Organizer Filter for meeting on specified organizers.
	Organizer *[]string `json:"organizer,omitempty"`

	// Parent Filters for meetings with the provided parent.
	// Deprecated:
	Parent *[]string `json:"parent,omitempty"`

	// ScheduledDate Provides ways to specify date ranges on objects.
	ScheduledDate *DateFilter `json:"scheduled_date,omitempty"`

	// State Filters for meeting on specified state or outcomes.
	State *[]MeetingState `json:"state,omitempty"`

	// Tags Filters for meeting by tags.
	Tags *[]string `json:"tags,omitempty"`
}

// MeetingsCountResponseBody defines model for meetings-count-response.
type MeetingsCountResponseBody struct {
	// Count The number of meetings matching the filter.
	Count int64 `json:"count"`
}

// MeetingsCreateRequest defines model for meetings-create-request.
type MeetingsCreateRequest struct {
	// Channel The channel of meeting.
	Channel MeetingChannel `json:"channel"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description The description of the meeting.
	Description *string `json:"description,omitempty"`

	// EndedDate Time at which meeting ended.
	EndedDate *time.Time `json:"ended_date,omitempty"`

	// ExternalRef External reference for the meeting.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalUrl External URL for the meeting.
	ExternalUrl *string `json:"external_url,omitempty"`

	// Members IDs of the users that were part of the meeting.
	Members []string `json:"members"`

	// Organizer The ID of the user who organized the meeting. If not provided, the
	// creator is set as the organizer.
	Organizer *string `json:"organizer,omitempty"`

	// Parent The parent object ID in which the meeting was created.
	// Deprecated:
	Parent *string `json:"parent,omitempty"`

	// Recording The ID of the meeting's recording artifact.
	Recording *string `json:"recording,omitempty"`

	// RecordingUrl The recording URL of the meeting.
	RecordingUrl *string `json:"recording_url,omitempty"`

	// ScheduledDate The date and time when the meeting was scheduled.
	ScheduledDate *time.Time `json:"scheduled_date,omitempty"`

	// State The state of meeting.
	State MeetingState `json:"state"`

	// Tags Tags associated with the meeting.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Title The title of the meeting.
	Title string `json:"title"`

	// Transcript The ID of the artifact for the transcript of the meeting.
	Transcript *string `json:"transcript,omitempty"`
}

// MeetingsCreateResponseBody defines model for meetings-create-response.
type MeetingsCreateResponseBody struct {
	Meeting Meeting `json:"meeting"`
}

// MeetingsDeleteRequest defines model for meetings-delete-request.
type MeetingsDeleteRequest struct {
	// Id The meeting's ID.
	Id string `json:"id"`
}

// MeetingsDeleteResponseBody defines model for meetings-delete-response.
type MeetingsDeleteResponseBody = map[string]interface{}

// MeetingsFilterLinkSummaryFilter The filter for the link summary.
type MeetingsFilterLinkSummaryFilter struct {
	// LinkType Filters for link type in links associated with the meeting.
	LinkType *string `json:"link_type,omitempty"`

	// Target Filters for target id in links associated with the meeting.
	Target *string `json:"target,omitempty"`

	// TargetObjectType Filters for target object type in links associated with the
	// meeting.
	TargetObjectType *string `json:"target_object_type,omitempty"`
}

// MeetingsGetRequest defines model for meetings-get-request.
type MeetingsGetRequest struct {
	// Id The meeting's ID.
	Id string `json:"id"`
}

// MeetingsGetResponseBody defines model for meetings-get-response.
type MeetingsGetResponseBody struct {
	Meeting Meeting `json:"meeting"`
}

// MeetingsListRequest defines model for meetings-list-request.
type MeetingsListRequest struct {
	// Channel Filters for meeting on specified channels.
	Channel *[]MeetingChannel `json:"channel,omitempty"`

	// CreatedBy Filters for meetings created by the specified user(s).
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for meeting on custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// EndedDate Provides ways to specify date ranges on objects.
	EndedDate *DateFilter `json:"ended_date,omitempty"`

	// ExternalRef Filters for meetings with the provided external_ref(s).
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// Limit The maximum number of meetings to return.
	Limit *int32 `json:"limit,omitempty"`

	// Links Filters for links associated with the meeting.
	Links *[]MeetingsFilterLinkSummaryFilter `json:"links,omitempty"`

	// Members Filter for meeting on specified Member Ids.
	Members *[]string `json:"members,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// Organizer Filter for meeting on specified organizers.
	Organizer *[]string `json:"organizer,omitempty"`

	// Parent Filters for meetings with the provided parent.
	// Deprecated:
	Parent *[]string `json:"parent,omitempty"`

	// ScheduledDate Provides ways to specify date ranges on objects.
	ScheduledDate *DateFilter `json:"scheduled_date,omitempty"`

	// SortBy Fields to sort the meetings by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// State Filters for meeting on specified state or outcomes.
	State *[]MeetingState `json:"state,omitempty"`

	// Tags Filters for meeting by tags.
	Tags *[]string `json:"tags,omitempty"`
}

// MeetingsListResponseBody defines model for meetings-list-response.
type MeetingsListResponseBody struct {
	// Meetings The list of meetings.
	Meetings []Meeting `json:"meetings"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// MeetingsUpdateRequest defines model for meetings-update-request.
type MeetingsUpdateRequest struct {
	// Channel The channel of meeting.
	Channel *MeetingChannel `json:"channel,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description The description of the meeting.
	Description *string `json:"description,omitempty"`

	// EndedDate Updates the date and time when the meeting ended.
	EndedDate *time.Time `json:"ended_date"`

	// ExternalRef External Reference for the meeting.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalUrl External URL for the meeting.
	ExternalUrl *string `json:"external_url,omitempty"`

	// Id The meetings ID.
	Id      string                        `json:"id"`
	Members *MeetingsUpdateRequestMembers `json:"members,omitempty"`

	// Organizer The ID of the user who organized the meeting.
	Organizer *string `json:"organizer,omitempty"`

	// Recording The ID of the meeting's recording artifact.
	Recording *string `json:"recording"`

	// RecordingUrl The recording URL of the meeting.
	RecordingUrl *string `json:"recording_url,omitempty"`

	// ScheduledDate Updates the date and time when the meeting was scheduled.
	ScheduledDate *time.Time `json:"scheduled_date"`

	// State The state of meeting.
	State *MeetingState              `json:"state,omitempty"`
	Tags  *MeetingsUpdateRequestTags `json:"tags,omitempty"`

	// Title The title of the meeting.
	Title *string `json:"title,omitempty"`

	// Transcript The ID of the artifact for the transcript of the meeting.
	Transcript *string `json:"transcript,omitempty"`
}

// MeetingsUpdateRequestMembers defines model for meetings-update-request-members.
type MeetingsUpdateRequestMembers struct {
	// Set Sets the members to the provided user IDs. This must not be empty.
	Set *[]string `json:"set,omitempty"`
}

// MeetingsUpdateRequestTags defines model for meetings-update-request-tags.
type MeetingsUpdateRequestTags struct {
	// Set Sets the provided tags on the meeting item.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// MeetingsUpdateResponseBody defines model for meetings-update-response.
type MeetingsUpdateResponseBody struct {
	Meeting Meeting `json:"meeting"`
}

// MemberSummary defines model for member-summary.
type MemberSummary struct {
	Type  MemberType `json:"type"`
	union json.RawMessage
}

// MemberType defines model for member-type.
type MemberType string

// MetricActionExecuteRequest defines model for metric-action-execute-request.
type MetricActionExecuteRequest struct {
	Action MetricActionExecuteRequestAction `json:"action"`

	// EventDate Timestamp of the event.
	EventDate time.Time `json:"event_date"`

	// Metric The metric's ID for which the metric action is to be executed.
	Metric string `json:"metric"`

	// Object The underlying object's ID on which the metric action is to be
	// executed.
	Object string `json:"object"`
}

// MetricActionExecuteRequestAction defines model for metric-action-execute-request-action.
type MetricActionExecuteRequestAction string

// MetricActionExecuteResponseBody defines model for metric-action-execute-response.
type MetricActionExecuteResponseBody = map[string]interface{}

// MetricDataPoint defines model for metric-data-point.
type MetricDataPoint struct {
	// Dimensions Key-value pairs for specifying additional attributes.
	Dimensions *[]MetricDataPointDimension `json:"dimensions,omitempty"`

	// Id An ID that uniquely identifies the metric data point. This ID will
	// be used for deduplication. Clients can generate its own ID and send
	// it in the request. If not provided, DevRev will perform
	// content-based deduplication.
	Id *string `json:"id,omitempty"`

	// Timestamp Timestamp when metric value is captured.
	Timestamp time.Time `json:"timestamp"`

	// Value The value corresponding to the metric. For simply recording
	// occurrence of an event, this value should be 1.0.
	Value float64 `json:"value"`
}

// MetricDataPointDimension defines model for metric-data-point-dimension.
type MetricDataPointDimension struct {
	// Key The key for the dimension. The keys must be unique and it is not
	// allowed to have more than one value with the same key. Key must be
	// at least one character long and cannot be longer than 64
	// characters.Key can only contain alphanumeric characters (A-Z, a-z,
	// and 0-9) and underscores (_). Key cannot start with a number and is
	// case-insensitive.
	Key string `json:"key"`

	// Value The value for the dimension. Value could be any string and cannot
	// be longer than 256 characters.
	Value string `json:"value"`
}

// MetricDefinition defines model for metric-definition.
type MetricDefinition struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Human readable name of the metric.
	Name *string `json:"name,omitempty"`
}

// MetricDefinitionAppliesTo The list of item types on which the metric might be applied.
type MetricDefinitionAppliesTo string

// MetricDefinitionMetricType The type of the metric. 'time' metrics track the time spent in some
// state, supporting operations like 'start', 'stop', 'pause', 'resume'.
// 'value' metrics track a value, supporting operations like 'set',
// 'increment', 'decrement'.
type MetricDefinitionMetricType string

// MetricDefinitionStatus The status of the metric. 'active' metrics can be used to create new
// SLAs, while 'inactive' metrics can not be used in new SLAs. Metrics can
// be updated between 'active' and 'inactive' states.
type MetricDefinitionStatus string

// MetricDefinitionSummary defines model for metric-definition-summary.
type MetricDefinitionSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Human readable name of the metric.
	Name *string `json:"name,omitempty"`
}

// MetricDefinitionsCreateRequest defines model for metric-definitions-create-request.
type MetricDefinitionsCreateRequest struct {
	// AppliesTo The list of object types on which the metric can be applied.
	AppliesTo []MetricDefinitionAppliesTo `json:"applies_to"`

	// Description Description of the purpose and operation of the metric.
	Description *string `json:"description,omitempty"`

	// Name A unique human readable name of the metric.
	Name string `json:"name"`
}

// MetricDefinitionsCreateResponseBody defines model for metric-definitions-create-response.
type MetricDefinitionsCreateResponseBody struct {
	MetricDefinition MetricDefinition `json:"metric_definition"`
}

// MetricDefinitionsDeleteRequest defines model for metric-definitions-delete-request.
type MetricDefinitionsDeleteRequest struct {
	// Id The ID of the metric definition to be deleted.
	Id string `json:"id"`
}

// MetricDefinitionsDeleteResponseBody The response to deleting a metric definition.
type MetricDefinitionsDeleteResponseBody = map[string]interface{}

// MetricDefinitionsGetRequest defines model for metric-definitions-get-request.
type MetricDefinitionsGetRequest struct {
	// Id The ID of the metric definition to get.
	Id *string `json:"id,omitempty"`

	// Name The unique human readable name of the metric.
	Name *string `json:"name,omitempty"`
}

// MetricDefinitionsGetResponseBody defines model for metric-definitions-get-response.
type MetricDefinitionsGetResponseBody struct {
	MetricDefinition MetricDefinition `json:"metric_definition"`
}

// MetricDefinitionsListRequest defines model for metric-definitions-list-request.
type MetricDefinitionsListRequest struct {
	// AppliesToType The type of objects the metric definition applies to.
	AppliesToType *[]MetricDefinitionAppliesTo `json:"applies_to_type,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// IncludeCustomMetrics Whether to include custom metrics in the response. If not set, then
	// custom metrics are excluded.
	IncludeCustomMetrics *bool `json:"include_custom_metrics,omitempty"`

	// Limit The maximum number of records to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// SortBy Fields to sort the records by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Status The status of the metric definition.
	Status *[]MetricDefinitionStatus `json:"status,omitempty"`

	// Type The type of metric definitions sought.
	Type *[]MetricDefinitionMetricType `json:"type,omitempty"`
}

// MetricDefinitionsListResponseBody defines model for metric-definitions-list-response.
type MetricDefinitionsListResponseBody struct {
	// MetricDefinitions The list of metric definitions.
	MetricDefinitions []MetricDefinition `json:"metric_definitions"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// MetricDefinitionsUpdateRequest defines model for metric-definitions-update-request.
type MetricDefinitionsUpdateRequest struct {
	// Description The updated description of the purpose and operation of the metric.
	Description *string `json:"description,omitempty"`

	// Id The ID of the metric definition to update.
	Id string `json:"id"`

	// Name The updated unique human readable name of the metric.
	Name *string `json:"name,omitempty"`

	// Status The status of the metric. 'active' metrics can be used to create new
	// SLAs, while 'inactive' metrics can not be used in new SLAs. Metrics can
	// be updated between 'active' and 'inactive' states.
	Status *MetricDefinitionStatus `json:"status,omitempty"`
}

// MetricDefinitionsUpdateResponseBody defines model for metric-definitions-update-response.
type MetricDefinitionsUpdateResponseBody struct {
	MetricDefinition MetricDefinition `json:"metric_definition"`
}

// MetricTracker defines model for metric-tracker.
type MetricTracker struct {
	Type MetricTrackerType `json:"type"`
}

// MetricTrackerType defines model for metric-tracker-type.
type MetricTrackerType = string

// MetricTrackersGetRequest defines model for metric-trackers-get-request.
type MetricTrackersGetRequest struct {
	// Metric The ID of the metric that is being tracked.
	Metric string `json:"metric"`

	// Object The ID of the underlying object on which the metric is being
	// tracked.
	Object string `json:"object"`
}

// MetricTrackersGetResponseBody defines model for metric-trackers-get-response.
type MetricTrackersGetResponseBody struct {
	MetricTracker MetricTracker `json:"metric_tracker"`
}

// MetricVisualizationYAxis The y axis for a metric visualization.
type MetricVisualizationYAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// MetricWidgetVisualization A metric visualization configuration. Includes metadata specific to
// metrics.
type MetricWidgetVisualization struct {
	// Pvp Configuration settings for enabling and customizing PVP (past vs.
	// present) value in widgets.
	Pvp *WidgetPvpConfig `json:"pvp,omitempty"`

	// Y The configuration for the Y-axis.
	Y []MetricVisualizationYAxis `json:"y"`
}

// MetricsData defines model for metrics-data.
type MetricsData struct {
	// AccountRef Account ID or external_ref of the account for which metric is being
	// published. Account ID is DevRev DON ID. For example,
	// don:identity:dvrv-us-1:devo/0:account/156. External_ref is the
	// identification of DevRev customer's customers. Devrev will
	// internally resolve external_ref to Account ID and use it for
	// further processing. For example, external_ref=customer_1 may
	// resolve to don:identity:dvrv-us-1:devo/0:account/155.
	AccountRef string `json:"account_ref"`

	// DataPoints One or more data points collected for a given metric such as object
	// usage, object state etc.
	DataPoints []MetricDataPoint `json:"data_points"`

	// Name Name of the metric which is being measured. For example,
	// num_api_calls, num_active_users, etc.
	Name string `json:"name"`

	// OrgRef Rev Org ID or external_ref for which metric is being published.Rev
	// Org ID is DevRev DON ID. For example,
	// don:identity:dvrv-us-1:devo/0:revo/156. External_ref is the
	// identification of DevRev customer's customers and maintained by
	// DevRev's customers. Devrev will internally resolve external_ref to
	// Rev Org ID and use it for further processing. For example,
	// external_ref=org_customer_1 may resolve to
	// don:identity:dvrv-us-1:devo/0:revo/155.
	OrgRef *string `json:"org_ref,omitempty"`

	// UserRef Rev User ID or user ref for which metric is being published.
	UserRef *string `json:"user_ref,omitempty"`
}

// MetricsDataIngestRequest defines model for metrics-data-ingest-request.
type MetricsDataIngestRequest struct {
	// Metrics Metrics data received from Dev orgs.
	Metrics []MetricsData `json:"metrics"`
}

// Money Money.
type Money struct {
	// Amount Amount of the money.
	Amount *string `json:"amount,omitempty"`

	// Currency Currency of the money.
	Currency *string `json:"currency,omitempty"`
}

// NotificationsSendRequest defines model for notifications-send-request.
type NotificationsSendRequest struct {
	// Notifications The list of notifications to send.
	Notifications []SendNotification `json:"notifications"`
}

// NotificationsSendResponseBody defines model for notifications-send-response.
type NotificationsSendResponseBody = map[string]interface{}

// ObjectMember defines model for object-member.
type ObjectMember struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	Member     *AtomSummary `json:"member,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time   `json:"modified_date,omitempty"`
	Object       *AtomSummary `json:"object,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`
}

// ObjectMemberSearchSummary defines model for object-member-search-summary.
type ObjectMemberSearchSummary struct {
	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time          `json:"modified_date,omitempty"`
	ObjectMember ObjectMemberSummary `json:"object_member"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// ObjectMemberSummary defines model for object-member-summary.
type ObjectMemberSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`
}

// OperationSearchSummary defines model for operation-search-summary.
type OperationSearchSummary struct {
	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time       `json:"modified_date,omitempty"`
	Operation    OperationSummary `json:"operation"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// OperationSummary defines model for operation-summary.
type OperationSummary = AtomBaseSummary

// Opportunity defines model for opportunity.
type Opportunity struct {
	Account *AccountSummary `json:"account,omitempty"`

	// ActualCloseDate Timestamp when the work was actually completed.
	ActualCloseDate *time.Time `json:"actual_close_date,omitempty"`

	// AnnualContractValue Money.
	AnnualContractValue *Money       `json:"annual_contract_value,omitempty"`
	AppliesToPart       *PartSummary `json:"applies_to_part,omitempty"`

	// Artifacts The artifacts attached to the work item.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body Body of the work object.
	Body *string `json:"body,omitempty"`

	// Contacts Contacts involved in the opportunity.
	Contacts  *[]UserSummary `json:"contacts,omitempty"`
	CreatedBy *UserSummary   `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ForecastCategoryV2 The properties of an enum value.
	ForecastCategoryV2 *EnumValue `json:"forecast_category_v2,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// ReportedBy Users that reported the work.
	ReportedBy *[]UserSummary `json:"reported_by,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStage `json:"stage,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`

	// Value Money.
	Value *Money `json:"value,omitempty"`
}

// OpportunityForecastCategory Forecast category of the opportunity.
type OpportunityForecastCategory string

// OpportunityPriority Priority of the opportunity.
type OpportunityPriority string

// OpportunitySummary defines model for opportunity-summary.
type OpportunitySummary struct {
	Account *AccountSummary `json:"account,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStageSummary `json:"stage,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// OrgBase defines model for org-base.
type OrgBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// OrgBaseSummary defines model for org-base-summary.
type OrgBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`
}

// OrgEnvironment The environment of the Org. Defaults to 'production' if not specified.
type OrgEnvironment string

// OrgSchedule defines model for org-schedule.
type OrgSchedule struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DefaultWeeklyOrgSchedule The schedule for each week.
	DefaultWeeklyOrgSchedule *WeeklyOrgSchedule `json:"default_weekly_org_schedule,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// MinValidDays The schedule must be valid and well-defined for at least this many
	// days in the future, otherwise a warning notification is generated.
	// Default is 0 if not specified.
	MinValidDays *int32       `json:"min_valid_days,omitempty"`
	ModifiedBy   *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Human-readable name.
	Name *string `json:"name,omitempty"`

	// OrgScheduleFragments The list of schedule fragments. It must be an ordered list of
	// contiguous fragments (the next starting when the previous one
	// ends), updates in a published schedule are only allowed to add new
	// ones to the future.
	OrgScheduleFragments *[]OrgScheduleFragmentOverview `json:"org_schedule_fragments,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleStatus `json:"status"`

	// Timezone Timezone in which this is defined. Only organization schedules in
	// the same timezone can be directly combined.
	Timezone *string `json:"timezone,omitempty"`

	// ValidUntil Derived field indicating when a valid organization schedule will
	// become invalid. If omitted, the schedule is already invalid. A
	// schedule is valid if it has a weekly schedule for all named periods
	// for all its schedule fragments, and if it has a schedule fragment
	// for the time period in question.
	ValidUntil *time.Time `json:"valid_until,omitempty"`

	// WeeklyOrgSchedules If the organization schedule fragment specifies that the given day
	// belongs to a named period, a weekly schedule from this list with
	// the matching name will be selected.
	WeeklyOrgSchedules *[]WeeklyOrgSchedule `json:"weekly_org_schedules,omitempty"`
}

// OrgScheduleFragment defines model for org-schedule-fragment.
type OrgScheduleFragment struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// From The date (inclusive) on which the organization schedule fragment
	// begins.
	From *time.Time `json:"from,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Intervals Periods during which the schedule is considered to be 'off' or to
	// be in some specific named period.
	Intervals  *[]OrgScheduleInterval `json:"intervals,omitempty"`
	ModifiedBy *UserSummary           `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Human-readable name, indicating the purpose of the schedule.
	Name *string `json:"name,omitempty"`

	// RegionCodes CLDR region code of the countries/regions it is meant to be valid
	// for. Does not drive logic, serves only for easier filtering and
	// organization.
	RegionCodes *[]string `json:"region_codes,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleFragmentStatus `json:"status"`

	// To The date (exclusive) on which the organization schedule fragment's
	// validity ends.
	To *time.Time `json:"to,omitempty"`
}

// OrgScheduleFragmentOverview The representation of the organization schedule fragment embedded
// inside a organization schedule, used to quickly look up the schedule
// fragment for the right period.
type OrgScheduleFragmentOverview = map[string]interface{}

// OrgScheduleFragmentStatus Status determines how an item can be used. In 'draft' status an item
// can be edited but can't be used. When 'published' the item can longer
// be edited but can be used. 'Archived' is read-only.
type OrgScheduleFragmentStatus string

// OrgScheduleFragmentsCreateRequest defines model for org-schedule-fragments-create-request.
type OrgScheduleFragmentsCreateRequest struct {
	// From Date (inclusive) on which the organization schedule fragment
	// begins.
	From time.Time `json:"from"`

	// Intervals The intervals that comprise the schedule fragment.
	Intervals []CreateOrgScheduleInterval `json:"intervals"`

	// Name Name of the organization schedule fragment.
	Name string `json:"name"`

	// RegionCodes CLDR region code of the countries/regions it is meant to be valid
	// for. Does not drive logic, serves only for easier filtering and
	// organization.
	RegionCodes *[]string `json:"region_codes,omitempty"`

	// To Date (exclusive) on which the organization schedule fragment's
	// validity ends.
	To time.Time `json:"to"`
}

// OrgScheduleFragmentsCreateResponseBody defines model for org-schedule-fragments-create-response.
type OrgScheduleFragmentsCreateResponseBody struct {
	OrgScheduleFragment OrgScheduleFragment `json:"org_schedule_fragment"`
}

// OrgScheduleFragmentsGetRequest defines model for org-schedule-fragments-get-request.
type OrgScheduleFragmentsGetRequest struct {
	// Id Organization schedule Fragment ID.
	Id string `json:"id"`
}

// OrgScheduleFragmentsGetResponseBody defines model for org-schedule-fragments-get-response.
type OrgScheduleFragmentsGetResponseBody struct {
	OrgScheduleFragment OrgScheduleFragment `json:"org_schedule_fragment"`
}

// OrgScheduleFragmentsTransitionRequest defines model for org-schedule-fragments-transition-request.
type OrgScheduleFragmentsTransitionRequest struct {
	// Id Organization schedule Fragment ID.
	Id string `json:"id"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleFragmentStatus `json:"status"`
}

// OrgScheduleFragmentsTransitionResponseBody defines model for org-schedule-fragments-transition-response.
type OrgScheduleFragmentsTransitionResponseBody struct {
	OrgScheduleFragment OrgScheduleFragment `json:"org_schedule_fragment"`
}

// OrgScheduleInterval An optionally named period on day granularity.
type OrgScheduleInterval = map[string]interface{}

// OrgScheduleStatus Status determines how an item can be used. In 'draft' status an item
// can be edited but can't be used. When 'published' the item can longer
// be edited but can be used. 'Archived' is read-only.
type OrgScheduleStatus string

// OrgScheduleSummary defines model for org-schedule-summary.
type OrgScheduleSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Human-readable name.
	Name *string `json:"name,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleStatus `json:"status"`

	// Timezone Timezone in which this is defined. Only organization schedules in
	// the same timezone can be directly combined.
	Timezone *string `json:"timezone,omitempty"`

	// ValidUntil Derived field indicating when a valid organization schedule will
	// become invalid. If omitted, the schedule is already invalid. A
	// schedule is valid if it has a weekly schedule for all named periods
	// for all its schedule fragments, and if it has a schedule fragment
	// for the time period in question.
	ValidUntil *time.Time `json:"valid_until,omitempty"`
}

// OrgSchedulesCreateRequest defines model for org-schedules-create-request.
type OrgSchedulesCreateRequest struct {
	DefaultWeeklyOrgSchedule *SetWeeklyOrgSchedule `json:"default_weekly_org_schedule,omitempty"`

	// MinValidDays Organization schedule must be valid for at least this many days in
	// the future. Meaning organization schedule fragments must cover this
	// period. 0 if omitted.
	MinValidDays *int64 `json:"min_valid_days,omitempty"`

	// Name Human-readable name.
	Name string `json:"name"`

	// OrgScheduleFragments List of organization schedule fragments with no overlaps or gaps.
	OrgScheduleFragments *[]SetOrgScheduleFragmentSummary `json:"org_schedule_fragments,omitempty"`

	// Timezone Timezone in which the organization schedule applies. Expected to be
	// a valid IANA time zone name such as America/New_York.
	Timezone string `json:"timezone"`

	// WeeklyOrgSchedules If this day belongs to a named period according to the currently
	// active organization schedule fragment, a weekly organization
	// schedule from this list with the corresponding name will apply.
	WeeklyOrgSchedules *[]SetWeeklyOrgSchedule `json:"weekly_org_schedules,omitempty"`
}

// OrgSchedulesCreateResponseBody defines model for org-schedules-create-response.
type OrgSchedulesCreateResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSchedulesEvaluateRequest defines model for org-schedules-evaluate-request.
type OrgSchedulesEvaluateRequest struct {
	// Id Organization schedule ID.
	Id string `json:"id"`

	// Instants Time instants to evaluate the organization schedule for.
	Instants []time.Time `json:"instants"`
}

// OrgSchedulesEvaluateResponseBody defines model for org-schedules-evaluate-response.
type OrgSchedulesEvaluateResponseBody struct {
	// InstantEvaluations The evaluations for the given time instants in the requested order.
	InstantEvaluations []InstantEvaluation `json:"instant_evaluations"`
}

// OrgSchedulesGetRequest defines model for org-schedules-get-request.
type OrgSchedulesGetRequest struct {
	// Id Organization schedule ID.
	Id string `json:"id"`
}

// OrgSchedulesGetResponseBody defines model for org-schedules-get-response.
type OrgSchedulesGetResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSchedulesListRequest defines model for org-schedules-list-request.
type OrgSchedulesListRequest struct {
	// CreatedById Creator ID the filter matches.
	CreatedById *[]string `json:"created_by_id,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit Max number of organization schedules returned in a page. Default is
	// 50.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Status The organization schedule statuses the filter matches.
	Status *[]OrgScheduleStatus `json:"status,omitempty"`

	// ValidUntil Provides ways to specify date ranges on objects.
	ValidUntil *DateFilter `json:"valid_until,omitempty"`
}

// OrgSchedulesListResponseBody defines model for org-schedules-list-response.
type OrgSchedulesListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// OrgSchedules The list of organization schedules.
	OrgSchedules []OrgSchedule `json:"org_schedules"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// OrgSchedulesSetFutureRequest defines model for org-schedules-set-future-request.
type OrgSchedulesSetFutureRequest struct {
	// Id Organization schedule ID.
	Id string `json:"id"`

	// OrgScheduleFragmentId Organization schedule Fragment ID.
	OrgScheduleFragmentId string `json:"org_schedule_fragment_id"`
}

// OrgSchedulesSetFutureResponseBody defines model for org-schedules-set-future-response.
type OrgSchedulesSetFutureResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSchedulesTransitionRequest defines model for org-schedules-transition-request.
type OrgSchedulesTransitionRequest struct {
	// Id Organization schedule ID.
	Id string `json:"id"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status OrgScheduleStatus `json:"status"`
}

// OrgSchedulesTransitionResponseBody defines model for org-schedules-transition-response.
type OrgSchedulesTransitionResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSchedulesUpdateRequest defines model for org-schedules-update-request.
type OrgSchedulesUpdateRequest struct {
	DefaultWeeklyOrgSchedule *SetWeeklyOrgSchedule `json:"default_weekly_org_schedule,omitempty"`

	// Id Organization schedule ID.
	Id string `json:"id"`

	// MinValidDays Organization schedule must be valid for at least this many days in
	// the future. Meaning organization schedule fragments must cover this
	// period. 0 if omitted.
	MinValidDays *int64 `json:"min_valid_days,omitempty"`

	// Name Human-readable name.
	Name *string `json:"name,omitempty"`

	// OrgScheduleFragments List of organization schedule fragments with no overlaps or gaps.
	OrgScheduleFragments *[]SetOrgScheduleFragmentSummary `json:"org_schedule_fragments,omitempty"`

	// Timezone Timezone in which the organization schedule applies. Expected to be
	// a valid IANA time zone name such as America/New_York.
	Timezone *string `json:"timezone,omitempty"`

	// WeeklyOrgSchedules If this day belongs to a named period according to the currently
	// active organization schedule fragment, a weekly organization
	// schedule from this list with the corresponding name will apply.
	WeeklyOrgSchedules *[]SetWeeklyOrgSchedule `json:"weekly_org_schedules,omitempty"`
}

// OrgSchedulesUpdateResponseBody defines model for org-schedules-update-response.
type OrgSchedulesUpdateResponseBody struct {
	OrgSchedule OrgSchedule `json:"org_schedule"`
}

// OrgSearchSummary defines model for org-search-summary.
type OrgSearchSummary struct {
	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
	Org          OrgSummary `json:"org"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// OrgSummary defines model for org-summary.
type OrgSummary struct {
	Type  OrgType `json:"type"`
	union json.RawMessage
}

// OrgType defines model for org-type.
type OrgType string

// PackedBubbleVisualizationXAxis The X-axis for a packed bubble visualization.
type PackedBubbleVisualizationXAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// PackedBubbleVisualizationYAxis The Y-axis for a packed bubble visualization.
type PackedBubbleVisualizationYAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// PackedBubbleWidgetVisualization A Packed Bubble chart visualization configuration. Includes metadata
// specific to packed bubble charts.
type PackedBubbleWidgetVisualization struct {
	// X The configuration for the X-axis.
	X []PackedBubbleVisualizationXAxis `json:"x"`

	// Y The configuration for the Y-axes.
	Y []PackedBubbleVisualizationYAxis `json:"y"`
}

// ParentPartFilter The filter for specifying parent part.
type ParentPartFilter struct {
	// Level Number of levels to fetch the part hierarchy up to.
	Level *int32 `json:"level,omitempty"`

	// Parts Part IDs to fetch the hierarchy for.
	Parts []string `json:"parts"`
}

// Part defines model for part.
type Part struct {
	Type  PartType `json:"type"`
	union json.RawMessage
}

// PartBase defines model for part-base.
type PartBase struct {
	// Artifacts The attached artifacts.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`
	CreatedBy *UserSummary       `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// Description Description of the part.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Name of the part.
	Name string `json:"name"`

	// OwnedBy The users that own the part.
	OwnedBy []UserSummary `json:"owned_by"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`
}

// PartBaseSummary defines model for part-base-summary.
type PartBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Name of the part.
	Name string `json:"name"`

	// OwnedBy The users that own the part.
	OwnedBy []UserSummary `json:"owned_by"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`
}

// PartSearchSummary defines model for part-search-summary.
type PartSearchSummary struct {
	// Comments Comments on the work.
	Comments *[]CommentSearchSummary `json:"comments,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time  `json:"modified_date,omitempty"`
	Part         PartSummary `json:"part"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// PartSummary defines model for part-summary.
type PartSummary struct {
	Type  PartType `json:"type"`
	union json.RawMessage
}

// PartType defines model for part-type.
type PartType string

// PartsCreateRequest defines model for parts-create-request.
type PartsCreateRequest struct {
	// Artifacts The IDs of the artifacts.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments The custom schema fragments to use.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description Description of the part.
	Description *string `json:"description,omitempty"`

	// Links Links associated with the part.
	Links *[]EmbedLinksCreateRequest `json:"links,omitempty"`

	// Name Name of the part.
	Name string `json:"name"`

	// OwnedBy The users that own the part.
	OwnedBy []string `json:"owned_by"`

	// StageValidationOptions The type of stage validations options when creating a part.
	StageValidationOptions *[]StageValidationOptionForCreate `json:"stage_validation_options,omitempty"`

	// Tags Tags associated with the part.
	Tags  *[]SetTagWithValue `json:"tags,omitempty"`
	Type  PartType           `json:"type"`
	union json.RawMessage
}

// PartsCreateRequestCapability defines model for parts-create-request-capability.
type PartsCreateRequestCapability struct {
	// ParentPart ID of the parent product for the capability.
	ParentPart []string `json:"parent_part"`
}

// PartsCreateRequestEnhancement defines model for parts-create-request-enhancement.
type PartsCreateRequestEnhancement struct {
	// ParentPart ID of the parent part on which the enhancement is to be created.
	ParentPart []string `json:"parent_part"`

	// StageV2 Custom stage ID which will be used for creating the enhancement.
	StageV2 *string `json:"stage_v2,omitempty"`

	// TargetCloseDate Target close date by which enhancement is expected to be closed.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// TargetStartDate Target start date by which enhancement is expected to be started.
	// Example Date Format: 2000-11-01T01:01:01Z
	TargetStartDate *time.Time `json:"target_start_date,omitempty"`
}

// PartsCreateRequestFeature defines model for parts-create-request-feature.
type PartsCreateRequestFeature struct {
	// ParentPart ID of the parent capability/feature for the feature.
	ParentPart []string `json:"parent_part"`
}

// PartsCreateRequestLinkable defines model for parts-create-request-linkable.
type PartsCreateRequestLinkable struct {
	// CodeInferredSurfaceArea Code Inferred surface area of the linkable.
	CodeInferredSurfaceArea *[]string `json:"code_inferred_surface_area,omitempty"`

	// CodeRepoPaths Repo Path of the linkable.
	CodeRepoPaths *string `json:"code_repo_paths,omitempty"`

	// CodeRepoUrl Repo url of the linkable.
	CodeRepoUrl *string `json:"code_repo_url,omitempty"`
}

// PartsCreateRequestProduct defines model for parts-create-request-product.
type PartsCreateRequestProduct = map[string]interface{}

// PartsCreateRequestRunnable defines model for parts-create-request-runnable.
type PartsCreateRequestRunnable struct {
	// CodeInferredSurfaceArea Code Inferred surface area of the runnable.
	CodeInferredSurfaceArea *[]string `json:"code_inferred_surface_area,omitempty"`

	// CodeRepoPaths Repo Path of the runnable.
	CodeRepoPaths *string `json:"code_repo_paths,omitempty"`

	// CodeRepoUrl Repo url of the runnable.
	CodeRepoUrl *string `json:"code_repo_url,omitempty"`
}

// PartsCreateResponseBody defines model for parts-create-response.
type PartsCreateResponseBody struct {
	Part Part `json:"part"`
}

// PartsDeleteRequest defines model for parts-delete-request.
type PartsDeleteRequest struct {
	// Id The ID of the part to delete.
	Id string `json:"id"`
}

// PartsDeleteResponseBody defines model for parts-delete-response.
type PartsDeleteResponseBody = map[string]interface{}

// PartsFilterEnhancement defines model for parts-filter-enhancement.
type PartsFilterEnhancement struct {
	// Accounts Filters for enhancement by its accounts.
	Accounts        *[]string       `json:"accounts,omitempty"`
	ActualCloseDate *DateTimeFilter `json:"actual_close_date,omitempty"`

	// ActualCloseDateV2 Provides ways to specify date ranges on objects.
	ActualCloseDateV2 *DateFilter     `json:"actual_close_date_v2,omitempty"`
	ActualStartDate   *DateTimeFilter `json:"actual_start_date,omitempty"`

	// ActualStartDateV2 Provides ways to specify date ranges on objects.
	ActualStartDateV2 *DateFilter `json:"actual_start_date_v2,omitempty"`

	// Opportunities Filters for enhancement by its opportunities.
	Opportunities *[]string `json:"opportunities,omitempty"`

	// RevScoreTier Filters for enhancement by its rev score tier.
	RevScoreTier *[]EnhancementRevScoreTier `json:"rev_score_tier,omitempty"`

	// StageV2 List of IDs of the custom stages which will be used for filtering.
	StageV2 *[]string `json:"stage_v2,omitempty"`

	// StateV2 Filters for part with any of the provided custom states.
	StateV2         *[]string       `json:"state_v2,omitempty"`
	TargetCloseDate *DateTimeFilter `json:"target_close_date,omitempty"`

	// TargetCloseDateV2 Provides ways to specify date ranges on objects.
	TargetCloseDateV2 *DateFilter     `json:"target_close_date_v2,omitempty"`
	TargetStartDate   *DateTimeFilter `json:"target_start_date,omitempty"`

	// TargetStartDateV2 Provides ways to specify date ranges on objects.
	TargetStartDateV2 *DateFilter `json:"target_start_date_v2,omitempty"`

	// Tickets Filters for enhancement by its tickets.
	Tickets *[]string `json:"tickets,omitempty"`
}

// PartsGetRequest defines model for parts-get-request.
type PartsGetRequest struct {
	// Id The ID of the part to retrieve.
	Id string `json:"id"`
}

// PartsGetResponseBody defines model for parts-get-response.
type PartsGetResponseBody struct {
	Part Part `json:"part"`
}

// PartsListRequest defines model for parts-list-request.
type PartsListRequest struct {
	// CreatedBy Filters for parts created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`
	Enhancement  *PartsFilterEnhancement `json:"enhancement,omitempty"`

	// Limit The maximum number of parts to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedBy Filters for parts modified by any of these users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`

	// Name Filters for parts of the provided name(s).
	Name *[]string `json:"name,omitempty"`

	// OwnedBy Filters for parts owned by any of these users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// ParentPart The filter for specifying parent part.
	ParentPart *ParentPartFilter `json:"parent_part,omitempty"`

	// Subtype Filters for subtypes.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags Filters for part with any of the provided tags.
	Tags *[]string `json:"tags,omitempty"`

	// Type Filters for parts of the provided type(s).
	Type *[]PartType `json:"type,omitempty"`
}

// PartsListResponseBody defines model for parts-list-response.
type PartsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// Parts The list of parts.
	Parts []Part `json:"parts"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// PartsUpdateRequest defines model for parts-update-request.
type PartsUpdateRequest struct {
	Artifacts *PartsUpdateRequestArtifacts `json:"artifacts,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments The custom schema fragments to use.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description The updated description of the part.
	Description *string `json:"description,omitempty"`

	// Id The ID of the part to update.
	Id string `json:"id"`

	// Name The updated name of the part.
	Name    *string                    `json:"name,omitempty"`
	OwnedBy *PartsUpdateRequestOwnedBy `json:"owned_by,omitempty"`

	// StageValidationOptions The type of stage validations options when updating the stage or
	// the stage diagram of an object.
	StageValidationOptions *[]StageValidationOptionForUpdate `json:"stage_validation_options,omitempty"`
	Tags                   *PartsUpdateRequestTags           `json:"tags,omitempty"`
	Type                   *PartType                         `json:"type,omitempty"`
	union                  json.RawMessage
}

// PartsUpdateRequestArtifacts defines model for parts-update-request-artifacts.
type PartsUpdateRequestArtifacts struct {
	// Set Sets the artifacts to the provided IDs.
	Set *[]string `json:"set,omitempty"`
}

// PartsUpdateRequestCapability defines model for parts-update-request-capability.
type PartsUpdateRequestCapability = map[string]interface{}

// PartsUpdateRequestEnhancement defines model for parts-update-request-enhancement.
type PartsUpdateRequestEnhancement struct {
	// StageV2 Custom stage ID which will be used for updating the enhancement.
	StageV2 *string `json:"stage_v2,omitempty"`

	// TargetCloseDate Updates the target close date of the enhancement.
	TargetCloseDate *time.Time `json:"target_close_date"`

	// TargetStartDate Updates the target start date of the enhancement. Example Date
	// Format: 2000-11-01T01:01:01Z
	TargetStartDate *time.Time `json:"target_start_date"`
}

// PartsUpdateRequestFeature defines model for parts-update-request-feature.
type PartsUpdateRequestFeature = map[string]interface{}

// PartsUpdateRequestLinkable defines model for parts-update-request-linkable.
type PartsUpdateRequestLinkable struct {
	// CodeInferredSurfaceArea Code Inferred surface area of the linkable.
	CodeInferredSurfaceArea *[]string `json:"code_inferred_surface_area,omitempty"`

	// CodeRepoPaths Repo Path of the linkable.
	CodeRepoPaths *string `json:"code_repo_paths,omitempty"`

	// CodeRepoUrl Repo url of the linkable.
	CodeRepoUrl *string `json:"code_repo_url,omitempty"`
}

// PartsUpdateRequestOwnedBy defines model for parts-update-request-owned-by.
type PartsUpdateRequestOwnedBy struct {
	// Set Sets the owner IDs to the provided user IDs. This must not be
	// empty.
	Set *[]string `json:"set,omitempty"`
}

// PartsUpdateRequestProduct defines model for parts-update-request-product.
type PartsUpdateRequestProduct = map[string]interface{}

// PartsUpdateRequestRunnable defines model for parts-update-request-runnable.
type PartsUpdateRequestRunnable struct {
	// CodeInferredSurfaceArea Code Inferred surface area of the runnable.
	CodeInferredSurfaceArea *[]string `json:"code_inferred_surface_area,omitempty"`

	// CodeRepoPaths Repo Path of the runnable.
	CodeRepoPaths *string `json:"code_repo_paths,omitempty"`

	// CodeRepoUrl Repo url of the runnable.
	CodeRepoUrl *string `json:"code_repo_url,omitempty"`
}

// PartsUpdateRequestTags defines model for parts-update-request-tags.
type PartsUpdateRequestTags struct {
	// Set Sets the tags to the provided tags.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// PartsUpdateResponseBody defines model for parts-update-response.
type PartsUpdateResponseBody struct {
	Part Part `json:"part"`
}

// PieVisualizationXAxis The X-axis for a pie visualization.
type PieVisualizationXAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// PieVisualizationYAxis The Y-axis for a pie visualization.
type PieVisualizationYAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// PieWidgetVisualization A pie chart visualization configuration. Includes metadata specific to
// pie charts.
type PieWidgetVisualization struct {
	// X The configuration for the X-axis.
	X []PieVisualizationXAxis `json:"x"`

	// Y The Y-axis for a pie visualization.
	Y PieVisualizationYAxis `json:"y"`
}

// Preferences defines model for preferences.
type Preferences struct {
	Type  PreferencesType `json:"type"`
	union json.RawMessage
}

// PreferencesBase defines model for preferences-base.
type PreferencesBase = AtomBase

// PreferencesBaseSummary defines model for preferences-base-summary.
type PreferencesBaseSummary = AtomBaseSummary

// PreferencesGetRequest defines model for preferences-get-request.
type PreferencesGetRequest struct {
	// LanguageCode Language code for which to get the preferences for.
	LanguageCode *string `json:"language_code,omitempty"`

	// Object The ID of the target object for which preferences object is to be
	// fetched.
	Object string          `json:"object"`
	Type   PreferencesType `json:"type"`
}

// PreferencesGetResponseBody defines model for preferences-get-response.
type PreferencesGetResponseBody struct {
	Preference Preferences `json:"preference"`
}

// PreferencesType defines model for preferences-type.
type PreferencesType string

// PreferencesUpdateRequest defines model for preferences-update-request.
type PreferencesUpdateRequest struct {
	// LanguageCode Language code for which to update the preferences for.
	LanguageCode *string `json:"language_code,omitempty"`

	// Object The ID of the object for which the preferences are to be updated.
	Object string          `json:"object"`
	Type   PreferencesType `json:"type"`
	union  json.RawMessage
}

// PreferencesUpdateResponseBody defines model for preferences-update-response.
type PreferencesUpdateResponseBody struct {
	Preferences Preferences `json:"preferences"`
}

// Product defines model for product.
type Product = PartBase

// ProductSummary defines model for product-summary.
type ProductSummary = PartBaseSummary

// QuestionAnswer defines model for question-answer.
type QuestionAnswer struct {
	// Answer The Answer.
	Answer *string `json:"answer,omitempty"`

	// AppliesToParts Details of the parts relevant to the question_answer.
	AppliesToParts *[]PartSummary `json:"applies_to_parts,omitempty"`
	CreatedBy      *UserSummary   `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Question The Question.
	Question *string `json:"question,omitempty"`

	// Sources Details of the sources from which the question answer was
	// generated.
	Sources *[]AtomSummary `json:"sources,omitempty"`

	// Status Status of the question answer.
	Status *QuestionAnswerStatus `json:"status,omitempty"`

	// SuggestedAnswer An alternative answer suggested by the Q/A generation algorithm.
	SuggestedAnswer *string `json:"suggested_answer,omitempty"`

	// SuggestedForDeletion Whether the Q/A was marked for deletion by the Q/A generation
	// algorithm.
	SuggestedForDeletion *bool `json:"suggested_for_deletion,omitempty"`

	// Topic The topic to which the QA belongs.
	Topic *string `json:"topic,omitempty"`

	// Verified Whether the Q/A was verified.
	Verified *bool `json:"verified,omitempty"`
}

// QuestionAnswerSearchSummary defines model for question-answer-search-summary.
type QuestionAnswerSearchSummary struct {
	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate   *time.Time            `json:"modified_date,omitempty"`
	QuestionAnswer QuestionAnswerSummary `json:"question_answer"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// QuestionAnswerStatus Status of the question answer.
type QuestionAnswerStatus string

// QuestionAnswerSummary defines model for question-answer-summary.
type QuestionAnswerSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Question The Question.
	Question *string `json:"question,omitempty"`
}

// QuestionAnswersCreateRequest The request to create a question-answer.
type QuestionAnswersCreateRequest struct {
	AccessLevel *AccessLevel `json:"access_level,omitempty"`

	// Answer Answer of the question-answer.
	Answer string `json:"answer"`

	// AppliesToArticles The articles that the question-answer applies to.
	AppliesToArticles *[]string `json:"applies_to_articles,omitempty"`

	// AppliesToParts The parts that the question-answer applies to.
	AppliesToParts []string `json:"applies_to_parts"`

	// OwnedBy The users that own the question-answer.
	OwnedBy []string `json:"owned_by"`

	// Question Question of the question-answer.
	Question string `json:"question"`

	// SharedWith Information about the role the member receives due to the share.
	SharedWith *[]SetSharedWithMembership `json:"shared_with,omitempty"`

	// Sources The source of the question-answer.
	Sources *[]string `json:"sources,omitempty"`

	// Status Status of the question answer.
	Status QuestionAnswerStatus `json:"status"`

	// SuggestedAnswer Alternative answer for the question-answer sugested by Q/A
	// Discovery.
	SuggestedAnswer *string `json:"suggested_answer,omitempty"`

	// SuggestedForDeletion Whether the question-answer was suggeste to be deleted by Q/A
	// Discovery.
	SuggestedForDeletion *bool `json:"suggested_for_deletion,omitempty"`

	// Tags Tags associated with the question-answer.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Topic Topic of the question-answer.
	Topic *string `json:"topic,omitempty"`

	// Verified Whether the question-answer was verified by a user or not.
	Verified *bool `json:"verified,omitempty"`
}

// QuestionAnswersCreateResponseBody Create question-answer response.
type QuestionAnswersCreateResponseBody struct {
	QuestionAnswer QuestionAnswer `json:"question_answer"`
}

// QuestionAnswersDeleteRequest The request to delete a question-answer.
type QuestionAnswersDeleteRequest struct {
	// Id The ID of the question-answer.
	Id string `json:"id"`

	// QuestionAnswerId The ID of the question-answer.
	// Deprecated:
	QuestionAnswerId *string `json:"question_answer_id,omitempty"`
}

// QuestionAnswersGetRequest The request to get a question-answer.
type QuestionAnswersGetRequest struct {
	// Id The ID of the required question-answer.
	Id string `json:"id"`
}

// QuestionAnswersGetResponseBody Get question-answer response.
type QuestionAnswersGetResponseBody struct {
	QuestionAnswer QuestionAnswer `json:"question_answer"`
}

// QuestionAnswersListRequest The request to list question-answers.
type QuestionAnswersListRequest struct {
	// AppliesToArticles Filters for question-answer belonging to any of the provided
	// articles.
	AppliesToArticles *[]string `json:"applies_to_articles,omitempty"`

	// AppliesToParts Filters for question-answer belonging to any of the provided parts.
	AppliesToParts *[]string `json:"applies_to_parts,omitempty"`

	// CreatedBy Filters for question-answers created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of question-answers to return. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// OwnedBy Filters for question-answers owned by any of the provided users.
	OwnedBy *[]string `json:"owned_by,omitempty"`
}

// QuestionAnswersListResponseBody List question-answers response.
type QuestionAnswersListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// QuestionAnswers The question-answers entries matching the request.
	QuestionAnswers []QuestionAnswer `json:"question_answers"`

	// Total Total number of question-answer items for the request.
	Total int32 `json:"total"`
}

// QuestionAnswersUpdateRequest The request to update a question-answer.
type QuestionAnswersUpdateRequest struct {
	AccessLevel *AccessLevel `json:"access_level,omitempty"`

	// Answer Updated answer of the question-answer object, or unchanged if not
	// provided.
	Answer            *string                                        `json:"answer,omitempty"`
	AppliesToArticles *QuestionAnswersUpdateRequestAppliesToArticles `json:"applies_to_articles,omitempty"`
	AppliesToParts    *QuestionAnswersUpdateRequestAppliesToParts    `json:"applies_to_parts,omitempty"`

	// Id The question-answer's ID.
	Id      string                               `json:"id"`
	OwnedBy *QuestionAnswersUpdateRequestOwnedBy `json:"owned_by,omitempty"`

	// Question Updated question of the question-answer object, or unchanged if not
	// provided.
	Question   *string                                 `json:"question,omitempty"`
	SharedWith *QuestionAnswersUpdateRequestSharedWith `json:"shared_with,omitempty"`
	Sources    *QuestionAnswersUpdateRequestSources    `json:"sources,omitempty"`

	// Status Status of the question answer.
	Status *QuestionAnswerStatus `json:"status,omitempty"`

	// SuggestedAnswer Updated suggested_answer of the question-answer object, or
	// unchanged if not provided.
	SuggestedAnswer *string `json:"suggested_answer,omitempty"`

	// SuggestedForDeletion Updated suggested_for_deletion of the question-answer object, or
	// unchanged if not provided.
	SuggestedForDeletion *bool                             `json:"suggested_for_deletion,omitempty"`
	Tags                 *QuestionAnswersUpdateRequestTags `json:"tags,omitempty"`

	// Topic Updated topic of the question-answer object, or unchanged if not
	// provided.
	Topic *string `json:"topic,omitempty"`

	// Verified Updates whether the question-answer was verified by a user or not.
	Verified *bool `json:"verified,omitempty"`
}

// QuestionAnswersUpdateRequestAppliesToArticles defines model for question-answers-update-request-applies-to-articles.
type QuestionAnswersUpdateRequestAppliesToArticles struct {
	// Set Updates the article that the question-answer applies to.
	Set *[]string `json:"set,omitempty"`
}

// QuestionAnswersUpdateRequestAppliesToParts defines model for question-answers-update-request-applies-to-parts.
type QuestionAnswersUpdateRequestAppliesToParts struct {
	// Set Updates the parts that the question-answer applies to.
	Set *[]string `json:"set,omitempty"`
}

// QuestionAnswersUpdateRequestOwnedBy defines model for question-answers-update-request-owned-by.
type QuestionAnswersUpdateRequestOwnedBy struct {
	// Set Sets the owner IDs to the provided user IDs. This must not be
	// empty.
	Set *[]string `json:"set,omitempty"`
}

// QuestionAnswersUpdateRequestSharedWith defines model for question-answers-update-request-shared-with.
type QuestionAnswersUpdateRequestSharedWith struct {
	// Set Sets the field to the provided membership list.
	Set *[]SetSharedWithMembership `json:"set,omitempty"`
}

// QuestionAnswersUpdateRequestSources defines model for question-answers-update-request-sources.
type QuestionAnswersUpdateRequestSources struct {
	// Set Sets the sources that generated the question-answer.
	Set *[]string `json:"set,omitempty"`
}

// QuestionAnswersUpdateRequestTags defines model for question-answers-update-request-tags.
type QuestionAnswersUpdateRequestTags struct {
	// Set Sets the provided tags on the question-answer.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// QuestionAnswersUpdateResponseBody defines model for question-answers-update-response.
type QuestionAnswersUpdateResponseBody struct {
	QuestionAnswer QuestionAnswer `json:"question_answer"`
}

// ReactionsListRequest defines model for reactions-list-request.
type ReactionsListRequest struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided,
	// then iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Emoji The emoji to list the reactors for. This can be the short name of
	// the emoji (e.g. "joy"), or the code point (e.g. "1f602").
	Emoji string `json:"emoji"`

	// Limit The maximum number of reactors to return.
	Limit *int32 `json:"limit,omitempty"`

	// Object The ID of the object to list reactors for.
	Object string `json:"object"`
}

// ReactionsListResponseBody defines model for reactions-list-response.
type ReactionsListResponseBody struct {
	// NextCursor The cursor that should be used to iterate the next sequence of
	// results, otherwise if not set, then no elements exist after.
	NextCursor *string `json:"next_cursor,omitempty"`

	// Reactors The users that have reacted.
	Reactors []UserSummary `json:"reactors"`
}

// ReactionsUpdateRequest defines model for reactions-update-request.
type ReactionsUpdateRequest struct {
	Action ReactionsUpdateRequestAction `json:"action"`

	// Emoji The emoji for the reaction. This can be the short name of the emoji
	// (e.g. "joy"), or the code point (e.g. "1f602").
	Emoji string `json:"emoji"`

	// Object The object to update the reaction for.
	Object string `json:"object"`
}

// ReactionsUpdateRequestAction defines model for reactions-update-request-action.
type ReactionsUpdateRequestAction string

// ReactionsUpdateResponseBody defines model for reactions-update-response.
type ReactionsUpdateResponseBody = map[string]interface{}

// RecordTemplate defines model for record-template.
type RecordTemplate struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom Fields of the object that the record template is associated
	// with.
	CustomFields *[]RecordTemplateFieldValues `json:"custom_fields,omitempty"`

	// Description Description of the record template.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// LeafType Type of object that the record template is associated with.
	LeafType   *string      `json:"leaf_type,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Name of the record template.
	Name *string `json:"name,omitempty"`

	// SharedWith Shared with membership.
	SharedWith *[]SharedWithMembership `json:"shared_with,omitempty"`

	// State State of the record template.
	State *RecordTemplateState `json:"state,omitempty"`

	// StockFields Stock Fields of the object that the record template is associated
	// with.
	StockFields *[]RecordTemplateFieldValues `json:"stock_fields,omitempty"`

	// Subtype Subtype of the object that the record template is associated with.
	Subtype *string `json:"subtype,omitempty"`
}

// RecordTemplateFieldValues Information about the field values.
type RecordTemplateFieldValues struct {
	// FieldName The field's name.
	FieldName *string `json:"field_name,omitempty"`

	// FieldValue Value of the given field.
	FieldValue *interface{} `json:"field_value,omitempty"`
}

// RecordTemplateGetRequest defines model for record-template-get-request.
type RecordTemplateGetRequest struct {
	// Id The ID of the record template.
	Id string `json:"id"`
}

// RecordTemplateGetResponseBody defines model for record-template-get-response.
type RecordTemplateGetResponseBody struct {
	RecordTemplateInfo RecordTemplateInfo `json:"record_template_info"`
}

// RecordTemplateInfo defines model for record-template-info.
type RecordTemplateInfo struct {
	RecordTemplate RecordTemplate `json:"record_template"`

	// StaleFields List of fields that do not conform to the expected schema of the
	// underlying leaf type of the template object.
	StaleFields *[]RecordTemplateFieldValues `json:"stale_fields,omitempty"`
}

// RecordTemplateState State of the record template.
type RecordTemplateState string

// RemoveTagWithValue defines model for remove-tag-with-value.
type RemoveTagWithValue struct {
	// Id The ID of the tag.
	Id string `json:"id"`
}

// RemovedSlaMetricHistory Information about removed metrics.
type RemovedSlaMetricHistory struct {
	MetricDefinition MetricDefinitionSummary `json:"metric_definition"`

	// RemovedAt Timestamp when the metric was removed.
	RemovedAt time.Time   `json:"removed_at"`
	RemovedBy UserSummary `json:"removed_by"`
}

// Resource Resource details.
type Resource struct {
	// Artifacts Artifacts of the resource (relevant only for type artifact).
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Url URL of the resource (relevant only for type url).
	Url *string `json:"url,omitempty"`
}

// ResourceSummary Resource details.
type ResourceSummary struct {
	// Artifacts Artifacts of the resource (relevant only for type artifact).
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Url URL of the resource (relevant only for type url).
	Url *string `json:"url,omitempty"`
}

// RevOrg defines model for rev-org.
type RevOrg struct {
	Account *AccountSummary `json:"account,omitempty"`

	// Artifacts The artifacts attached to the Rev organization.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`
	CreatedBy *UserSummary       `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// Description Description of the Rev organization.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName Name of the Organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Domain Company's domain name. Example - 'devrev.ai'.
	// Deprecated:
	Domain *string `json:"domain,omitempty"`

	// ExternalRef External ref is a unique identifier for the Rev (customer)
	// organization from your primary customer system of records. If none
	// is specified, a system-generated identifier will be assigned to the
	// organization.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate  *time.Time  `json:"modified_date,omitempty"`
	PrimaryRevOrg *OrgSummary `json:"primary_rev_org,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// Tags Tags associated with an object.
	Tags *[]TagWithValue `json:"tags,omitempty"`
}

// RevOrgSummary defines model for rev-org-summary.
type RevOrgSummary = OrgBaseSummary

// RevOrgsCreateRequest Request object to create a new Rev organization in the Dev
// organization.
type RevOrgsCreateRequest struct {
	// Account Account Id to associate with this Rev organization.
	Account string `json:"account"`

	// Artifacts The IDs of the artifacts to associate with the Rev organization.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Schema fragment IDs associated with this Rev organization.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// Description Description of the Rev organization.
	Description *string `json:"description,omitempty"`

	// DisplayName Name of the Rev organization.
	DisplayName string `json:"display_name"`

	// Domain Company's domain name. Example - 'devrev.ai'.
	// Deprecated:
	Domain *string `json:"domain,omitempty"`

	// Environment The environment of the Org. Defaults to 'production' if not specified.
	Environment *OrgEnvironment `json:"environment,omitempty"`

	// ExternalRef External ref is a custom unique identifier which is a reference to
	// an unique id for this organization's data in some system of
	// records.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Tags Tags associated with the Rev organization.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Tier The tier of the RevOrg.
	Tier *string `json:"tier,omitempty"`
}

// RevOrgsCreateResponseBody Response object for request to create a new Rev organization.
type RevOrgsCreateResponseBody struct {
	RevOrg RevOrg `json:"rev_org"`
}

// RevOrgsDeleteRequest Request object to delete a Rev organization.
type RevOrgsDeleteRequest struct {
	// Id The ID of Rev organization to delete.
	Id string `json:"id"`
}

// RevOrgsDeleteResponseBody The response to deleting a Rev organization.
type RevOrgsDeleteResponseBody = map[string]interface{}

// RevOrgsGetRequest Request object to get Rev organization's information.
type RevOrgsGetRequest struct {
	// Account The ID of account for which default Rev organization is to be
	// fetched.
	Account *string `json:"account,omitempty"`

	// Id The ID of the required Rev organization.
	Id *string `json:"id,omitempty"`
}

// RevOrgsGetResponseBody The response to getting a Rev organization's information.
type RevOrgsGetResponseBody struct {
	RevOrg RevOrg `json:"rev_org"`
}

// RevOrgsListRequest A request to get the list of Rev organizations for the authenticated
// user's Dev organization.
type RevOrgsListRequest struct {
	// Account Filters by account.
	Account *[]string `json:"account,omitempty"`

	// CreatedBy Filters by creator.
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFieldFilter Filters on custom fields. Input will be of the format
	// (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
	CustomFieldFilter *[]string `json:"custom_field_filter,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// DisplayName Array of display names of Rev orgs to be filtered.
	DisplayName *[]string `json:"display_name,omitempty"`

	// ExternalRef List of external refs to filter Rev organizations for.
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// Limit The maximum number of Rev organizations to be retrieved per page.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// SortBy Fields to sort the Rev organizations by and the direction to sort
	// them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `json:"tags,omitempty"`
}

// RevOrgsListResponseBody The response to getting a list of Rev organizations' information.
type RevOrgsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// RevOrgs List with all of the Rev organizations' information.
	RevOrgs []RevOrg `json:"rev_orgs"`
}

// RevOrgsUpdateRequest Request object to update information of the Rev organization.
type RevOrgsUpdateRequest struct {
	// Account New account ID to associate with this Rev organization.
	// Deprecated:
	Account   *string                        `json:"account,omitempty"`
	Artifacts *RevOrgsUpdateRequestArtifacts `json:"artifacts,omitempty"`

	// CustomSchemaFragments Schema fragment IDs associated with this Rev organization.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// Description Description of the Rev organization.
	Description *string `json:"description,omitempty"`

	// DisplayName Customer chosen name for the Rev organization.
	DisplayName *string `json:"display_name,omitempty"`

	// Domain Company's domain name. Example - 'devrev.ai'.
	// Deprecated:
	Domain *string `json:"domain,omitempty"`

	// Environment The environment of the Org. Defaults to 'production' if not specified.
	Environment *OrgEnvironment `json:"environment,omitempty"`

	// ExternalRef External ref is a custom unique identifier which is a reference to
	// an unique id for this organization's data in some system of
	// records.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Id The ID of Rev organization to update.
	Id string `json:"id"`

	// Tags Tags associated with the Rev organization.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// Tier The tier of the RevOrg.
	Tier *string `json:"tier,omitempty"`
}

// RevOrgsUpdateRequestArtifacts defines model for rev-orgs-update-request-artifacts.
type RevOrgsUpdateRequestArtifacts struct {
	// Set Sets the IDs to the provided artifact IDs.
	Set *[]string `json:"set,omitempty"`
}

// RevOrgsUpdateResponseBody Response object to updating Rev organization's information.
type RevOrgsUpdateResponseBody struct {
	RevOrg RevOrg `json:"rev_org"`
}

// RevUser defines model for rev-user.
type RevUser struct {
	// Artifacts The artifacts attached to the Rev user.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`
	CreatedBy *UserSummary       `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// Description Description of the Rev user.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// ExternalRef External ref is a mutable unique identifier for a user within the
	// Rev organization from your primary customer record. If none is
	// available, a good alternative is the email address/phone number
	// which could uniquely identify the user. If none is specified, a
	// system-generated identifier will be assigned to the user.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalRefs External refs are mutable unique identifiers for a contact record.
	// If none are available, a good alternative is the email
	// address(es)/phone number(s) which could uniquely identify the
	// contact. If no identifier is specified, a system-generated
	// identifier will be assigned to the contact. For organizations with
	// multi-association contacts support enabled, this field accepts
	// multiple identifiers, where each identifier must be unique across
	// your DevOrg. For organizations without multi-association contacts
	// support, this field accepts a single identifier, maintaining
	// functionality consistent with the existing external_uid field.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsVerified Whether the Rev user is verified or not.
	IsVerified *bool        `json:"is_verified,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// PhoneNumbers Phone numbers of the user.
	PhoneNumbers    *[]string    `json:"phone_numbers,omitempty"`
	PrimaryIdentity *UserSummary `json:"primary_identity,omitempty"`
	RevOrg          *OrgSummary  `json:"rev_org,omitempty"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`
}

// RevUserAssociation Association of Rev users with Rev orgs or accounts. A Rev user can be
// associated with 0 or more accounts and Rev orgs. A Rev org association
// automatically adds an account association.
type RevUserAssociation struct {
	AssociatedTo *AssociatedToSummary `json:"associated_to,omitempty"`
}

// RevUserSummary defines model for rev-user-summary.
type RevUserSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// ExternalRef External ref is a mutable unique identifier for a user within the
	// Rev organization from your primary customer record. If none is
	// available, a good alternative is the email address/phone number
	// which could uniquely identify the user. If none is specified, a
	// system-generated identifier will be assigned to the user.
	ExternalRef *string `json:"external_ref,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id     string      `json:"id"`
	RevOrg *OrgSummary `json:"rev_org,omitempty"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`
}

// RevUsersAssociationsAddRequest Request to add associations of Rev users to Rev orgs or accounts. Rev
// org association automatically adds an account association.
type RevUsersAssociationsAddRequest struct {
	// Associations Associations of the Rev user to Rev orgs/accounts.
	Associations []CreateAssociation `json:"associations"`

	// RevUserId ID of the Rev user to associate to.
	RevUserId string `json:"rev_user_id"`
}

// RevUsersAssociationsAddResponseBody Response for adding associations to a Rev user.
type RevUsersAssociationsAddResponseBody = map[string]interface{}

// RevUsersAssociationsListRequest Gets the list of Rev user associations.
type RevUsersAssociationsListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of Associations to return per page. The default
	// is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// RevUserId The ID of Rev user to list all associations of.
	RevUserId string `json:"rev_user_id"`
}

// RevUsersAssociationsListResponseBody The response to listing all the associations of a Rev user.
type RevUsersAssociationsListResponseBody struct {
	// Associations The associations of a Rev user.
	Associations []RevUserAssociation `json:"associations"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`
}

// RevUsersAssociationsRemoveRequest Request to remove associations of a Rev user.
type RevUsersAssociationsRemoveRequest struct {
	// Associations Associations of the Rev user to remove.
	Associations []string `json:"associations"`

	// RevUserId ID of the Rev user whose associations are to be removed.
	RevUserId string `json:"rev_user_id"`
}

// RevUsersAssociationsRemoveResponseBody Response for removing associations from a Rev user.
type RevUsersAssociationsRemoveResponseBody = map[string]interface{}

// RevUsersCreateRequest Request object to create a new Rev user for a Rev organization.
type RevUsersCreateRequest struct {
	// Account The ID of the account to which the created Rev user is associated.
	Account *string `json:"account,omitempty"`

	// Artifacts The IDs of the artifacts to associate with the Rev user.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments The schema fragment IDs associated with the Rev user.
	// Deprecated:
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description Description of the Rev user.
	Description *string `json:"description,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName *string `json:"display_name,omitempty"`

	// DisplayPicture Artifact ID of a Rev user's display picture.
	DisplayPicture *string `json:"display_picture,omitempty"`

	// Email Email address of the Rev user.
	Email *string `json:"email,omitempty"`

	// ExternalRef External ref is a mutable unique identifier for a user within the
	// Dev organization from your primary customer record. If none is
	// available, a good alternative is the email address/phone number
	// which could uniquely identify the user. If none is specified, a
	// system-generated identifier will be assigned to the user.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalRefs External refs are mutable unique identifiers for a contact record.
	// If none are available, a good alternative is the email
	// address(es)/phone number(s) which could uniquely identify the
	// contact. If no identifier is specified, a system-generated
	// identifier will be assigned to the contact. For organizations with
	// multi-association contacts support enabled, this field accepts
	// multiple identifiers, where each identifier must be unique across
	// your DevOrg. For organizations without multi-association contacts
	// support, this field accepts a single identifier, maintaining
	// functionality consistent with the existing external_uid field.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// PhoneNumbers Phone numbers, in E.164 format, of the Rev user.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`

	// RevOrg The ID of the Rev organization to which the created Rev user is
	// associated.
	RevOrg *string `json:"rev_org,omitempty"`

	// Tags Tags associated with the Rev user.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`
}

// RevUsersCreateResponseBody Response object for creating a new Rev user for Rev organization.
type RevUsersCreateResponseBody struct {
	RevUser RevUser `json:"rev_user"`
}

// RevUsersDeleteRequest Request object to delete a Rev user.
type RevUsersDeleteRequest struct {
	// Id The ID of Rev user to delete.
	Id string `json:"id"`
}

// RevUsersDeleteResponseBody The response to deleting a Rev user of a Rev organization.
type RevUsersDeleteResponseBody = map[string]interface{}

// RevUsersGetRequest Request object to get a Rev user.
type RevUsersGetRequest struct {
	// Id The ID of Rev user to be retrieved.
	Id string `json:"id"`
}

// RevUsersGetResponseBody The returned Rev user.
type RevUsersGetResponseBody struct {
	RevUser RevUser `json:"rev_user"`
}

// RevUsersListRequest Gets the list of Rev users belonging to the authenticated user's Dev
// organization which the user is also authorized to access.
type RevUsersListRequest struct {
	// Associations Filters for Rev users with specified associations
	// (account/workspace).
	Associations *[]string `json:"associations,omitempty"`

	// CreatedBy Filters for Rev users that were created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Email List of emails of Rev users to be filtered.
	Email *[]string `json:"email,omitempty"`

	// ExternalRef List of external refs to filter Rev users for.
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// ExternalRefs Filters for Rev users with the provided external_refs.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// IsVerified Value of is_verified field to filter the Rev users.
	IsVerified *bool `json:"is_verified,omitempty"`

	// Limit The maximum number of Rev users to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// PhoneNumbers List of phone numbers, in E.164 format, to filter Rev users on.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`

	// RevOrg List of IDs of Rev organizations to be filtered.
	RevOrg *[]string `json:"rev_org,omitempty"`

	// SortBy Fields to sort the Rev users by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `json:"tags,omitempty"`
}

// RevUsersListResponseBody The response to listing all Rev users matching the filter criteria.
type RevUsersListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// RevUsers List containing all the Rev users.
	RevUsers []RevUser `json:"rev_users"`
}

// RevUsersMergeRequest Request to merge two Rev users, retaining the primary user.
type RevUsersMergeRequest struct {
	// PrimaryUser The ID of the primary Rev user, which will be retained.
	PrimaryUser string `json:"primary_user"`

	// SecondaryUser The ID of the secondary Rev user, which will be merged into the
	// Primary Rev user.
	SecondaryUser string `json:"secondary_user"`
}

// RevUsersMergeResponseBody Acknowledgment response indicating that the merge request has been
// received for processing asynchronously.
type RevUsersMergeResponseBody = map[string]interface{}

// RevUsersScanRequest Scans the list of Rev users.
type RevUsersScanRequest struct {
	// Associations Filters for Rev users with specified associations
	// (account/workspace).
	Associations *[]string `json:"associations,omitempty"`

	// CreatedBy Filters for Rev users that were created by the specified user(s).
	CreatedBy   *[]string       `json:"created_by,omitempty"`
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration, otherwise the beginning if not
	// provided.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Email List of emails of Rev users to be filtered.
	Email *[]string `json:"email,omitempty"`

	// ExternalRef List of external refs to filter Rev users for.
	ExternalRef *[]string `json:"external_ref,omitempty"`

	// ExternalRefs Filters for Rev users with the provided external_refs.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// IsVerified Value of is_verified field to filter the Rev users.
	IsVerified   *bool           `json:"is_verified,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// PhoneNumbers List of phone numbers, in E.164 format, to filter Rev users on.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`

	// RevOrg List of IDs of Rev organizations to be filtered.
	RevOrg *[]string `json:"rev_org,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `json:"tags,omitempty"`
}

// RevUsersScanResponseBody The response to scanning Rev users.
type RevUsersScanResponseBody struct {
	// NextCursor The cursor that should be used to resume iteration, otherwise if
	// not provided, then iteration has completed.
	NextCursor *string `json:"next_cursor,omitempty"`

	// RevUsers The iterated Rev users.
	RevUsers []RevUser `json:"rev_users"`
}

// RevUsersUpdateRequest Request to update details of a Rev user.
type RevUsersUpdateRequest struct {
	Artifacts *RevUsersUpdateRequestArtifacts `json:"artifacts,omitempty"`

	// CustomFields Application-defined custom fields.
	CustomFields          *map[string]interface{}                     `json:"custom_fields,omitempty"`
	CustomSchemaFragments *RevUsersUpdateRequestCustomSchemaFragments `json:"custom_schema_fragments,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Description Updated description of the Rev user.
	Description *string `json:"description,omitempty"`

	// DisplayName Updated display name of the Rev user.
	DisplayName *string `json:"display_name,omitempty"`

	// DisplayPicture Artifact ID of a Rev user's updated display picture.
	DisplayPicture *string `json:"display_picture"`

	// Email Updated email address of the Rev user.
	Email *string `json:"email,omitempty"`

	// ExternalRef Updated external ref value of the Rev user.
	ExternalRef *string `json:"external_ref,omitempty"`

	// ExternalRefs External refs are mutable unique identifiers for a contact record.
	// If none are available, a good alternative is the email
	// address(es)/phone number(s) which could uniquely identify the
	// contact. If no identifier is specified, a system-generated
	// identifier will be assigned to the contact. For organizations with
	// multi-association contacts support enabled, this field accepts
	// multiple identifiers, where each identifier must be unique across
	// your DevOrg. For organizations without multi-association contacts
	// support, this field accepts a single identifier, maintaining
	// functionality consistent with the existing external_uid field.
	ExternalRefs *[]string `json:"external_refs,omitempty"`

	// Id The ID of Rev user to update.
	Id string `json:"id"`

	// PhoneNumbers The phone numbers, in E.164 format, of the Rev user.
	PhoneNumbers *[]string `json:"phone_numbers,omitempty"`

	// Tags Tags associated with the Rev user.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`
}

// RevUsersUpdateRequestArtifacts defines model for rev-users-update-request-artifacts.
type RevUsersUpdateRequestArtifacts struct {
	// Set Sets the IDs to the provided artifact IDs.
	Set *[]string `json:"set,omitempty"`
}

// RevUsersUpdateRequestCustomSchemaFragments defines model for rev-users-update-request-custom-schema-fragments.
type RevUsersUpdateRequestCustomSchemaFragments struct {
	// Set Sets the IDs to the provided schema fragment IDs.
	Set *[]string `json:"set,omitempty"`
}

// RevUsersUpdateResponseBody Updated Rev user object.
type RevUsersUpdateResponseBody struct {
	RevUser RevUser `json:"rev_user"`
}

// RichTextWidgetVisualization The configuration for a rich text visualization.
type RichTextWidgetVisualization struct {
	// Content The content of the rich text.
	Content *map[string]interface{} `json:"content,omitempty"`
}

// Role defines model for role.
type Role struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`
}

// RolePrivileges Privileges the role provides.
type RolePrivileges string

// RoleSummary defines model for role-summary.
type RoleSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`
}

// RoleTarget Target object type of the role.
type RoleTarget string

// RolesApplyRequest A request to apply (assign or revoke) roles of a principal.
type RolesApplyRequest struct {
	// Assign Roles to be additionally assigned to principal.
	Assign *[]string `json:"assign,omitempty"`

	// Principal The ID of the principal.
	Principal string `json:"principal"`
}

// RolesApplyResponseBody The response to roles apply.
type RolesApplyResponseBody = map[string]interface{}

// RolesCreateRequest A request to create a new role.
type RolesCreateRequest struct {
	// Description The description of the role.
	Description *string `json:"description,omitempty"`

	// IncludeAllSubtypes Whether to include all subtypes of the leaf type as target of the
	// role.
	IncludeAllSubtypes *bool `json:"include_all_subtypes,omitempty"`

	// Name The name of the role.
	Name *string `json:"name,omitempty"`

	// Privileges The privileges the role provides on target.
	Privileges *[]RolePrivileges `json:"privileges,omitempty"`

	// Target Target object type of the role.
	Target RoleTarget `json:"target"`

	// TargetSubtype The subtype of the target.
	TargetSubtype *string `json:"target_subtype,omitempty"`
}

// RolesCreateResponseBody A response to a request to create a new role.
type RolesCreateResponseBody struct {
	Role Role `json:"role"`
}

// Runnable defines model for runnable.
type Runnable = PartBase

// RunnableSummary defines model for runnable-summary.
type RunnableSummary = PartBaseSummary

// SamlConnectionFieldsMap defines model for saml-connection-fields-map.
type SamlConnectionFieldsMap struct {
	// Email Claims in the SAML assertion returned by the identity provider that
	// map to the email address of the user.
	Email *string `json:"email,omitempty"`

	// UserId Claims in the SAML assertion returned by the identity provider that
	// map to the user ID of the user.
	UserId *string `json:"user_id,omitempty"`
}

// ScatterVisualizationXAxis The X-axis for a scatter visualization.
type ScatterVisualizationXAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// ScatterVisualizationYAxis The Y-axis for a scatter visualization.
type ScatterVisualizationYAxis struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`
}

// ScatterWidgetVisualization A Scatter chart visualization configuration. Includes metadata specific
// to scatter charts.
type ScatterWidgetVisualization struct {
	// X The configuration for the X-axis.
	X []ScatterVisualizationXAxis `json:"x"`

	// Y The configuration for the Y-axes.
	Y []ScatterVisualizationYAxis `json:"y"`
}

// SchemaBoolFieldDescriptor defines model for schema-bool-field-descriptor.
type SchemaBoolFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *bool `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaBoolListFieldDescriptor defines model for schema-bool-list-field-descriptor.
type SchemaBoolListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]bool `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaCompositeFieldDescriptor defines model for schema-composite-field-descriptor.
type SchemaCompositeFieldDescriptor struct {
	// CompositeType Composite type. Required when field type is composite.
	CompositeType *string `json:"composite_type,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaCompositeListFieldDescriptor defines model for schema-composite-list-field-descriptor.
type SchemaCompositeListFieldDescriptor struct {
	// CompositeType Composite type. Required when field type is composite.
	CompositeType *string `json:"composite_type,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaDateFieldDescriptor defines model for schema-date-field-descriptor.
type SchemaDateFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaDateListFieldDescriptor defines model for schema-date-list-field-descriptor.
type SchemaDateListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaDoubleFieldDescriptor defines model for schema-double-field-descriptor.
type SchemaDoubleFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *float64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaDoubleListFieldDescriptor defines model for schema-double-list-field-descriptor.
type SchemaDoubleListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]float64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaEnumFieldDescriptor defines model for schema-enum-field-descriptor.
type SchemaEnumFieldDescriptor struct {
	// AllowedValues Allowed values for the field.
	AllowedValues []string `json:"allowed_values"`

	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsOverridable Whether the enum is overridable.
	IsOverridable *bool `json:"is_overridable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// TranslatedValues Translations for allowed_values field.
	TranslatedValues *map[string]string `json:"translated_values,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaEnumListFieldDescriptor defines model for schema-enum-list-field-descriptor.
type SchemaEnumListFieldDescriptor struct {
	// AllowedValues Allowed values for the field.
	AllowedValues []string `json:"allowed_values"`

	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsOverridable Whether the enum is overridable.
	IsOverridable *bool `json:"is_overridable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// TranslatedValues Translations for allowed_values field.
	TranslatedValues *map[string]string `json:"translated_values,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaFieldCreateViewUiMetadata Create view UI hint overrides.
type SchemaFieldCreateViewUiMetadata struct {
	// IsHidden Whether field is hidden in the UI create view.
	IsHidden *bool `json:"is_hidden,omitempty"`
}

// SchemaFieldDescriptor Set of field attributes.
type SchemaFieldDescriptor struct {
	FieldType SchemaFieldDescriptorFieldType `json:"field_type"`
	union     json.RawMessage
}

// SchemaFieldDescriptorArrayType defines model for schema-field-descriptor-array-type.
type SchemaFieldDescriptorArrayType struct {
	BaseType SchemaFieldDescriptorArrayTypeBaseType `json:"base_type"`

	// EqItems The exact array length.
	EqItems *int64 `json:"eq_items,omitempty"`

	// MaxItems The maximum array length.
	MaxItems *int64 `json:"max_items,omitempty"`

	// MinItems The minimum array length.
	MinItems *int64 `json:"min_items,omitempty"`
	union    json.RawMessage
}

// SchemaFieldDescriptorArrayTypeBaseType defines model for schema-field-descriptor-array-type-base-type.
type SchemaFieldDescriptorArrayTypeBaseType string

// SchemaFieldDescriptorBase defines model for schema-field-descriptor-base.
type SchemaFieldDescriptorBase struct {
	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaFieldDescriptorFieldType defines model for schema-field-descriptor-field-type.
type SchemaFieldDescriptorFieldType string

// SchemaFieldDetailViewUiMetadata Detail view UI hint overrides.
type SchemaFieldDetailViewUiMetadata struct {
	// IsHidden Whether the field is hidden in the UI detail view.
	IsHidden *bool `json:"is_hidden,omitempty"`
}

// SchemaFieldFilterViewUiMetadata Filter view UI hint overrides.
type SchemaFieldFilterViewUiMetadata struct {
	// IsHidden Whether field is hidden in the UI filter view.
	IsHidden *bool `json:"is_hidden,omitempty"`
}

// SchemaFieldListViewUiMetadata List view UI hint overrides.
type SchemaFieldListViewUiMetadata struct {
	// IsHidden Whether the field is hidden in the UI list view.
	IsHidden *bool `json:"is_hidden,omitempty"`
}

// SchemaFieldMfzMetadata The schema of MFZ specific fields.
type SchemaFieldMfzMetadata = map[string]interface{}

// SchemaFieldOasisMetadata The schema of oasis specific fields.
type SchemaFieldOasisMetadata = map[string]interface{}

// SchemaFieldSummaryViewUiMetadata Summary view UI hint overrides.
type SchemaFieldSummaryViewUiMetadata struct {
	// IsHidden Whether field is hidden in the UI summary view.
	IsHidden *bool `json:"is_hidden,omitempty"`
}

// SchemaFieldUenumValue A unified enum value.
type SchemaFieldUenumValue struct {
	// Id The immutable id of the enum value.
	Id int64 `json:"id"`

	// IsDeprecated True if this value is deprecated.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// Label The human readable name of the enum value.
	Label string `json:"label"`

	// Ordinal The order value of the enum.
	Ordinal int64 `json:"ordinal"`

	// Tooltip Tooltip shown in the UI for this value.
	Tooltip *string `json:"tooltip,omitempty"`
}

// SchemaFieldUiMetadata The schema of ui specific fields.
type SchemaFieldUiMetadata struct {
	// ClientOverrides The client overrides for the field.
	ClientOverrides *[]ClientOverride `json:"client_overrides,omitempty"`

	// CreateView Create view UI hint overrides.
	CreateView *SchemaFieldCreateViewUiMetadata `json:"create_view,omitempty"`

	// DetailView Detail view UI hint overrides.
	DetailView *SchemaFieldDetailViewUiMetadata `json:"detail_view,omitempty"`

	// DisplayName The display name of the field.
	DisplayName *string `json:"display_name,omitempty"`

	// FilterView Filter view UI hint overrides.
	FilterView *SchemaFieldFilterViewUiMetadata `json:"filter_view,omitempty"`

	// GroupName An optional group name for the field.
	GroupName *string `json:"group_name,omitempty"`

	// IsActiveInDetailView Whether the field is active in the UI detail view.
	IsActiveInDetailView *bool `json:"is_active_in_detail_view,omitempty"`

	// IsBulkActionEnabled Whether the field supports bulk action.
	IsBulkActionEnabled *bool `json:"is_bulk_action_enabled,omitempty"`

	// IsCurrencyField Indicates if the field holds a currency value in USD.
	IsCurrencyField *bool `json:"is_currency_field,omitempty"`

	// IsGroupable Whether the field is groupable in the UI.
	IsGroupable *bool `json:"is_groupable,omitempty"`

	// IsHidden Whether the field is hidden in the UI.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsHiddenDuringCreate Whether the field is hidden in the UI during creation.
	IsHiddenDuringCreate *bool `json:"is_hidden_during_create,omitempty"`

	// IsReadOnly Whether the field is read-only in the UI.
	IsReadOnly *bool `json:"is_read_only,omitempty"`

	// IsRequired Whether the field is mandatory in the UI.
	IsRequired *bool `json:"is_required,omitempty"`

	// IsShownInSummary Whether the field is shown in the UI summary view.
	IsShownInSummary *bool `json:"is_shown_in_summary,omitempty"`

	// IsSortable Whether the field is sortable in the UI.
	IsSortable *bool `json:"is_sortable,omitempty"`

	// ListView List view UI hint overrides.
	ListView *SchemaFieldListViewUiMetadata `json:"list_view,omitempty"`

	// Order Order in which field is shown.
	Order *int32 `json:"order,omitempty"`

	// Placeholder A placeholder for the field.
	Placeholder *string `json:"placeholder,omitempty"`

	// SummaryView Summary view UI hint overrides.
	SummaryView *SchemaFieldSummaryViewUiMetadata `json:"summary_view,omitempty"`

	// Tooltip Tooltip for the field.
	Tooltip *string `json:"tooltip,omitempty"`

	// Unit Unit of measurment.
	Unit *string `json:"unit,omitempty"`
}

// SchemaIdFieldDescriptor defines model for schema-id-field-descriptor.
type SchemaIdFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IdType Object ID types. Required when field type is ID.
	IdType *[]string `json:"id_type,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaIdListFieldDescriptor defines model for schema-id-list-field-descriptor.
type SchemaIdListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IdType Object ID types. Required when field type is ID.
	IdType *[]string `json:"id_type,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaIntFieldDescriptor defines model for schema-int-field-descriptor.
type SchemaIntFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *int64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// Gt The minimum value for the integer (exclusive).
	Gt *int64 `json:"gt,omitempty"`

	// Gte The minimum value for the integer (inclusive).
	Gte *int64 `json:"gte,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Lt The maximum value for the integer (exclusive).
	Lt *int64 `json:"lt,omitempty"`

	// Lte The maximum value for the integer (inclusive).
	Lte *int64 `json:"lte,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaIntListFieldDescriptor defines model for schema-int-list-field-descriptor.
type SchemaIntListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]int64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// Gt The minimum value for the integer (exclusive).
	Gt *int64 `json:"gt,omitempty"`

	// Gte The minimum value for the integer (inclusive).
	Gte *int64 `json:"gte,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Lt The maximum value for the integer (exclusive).
	Lt *int64 `json:"lt,omitempty"`

	// Lte The maximum value for the integer (inclusive).
	Lte *int64 `json:"lte,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaJsonValueFieldDescriptor defines model for schema-json-value-field-descriptor.
type SchemaJsonValueFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *interface{} `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaJsonValueListFieldDescriptor defines model for schema-json-value-list-field-descriptor.
type SchemaJsonValueListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]interface{} `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaRichTextFieldDescriptor defines model for schema-rich-text-field-descriptor.
type SchemaRichTextFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaRichTextListFieldDescriptor defines model for schema-rich-text-list-field-descriptor.
type SchemaRichTextListFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaStructFieldDescriptor defines model for schema-struct-field-descriptor.
type SchemaStructFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *map[string]interface{} `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaStructListFieldDescriptor defines model for schema-struct-list-field-descriptor.
type SchemaStructListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]map[string]interface{} `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTextFieldDescriptor defines model for schema-text-field-descriptor.
type SchemaTextFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTextListFieldDescriptor defines model for schema-text-list-field-descriptor.
type SchemaTextListFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTimestampFieldDescriptor defines model for schema-timestamp-field-descriptor.
type SchemaTimestampFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTimestampListFieldDescriptor defines model for schema-timestamp-list-field-descriptor.
type SchemaTimestampListFieldDescriptor struct {
	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTokensFieldDescriptor defines model for schema-tokens-field-descriptor.
type SchemaTokensFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaTokensListFieldDescriptor defines model for schema-tokens-list-field-descriptor.
type SchemaTokensListFieldDescriptor struct {
	// Contains The contained substring.
	Contains *string `json:"contains,omitempty"`

	// DefaultValue Default value.
	DefaultValue *[]string `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// EqLen The exact string length.
	EqLen *int64 `json:"eq_len,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// MaxLen The maximum string length.
	MaxLen *int64 `json:"max_len,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// MinLen The minimum string length.
	MinLen *int64 `json:"min_len,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Pattern The string pattern (regular expression).
	Pattern *string `json:"pattern,omitempty"`

	// Prefix The string prefix.
	Prefix *string `json:"prefix,omitempty"`

	// Suffix The string suffix.
	Suffix *string `json:"suffix,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaUenumFieldDescriptor defines model for schema-uenum-field-descriptor.
type SchemaUenumFieldDescriptor struct {
	// AllowedValues Allowed values for the field.
	AllowedValues []SchemaFieldUenumValue `json:"allowed_values"`

	// DefaultValue Default value.
	DefaultValue *int64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaUenumListFieldDescriptor defines model for schema-uenum-list-field-descriptor.
type SchemaUenumListFieldDescriptor struct {
	// AllowedValues Allowed values for the field.
	AllowedValues []SchemaFieldUenumValue `json:"allowed_values"`

	// DefaultValue Default value.
	DefaultValue *[]int64 `json:"default_value,omitempty"`

	// Description Description of the field.
	Description *string `json:"description,omitempty"`

	// IsFilterable Whether this field is filterable, groupable and sortable.
	IsFilterable *bool `json:"is_filterable,omitempty"`

	// IsImmutable Whether this field is immutable or not.
	IsImmutable *bool `json:"is_immutable,omitempty"`

	// IsPii Whether this field can hold Personally Identifiable Information
	// (PII).
	IsPii *bool `json:"is_pii,omitempty"`

	// IsRequired Whether this field is required or not.
	IsRequired *bool `json:"is_required,omitempty"`

	// Mfz The schema of MFZ specific fields.
	Mfz *SchemaFieldMfzMetadata `json:"mfz,omitempty"`

	// Name Name of the field.
	Name string `json:"name"`

	// Oasis The schema of oasis specific fields.
	Oasis *SchemaFieldOasisMetadata `json:"oasis,omitempty"`

	// Origin Type this field is from.
	Origin *string `json:"origin,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// SchemaUnknownFieldDescriptor defines model for schema-unknown-field-descriptor.
type SchemaUnknownFieldDescriptor = SchemaFieldDescriptorBase

// SchemasSubtypePrepareUpdateGetRequest defines model for schemas-subtype-prepare-update-get-request.
type SchemasSubtypePrepareUpdateGetRequest struct {
	// IsCustomLeafType Whether the leaf type corresponds to a custom object.
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// LeafType Leaf type of the object.
	LeafType string `json:"leaf_type"`

	// NewSubtype Name of the new subtype for the object.
	NewSubtype *string `json:"new_subtype,omitempty"`

	// Object ID of the object of which subtype is to be changed. Used to fetch
	// the object's custom schema fragments and custom fields
	Object *string `json:"object,omitempty"`
}

// SchemasSubtypePrepareUpdateGetResponseBody defines model for schemas-subtype-prepare-update-get-response.
type SchemasSubtypePrepareUpdateGetResponseBody struct {
	// AddedFields List of fields that have a default value and need to be set.
	AddedFields *[]SchemasSubtypePrepareUpdateGetResponseAddedField `json:"added_fields,omitempty"`

	// DroppedFields List of fields that will be dropped from the object.
	DroppedFields *[]SchemasSubtypePrepareUpdateGetResponseDroppedField `json:"dropped_fields,omitempty"`

	// NewCustomSchemaFragments List of new custom schema fragment IDs of the object.
	NewCustomSchemaFragments *[]string `json:"new_custom_schema_fragments,omitempty"`

	// NewStartStage ID of the start stage of the new diagram if the subtype change
	// results in a change in the stage diagram.
	NewStartStage *string `json:"new_start_stage,omitempty"`
}

// SchemasSubtypePrepareUpdateGetResponseAddedField defines model for schemas-subtype-prepare-update-get-response-added-field.
type SchemasSubtypePrepareUpdateGetResponseAddedField struct {
	// DefaultValue Default value of the added field.
	DefaultValue *interface{} `json:"default_value,omitempty"`

	// Name API-compliant qualified name of the added field.
	Name string `json:"name"`
}

// SchemasSubtypePrepareUpdateGetResponseConflictType defines model for schemas-subtype-prepare-update-get-response-conflict-type.
type SchemasSubtypePrepareUpdateGetResponseConflictType string

// SchemasSubtypePrepareUpdateGetResponseDroppedField defines model for schemas-subtype-prepare-update-get-response-dropped-field.
type SchemasSubtypePrepareUpdateGetResponseDroppedField struct {
	ConflictType SchemasSubtypePrepareUpdateGetResponseConflictType `json:"conflict_type"`

	// Message Conflict message for the field being dropped.
	Message string `json:"message"`

	// Name API-compliant qualified name of the dropped field.
	Name string `json:"name"`
}

// SearchCoreRequest Search request.
type SearchCoreRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of items to return in a page. The default is
	// '10'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Namespaces The namespaces to search in.
	Namespaces *[]SearchNamespace `json:"namespaces,omitempty"`

	// Query The query string. Search query language:
	// https://docs.devrev.ai/product/search#fields
	Query string `json:"query"`

	// SortBy Search sort by parameters.
	SortBy *SearchSortByParam `json:"sort_by,omitempty"`

	// SortOrder Search sort order parameters.
	SortOrder *SearchSortOrderParam `json:"sort_order,omitempty"`
}

// SearchCoreResponseBody Search response.
type SearchCoreResponseBody struct {
	// Cursor The cursor from where to begin iteration. Start from beginning if
	// not provided.
	Cursor *string `json:"cursor,omitempty"`

	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Results The search results.
	Results []SearchResult `json:"results"`
}

// SearchHybridNamespace The namespaces for hybrid search.
type SearchHybridNamespace string

// SearchHybridRequest Request for search with exact, prefix and infix matches.
type SearchHybridRequest struct {
	// Limit The maximum number of items to return in a page. The default is
	// '10'.
	Limit *int32 `json:"limit,omitempty"`

	// Namespace The namespaces for hybrid search.
	Namespace SearchHybridNamespace `json:"namespace"`

	// Query The query string.
	Query string `json:"query"`

	// SemanticWeight The weightage for semantic search. Values between 0 and 1 are
	// accepted.
	SemanticWeight *float32 `json:"semantic_weight,omitempty"`
}

// SearchHybridResponseBody Hybrid search response.
type SearchHybridResponseBody struct {
	// Results The search results.
	Results []SearchResult `json:"results"`
}

// SearchNamespace The namespaces to search in.
type SearchNamespace string

// SearchResult defines model for search-result.
type SearchResult struct {
	Type  SearchResultType `json:"type"`
	union json.RawMessage
}

// SearchResultType defines model for search-result-type.
type SearchResultType string

// SearchSortByParam Search sort by parameters.
type SearchSortByParam string

// SearchSortOrderParam Search sort order parameters.
type SearchSortOrderParam string

// SearchSummaryBase defines model for search-summary-base.
type SearchSummaryBase struct {
	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`
}

// SendNotification defines model for send-notification.
type SendNotification struct {
	// Parent The ID of the parent object associated with the notification.
	Parent *string `json:"parent,omitempty"`

	// Receiver The ID of the user for whom the notification was generated.
	Receiver string `json:"receiver"`

	// Timestamp Timestamp of the event that triggered the notification.
	Timestamp *time.Time           `json:"timestamp,omitempty"`
	Type      SendNotificationType `json:"type"`
	union     json.RawMessage
}

// SendNotificationGenericNotificationEntry defines model for send-notification-generic-notification-entry.
type SendNotificationGenericNotificationEntry struct {
	// EventId ID used to group notifications in the inbox for the same parent.
	EventId *string `json:"event_id,omitempty"`

	// EventType Event type of the notification.
	EventType GenericNotificationEventType `json:"event_type"`

	// Metadata Metadata for the objects that triggered the notification.
	Metadata []SendNotificationGenericNotificationEntryMetadata `json:"metadata"`
}

// SendNotificationGenericNotificationEntryMetadata defines model for send-notification-generic-notification-entry-metadata.
type SendNotificationGenericNotificationEntryMetadata struct {
	Action *SendNotificationGenericNotificationEntryNotificationAction `json:"action,omitempty"`

	// ContentTemplate The ID of the content template for the content of the notification.
	ContentTemplate string `json:"content_template"`

	// Inputs Inputs required for the template.
	Inputs *map[string]interface{} `json:"inputs,omitempty"`
}

// SendNotificationGenericNotificationEntryNotificationAction defines model for send-notification-generic-notification-entry-notification-action.
type SendNotificationGenericNotificationEntryNotificationAction struct {
	ClickableAction *SendNotificationGenericNotificationEntryNotificationActionClickableAction `json:"clickable_action,omitempty"`
	Type            *SendNotificationGenericNotificationEntryNotificationActionType            `json:"type,omitempty"`
}

// SendNotificationGenericNotificationEntryNotificationActionType defines model for SendNotificationGenericNotificationEntryNotificationAction.Type.
type SendNotificationGenericNotificationEntryNotificationActionType string

// SendNotificationGenericNotificationEntryNotificationActionClickableAction defines model for send-notification-generic-notification-entry-notification-action-clickable-action.
type SendNotificationGenericNotificationEntryNotificationActionClickableAction struct {
	// Object The ID of the object that the notification should redirect the user
	// to when selected.
	Object *string                                                                        `json:"object,omitempty"`
	Type   *SendNotificationGenericNotificationEntryNotificationActionClickableActionType `json:"type,omitempty"`

	// Url The URL to redirect the user to.
	Url *string `json:"url,omitempty"`
}

// SendNotificationGenericNotificationEntryNotificationActionClickableActionType defines model for SendNotificationGenericNotificationEntryNotificationActionClickableAction.Type.
type SendNotificationGenericNotificationEntryNotificationActionClickableActionType string

// SendNotificationType defines model for send-notification-type.
type SendNotificationType string

// ServiceAccount defines model for service-account.
type ServiceAccount = UserBase

// ServiceAccountSummary defines model for service-account-summary.
type ServiceAccountSummary = UserBaseSummary

// ServiceAccountsCreateRequest The request object to create a new service account.
type ServiceAccountsCreateRequest struct {
	// DisplayName The service account's display name. A unique, human readable name
	// to identify a service account.
	DisplayName string `json:"display_name"`

	// GenKeyring Indicates whether to generate a keyring along with the new service
	// account. The default is false.
	GenKeyring *bool `json:"gen_keyring,omitempty"`
}

// ServiceAccountsCreateResponseBody The response object to the corresponding create service account
// request.
type ServiceAccountsCreateResponseBody struct {
	ServiceAccount ServiceAccount `json:"service_account"`
}

// ServiceAccountsGetRequest The request object to get a service account's information.
type ServiceAccountsGetRequest struct {
	// Id The ID of the requested service account.
	Id string `json:"id"`
}

// ServiceAccountsGetResponseBody The response object that carries the service account's information
// corresponding to the request.
type ServiceAccountsGetResponseBody struct {
	ServiceAccount ServiceAccount `json:"service_account"`
}

// ServiceAccountsUpdateRequest The request object to update a service account.
type ServiceAccountsUpdateRequest struct {
	// DisplayName The service account's display name to be updated. A unique, human
	// readable name to identify a service account.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The ID of the requested service account.
	Id string `json:"id"`
}

// ServiceAccountsUpdateResponseBody The response object that carries the updated service account's
// information.
type ServiceAccountsUpdateResponseBody struct {
	ServiceAccount ServiceAccount `json:"service_account"`
}

// SetIssueSelector defines model for set-issue-selector.
type SetIssueSelector struct {
	// CustomFields Custom fields on the issue with their fully qualified names and the
	// associated with their exact allowed values. The SLA policy applies
	// to issues where all named custom fields have exactly the specified
	// values.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Owners The SLA policy applies to the issues of these owners.
	Owners *[]string `json:"owners,omitempty"`

	// Parts The SLA policy applies to the issues of these parts.
	Parts *[]string `json:"parts,omitempty"`

	// RevOrgs The SLA policy applies to the issues of these revorgs.
	RevOrgs *[]string `json:"rev_orgs,omitempty"`

	// StageName The SLA policy applies to issues with these stages.
	StageName *[]string `json:"stage_name,omitempty"`

	// Subtype The issue subtype for which the SLA policy applies.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags The SLA policy applies to issues with these tags. If empty, the tag
	// filter isn't applied.
	Tags *[]string `json:"tags,omitempty"`
}

// SetMoney The money value to create.
type SetMoney struct {
	// Amount The amount.
	Amount string `json:"amount"`

	// Currency The currency code conforming ISO 4217 standard.
	Currency string `json:"currency"`
}

// SetOrgScheduleFragmentSummary defines model for set-org-schedule-fragment-summary.
type SetOrgScheduleFragmentSummary struct {
	// Id Organization schedule fragment ID.
	Id string `json:"id"`
}

// SetSharedWithMembership Information about the role the member receives due to the share.
type SetSharedWithMembership struct {
	// Member ID of the member the object is shared with.
	Member *string `json:"member,omitempty"`

	// Role ID of the role that describes what privileges the membership
	// entails.
	Role *string `json:"role,omitempty"`
}

// SetSlaPolicy defines model for set-sla-policy.
type SetSlaPolicy struct {
	// Metrics Metrics to apply to the selected items.
	Metrics *[]SetSupportMetricTarget `json:"metrics,omitempty"`

	// Name Human-readable name.
	Name     string         `json:"name"`
	Selector SetSlaSelector `json:"selector"`
}

// SetSlaSelector defines model for set-sla-selector.
type SetSlaSelector struct {
	// AppliesTo The item type for which the SLA policy applies.
	AppliesTo SlaSelectorAppliesTo `json:"applies_to"`

	// CustomFields Custom fields with their fully qualified names and associated with
	// their exact allowed values. The SLA policy applies to records where
	// all named custom fields have exactly the specified values. If the
	// value is null, the field must have null value or not be present.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// Groups The SLA policy applies to the tickets or conversations of these
	// groups.
	Groups        *[]string         `json:"groups,omitempty"`
	IssueSelector *SetIssueSelector `json:"issue_selector,omitempty"`

	// Owners The SLA policy applies to the tickets or conversations of these
	// owners.
	Owners *[]string `json:"owners,omitempty"`

	// Parts The SLA policy applies to the tickets of these parts.
	Parts *[]string `json:"parts,omitempty"`

	// Priority The SLA policy applies to conversations with these priorities.
	Priority *[]SlaSelectorPriority `json:"priority,omitempty"`

	// Severity The SLA policy applies to tickets with these severities.
	Severity *[]SlaSelectorSeverity `json:"severity,omitempty"`

	// SourceChannel The SLA policy applies to conversations with these sources.
	SourceChannel *[]string `json:"source_channel,omitempty"`

	// Subtype The SLA policy applies to tickets with these subtypes.
	Subtype *[]string `json:"subtype,omitempty"`

	// Tags The SLA policy applies to items with these tags.
	Tags *[]string `json:"tags,omitempty"`

	// TicketSourceChannel The SLA policy applies to tickets with these source channels.
	TicketSourceChannel *[]string `json:"ticket_source_channel,omitempty"`
}

// SetSupportMetricTarget defines model for set-support-metric-target.
type SetSupportMetricTarget struct {
	// Metric The metric to apply.
	Metric string `json:"metric"`

	// OrgScheduleId The organization schedule controlling this metrics calculation.
	// Time based metrics don't consume time while their schedule is off.
	OrgScheduleId *string `json:"org_schedule_id,omitempty"`

	// Performance The percentage of instances for which this metric's target must not
	// be breached, in order to avoid breaching the overall SLA policy.
	Performance *float64 `json:"performance,omitempty"`

	// Target The target value to be achieved, for example the time in which to
	// do something, or the maximum allowed number of message pairs. The
	// units and interpretation of the value is controlled by the
	// properties of the referenced metric.
	Target int32 `json:"target"`

	// WarningTarget The threshold in the same units as target where the metric is
	// considered to be 'at risk'.
	WarningTarget *int32 `json:"warning_target,omitempty"`
}

// SetTagWithValue defines model for set-tag-with-value.
type SetTagWithValue struct {
	// Id The ID of the tag.
	Id string `json:"id"`

	// Value The value for the object's association with the tag. If specified,
	// the value must be one that's specified in the tag's allowed values.
	Value *string `json:"value,omitempty"`
}

// SetWeeklyOrgSchedule defines model for set-weekly-org-schedule.
type SetWeeklyOrgSchedule struct {
	// Intervals The 'on' intervals of the week.
	Intervals []CreateWeeklyOrgScheduleInterval `json:"intervals"`

	// PeriodName The name of the period during which the organization schedule
	// applies.
	PeriodName string `json:"period_name"`
}

// SharedWithMembership Information about the role the member receives due to the share.
type SharedWithMembership struct {
	Member *MemberSummary `json:"member,omitempty"`
	Role   *RoleSummary   `json:"role,omitempty"`
}

// SharedWithMembershipFilter Filter on target item based on intended audience.
type SharedWithMembershipFilter struct {
	// Member ID of the group/member with whom the item is shared.
	Member *string `json:"member,omitempty"`

	// Role Role ID of the group/member with whom the item is shared.
	Role *string `json:"role,omitempty"`
}

// Sla defines model for sla.
type Sla struct {
	// AccountFilter A set of account attributes that must be satisfied for the SLA to
	// apply. AND applies between each field.
	AccountFilter *map[string]interface{} `json:"account_filter,omitempty"`

	// Compensation Describes the compensation to be provided in case of SLA breach. It is
	// not 'self-executing', it is the responsibility of the organization
	// providing the SLA to actually transfer the promised credit, resource or
	// other payment.
	Compensation *SlaCompensation `json:"compensation,omitempty"`
	CreatedBy    *UserSummary     `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the purpose and capabilities of the SLA.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// EvaluationPeriod Specifies the frequency of when the contractually-meaningful evaluation
	// of the SLA happens. The organization for their own information might
	// evaluate the various metrics contained in the policy as often as we can
	// make it feasible for them, but only the evaluation at the end of the
	// evaluation period triggers a compensation and needs to be shared with
	// the customer.
	EvaluationPeriod *SlaEvaluationPeriod `json:"evaluation_period,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Human-readable name.
	Name string `json:"name"`

	// Policies The policies encompassed by this SLA, ordered in decreasing
	// priority.
	Policies *[]SlaPolicy `json:"policies,omitempty"`

	// SlaType Type of the SLA.
	SlaType *SlaType `json:"sla_type,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status SlaStatus `json:"status"`
}

// SlaAppliesTo The object types on which the SLA applies. An external SLA can apply to
// multiple object types, but an internal SLA can apply to only one object
// type.
type SlaAppliesTo string

// SlaAssignResult defines model for sla-assign-result.
type SlaAssignResult struct {
	Error  *Error        `json:"error,omitempty"`
	RevOrg RevOrgSummary `json:"rev_org"`
}

// SlaCompensation Describes the compensation to be provided in case of SLA breach. It is
// not 'self-executing', it is the responsibility of the organization
// providing the SLA to actually transfer the promised credit, resource or
// other payment.
type SlaCompensation = map[string]interface{}

// SlaEvaluationPeriod Specifies the frequency of when the contractually-meaningful evaluation
// of the SLA happens. The organization for their own information might
// evaluate the various metrics contained in the policy as often as we can
// make it feasible for them, but only the evaluation at the end of the
// evaluation period triggers a compensation and needs to be shared with
// the customer.
type SlaEvaluationPeriod string

// SlaPolicy A policy that represents a promise to your revs.
type SlaPolicy = map[string]interface{}

// SlaSelectorAppliesTo The item type for which the SLA policy applies.
type SlaSelectorAppliesTo string

// SlaSelectorPriority The SLA policy applies to conversations with these priorities.
type SlaSelectorPriority string

// SlaSelectorSeverity The SLA policy applies to tickets with these severities.
type SlaSelectorSeverity string

// SlaStatus Status determines how an item can be used. In 'draft' status an item
// can be edited but can't be used. When 'published' the item can longer
// be edited but can be used. 'Archived' is read-only.
type SlaStatus string

// SlaSummary defines model for sla-summary.
type SlaSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Human-readable name.
	Name string `json:"name"`

	// SlaType Type of the SLA.
	SlaType *SlaType `json:"sla_type,omitempty"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status SlaStatus `json:"status"`
}

// SlaSummaryFilter The filter for SLA summary.
type SlaSummaryFilter struct {
	// Stage Filters for records with any of the provided SLA stages.
	Stage *[]SlaSummaryStage `json:"stage,omitempty"`

	// TargetTime Provides ways to specify date ranges on objects.
	TargetTime *DateFilter `json:"target_time,omitempty"`
}

// SlaSummaryStage The stage of the SLA. This is the metric stage which is closest to
// breach.
type SlaSummaryStage string

// SlaTracker defines model for sla-tracker.
type SlaTracker struct {
	// AppliesToId Details of the object on which the SLA is being tracked.
	AppliesToId *string `json:"applies_to_id,omitempty"`

	// AppliesToType The type of the object on which the SLA is being tracked.
	AppliesToType *SlaTrackerAppliesToType `json:"applies_to_type,omitempty"`
	CreatedBy     *UserSummary             `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// MetricTargetSummaries Summary of the metrics target being tracked in the SLA tracker.
	MetricTargetSummaries []ArchetypeMetricTarget `json:"metric_target_summaries"`
	ModifiedBy            *UserSummary            `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// RemovedSlaMetricHistory Information about removed metrics.
	RemovedSlaMetricHistory *[]RemovedSlaMetricHistory `json:"removed_sla_metric_history,omitempty"`
	Sla                     *SlaSummary                `json:"sla,omitempty"`

	// SlaPolicyId Details of the applicable SLA policy. Can be omitted if no sla
	// applies, or if no policy of the sla applies at the moment.
	SlaPolicyId *string `json:"sla_policy_id,omitempty"`

	// Stage SLA stage of the object being tracked.
	Stage *string `json:"stage,omitempty"`

	// Status It is an indicator of whether the SLA has ever been breached
	// (missed). If not, it shows whether the SLA is completed, in
	// progress, or nil - if no policy is applied.
	Status *string `json:"status,omitempty"`
}

// SlaTrackerAppliesToType The type of the object on which the SLA is being tracked.
type SlaTrackerAppliesToType string

// SlaTrackerSummary defines model for sla-tracker-summary.
type SlaTrackerSummary struct {
	// AppliesToType The type of the object on which the SLA is being tracked.
	AppliesToType *SlaTrackerAppliesToType `json:"applies_to_type,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`
}

// SlaTrackersGetRequest defines model for sla-trackers-get-request.
type SlaTrackersGetRequest struct {
	// Id The ID of the SLA tracker to get.
	Id string `json:"id"`
}

// SlaTrackersGetResponseBody defines model for sla-trackers-get-response.
type SlaTrackersGetResponseBody struct {
	SlaTracker SlaTracker `json:"sla_tracker"`
}

// SlaTrackersListRequest defines model for sla-trackers-list-request.
type SlaTrackersListRequest struct {
	CreatedDate *DateTimeFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of SLA trackers to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode         *ListMode       `json:"mode,omitempty"`
	ModifiedDate *DateTimeFilter `json:"modified_date,omitempty"`

	// SortBy Fields to sort the SLA Trackers by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stage The SLA tracker stages the filter matches.
	Stage *[]string `json:"stage,omitempty"`

	// Status The SLA tracker statuses the filter matches.
	Status *[]string `json:"status,omitempty"`
}

// SlaTrackersListResponseBody defines model for sla-trackers-list-response.
type SlaTrackersListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// SlaTrackers The list of SLA trackers.
	SlaTrackers []SlaTracker `json:"sla_trackers"`
}

// SlaTrackersRemoveMetricRequest defines model for sla-trackers-remove-metric-request.
type SlaTrackersRemoveMetricRequest struct {
	// Metric ID of the metric that is to be removed. If the metric has already
	// been removed, there will be no effect.
	Metric string `json:"metric"`

	// Object ID of the object from which the metric is to be removed.
	Object string `json:"object"`
}

// SlaTrackersRemoveMetricResponseBody defines model for sla-trackers-remove-metric-response.
type SlaTrackersRemoveMetricResponseBody struct {
	SlaTracker SlaTracker `json:"sla_tracker"`
}

// SlaType Type of the SLA.
type SlaType string

// SlasAssignRequest defines model for slas-assign-request.
type SlasAssignRequest struct {
	// Id The SLA which would be assigned to the Rev organizations. If
	// omitted, the SLA of all the rev organizations referenced will be
	// unset.
	Id *string `json:"id,omitempty"`

	// RevOrgs The Rev organizations to apply the SLA to.
	RevOrgs []string `json:"rev_orgs"`
}

// SlasAssignResponseBody defines model for slas-assign-response.
type SlasAssignResponseBody struct {
	// Results The list of outcomes for each Rev organization.
	Results []SlaAssignResult `json:"results"`
}

// SlasCreateRequest defines model for slas-create-request.
type SlasCreateRequest struct {
	AccountSelector *AccountsFilters `json:"account_selector,omitempty"`

	// AppliesTo The object types this SLA can apply to.
	AppliesTo *[]SlaAppliesTo `json:"applies_to,omitempty"`

	// Description Description of the purpose and capabilities of the SLA.
	Description *string `json:"description,omitempty"`

	// EvaluationPeriod Specifies the frequency of when the contractually-meaningful evaluation
	// of the SLA happens. The organization for their own information might
	// evaluate the various metrics contained in the policy as often as we can
	// make it feasible for them, but only the evaluation at the end of the
	// evaluation period triggers a compensation and needs to be shared with
	// the customer.
	EvaluationPeriod *SlaEvaluationPeriod `json:"evaluation_period,omitempty"`

	// Name Human-readable name.
	Name string `json:"name"`

	// Policies The policies encompassed by this SLA, ordered in decreasing
	// priority.
	Policies *[]SetSlaPolicy `json:"policies,omitempty"`

	// SlaType Type of the SLA.
	SlaType *SlaType `json:"sla_type,omitempty"`
}

// SlasCreateResponseBody defines model for slas-create-response.
type SlasCreateResponseBody struct {
	Sla Sla `json:"sla"`
}

// SlasFilterAppliesToOperatorType defines model for slas-filter-applies-to-operator-type.
type SlasFilterAppliesToOperatorType string

// SlasGetRequest defines model for slas-get-request.
type SlasGetRequest struct {
	// Id The ID of the SLA to get.
	Id string `json:"id"`
}

// SlasGetResponseBody defines model for slas-get-response.
type SlasGetResponseBody struct {
	Sla Sla `json:"sla"`
}

// SlasListRequest defines model for slas-list-request.
type SlasListRequest struct {
	// AppliesTo The object types the SLA applies to.
	AppliesTo   *[]SlaAppliesTo                  `json:"applies_to,omitempty"`
	AppliesToOp *SlasFilterAppliesToOperatorType `json:"applies_to_op,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of SLAs to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// SlaType The SLA types the filter matches.
	SlaType *[]SlaType `json:"sla_type,omitempty"`

	// SortBy Fields to sort the SLAs by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Status The SLA statuses the filter matches.
	Status *[]SlaStatus `json:"status,omitempty"`
}

// SlasListResponseBody defines model for slas-list-response.
type SlasListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Slas The list of SLAs.
	Slas []Sla `json:"slas"`
}

// SlasTransitionRequest defines model for slas-transition-request.
type SlasTransitionRequest struct {
	// Id The updated SLA.
	Id string `json:"id"`

	// Status Status determines how an item can be used. In 'draft' status an item
	// can be edited but can't be used. When 'published' the item can longer
	// be edited but can be used. 'Archived' is read-only.
	Status SlaStatus `json:"status"`
}

// SlasTransitionResponseBody defines model for slas-transition-response.
type SlasTransitionResponseBody struct {
	Sla Sla `json:"sla"`
}

// SlasUpdateRequest defines model for slas-update-request.
type SlasUpdateRequest struct {
	AccountSelector *AccountsFilters `json:"account_selector,omitempty"`

	// Description Description of the purpose and capabilities of the SLA.
	Description *string `json:"description,omitempty"`

	// EvaluationPeriod Specifies the frequency of when the contractually-meaningful evaluation
	// of the SLA happens. The organization for their own information might
	// evaluate the various metrics contained in the policy as often as we can
	// make it feasible for them, but only the evaluation at the end of the
	// evaluation period triggers a compensation and needs to be shared with
	// the customer.
	EvaluationPeriod *SlaEvaluationPeriod `json:"evaluation_period,omitempty"`

	// Id The SLA's ID.
	Id string `json:"id"`

	// Name Human-readable name.
	Name *string `json:"name,omitempty"`

	// Policies The policies encompassed by this SLA, ordered in decreasing
	// priority, the whole array will be overwritten by the contents of
	// this array.
	Policies *[]SetSlaPolicy `json:"policies,omitempty"`
}

// SlasUpdateResponseBody defines model for slas-update-response.
type SlasUpdateResponseBody struct {
	Sla Sla `json:"sla"`
}

// SnapIn defines model for snap-in.
type SnapIn struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// InputsValues Values of the inputs.
	InputsValues *map[string]interface{} `json:"inputs_values,omitempty"`
	ModifiedBy   *UserSummary            `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// SnapInSummary defines model for snap-in-summary.
type SnapInSummary = AtomBaseSummary

// SnapInVersion defines model for snap-in-version.
type SnapInVersion = AtomBase

// SnapInVersionSummary defines model for snap-in-version-summary.
type SnapInVersionSummary = AtomBaseSummary

// SnapInsResourcesRequest defines model for snap-ins-resources-request.
type SnapInsResourcesRequest struct {
	// Id The ID of the snap-in to get resources for.
	Id string `json:"id"`

	// User The ID of the user to get resources for.
	User string `json:"user"`
}

// SnapInsResourcesResponseBody defines model for snap-ins-resources-response.
type SnapInsResourcesResponseBody struct {
	// EventSources The event sources for the snap-in.
	EventSources *map[string]string `json:"event_sources,omitempty"`

	// Inputs The inputs for the snap-in.
	Inputs *map[string]interface{} `json:"inputs,omitempty"`

	// Keyrings Map of keyring names and its data.
	Keyrings      *map[string]SnapInsResourcesResponseKeyringData `json:"keyrings,omitempty"`
	SnapInVersion SnapInVersionSummary                            `json:"snap_in_version"`
}

// SnapInsResourcesResponseKeyringData defines model for snap-ins-resources-response-keyring-data.
type SnapInsResourcesResponseKeyringData struct {
	// Id The ID of the keyring.
	Id string `json:"id"`

	// IsExpired Whether the keyring token is expired.
	IsExpired bool `json:"is_expired"`

	// Secret The secret value of the keyring. This must be handled with caution.
	Secret string `json:"secret"`
}

// SnapInsUpdateRequest defines model for snap-ins-update-request.
type SnapInsUpdateRequest struct {
	// Id The ID of the snap-in to update.
	Id string `json:"id"`

	// InputsValues The updated values of the inputs.
	InputsValues *map[string]interface{} `json:"inputs_values,omitempty"`
}

// SnapInsUpdateResponseBody defines model for snap-ins-update-response.
type SnapInsUpdateResponseBody struct {
	SnapIn SnapIn `json:"snap_in"`
}

// SnapKitActionExecuteDeferredRequest defines model for snap-kit-action-execute-deferred-request.
type SnapKitActionExecuteDeferredRequest struct {
	// Actions List of actions triggered in the request.
	Actions []SnapKitActionRequest `json:"actions"`

	// Id ID of the deferred snap-kit action to be executed.
	Id string `json:"id"`
}

// SnapKitActionExecuteDeferredResponseBody defines model for snap-kit-action-execute-deferred-response.
type SnapKitActionExecuteDeferredResponseBody = map[string]interface{}

// SnapKitActionRequest defines model for snap-kit-action-request.
type SnapKitActionRequest struct {
	// ActionId Id of the interactive element specified by developer in a snap-kit
	// object.
	ActionId string `json:"action_id"`

	// ActionType Action interaction type.
	ActionType *string `json:"action_type,omitempty"`

	// BlockId Id of the block within the surface which is the container for the
	// interactive element.
	BlockId *string `json:"block_id,omitempty"`

	// Timestamp Timestamp when the action was originated.
	Timestamp time.Time                            `json:"timestamp"`
	Type      SnapKitActionRequestElementTypeValue `json:"type"`
	union     json.RawMessage
}

// SnapKitActionRequestButton defines model for snap-kit-action-request-button.
type SnapKitActionRequestButton struct {
	// Value Value for the button interactive element.
	Value string `json:"value"`
}

// SnapKitActionRequestElementTypeValue defines model for snap-kit-action-request-element-type-value.
type SnapKitActionRequestElementTypeValue string

// SnapKitActionRequestForm defines model for snap-kit-action-request-form.
type SnapKitActionRequestForm struct {
	// Value Value for the form interactive element.
	Value map[string]interface{} `json:"value"`
}

// SnapKitBaseWidget A SnapKit based widget.
type SnapKitBaseWidget struct {
	SnapKitExecution *string `json:"snap_kit_execution,omitempty"`
}

// SnapWidget defines model for snap-widget.
type SnapWidget struct {
	Type  SnapWidgetType `json:"type"`
	union json.RawMessage
}

// SnapWidgetBase defines model for snap-widget-base.
type SnapWidgetBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Interactions A list of interactions supported by the widget.
	Interactions *[]SnapWidgetInteraction `json:"interactions,omitempty"`
	ModifiedBy   *UserSummary             `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name A human readable name for the snap widget.
	Name string `json:"name"`

	// Namespace Logical grouping of snap widgets. Useful for filtering.
	Namespace *SnapWidgetNamespace `json:"namespace,omitempty"`

	// Status The status of the snap widget.
	Status SnapWidgetStatus `json:"status"`
}

// SnapWidgetClickInteraction An interaction supported by a widget.
type SnapWidgetClickInteraction struct {
	ClickAction SnapWidgetClickInteractionClickAction `json:"click_action"`
	union       json.RawMessage
}

// SnapWidgetClickInteractionClickAction defines model for snap-widget-click-interaction-click-action.
type SnapWidgetClickInteractionClickAction string

// SnapWidgetEmailInputInteraction An interaction supported by a widget.
type SnapWidgetEmailInputInteraction = map[string]interface{}

// SnapWidgetInteraction An interaction supported by a widget.
type SnapWidgetInteraction struct {
	Type  SnapWidgetInteractionType `json:"type"`
	union json.RawMessage
}

// SnapWidgetInteractionType defines model for snap-widget-interaction-type.
type SnapWidgetInteractionType string

// SnapWidgetNamespace Logical grouping of snap widgets. Useful for filtering.
type SnapWidgetNamespace string

// SnapWidgetOpenPlugWidgetAction Details of open plug widget action.
type SnapWidgetOpenPlugWidgetAction = map[string]interface{}

// SnapWidgetOpenUrlAction Details of open url widget action.
type SnapWidgetOpenUrlAction struct {
	// Url The url to open when the widget is clicked.
	Url string `json:"url"`
}

// SnapWidgetStartConversationAction Details of start conversation action.
type SnapWidgetStartConversationAction struct {
	// RteEnabled Whether the rich text editor is enabled on the object. Default is
	// false.
	RteEnabled *bool `json:"rte_enabled,omitempty"`

	// StarterMessage A SnapKit based widget.
	StarterMessage *SnapKitBaseWidget `json:"starter_message,omitempty"`
}

// SnapWidgetStatus The status of the snap widget.
type SnapWidgetStatus string

// SnapWidgetType defines model for snap-widget-type.
type SnapWidgetType string

// SnapWidgetsCreateRequest defines model for snap-widgets-create-request.
type SnapWidgetsCreateRequest struct {
	// Interactions The list of interactions supported by the widget.
	Interactions *[]SnapWidgetInteraction `json:"interactions,omitempty"`

	// Name A human readable name for the snap widget.
	Name string `json:"name"`

	// Namespace Logical grouping of snap widgets. Useful for filtering.
	Namespace *SnapWidgetNamespace `json:"namespace,omitempty"`

	// SharedWith Sets the members that the snap widget is shared with.
	SharedWith *[]SetSharedWithMembership `json:"shared_with,omitempty"`

	// Status The status of the snap widget.
	Status *SnapWidgetStatus            `json:"status,omitempty"`
	Type   SnapWidgetsCreateRequestType `json:"type"`
	union  json.RawMessage
}

// SnapWidgetsCreateRequestType defines model for snap-widgets-create-request-type.
type SnapWidgetsCreateRequestType string

// SnapWidgetsCreateResponseBody defines model for snap-widgets-create-response.
type SnapWidgetsCreateResponseBody struct {
	SnapWidget SnapWidget `json:"snap_widget"`
}

// Stage Describes the current stage of a object.
type Stage struct {
	Stage *CustomStageSummary `json:"stage,omitempty"`
	State *CustomStateSummary `json:"state,omitempty"`
}

// StageDiagram defines model for stage-diagram.
type StageDiagram struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsCustomLeafType True if this diagram corresponds to a custom leaf type.
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// IsDefault True if this diagram is the default for the leaf type.
	IsDefault *bool `json:"is_default,omitempty"`

	// LeafType The leaf type this stage diagram applies to.
	LeafType   *string      `json:"leaf_type,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name The human readable name of the diagram.
	Name *string `json:"name,omitempty"`

	// Stages Stage node.
	Stages []StageNode `json:"stages"`
}

// StageDiagramSummary defines model for stage-diagram-summary.
type StageDiagramSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name The human readable name of the diagram.
	Name *string `json:"name,omitempty"`
}

// StageDiagramsCreateRequest defines model for stage-diagrams-create-request.
type StageDiagramsCreateRequest struct {
	// IsCustomLeafType Whether the leaf type corresponds to a custom object.
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// IsDefault Whether this is a default stage diagram.
	IsDefault *bool `json:"is_default,omitempty"`

	// LeafType The leaf type this stage diagram applies to.
	LeafType string `json:"leaf_type"`

	// Name The name of the stage diagram. Stage diagram is used for defining
	// stage transitions.
	Name string `json:"name"`

	// Stages List of stages in the diagram.
	Stages []CreateStageNode `json:"stages"`
}

// StageDiagramsCreateResponseBody defines model for stage-diagrams-create-response.
type StageDiagramsCreateResponseBody struct {
	StageDiagram StageDiagram `json:"stage_diagram"`
}

// StageDiagramsGetRequest defines model for stage-diagrams-get-request.
type StageDiagramsGetRequest struct {
	// Id The ID of the stage diagram to get.
	Id *string `json:"id,omitempty"`

	// IsCustomLeafType Whether the leaf type corresponds to a custom object. Specify this
	// along with leaf_type to get the default custom object stage
	// diagram.
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// LeafType The leaf type. Should be specified to retrieve the default stage
	// diagram for the leaf type. If not provided, then id is used.
	LeafType *string `json:"leaf_type,omitempty"`
}

// StageDiagramsGetResponseBody defines model for stage-diagrams-get-response.
type StageDiagramsGetResponseBody struct {
	StageDiagram StageDiagram `json:"stage_diagram"`
}

// StageDiagramsListRequest defines model for stage-diagrams-list-request.
type StageDiagramsListRequest struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided,
	// then iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// IsCustomLeafType Whether only custom object stage diagrams should be filtered.
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// LeafType The list of leaf types.
	LeafType *[]string `json:"leaf_type,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `json:"limit,omitempty"`

	// Name The list of stage diagram names.
	Name *[]string `json:"name,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// StageDiagramsListResponseBody defines model for stage-diagrams-list-response.
type StageDiagramsListResponseBody struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided,
	// then iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Result The stage diagram.
	Result []StageDiagram `json:"result"`
}

// StageDiagramsUpdateRequest defines model for stage-diagrams-update-request.
type StageDiagramsUpdateRequest struct {
	// Id The ID of the stage diagram to update.
	Id string `json:"id"`

	// Name The updated name of the stage diagram.
	Name *string `json:"name,omitempty"`

	// Stages List of stages in the stage diagram.
	Stages *[]UpdateStageNode `json:"stages,omitempty"`
}

// StageDiagramsUpdateResponseBody defines model for stage-diagrams-update-response.
type StageDiagramsUpdateResponseBody struct {
	StageDiagram StageDiagram `json:"stage_diagram"`
}

// StageFilter The filter for stages.
type StageFilter struct {
	// Name Filters for records in the provided stage(s) by name.
	Name *[]string `json:"name,omitempty"`
}

// StageInit Sets an object's initial stage.
type StageInit struct {
	// Id The ID of the custom stage. If this is set, the name field is
	// ignored.
	Id *string `json:"id,omitempty"`

	// Name The name of the stage.
	Name *string `json:"name,omitempty"`
}

// StageNode Diagram stage.
type StageNode struct {
	// IsDeprecated True if this stage has been deprecated.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// IsStart True if this stage is the starting stage of the stage diagram.
	IsStart *bool               `json:"is_start,omitempty"`
	Stage   *CustomStageSummary `json:"stage,omitempty"`

	// Transitions The list of stages that can be reached.
	Transitions *[]StageTransition `json:"transitions,omitempty"`
}

// StageSummary Describes the current stage of a object.
type StageSummary struct {
	Stage *CustomStageSummary `json:"stage,omitempty"`
}

// StageTransition Stage transition.
type StageTransition struct {
	TargetStage *CustomStageSummary `json:"target_stage,omitempty"`
}

// StageUpdate Updates an object's stage.
type StageUpdate struct {
	// Name The updated name of the stage, otherwise unchanged if not set.
	Name *string `json:"name,omitempty"`

	// Stage The ID of the updated custom stage, otherwise unchanged if not set.
	// If this is set, the name field is ignored.
	Stage *string `json:"stage,omitempty"`
}

// StageValidationOptionForCreate Type of stage validation options when creating an object.
type StageValidationOptionForCreate string

// StageValidationOptionForUpdate Type of state validation options when updating the stage of an object.
type StageValidationOptionForUpdate string

// StagedInfoFilter defines model for staged-info-filter.
type StagedInfoFilter struct {
	// IsStaged Filters for issues that are staged.
	IsStaged *bool `json:"is_staged,omitempty"`
}

// StarterMessageNudgeWidget defines model for starter-message-nudge-widget.
type StarterMessageNudgeWidget struct {
	StarterMessageNudgeType StarterMessageNudgeWidgetStarterMessageNudgeType `json:"starter_message_nudge_type"`
}

// StarterMessageNudgeWidgetStarterMessageNudgeType defines model for starter-message-nudge-widget-starter-message-nudge-type.
type StarterMessageNudgeWidgetStarterMessageNudgeType = string

// StockFieldOverride A stock field override.
type StockFieldOverride struct {
	// IsRequired Whether the field is required.
	IsRequired *bool `json:"is_required,omitempty"`

	// Name Name of the stock field to be overridden.
	Name *string `json:"name,omitempty"`

	// UenumValues Overridden allowed values for a unified enum.
	UenumValues *[]SchemaFieldUenumValue `json:"uenum_values,omitempty"`

	// Ui The schema of ui specific fields.
	Ui *SchemaFieldUiMetadata `json:"ui,omitempty"`
}

// StockSchemaFragment defines model for stock-schema-fragment.
type StockSchemaFragment struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the schema.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Fields List of all fields in this schema.
	Fields []SchemaFieldDescriptor `json:"fields"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// LeafType Leaf type this fragment applies to.
	LeafType   *string      `json:"leaf_type,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate   *time.Time   `json:"modified_date,omitempty"`
	NewFragmentRef *AtomSummary `json:"new_fragment_ref,omitempty"`
	OldFragmentRef *AtomSummary `json:"old_fragment_ref,omitempty"`

	// Title Title of the schema.
	Title *string `json:"title,omitempty"`
}

// StockSchemaFragmentsGetRequest defines model for stock-schema-fragments-get-request.
type StockSchemaFragmentsGetRequest struct {
	// Id The ID of the stock schema fragment.
	Id *string `json:"id,omitempty"`

	// LeafType The leaf type this fragment applies to.
	LeafType *string `json:"leaf_type,omitempty"`
}

// StockSchemaFragmentsGetResponseBody defines model for stock-schema-fragments-get-response.
type StockSchemaFragmentsGetResponseBody struct {
	Fragment StockSchemaFragment `json:"fragment"`
}

// StockSchemaFragmentsListRequest defines model for stock-schema-fragments-list-request.
type StockSchemaFragmentsListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor       *string                                      `json:"cursor,omitempty"`
	FilterPreset *StockSchemaFragmentsListRequestFilterPreset `json:"filter_preset,omitempty"`

	// LeafType The list of leaf types.
	LeafType *[]string `json:"leaf_type,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Prune List of fields which are not required in the payload and can be
	// pruned away.
	Prune *[]StockSchemaFragmentsListRequestPrune `json:"prune,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// StockSchemaFragmentsListRequestFilterPreset defines model for stock-schema-fragments-list-request-filter-preset.
type StockSchemaFragmentsListRequestFilterPreset string

// StockSchemaFragmentsListRequestPrune defines model for stock-schema-fragments-list-request-prune.
type StockSchemaFragmentsListRequestPrune string

// StockSchemaFragmentsListResponseBody defines model for stock-schema-fragments-list-response.
type StockSchemaFragmentsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Result The stock schema fragments.
	Result []StockSchemaFragment `json:"result"`
}

// SubWidget A sub-widget represents a data visualization unit contained within a
// widget.
type SubWidget struct {
	// Query The query for a widget. This includes measures and dimensions to be
	// visualized.
	Query *WidgetQuery `json:"query,omitempty"`

	// ReferenceId A reference ID for the sub-widget. It should be unique within the
	// widget.
	ReferenceId string `json:"reference_id"`

	// Visualization The visualization for a widget. This includes the type of visualization
	// and any  configuration specific to that type.
	Visualization WidgetVisualization `json:"visualization"`
}

// SubscribersListRequest defines model for subscribers-list-request.
type SubscribersListRequest struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided,
	// then iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Id The object's ID.
	Id string `json:"id"`

	// Limit The maximum number of subscribers to return. If not set or `<= 0`,
	// then this defaults to `50`.
	Limit *int32 `json:"limit,omitempty"`
}

// SubscribersListResponseBody defines model for subscribers-list-response.
type SubscribersListResponseBody struct {
	// NextCursor The cursor that should be used to iterate the next sequence of
	// results, otherwise if not set, then no elements exist after.
	NextCursor *string `json:"next_cursor,omitempty"`

	// Users The list of subscribers on the object.
	Users []UserSummary `json:"users"`
}

// SubscribersUpdateRequest defines model for subscribers-update-request.
type SubscribersUpdateRequest struct {
	// Id The object's ID.
	Id          string                               `json:"id"`
	Subscribers *SubscribersUpdateRequestSubscribers `json:"subscribers,omitempty"`
}

// SubscribersUpdateRequestSubscribers defines model for subscribers-update-request-subscribers.
type SubscribersUpdateRequestSubscribers struct {
	// Add The list of users to add as subscribers on the object.
	Add *[]string `json:"add,omitempty"`

	// Remove The list of users to remove as subscribers on the object.
	Remove *[]string `json:"remove,omitempty"`
}

// SubscribersUpdateResponseBody defines model for subscribers-update-response.
type SubscribersUpdateResponseBody = map[string]interface{}

// Subtype defines model for subtype.
type Subtype struct {
	// DisplayName Display name of the subtype.
	DisplayName *string `json:"display_name,omitempty"`

	// FragmentId DON of the custom type fragment this subtype belongs to.
	FragmentId string `json:"fragment_id"`

	// LeafType Leaf type for the subtype.
	LeafType string `json:"leaf_type"`

	// Value Value of the subtype.
	Value string `json:"value"`
}

// SubtypesListRequest defines model for subtypes-list-request.
type SubtypesListRequest struct {
	// LeafType Leaf type for which subtypes are required.
	// Deprecated:
	LeafType *string `json:"leaf_type,omitempty"`

	// LeafTypes List of leaf types for which subtypes are required.
	LeafTypes *[]string `json:"leaf_types,omitempty"`
}

// SubtypesListResponseBody defines model for subtypes-list-response.
type SubtypesListResponseBody struct {
	// Subtypes List of subtypes.
	Subtypes []Subtype `json:"subtypes"`
}

// Survey defines model for survey.
type Survey struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the survey.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Header Header of the survey.
	Header *string `json:"header,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IntroductoryText Text posted when introducing the survey to the responder.
	IntroductoryText *string      `json:"introductory_text,omitempty"`
	ModifiedBy       *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Survey name associated with schema. This name would be unique per
	// dev org.
	Name *string `json:"name,omitempty"`

	// ResponseText Text posted after the response is collected.
	ResponseText *string `json:"response_text,omitempty"`

	// Schema List of all fields in the schema.
	Schema *[]SchemaFieldDescriptor `json:"schema,omitempty"`

	// SchemaWithMetadata List of all the fields and their respective metadata in the schema.
	SchemaWithMetadata *[]SurveyFieldWithMetadata `json:"schema_with_metadata,omitempty"`

	// Title Title of the survey.
	Title *string `json:"title,omitempty"`
}

// SurveyAggregationFilter The filter for survey aggregation.
type SurveyAggregationFilter = map[string]interface{}

// SurveyFieldWithMetadata Field descriptors with additional metadata for surveys.
type SurveyFieldWithMetadata struct {
	// Field Set of field attributes.
	Field *SchemaFieldDescriptor `json:"field,omitempty"`

	// Metadata Additional metadata for the input field.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Question The question linked to the input field.
	Question *string `json:"question,omitempty"`
}

// SurveyResponse defines model for survey-response.
type SurveyResponse struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DispatchId The unique ID associated with the dispatched survey.
	DispatchId *string `json:"dispatch_id,omitempty"`

	// DispatchedChannels Source channels on which the survey is sent. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "plug",
	//     "ordinal": 1,
	//     "overridable": false
	//   },
	//   {
	//     "id": 2,
	//     "label": "portal",
	//     "ordinal": 2,
	//     "overridable": false
	//   },
	//   {
	//     "id": 3,
	//     "label": "email",
	//     "ordinal": 3,
	//     "overridable": false
	//   },
	//   {
	//     "id": 4,
	//     "label": "slack",
	//     "ordinal": 4,
	//     "overridable": false
	//   }
	// ```
	DispatchedChannels *[]EnumValue `json:"dispatched_channels,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Object The ID of the object for which survey is taken.
	Object    *string      `json:"object,omitempty"`
	Recipient *UserSummary `json:"recipient,omitempty"`

	// Response Response for the survey.
	Response *map[string]interface{} `json:"response,omitempty"`

	// ResponseChannel The properties of an enum value.
	ResponseChannel *EnumValue `json:"response_channel,omitempty"`

	// Stage The properties of an enum value.
	Stage *EnumValue `json:"stage,omitempty"`

	// Survey The ID of the survey for which response is taken.
	Survey *string `json:"survey,omitempty"`
}

// SurveysCreateRequest defines model for surveys-create-request.
type SurveysCreateRequest struct {
	// Description Description about the survey.
	Description *string `json:"description,omitempty"`

	// Header Header of the survey.
	Header *string `json:"header,omitempty"`

	// IntroductoryText Text posted when introducing the survey to the responder.
	IntroductoryText *string `json:"introductory_text,omitempty"`

	// Name The survey's name.
	Name string `json:"name"`

	// ResponseText Text posted after the response is collected.
	ResponseText *string `json:"response_text,omitempty"`

	// Schema Schema for the survey.
	Schema *[]FieldDescriptor `json:"schema,omitempty"`

	// SchemaWithMetadata The schema with metadata for the survey.
	SchemaWithMetadata *[]SurveyFieldWithMetadata `json:"schema_with_metadata,omitempty"`

	// Title Title of the survey.
	Title *string `json:"title,omitempty"`
}

// SurveysCreateResponseBody defines model for surveys-create-response.
type SurveysCreateResponseBody struct {
	Survey Survey `json:"survey"`
}

// SurveysDeleteRequest defines model for surveys-delete-request.
type SurveysDeleteRequest struct {
	// Id ID of the survey being deleted.
	Id string `json:"id"`
}

// SurveysDeleteResponseBody defines model for surveys-delete-response.
type SurveysDeleteResponseBody = map[string]interface{}

// SurveysGetRequest defines model for surveys-get-request.
type SurveysGetRequest struct {
	// Id The ID of the survey to get.
	Id string `json:"id"`
}

// SurveysGetResponseBody defines model for surveys-get-response.
type SurveysGetResponseBody struct {
	Survey Survey `json:"survey"`
}

// SurveysListRequest defines model for surveys-list-request.
type SurveysListRequest struct {
	// CreatedBy Filters for surveys created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of surveys to return. If not set, then the
	// default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// Name Filters for surveys by name(s).
	Name *[]string `json:"name,omitempty"`

	// SortBy Fields to sort the surveys by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// SurveysListResponseBody defines model for surveys-list-response.
type SurveysListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Surveys The list of the surveys.
	Surveys []Survey `json:"surveys"`
}

// SurveysResponsesListRequest defines model for surveys-responses-list-request.
type SurveysResponsesListRequest struct {
	// CreatedBy Filters for survey responses created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// DispatchIds Filters for survey responses associated with these unique IDs.
	DispatchIds *[]string `json:"dispatch_ids,omitempty"`

	// Limit The maximum number of survey responses to return. If not set, then
	// the default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`

	// Objects Filters for survey responses created for the objects.
	Objects *[]string `json:"objects,omitempty"`

	// Recipient Filters for survey responses dispatched to any of these users.
	Recipient *[]string `json:"recipient,omitempty"`

	// SortBy Fields to sort the survey responses by and the direction to sort
	// them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stages Filters for survey response stages.
	Stages *[]int64 `json:"stages,omitempty"`

	// Surveys Filters for survey responses for the provided survey IDs.
	Surveys *[]string `json:"surveys,omitempty"`
}

// SurveysResponsesListResponseBody defines model for surveys-responses-list-response.
type SurveysResponsesListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// SurveyResponses The list of the survey responses.
	SurveyResponses []SurveyResponse `json:"survey_responses"`
}

// SurveysResponsesUpdateRequest defines model for surveys-responses-update-request.
type SurveysResponsesUpdateRequest struct {
	// DispatchId The unique ID associated with the dispatched survey.
	DispatchId string `json:"dispatch_id"`

	// Response Survey response submitted for the object.
	Response *map[string]interface{} `json:"response,omitempty"`

	// ResponseChannel The source channel ordinal which recorded the survey response.
	ResponseChannel *int64 `json:"response_channel,omitempty"`

	// ResponseScore The response score for the survey. Only applicable for CSAT and
	// NPS.
	ResponseScore *int32 `json:"response_score,omitempty"`

	// Stage The stage ordinal of the survey response object.
	Stage *int64 `json:"stage,omitempty"`
}

// SurveysResponsesUpdateResponseBody defines model for surveys-responses-update-response.
type SurveysResponsesUpdateResponseBody = map[string]interface{}

// SurveysSendRequest defines model for surveys-send-request.
type SurveysSendRequest struct {
	Email SurveysSendRequestEmail `json:"email"`
}

// SurveysSendRequestEmail defines model for surveys-send-request-email.
type SurveysSendRequestEmail struct {
	// Body Message body for a survey email.
	Body string `json:"body"`

	// Recipients Recipients list for a survey email.
	Recipients []string `json:"recipients"`

	// Sender Sender email address from which an email is sent.
	Sender string `json:"sender"`

	// Subject Subject for an email where survey is sent.
	Subject string `json:"subject"`
}

// SurveysSendResponseBody defines model for surveys-send-response.
type SurveysSendResponseBody = map[string]interface{}

// SurveysSubmitRequest defines model for surveys-submit-request.
type SurveysSubmitRequest struct {
	// DispatchId The unique ID associated with the dispatched survey.
	DispatchId *string `json:"dispatch_id,omitempty"`

	// DispatchedChannels The ordinals of the source channels on which the survey is sent.
	DispatchedChannels *[]int64 `json:"dispatched_channels,omitempty"`

	// Object The ID of the object this survey is on (e.g. ticket, conversation,
	// etc).
	Object string `json:"object"`

	// Recipient The unique ID associated with the recipient of the survey.
	Recipient *string `json:"recipient,omitempty"`

	// Response Survey response submitted for the object.
	Response *map[string]interface{} `json:"response,omitempty"`

	// ResponseScore The response score for the survey. Only applicable for CSAT and
	// NPS.
	ResponseScore *int32 `json:"response_score,omitempty"`

	// SourceChannel The source channel from which survey response is submitted.
	SourceChannel *string `json:"source_channel,omitempty"`

	// Stage The stage ordinal of the survey response object.
	Stage *int64 `json:"stage,omitempty"`

	// Survey The ID of the survey to submit the response to.
	Survey string `json:"survey"`
}

// SurveysSubmitResponseBody defines model for surveys-submit-response.
type SurveysSubmitResponseBody = map[string]interface{}

// SurveysUpdateRequest defines model for surveys-update-request.
type SurveysUpdateRequest struct {
	// Description The updated description about the survey.
	Description *string `json:"description,omitempty"`

	// Header Header of the survey.
	Header *string `json:"header,omitempty"`

	// Id The ID of the survey to update.
	Id string `json:"id"`

	// IntroductoryText The updated text posted when introducing the survey to the
	// responder.
	IntroductoryText *string `json:"introductory_text,omitempty"`

	// Name The survey's updated name.
	Name *string `json:"name,omitempty"`

	// ResponseText Text posted after the response is collected.
	ResponseText *string `json:"response_text,omitempty"`

	// SchemaWithMetadata The updated schema with metadata for the survey.
	SchemaWithMetadata *[]SurveyFieldWithMetadata `json:"schema_with_metadata,omitempty"`

	// Survey The ID of the survey to update.
	// Deprecated:
	Survey *string `json:"survey,omitempty"`

	// Title Title of the survey.
	Title *string `json:"title,omitempty"`
}

// SurveysUpdateResponseBody defines model for surveys-update-response.
type SurveysUpdateResponseBody struct {
	Survey Survey `json:"survey"`
}

// SyncHistory defines model for sync-history.
type SyncHistory struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// SyncRun Object for holding run-specific data.
	SyncRun *SyncRun `json:"sync_run,omitempty"`

	// SyncUnit SyncUnit ID associated with this historical entry.
	SyncUnit *string `json:"sync_unit,omitempty"`
}

// SyncIn Information about the sync to DevRev.
type SyncIn struct {
	// Status Status of the sync for the object.
	Status *SyncInStatus `json:"status,omitempty"`

	// SyncDate Timestamp when the object was synced in/from DevRev.
	SyncDate *time.Time       `json:"sync_date,omitempty"`
	SyncUnit *SyncUnitSummary `json:"sync_unit,omitempty"`
}

// SyncInStatus Status of the sync for the object.
type SyncInStatus string

// SyncMetadata Sync information for records synced into/from DevRev.
type SyncMetadata struct {
	// ExternalReference External record URL.
	ExternalReference *string `json:"external_reference,omitempty"`

	// LastSyncIn Information about the sync to DevRev.
	LastSyncIn *SyncIn `json:"last_sync_in,omitempty"`

	// LastSyncOut Information about the sync from DevRev.
	LastSyncOut *SyncOut `json:"last_sync_out,omitempty"`

	// OriginSystem Where the record was first created.
	OriginSystem *string `json:"origin_system,omitempty"`
}

// SyncMetadataFilter defines model for sync-metadata-filter.
type SyncMetadataFilter struct {
	// ExternalReference Filters for issues with this specific external reference.
	ExternalReference *[]string                        `json:"external_reference,omitempty"`
	LastSyncIn        *SyncMetadataFilterSyncInFilter  `json:"last_sync_in,omitempty"`
	LastSyncOut       *SyncMetadataFilterSyncOutFilter `json:"last_sync_out,omitempty"`

	// OriginSystem Filters for issues synced from this specific origin system.
	OriginSystem *[]string `json:"origin_system,omitempty"`
}

// SyncMetadataFilterSyncInFilter defines model for sync-metadata-filter-sync-in-filter.
type SyncMetadataFilterSyncInFilter struct {
	// Status Filters for works with selected sync statuses.
	Status *[]SyncMetadataFilterSyncInFilterStatus `json:"status,omitempty"`

	// SyncDate Provides ways to specify date ranges on objects.
	SyncDate *DateFilter `json:"sync_date,omitempty"`

	// SyncHistory Filters for works modified with selected sync history.
	SyncHistory *[]string `json:"sync_history,omitempty"`

	// SyncUnit Filters for works modified with selected sync units.
	SyncUnit *[]string `json:"sync_unit,omitempty"`
}

// SyncMetadataFilterSyncInFilterStatus defines model for sync-metadata-filter-sync-in-filter-status.
type SyncMetadataFilterSyncInFilterStatus string

// SyncMetadataFilterSyncOutFilter defines model for sync-metadata-filter-sync-out-filter.
type SyncMetadataFilterSyncOutFilter struct {
	// Status Filters for works with selected sync statuses.
	Status *[]SyncMetadataFilterSyncOutFilterStatus `json:"status,omitempty"`

	// SyncDate Provides ways to specify date ranges on objects.
	SyncDate *DateFilter `json:"sync_date,omitempty"`

	// SyncHistory Filters for works modified with selected sync history.
	SyncHistory *[]string `json:"sync_history,omitempty"`

	// SyncUnit Filters for works modified with selected sync units.
	SyncUnit *[]string `json:"sync_unit,omitempty"`
}

// SyncMetadataFilterSyncOutFilterStatus defines model for sync-metadata-filter-sync-out-filter-status.
type SyncMetadataFilterSyncOutFilterStatus string

// SyncMetadataSummary Sync information for records synced into/from DevRev.
type SyncMetadataSummary struct {
	// ExternalReference External record URL.
	ExternalReference *string `json:"external_reference,omitempty"`

	// OriginSystem Where the record was first created.
	OriginSystem *string `json:"origin_system,omitempty"`
}

// SyncOut Information about the sync from DevRev.
type SyncOut struct {
	// Status Status of the sync for the object.
	Status *SyncOutStatus `json:"status,omitempty"`

	// SyncDate Timestamp when the object was synced in/from DevRev.
	SyncDate *time.Time       `json:"sync_date,omitempty"`
	SyncUnit *SyncUnitSummary `json:"sync_unit,omitempty"`
}

// SyncOutStatus Status of the sync for the object.
type SyncOutStatus string

// SyncProgress Progress.
type SyncProgress struct {
	// State The state of a sync progress.
	State *SyncProgressState `json:"state,omitempty"`
}

// SyncProgressState The state of a sync progress.
type SyncProgressState string

// SyncProgressSummary Progress.
type SyncProgressSummary struct {
	// State The state of a sync progress.
	State *SyncProgressState `json:"state,omitempty"`
}

// SyncRun Object for holding run-specific data.
type SyncRun struct {
	// EndedAt The time when a sync was ended.
	EndedAt *time.Time `json:"ended_at,omitempty"`

	// Mode The direction/mode of a sync run.
	Mode *SyncRunMode `json:"mode,omitempty"`

	// Progress Progress.
	Progress *SyncProgress `json:"progress,omitempty"`

	// StartedAt The time when a sync was started.
	StartedAt *time.Time `json:"started_at,omitempty"`
}

// SyncRunMode The direction/mode of a sync run.
type SyncRunMode string

// SyncRunProgressState The state of a sync progress.
type SyncRunProgressState string

// SyncRunStartedBy Describes how the sync was initiated.
type SyncRunStartedBy string

// SyncRunSummary Object for holding run-specific data.
type SyncRunSummary struct {
	// Mode The direction/mode of a sync run.
	Mode *SyncRunMode `json:"mode,omitempty"`

	// Progress Progress.
	Progress *SyncProgressSummary `json:"progress,omitempty"`
}

// SyncUnit defines model for sync-unit.
type SyncUnit struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ExternalSystemName The name of the external system.
	ExternalSystemName *string             `json:"external_system_name,omitempty"`
	ExternalSystemType *ExternalSystemType `json:"external_system_type,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsArchived The flag signaling if sync unit is archived.
	IsArchived *bool        `json:"is_archived,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name The name of the sync unit.
	Name *string `json:"name,omitempty"`

	// SyncRun Object for holding run-specific data.
	SyncRun *SyncRun `json:"sync_run,omitempty"`

	// SyncType Type of sync preferences.
	SyncType *SyncUnitSyncType `json:"sync_type,omitempty"`
}

// SyncUnitSummary defines model for sync-unit-summary.
type SyncUnitSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId          *string             `json:"display_id,omitempty"`
	ExternalSystemType *ExternalSystemType `json:"external_system_type,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsArchived The flag signaling if sync unit is archived.
	IsArchived *bool `json:"is_archived,omitempty"`

	// Name The name of the sync unit.
	Name *string `json:"name,omitempty"`

	// SyncRun Object for holding run-specific data.
	SyncRun *SyncRunSummary `json:"sync_run,omitempty"`

	// SyncType Type of sync preferences.
	SyncType *SyncUnitSyncType `json:"sync_type,omitempty"`
}

// SyncUnitSyncType Type of sync preferences.
type SyncUnitSyncType string

// SysUser defines model for sys-user.
type SysUser = UserBase

// SysUserSummary defines model for sys-user-summary.
type SysUserSummary = UserBaseSummary

// SysUsersListRequest A request to get the list of system user's information.
type SysUsersListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of system users to return. Value can range from
	// '1' to '100', with a default of '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// SortBy Fields to sort the system users by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// SysUsersListResponseBody The response to listing the system users.
type SysUsersListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// SysUsers The list of system users.
	SysUsers []SysUser `json:"sys_users"`
}

// SysUsersUpdateRequest Request to update information of the system user.
type SysUsersUpdateRequest struct {
	// DisplayName Updated display name for the system user.
	DisplayName *string `json:"display_name,omitempty"`

	// DisplayPicture Artifact ID of the system user's new display picture.
	DisplayPicture *string `json:"display_picture"`

	// FullName Updated full name for the system user.
	FullName *string `json:"full_name,omitempty"`

	// Id The ID of system user to update.
	Id string `json:"id"`
}

// SysUsersUpdateResponseBody Updated Sys user object.
type SysUsersUpdateResponseBody struct {
	SysUser SysUser `json:"sys_user"`
}

// TableVisualizationColumn A column in a table visualization.
type TableVisualizationColumn struct {
	// Color The color for an axis. This can be a single color or a gradient.
	Color *VisualizationAxisColor `json:"color,omitempty"`

	// DrillThroughs The drill through configurations for the axis.
	DrillThroughs *[]VisualizationAxisDrillThrough `json:"drill_throughs,omitempty"`

	// IsHidden Whether the axis should be hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsMovable Whether the column should be movable.
	IsMovable *bool `json:"is_movable,omitempty"`

	// IsPinned Whether the column should be pinned, by default set to false.
	IsPinned *bool `json:"is_pinned,omitempty"`

	// IsResizable Whether the column should be resizable.
	IsResizable *bool `json:"is_resizable,omitempty"`

	// IsSortable Whether the column should be sortable.
	IsSortable *bool `json:"is_sortable,omitempty"`

	// IsVisibilityTogglable Whether the column visibility can be toggled.
	IsVisibilityTogglable *bool `json:"is_visibility_togglable,omitempty"`

	// Label The label for the axis.
	Label *string `json:"label,omitempty"`

	// LockPosition Whether the column should be locked to the left or right side of the
	// table.
	LockPosition *TableVisualizationColumnLockPosition `json:"lock_position,omitempty"`

	// MaxWidth The maximum width of the column.
	MaxWidth *int32 `json:"max_width,omitempty"`

	// MinWidth The minimum width of the column.
	MinWidth *int32 `json:"min_width,omitempty"`

	// Order The order in which the column should be displayed.
	Order *int32 `json:"order,omitempty"`

	// PinPosition Whether the column should be pinned to the left or right side of the
	// table.
	PinPosition *TableVisualizationColumnPinPosition `json:"pin_position,omitempty"`

	// ReferenceName The reference name of the axis.
	ReferenceName string `json:"reference_name"`

	// Width The width of the column in pixel.
	Width *int32 `json:"width,omitempty"`
}

// TableVisualizationColumnLockPosition Whether the column should be locked to the left or right side of the
// table.
type TableVisualizationColumnLockPosition string

// TableVisualizationColumnPinPosition Whether the column should be pinned to the left or right side of the
// table.
type TableVisualizationColumnPinPosition string

// TableWidgetVisualization A table visualization configuration. Includes metadata specific to
// tables.
type TableWidgetVisualization struct {
	// Columns The configuration for the columns in the table.
	Columns []TableVisualizationColumn `json:"columns"`

	// GroupBy The group_by configuration in the table.
	GroupBy *[]WidgetGroupByConfig `json:"group_by,omitempty"`
}

// Tag defines model for tag.
type Tag struct {
	// AllowedValues The allowed values for the tag, where a value is provided when a
	// tag is associated with an object. If empty, then no value should be
	// provided when the association is made.
	AllowedValues *[]string    `json:"allowed_values,omitempty"`
	CreatedBy     *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description An informative description for the tag that should provide context
	// on the tag's purpose and usage.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name The name of the tag, which denotes the logical concept by which all
	// tagged objects will be associated. The name is guaranteed to be
	// unique.
	Name     string    `json:"name"`
	StyleNew *TagStyle `json:"style_new,omitempty"`
}

// TagSearchSummary defines model for tag-search-summary.
type TagSearchSummary struct {
	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string    `json:"snippet,omitempty"`
	Tag     TagSummary `json:"tag"`
}

// TagStyle defines model for tag-style.
type TagStyle struct {
	// Color The hex color code in "#RRGGBB" format.
	Color *string `json:"color,omitempty"`
}

// TagStyleSummary defines model for tag-style-summary.
type TagStyleSummary struct {
	// Color The hex color code in "#RRGGBB" format.
	Color *string `json:"color,omitempty"`
}

// TagSummary defines model for tag-summary.
type TagSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name The name of the tag, which denotes the logical concept by which all
	// tagged objects will be associated. The name is guaranteed to be
	// unique.
	Name     string           `json:"name"`
	StyleNew *TagStyleSummary `json:"style_new,omitempty"`
}

// TagWithValue defines model for tag-with-value.
type TagWithValue struct {
	Tag TagSummary `json:"tag"`

	// Value The value for the object's association with the tag.
	Value *string `json:"value,omitempty"`
}

// TagWithValueFilter defines model for tag-with-value-filter.
type TagWithValueFilter struct {
	// Id The ID of the tag.
	Id *string `json:"id,omitempty"`

	// Value The value for the object's association with the tag. If specified,
	// the value must be one that's specified in the tag's allowed values.
	Value *string `json:"value,omitempty"`
}

// TagsCreateRequest The request to create a new tag.
type TagsCreateRequest struct {
	// AllowedValues The allowed values for the tag, or empty if no values are
	// permitted.
	AllowedValues *[]string `json:"allowed_values,omitempty"`

	// Description The description for the tag.
	Description *string `json:"description,omitempty"`

	// Name The name for the tag, which must be unique across all tags.
	Name     string    `json:"name"`
	StyleNew *TagStyle `json:"style_new,omitempty"`
}

// TagsCreateResponseBody The response to creating a new tag.
type TagsCreateResponseBody struct {
	Tag Tag `json:"tag"`
}

// TagsDeleteRequest The request to delete a tag.
type TagsDeleteRequest struct {
	// Id The ID of the tag to delete.
	Id string `json:"id"`
}

// TagsDeleteResponseBody The response for deleting a tag.
type TagsDeleteResponseBody = map[string]interface{}

// TagsGetRequest The request to get a tag's information.
type TagsGetRequest struct {
	// Id The requested tag's ID.
	Id string `json:"id"`
}

// TagsGetResponseBody The response to getting a tag's information.
type TagsGetResponseBody struct {
	Tag Tag `json:"tag"`
}

// TagsListRequest The request to get information about a list of tags.
type TagsListRequest struct {
	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of tags to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Name Filters for tags with the provided names.
	Name *[]string `json:"name,omitempty"`

	// SortBy Fields to sort tags by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`
}

// TagsListResponseBody The response to listing the tags.
type TagsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Tags The list of tags.
	Tags []Tag `json:"tags"`
}

// TagsUpdateAllowedValues Specifies an update to a tag's allowed values.
type TagsUpdateAllowedValues struct {
	// Set Sets the allowed values for the tag.
	Set *[]string `json:"set,omitempty"`
}

// TagsUpdateRequest The request to update a tag.
type TagsUpdateRequest struct {
	// AllowedValues Specifies an update to a tag's allowed values.
	AllowedValues *TagsUpdateAllowedValues `json:"allowed_values,omitempty"`

	// Description The updated description of the tag.
	Description *string `json:"description,omitempty"`

	// Id The ID of the tag to update.
	Id string `json:"id"`

	// Name The updated name of the tag. The name must be unique across all
	// tags.
	Name     *string   `json:"name,omitempty"`
	StyleNew *TagStyle `json:"style_new,omitempty"`
}

// TagsUpdateResponseBody The response for updating a tag.
type TagsUpdateResponseBody struct {
	Tag Tag `json:"tag"`
}

// Task defines model for task.
type Task = WorkBase

// TaskPriority Priority of the work based upon impact and criticality.
type TaskPriority string

// TaskSummary defines model for task-summary.
type TaskSummary = WorkBaseSummary

// TenantFragment defines model for tenant-fragment.
type TenantFragment struct {
	// Conditions The conditions associated with the fields.
	Conditions *[]CustomSchemaFragmentCondition `json:"conditions,omitempty"`
	CreatedBy  *UserSummary                     `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Deprecated Indicates if the fragment has been deprecated. Modifications to
	// this field are done in-place and don't result in creation of a new
	// fragment in chain.
	Deprecated *bool `json:"deprecated,omitempty"`

	// Description Description of the custom schema fragment.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Fields List of all fields in this custom schema fragment.
	Fields *[]SchemaFieldDescriptor `json:"fields,omitempty"`

	// FragmentType Type of the custom schema fragment.
	FragmentType *CustomSchemaFragmentFragmentType `json:"fragment_type,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsDeprecated Indicates if the fragment is deprecated. Modifications to this
	// field are done in-place and don't result in creation of a new
	// fragment in chain.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// LeafType Leaf type this fragment applies to.
	LeafType   *string      `json:"leaf_type,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate   *time.Time                   `json:"modified_date,omitempty"`
	NewFragmentRef *CustomSchemaFragmentSummary `json:"new_fragment_ref,omitempty"`
	OldFragmentRef *CustomSchemaFragmentSummary `json:"old_fragment_ref,omitempty"`

	// StockFieldOverrides The stock field overrides.
	StockFieldOverrides *[]StockFieldOverride `json:"stock_field_overrides,omitempty"`
}

// TenantFragmentSummary defines model for tenant-fragment-summary.
type TenantFragmentSummary = CustomSchemaFragmentBaseSummary

// Ticket defines model for ticket.
type Ticket struct {
	Account *AccountSummary `json:"account,omitempty"`

	// ActualCloseDate Timestamp when the work was actually completed.
	ActualCloseDate *time.Time   `json:"actual_close_date,omitempty"`
	AppliesToPart   *PartSummary `json:"applies_to_part,omitempty"`

	// Artifacts The artifacts attached to the work item.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body Body of the work object.
	Body *string `json:"body,omitempty"`

	// Channels Channels of the ticket.
	Channels *[]TicketChannels `json:"channels,omitempty"`

	// ChannelsV2 Channel IDs of the ticket.
	ChannelsV2 *[]ExternalCommunicationChannelSummary `json:"channels_v2,omitempty"`
	CreatedBy  *UserSummary                           `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string       `json:"display_id,omitempty"`
	Group     *GroupSummary `json:"group,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// NeedsResponse Whether the ticket needs a response.
	NeedsResponse *bool `json:"needs_response,omitempty"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// ReportedBy Users that reported the work.
	ReportedBy *[]UserSummary `json:"reported_by,omitempty"`
	RevOrg     *OrgSummary    `json:"rev_org,omitempty"`

	// Sentiment The properties of an enum value.
	Sentiment *EnumValue `json:"sentiment,omitempty"`

	// SentimentModifiedDate Timestamp when the sentiment was last modified.
	SentimentModifiedDate *time.Time `json:"sentiment_modified_date,omitempty"`

	// SentimentSummary Summary justifying the sentiment.
	SentimentSummary *string `json:"sentiment_summary,omitempty"`

	// Severity Severity of the ticket.
	Severity *TicketSeverity `json:"severity,omitempty"`

	// SlaSummary SLA summary for the object.
	SlaSummary *ArchetypeSlaSummary `json:"sla_summary,omitempty"`
	SlaTracker *SlaTrackerSummary   `json:"sla_tracker,omitempty"`

	// SourceChannel Source channel of the ticket.
	SourceChannel   *string                              `json:"source_channel,omitempty"`
	SourceChannelV2 *ExternalCommunicationChannelSummary `json:"source_channel_v2,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStage `json:"stage,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`

	// Visibility The properties of an enum value.
	Visibility *EnumValue `json:"visibility,omitempty"`
}

// TicketChannels Channels of the ticket.
type TicketChannels string

// TicketSeverity Severity of the ticket.
type TicketSeverity string

// TicketSummary defines model for ticket-summary.
type TicketSummary struct {
	Account *AccountSummary `json:"account,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`
	RevOrg  *OrgSummary   `json:"rev_org,omitempty"`

	// Severity Severity of the ticket.
	Severity *TicketSeverity `json:"severity,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStageSummary `json:"stage,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// TimelineChangeEvent defines model for timeline-change-event.
type TimelineChangeEvent struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Event A timeline change event.
	Event *TimelineChangeEventEvent `json:"event,omitempty"`

	// ExternalRef An external reference that's associated with the Timeline entry
	// that's guaranteed to be unique among its siblings.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Labels Labels that are associated with the Timeline entry.
	Labels     *[]string    `json:"labels,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Object The object that the Timeline entry belongs to.
	Object string `json:"object"`

	// ObjectDisplayId The display ID of the object that the Timeline entry belongs to.
	ObjectDisplayId string `json:"object_display_id"`

	// ObjectType The type of object that the Timeline entry belongs to.
	ObjectType *TimelineEntryObjectType `json:"object_type,omitempty"`

	// Panels Display panels for the Timeline entry.
	Panels *[]TimelineEntryPanel `json:"panels,omitempty"`

	// Reactions The reactions to the entry.
	Reactions *[]TimelineReaction `json:"reactions,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Thread Thread.
	Thread *TimelineThread `json:"thread,omitempty"`

	// Visibility The visibility of the entry. If 'private', then the entry is only
	// visible to the creator, 'internal' is visible with the Dev
	// organization, 'external' is visible to the Dev organzation and Rev
	// users, and 'public' is visible to all. If not set, then the default
	// visibility is 'external'.
	Visibility *TimelineEntryVisibility `json:"visibility,omitempty"`
}

// TimelineChangeEventCreated A creation event.
type TimelineChangeEventCreated struct {
	Object *AtomSummary `json:"object,omitempty"`
}

// TimelineChangeEventDeleted A deletion event.
type TimelineChangeEventDeleted struct {
	// ObjectId The ID correspending to the deleted object.
	ObjectId *string `json:"object_id,omitempty"`
}

// TimelineChangeEventEvent A timeline change event.
type TimelineChangeEventEvent struct {
	// Created A creation event.
	Created *TimelineChangeEventCreated `json:"created,omitempty"`

	// Deleted A deletion event.
	Deleted *TimelineChangeEventDeleted `json:"deleted,omitempty"`

	// Linked A linking event.
	Linked *TimelineChangeEventLinked `json:"linked,omitempty"`

	// Type The type of the event.
	Type *TimelineChangeEventEventType `json:"type,omitempty"`

	// Updated An update event.
	Updated *TimelineChangeEventUpdated `json:"updated,omitempty"`
}

// TimelineChangeEventEventType The type of the event.
type TimelineChangeEventEventType string

// TimelineChangeEventLinked A linking event.
type TimelineChangeEventLinked struct {
	Link *LinkSummary `json:"link,omitempty"`
}

// TimelineChangeEventSummary defines model for timeline-change-event-summary.
type TimelineChangeEventSummary = TimelineEntryBaseSummary

// TimelineChangeEventUpdated An update event.
type TimelineChangeEventUpdated struct {
	// FieldDeltas List of field changes.
	FieldDeltas *[]FieldDelta `json:"field_deltas,omitempty"`

	// ObjectType Type of DevRev object.
	ObjectType *string `json:"object_type,omitempty"`
}

// TimelineComment defines model for timeline-comment.
type TimelineComment struct {
	// Artifacts The artifacts for the comment.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body The comment's body. If the comment has been deleted, then no body
	// will appear in the response.
	Body *string `json:"body,omitempty"`

	// BodyType The type of the body to use for the comment.
	BodyType  *TimelineCommentBodyType `json:"body_type,omitempty"`
	CreatedBy *UserSummary             `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ExternalRef An external reference that's associated with the Timeline entry
	// that's guaranteed to be unique among its siblings.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Labels Labels that are associated with the Timeline entry.
	Labels     *[]string    `json:"labels,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Object The object that the Timeline entry belongs to.
	Object string `json:"object"`

	// ObjectDisplayId The display ID of the object that the Timeline entry belongs to.
	ObjectDisplayId string `json:"object_display_id"`

	// ObjectType The type of object that the Timeline entry belongs to.
	ObjectType *TimelineEntryObjectType `json:"object_type,omitempty"`

	// Panels Display panels for the Timeline entry.
	Panels *[]TimelineEntryPanel `json:"panels,omitempty"`

	// Reactions The reactions to the entry.
	Reactions *[]TimelineReaction `json:"reactions,omitempty"`

	// References Summary information about objects that are referenced in the
	// comment.
	References *[]AtomSummary `json:"references,omitempty"`

	// SnapKitBody Snap Kit Body of the comment.
	SnapKitBody *TimelineSnapKitBody `json:"snap_kit_body,omitempty"`

	// SnapWidgetBody The snap widget body of the comment.
	SnapWidgetBody *[]SnapWidget `json:"snap_widget_body,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Thread Thread.
	Thread *TimelineThread `json:"thread,omitempty"`

	// Visibility The visibility of the entry. If 'private', then the entry is only
	// visible to the creator, 'internal' is visible with the Dev
	// organization, 'external' is visible to the Dev organzation and Rev
	// users, and 'public' is visible to all. If not set, then the default
	// visibility is 'external'.
	Visibility *TimelineEntryVisibility `json:"visibility,omitempty"`
}

// TimelineCommentBodyType The type of the body to use for the comment.
type TimelineCommentBodyType string

// TimelineCommentSummary defines model for timeline-comment-summary.
type TimelineCommentSummary = TimelineEntryBaseSummary

// TimelineEntriesCollection Describes collections of timeline entries.
type TimelineEntriesCollection string

// TimelineEntriesCreateRequest The request to create a timeline entry for an object.
type TimelineEntriesCreateRequest struct {
	// Collections The collection(s) that the entry belongs to, otherwise if not
	// provided, then the entry's default collection is used.
	Collections *[]TimelineEntriesCollection `json:"collections,omitempty"`

	// ExpiresAt If set, then the entry is ephemeral and will be deleted after the
	// provided time. The minimum value should be at least a minute more
	// than the current timestamp.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Labels The labels to be associated with the entry.
	Labels *[]string `json:"labels,omitempty"`

	// Object The ID of the object to create the timeline entry for.
	Object string `json:"object"`

	// PrivateTo If the visibility of the entry is private, this specifies the users
	// that the entry is private to. Note the creator is always implicitly
	// included in this list.
	PrivateTo *[]string                        `json:"private_to,omitempty"`
	Type      TimelineEntriesCreateRequestType `json:"type"`

	// Visibility The visibility of the entry. If 'private', then the entry is only
	// visible to the creator, 'internal' is visible with the Dev
	// organization, 'external' is visible to the Dev organzation and Rev
	// users, and 'public' is visible to all. If not set, then the default
	// visibility is 'external'.
	Visibility *TimelineEntryVisibility `json:"visibility,omitempty"`
	union      json.RawMessage
}

// TimelineEntriesCreateRequestTimelineComment defines model for timeline-entries-create-request-timeline-comment.
type TimelineEntriesCreateRequestTimelineComment struct {
	// Artifacts The IDs of the artifacts attached to the comment.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Body The comment's body.
	Body *string `json:"body,omitempty"`

	// BodyType The type of the body to use for the comment.
	BodyType *TimelineCommentBodyType `json:"body_type,omitempty"`

	// ExternalRef The external reference for the comment. This must be unique within
	// the object's timeline.
	ExternalRef *string `json:"external_ref,omitempty"`

	// LinkPreviews The IDs of the previews of the links posted in the comment.
	LinkPreviews *[]string `json:"link_previews,omitempty"`

	// SnapKitBody Snap Kit Body of the comment.
	SnapKitBody *TimelineSnapKitBody `json:"snap_kit_body,omitempty"`

	// SnapWidgetBody The snap widget body of the comment.
	SnapWidgetBody *[]string `json:"snap_widget_body,omitempty"`
}

// TimelineEntriesCreateRequestType defines model for timeline-entries-create-request-type.
type TimelineEntriesCreateRequestType string

// TimelineEntriesCreateResponseBody The response to creating a timeline entry for an object.
type TimelineEntriesCreateResponseBody struct {
	TimelineEntry TimelineEntry `json:"timeline_entry"`
}

// TimelineEntriesDeleteRequest The request to delete a timeline entry from an object.
type TimelineEntriesDeleteRequest struct {
	// Id The ID of the timeline entry to delete.
	Id string `json:"id"`
}

// TimelineEntriesDeleteResponseBody The response to deleting a timeline entry from an object.
type TimelineEntriesDeleteResponseBody = map[string]interface{}

// TimelineEntriesGetRequest The request to get a timeline entry.
type TimelineEntriesGetRequest struct {
	// ExternalRef If set, then gets the entry with the given external reference for
	// the provided entry ID's timeline.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Id The ID of the timeline entry to get.
	Id string `json:"id"`
}

// TimelineEntriesGetResponseBody The request to getting a timeline entry.
type TimelineEntriesGetResponseBody struct {
	TimelineEntry TimelineEntry `json:"timeline_entry"`
}

// TimelineEntriesListRequest The request to list timeline entries for an object.
type TimelineEntriesListRequest struct {
	// Collections The collection(s) to list entries from, otherwise if not provided,
	// all entries are returned.
	Collections *[]TimelineEntriesCollection `json:"collections,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Labels Filters for entries containing at least one of the provided labels,
	// otherwise if no labels are provided, then no label filtering is
	// done.
	Labels *[]string `json:"labels,omitempty"`

	// Limit The maximum number of entries to return. If not set, then this
	// defaults to `50`.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// Object The ID of the object to list timeline entries for.
	Object string `json:"object"`

	// Visibility The visibility of the timeline entries to filter for. Note this is
	// a strict filter, such that only entries with the exact visibilities
	// specified will be returned.
	Visibility *[]TimelineEntryVisibility `json:"visibility,omitempty"`
}

// TimelineEntriesListResponseBody The response to listing timeline entries for an object.
type TimelineEntriesListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// TimelineEntries The timeline entries for the object.
	TimelineEntries []TimelineEntry `json:"timeline_entries"`
}

// TimelineEntriesUpdateRequest The request to update a timeline entry.
type TimelineEntriesUpdateRequest struct {
	// Id The ID of the timeline entry to update.
	Id    string                           `json:"id"`
	Type  TimelineEntriesUpdateRequestType `json:"type"`
	union json.RawMessage
}

// TimelineEntriesUpdateRequestTimelineComment defines model for timeline-entries-update-request-timeline-comment.
type TimelineEntriesUpdateRequestTimelineComment struct {
	Artifacts *TimelineEntriesUpdateRequestTimelineCommentArtifacts `json:"artifacts,omitempty"`

	// Body The updated comment's body.
	Body *string `json:"body,omitempty"`

	// BodyType The type of the body to use for the comment.
	BodyType *TimelineCommentBodyType `json:"body_type,omitempty"`

	// ExternalRef The updated external reference for the comment. If set, this must
	// be unique within the object's timeline, otherwise if null, then
	// clears the value.
	ExternalRef  *string                                                  `json:"external_ref"`
	LinkPreviews *TimelineEntriesUpdateRequestTimelineCommentLinkPreviews `json:"link_previews,omitempty"`

	// SnapKitBody Snap Kit Body of the comment.
	SnapKitBody *TimelineSnapKitBody `json:"snap_kit_body,omitempty"`
}

// TimelineEntriesUpdateRequestTimelineCommentArtifacts defines model for timeline-entries-update-request-timeline-comment-artifacts.
type TimelineEntriesUpdateRequestTimelineCommentArtifacts struct {
	// Add Adds the provided artifacts to the comment. An artifact cannot be
	// added more than once, i.e. nothing is done if the artifact is
	// already attached. Mutually exclusive with `set`.
	Add *[]string `json:"add,omitempty"`

	// Remove Removes the provided artifacts from the comment. If an artifact is
	// not present, then it's ignored. Mututally exclusive with `set`.
	Remove *[]string `json:"remove,omitempty"`

	// Set Sets the field to the provided artifacts.
	Set *[]string `json:"set,omitempty"`
}

// TimelineEntriesUpdateRequestTimelineCommentLinkPreviews defines model for timeline-entries-update-request-timeline-comment-link-previews.
type TimelineEntriesUpdateRequestTimelineCommentLinkPreviews struct {
	// Add Adds the provided link previews to the comment. A link preview
	// cannot be added more than once, i.e. nothing is done if the link
	// preview is already present. Mutually exclusive with `set`.
	Add *[]string `json:"add,omitempty"`

	// Remove Removes the provided link previews from the comment. If a link
	// preview is not present, then it's ignored. Mutually exclusive with
	// `set`.
	Remove *[]string `json:"remove,omitempty"`

	// Set Set the link previews to the provided IDs.
	Set *[]string `json:"set,omitempty"`
}

// TimelineEntriesUpdateRequestType defines model for timeline-entries-update-request-type.
type TimelineEntriesUpdateRequestType string

// TimelineEntriesUpdateResponseBody The response to updating a timeline entry.
type TimelineEntriesUpdateResponseBody struct {
	TimelineEntry TimelineEntry `json:"timeline_entry"`
}

// TimelineEntry defines model for timeline-entry.
type TimelineEntry struct {
	Type  TimelineEntryType `json:"type"`
	union json.RawMessage
}

// TimelineEntryBase defines model for timeline-entry-base.
type TimelineEntryBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// ExternalRef An external reference that's associated with the Timeline entry
	// that's guaranteed to be unique among its siblings.
	ExternalRef *string `json:"external_ref,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Labels Labels that are associated with the Timeline entry.
	Labels     *[]string    `json:"labels,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Object The object that the Timeline entry belongs to.
	Object string `json:"object"`

	// ObjectDisplayId The display ID of the object that the Timeline entry belongs to.
	ObjectDisplayId string `json:"object_display_id"`

	// ObjectType The type of object that the Timeline entry belongs to.
	ObjectType *TimelineEntryObjectType `json:"object_type,omitempty"`

	// Panels Display panels for the Timeline entry.
	Panels *[]TimelineEntryPanel `json:"panels,omitempty"`

	// Reactions The reactions to the entry.
	Reactions *[]TimelineReaction `json:"reactions,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Thread Thread.
	Thread *TimelineThread `json:"thread,omitempty"`

	// Visibility The visibility of the entry. If 'private', then the entry is only
	// visible to the creator, 'internal' is visible with the Dev
	// organization, 'external' is visible to the Dev organzation and Rev
	// users, and 'public' is visible to all. If not set, then the default
	// visibility is 'external'.
	Visibility *TimelineEntryVisibility `json:"visibility,omitempty"`
}

// TimelineEntryBaseSummary defines model for timeline-entry-base-summary.
type TimelineEntryBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`
}

// TimelineEntryObjectType The type of object that the Timeline entry belongs to.
type TimelineEntryObjectType string

// TimelineEntryPanel Display panels for the Timeline entry.
type TimelineEntryPanel string

// TimelineEntryType defines model for timeline-entry-type.
type TimelineEntryType string

// TimelineEntryVisibility The visibility of the entry. If 'private', then the entry is only
// visible to the creator, 'internal' is visible with the Dev
// organization, 'external' is visible to the Dev organzation and Rev
// users, and 'public' is visible to all. If not set, then the default
// visibility is 'external'.
type TimelineEntryVisibility string

// TimelineReaction Reaction.
type TimelineReaction struct {
	// Emoji The reaction emoji's unicode codepoint, e.g. "1f44d".
	Emoji *string `json:"emoji,omitempty"`

	// Reacted Whether the requesting user reacted.
	Reacted *bool `json:"reacted,omitempty"`

	// TotalUsers The total number of users with this reaction.
	TotalUsers *int32 `json:"total_users,omitempty"`
}

// TimelineSnapKitBody Snap Kit Body of the comment.
type TimelineSnapKitBody struct {
	// Body The JSON body of the SnapKit.
	Body *map[string]interface{} `json:"body,omitempty"`

	// SnapInActionName The name of an action defined in the SnapIn. The combination of
	// snap_in_id and snap_in_action_name uniquely identifies the
	// interaction object which is to be called when actions on a snapkit
	// element is taken.
	SnapInActionName *string `json:"snap_in_action_name,omitempty"`

	// SnapInId ID of the snap-in which created the SnapKit.
	SnapInId *string `json:"snap_in_id,omitempty"`
}

// TimelineThread Thread.
type TimelineThread struct {
	// TotalReplies The total number of replies in the thread.
	TotalReplies *int32 `json:"total_replies,omitempty"`
}

// TrackEvent defines model for track-event.
type TrackEvent struct {
	// ClientContext Properties of client to be used in track API.
	ClientContext *ClientContext `json:"client_context,omitempty"`

	// EventId Unique ID for the event.
	EventId *string `json:"event_id,omitempty"`

	// EventTime The timestamp at which the event occurred.
	EventTime *time.Time `json:"event_time,omitempty"`

	// Name Name of the event.
	Name string `json:"name"`

	// Payload Payload of the event
	Payload map[string]interface{} `json:"payload"`
}

// TrackEventsPublishRequest defines model for track-events-publish-request.
type TrackEventsPublishRequest struct {
	EventsList []TrackEvent `json:"events_list"`
}

// TrackEventsPublishResponseBody defines model for track-events-publish-response.
type TrackEventsPublishResponseBody = map[string]interface{}

// TuringSources defines model for turing-sources.
type TuringSources struct {
	Type  TuringSourcesType `json:"type"`
	union json.RawMessage
}

// TuringSourcesType defines model for turing-sources-type.
type TuringSourcesType string

// Unit Unit encapsulates the name of the unit and the type of the unit. For
// example, '#Number of API calls' where name is 'number_of_api_calls' and
// type is 'number'.
type Unit struct {
	// Name This represents human readable unit name of the UOM For example,
	// number of API calls.
	Name string `json:"name"`

	// Type This defines the UOM unit type. For example, for 'number of video
	// calls', unit type will be a number.
	Type UnitType `json:"type"`
}

// UnitSummary Unit encapsulates the name of the unit and the type of the unit. For
// example, '#Number of API calls' where name is 'number_of_api_calls' and
// type is 'number'.
type UnitSummary struct {
	// Name This represents human readable unit name of the UOM For example,
	// number of API calls.
	Name string `json:"name"`

	// Type This defines the UOM unit type. For example, for 'number of video
	// calls', unit type will be a number.
	Type UnitType `json:"type"`
}

// UnitType This defines the UOM unit type. For example, for 'number of video
// calls', unit type will be a number.
type UnitType string

// UnlinkRevUserFromRevOrgRequest Request to unlink/remove a Rev user from a Rev organization.
type UnlinkRevUserFromRevOrgRequest struct {
	// Id The ID of the Rev user.
	Id *string `json:"id,omitempty"`

	// RevOrg The ID of the Rev organization to unlink the Rev user from.
	RevOrg *string `json:"rev_org,omitempty"`

	// RevOrgDon The don of the rev org to unlink the rev user from. This is
	// deprecated, use rev_org instead.
	// Deprecated:
	RevOrgDon *string `json:"rev_org_don,omitempty"`

	// UserDon The don of the rev user to unlink. This is deprecated, use id
	// instead.
	// Deprecated:
	UserDon *string `json:"user_don,omitempty"`
}

// UnlinkRevUserFromRevOrgResponseBody Response for unlinking/removing a Rev user from a Rev organization.
type UnlinkRevUserFromRevOrgResponseBody struct {
	RevUser RevUser `json:"rev_user"`
}

// Uom defines model for uom.
type Uom struct {
	// AggregationDetails Stores aggregation type and dimension information.
	AggregationDetails AggregationDetail `json:"aggregation_details"`
	CreatedBy          *UserSummary      `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the UOM.
	Description *string `json:"description,omitempty"`

	// Dimensions The list of dimensions that can be emitted along with the metering
	// data.
	Dimensions *[]string `json:"dimensions,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsEnabled If set to true, then the UOM can be configured as part of
	// entitlements in skus and metering data only for the enabled uoms
	// will be passed through the metering pipeline.
	IsEnabled bool `json:"is_enabled"`

	// MetricName Human readable metric name of the UOM.
	MetricName string `json:"metric_name"`

	// MetricScope The granularity at which the metrics ingestion data is to be emitted
	// for the UOM.
	MetricScope UomMetricScope `json:"metric_scope"`
	ModifiedBy  *UserSummary   `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name Human readable name of the UOM.
	Name    string       `json:"name"`
	Part    *PartSummary `json:"part,omitempty"`
	Product PartSummary  `json:"product"`

	// Unit Unit encapsulates the name of the unit and the type of the unit. For
	// example, '#Number of API calls' where name is 'number_of_api_calls' and
	// type is 'number'.
	Unit Unit `json:"unit"`
}

// UomMetricScope The granularity at which the metrics ingestion data is to be emitted
// for the UOM.
type UomMetricScope string

// UomSummary defines model for uom-summary.
type UomSummary struct {
	// AggregationDetails Stores aggregation type and dimension information.
	AggregationDetails AggregationDetailSummary `json:"aggregation_details"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// MetricName Human readable metric name of the UOM.
	MetricName string `json:"metric_name"`

	// Name Human readable name of the UOM.
	Name string `json:"name"`

	// Unit Unit encapsulates the name of the unit and the type of the unit. For
	// example, '#Number of API calls' where name is 'number_of_api_calls' and
	// type is 'number'.
	Unit UnitSummary `json:"unit"`
}

// UomsCountRequest defines model for uoms-count-request.
type UomsCountRequest struct {
	// AggregationTypes List of aggregation types for filtering list of UOMs.
	AggregationTypes *[]AggregationDetailAggregationType `json:"aggregation_types,omitempty"`

	// Ids List of Unit of Measurement (UOM) DONs to be used in filtering
	// complete list of UOMs defined in a Dev Org.
	Ids *[]string `json:"ids,omitempty"`

	// MetricNames List of metric names for filtering list of UOMs.
	MetricNames *[]string `json:"metric_names,omitempty"`

	// PartIds List of part IDs for filtering list of UOMs.
	PartIds *[]string `json:"part_ids,omitempty"`

	// ProductIds List of product IDs for filtering list of UOMs.
	ProductIds *[]string `json:"product_ids,omitempty"`

	// UnitTypes List of unit types for filtering list of UOMs.
	UnitTypes *[]UnitType `json:"unit_types,omitempty"`
}

// UomsCountResponseBody defines model for uoms-count-response.
type UomsCountResponseBody struct {
	// Count Count of Unit of Measurements matching the filter.
	Count int32 `json:"count"`
}

// UomsCreateRequest defines model for uoms-create-request.
type UomsCreateRequest struct {
	// AggregationDetail Stores aggregation type and dimension information.
	AggregationDetail AggregationDetail `json:"aggregation_detail"`

	// Description Description of the Unit of Measurement (UOM).
	Description *string `json:"description,omitempty"`

	// Dimensions The list of dimensions that can be emitted as part of metrics data.
	// Dimensions consist of list of key-value pairs. For example, if the
	// UOM is 'number_of_api_calls', then dimensions can be ['api_name',
	// 'api_version'].Dimension keys can only contain alphanumeric
	// characters (A-Z, a-z, and 0-9) and underscores (_). Dimension keys
	// cannot start with a number and is case-insensitive.Dimension keys
	// must be unique and it is not allowed to have more than one value
	// with the same key.Metrics data ingested in DevRev metrics format
	// will be grouped and aggregated based on the dimensions specified in
	// UOM.
	Dimensions *[]string `json:"dimensions,omitempty"`

	// MetricName Name of the Unit of Measurement (UOM). Unit of Measurement is a
	// unit of measure defined over a part offered by a Dev Org. A single
	// part can have multiple unit of measurements defined over it. For
	// example, a part can be 'video call', one UOM defined on this can be
	// 'number_of_calls', other UOM can be 'call_duration' etc.Metric name
	// should be unique across all UOMs in a Dev Org.Metric name can only
	// contain alphanumeric characters (A-Z, a-z, and 0-9) and underscores
	// (_). Metric name cannot start with a number and is
	// case-insensitive.
	MetricName string `json:"metric_name"`

	// Name Human readable name of the Unit of Measurement (UOM).
	Name string `json:"name"`

	// PartId The part ID for which the Unit of Measurement (UOM) is defined.
	// When defined, ingested metrics data will be associated with part
	// and product specified in UOM.
	PartId *string `json:"part_id,omitempty"`

	// ProductId The product ID for which the Unit of Measurement (UOM) is defined.
	ProductId string `json:"product_id"`

	// Unit Unit encapsulates the name of the unit and the type of the unit. For
	// example, '#Number of API calls' where name is 'number_of_api_calls' and
	// type is 'number'.
	Unit Unit `json:"unit"`
}

// UomsCreateResponseBody defines model for uoms-create-response.
type UomsCreateResponseBody struct {
	Uom Uom `json:"uom"`
}

// UomsDeleteRequest defines model for uoms-delete-request.
type UomsDeleteRequest struct {
	// Id The Unit of Measurement (UOM)'s DON.
	Id string `json:"id"`
}

// UomsGetRequest defines model for uoms-get-request.
type UomsGetRequest struct {
	// Id The Unit of Measurement (UOM)'s DON.
	Id string `json:"id"`
}

// UomsGetResponseBody defines model for uoms-get-response.
type UomsGetResponseBody struct {
	Uom Uom `json:"uom"`
}

// UomsListRequest defines model for uoms-list-request.
type UomsListRequest struct {
	// AggregationTypes List of aggregation types for filtering list of UOMs.
	AggregationTypes *[]AggregationDetailAggregationType `json:"aggregation_types,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Ids List of Unit of Measurement (UOM) DONs to be used in filtering
	// complete list of UOMs defined in a Dev Org.
	Ids *[]string `json:"ids,omitempty"`

	// Limit The maximum number of UOMs to be returned in a response. The
	// default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// MetricNames List of metric names for filtering list of UOMs.
	MetricNames *[]string `json:"metric_names,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// PartIds List of part IDs for filtering list of UOMs.
	PartIds *[]string `json:"part_ids,omitempty"`

	// ProductIds List of product IDs for filtering list of UOMs.
	ProductIds *[]string `json:"product_ids,omitempty"`

	// SortBy Fields to sort the Unit Of Measuments (UOMs) by and the direction
	// to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// UnitTypes List of unit types for filtering list of UOMs.
	UnitTypes *[]UnitType `json:"unit_types,omitempty"`
}

// UomsListResponseBody defines model for uoms-list-response.
type UomsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Uoms The list of Unit of Measurement (UOM) objects.
	Uoms []Uom `json:"uoms"`
}

// UomsUpdateRequest defines model for uoms-update-request.
type UomsUpdateRequest struct {
	// AggregationType Aggregation type to be used while aggregating the metering data for the
	// UOM. 1] Sum - sum of all the values for the meter in a given period Ex.
	// { M1:2, M1:4 } => {M1:6} 2] Minimum - min of all the values for the
	// meter in a given period Ex. { M1:2, M1:4 } => {M1:2} 3] Maximum - max
	// of all the values for the meter in a given period Ex. { M1:2, M1:4 } =>
	// {M1:4} 4] Unique Count - Sum of distinct unique dimension observed for
	// the meter in the given period (not considering the data from the
	// previous billing period) Ex. January {M1:{VM:VM0}}, February
	// {M1:{VM:VM1}, M1:{VM:VM2}, M1:{VM:VM1}} => {M1:2} 5] Running Total -
	// Sum of distinct active unique dimension observed for a meter in the
	// given period, taking into consideration the active data from the
	// previous billing cycle Ex. January {M1:{VM:VM0,on}, {M1:{VM:VM1,off}
	// February {M1:{VM:VM2, on}, M1:{VM:VM2, off}, M1:{VM:VM3, on}} => {M1:3}
	// 6] Duration - Sum of distinct active unique dimension duration for a
	// meter in the given period, taking into consideration the active data
	// from the previous month Ex. January15 {M1:{VM:VM0,on, 4}} February15
	// {M1:{VM:VM0,off}, February18 {M1:{VM:VM1,on,5} => M1->
	// 30*4*charge_per_day + 10*5*charge_per_day 7] Latest - consider the
	// latest/last meter in the given period 8] Oldest - consider the
	// oldest/first record in the given period.
	AggregationType *AggregationDetailAggregationType `json:"aggregation_type,omitempty"`

	// Description Description of the Unit of Measurement (UOM).
	Description *string                      `json:"description,omitempty"`
	Dimensions  *UomsUpdateRequestDimensions `json:"dimensions,omitempty"`

	// Id The Unit of Measurement (UOM)'s DON.
	Id string `json:"id"`

	// IsEnabled Flag used to enable/disable the Unit of Measurement (UOM). When
	// disabled, any metricsrecords ingested against this UOM will be
	// dropped.
	IsEnabled *bool `json:"is_enabled,omitempty"`

	// Name Human readable name of the Unit of Measurement (UOM).
	Name *string `json:"name,omitempty"`

	// PartId The part ID such as feature or capability for which the Unit of
	// Measurement (UOM) is defined.
	PartId *string `json:"part_id,omitempty"`

	// ProductId The product ID for which the Unit of Measurement (UOM) is defined.
	ProductId *string `json:"product_id,omitempty"`

	// Unit Unit name of the Unit of Measurement (UOM).
	Unit *string `json:"unit,omitempty"`
}

// UomsUpdateRequestDimensions defines model for uoms-update-request-dimensions.
type UomsUpdateRequestDimensions struct {
	// Add Adds the provided dimensions to the UOM.
	Add *[]string `json:"add,omitempty"`

	// Remove Removes the provided dimensions from the UOM.
	Remove *[]string `json:"remove,omitempty"`
}

// UomsUpdateResponseBody defines model for uoms-update-response.
type UomsUpdateResponseBody struct {
	Uom Uom `json:"uom"`
}

// UpdateAvailabilityPreferencesGroup Update object for AvailabilityPreferencesGroup.
type UpdateAvailabilityPreferencesGroup struct {
	// ManualAway Manually set presence to away
	ManualAway *bool `json:"manual_away,omitempty"`
}

// UpdateCommandAction defines model for update-command-action.
type UpdateCommandAction struct {
	ActionDetails *UpdateCommandActionDetails `json:"action_details,omitempty"`

	// Artifacts IDs of the new artifact items
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Code The raw code to execute, defined in the language specified by
	// executor
	Code *string `json:"code,omitempty"`

	// ExecutorConfig Executor specific config
	ExecutorConfig *map[string]interface{} `json:"executor_config,omitempty"`

	// Message The message to populate in discussion box, when the command is
	// selected to execute.
	Message *string `json:"message,omitempty"`

	// SnapInFunctionId Function containing logic for the command. If function ID is
	// specified the executor config is ignored and command is executed by
	// functions.
	SnapInFunctionId *string `json:"snap_in_function_id,omitempty"`

	// TemplateType The template engine for resolving message.
	TemplateType *CommandActionTemplateType `json:"template_type,omitempty"`
}

// UpdateCommandActionDetails defines model for update-command-action-details.
type UpdateCommandActionDetails struct {
	// ObjectUpdatePayload The payload to update the object in context upon command execution.
	ObjectUpdatePayload *map[string]interface{} `json:"object_update_payload,omitempty"`
}

// UpdateCommandSurface defines model for update-command-surface.
type UpdateCommandSurface struct {
	// ObjectTypes Objects types on which a command can be invoked
	ObjectTypes *[]CommandSurfaceObjectTypes `json:"object_types,omitempty"`

	// Surface Surfaces from where this command can be invoked.
	Surface *CommandSurfaceSurface `json:"surface,omitempty"`
}

// UpdateExternalSourceDataComp defines model for update-external-source-data-comp.
type UpdateExternalSourceDataComp struct {
	// ClosedDate Timestamp when the object was closed in the source system.
	ClosedDate *time.Time `json:"closed_date,omitempty"`

	// CreatedDate Timestamp when the object was created in the source system.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// ModifiedDate Timestamp when the object was modified in the source system.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// UpdateGeneralPreferencesGroup Update object for GeneralPreferencesGroup.
type UpdateGeneralPreferencesGroup struct {
	// Availability Update object for AvailabilityPreferencesGroup.
	Availability *UpdateAvailabilityPreferencesGroup `json:"availability,omitempty"`

	// PreferredLocale Preferred locale of the user
	PreferredLocale *string `json:"preferred_locale,omitempty"`
}

// UpdateImpactedCustomerDetails defines model for update-impacted-customer-details.
type UpdateImpactedCustomerDetails struct {
	// Count Count of customers impacted.
	Count       *int64                                    `json:"count,omitempty"`
	CustomerIds *UpdateImpactedCustomerDetailsCustomerIds `json:"customer_ids,omitempty"`
}

// UpdateImpactedCustomerDetailsCustomerIds defines model for update-impacted-customer-details-customer-ids.
type UpdateImpactedCustomerDetailsCustomerIds struct {
	// Set Sets the list of customers impacted due to the incident.
	Set *[]string `json:"set,omitempty"`
}

// UpdateIncidentAppliesToParts defines model for update-incident-applies-to-parts.
type UpdateIncidentAppliesToParts struct {
	// Set Sets the parts to which the incident is applicable to.
	Set *[]string `json:"set,omitempty"`
}

// UpdateIncidentArtifacts defines model for update-incident-artifacts.
type UpdateIncidentArtifacts struct {
	// Set Sets the artifacts attached to the incident.
	Set *[]string `json:"set,omitempty"`
}

// UpdateIncidentOwnedBy defines model for update-incident-owned-by.
type UpdateIncidentOwnedBy struct {
	// Set Sets the user IDs of the users that own the incident.
	Set *[]string `json:"set,omitempty"`
}

// UpdateIncidentPia defines model for update-incident-pia.
type UpdateIncidentPia struct {
	// Set Sets the the article ids of the Post-Incident Analysis(PIA) of the
	// incident.
	Set *[]string `json:"set,omitempty"`
}

// UpdateIncidentPlaybooks defines model for update-incident-playbooks.
type UpdateIncidentPlaybooks struct {
	// Set Sets the the article ids of the playbook(s) associated with the
	// incident.
	Set *[]string `json:"set,omitempty"`
}

// UpdateIncidentRelatedDocs defines model for update-incident-related-docs.
type UpdateIncidentRelatedDocs struct {
	// Set Sets the the article ids of other documents associated with the
	// incident.
	Set *[]string `json:"set,omitempty"`
}

// UpdateIncidentTags defines model for update-incident-tags.
type UpdateIncidentTags struct {
	// Set Sets the tags associated with the object.
	Set *[]UpdateTagWithValue `json:"set,omitempty"`
}

// UpdateStage Update object for Stage.
type UpdateStage struct {
	// Notes Notes relevant to the stage
	Notes *string `json:"notes,omitempty"`

	// Stage DON of the stage.
	Stage *string `json:"stage,omitempty"`
}

// UpdateStageNode defines model for update-stage-node.
type UpdateStageNode struct {
	// IsDeprecated Whether this stage is deprecated.
	IsDeprecated *bool `json:"is_deprecated,omitempty"`

	// IsStart Whether this is the start stage.
	IsStart *bool `json:"is_start,omitempty"`

	// StageId The ID of the stage.
	StageId string `json:"stage_id"`

	// Transitions List of transitions from this stage.
	Transitions *[]UpdateStageTransition `json:"transitions,omitempty"`
}

// UpdateStageTransition defines model for update-stage-transition.
type UpdateStageTransition struct {
	// TargetStageId The ID of the target stage.
	TargetStageId string                 `json:"target_stage_id"`
	Ui            *UpdateStageUiMetadata `json:"ui,omitempty"`
}

// UpdateStageUiMetadata defines model for update-stage-ui-metadata.
type UpdateStageUiMetadata struct {
	// IsHidden Whether the stage is hidden.
	IsHidden *bool `json:"is_hidden,omitempty"`
}

// UpdateStagedInfo Update object for StagedInfo.
type UpdateStagedInfo struct {
	// IsStaged Whether the record is staged and requires confirmation before
	// further processing
	IsStaged *bool `json:"is_staged,omitempty"`

	// SyncInUnresolvedFields A list of fields that have not been resolved while syncing from
	// external system of records to DevRev
	SyncInUnresolvedFields *[]UpdateStagedUnresolvedField `json:"sync_in_unresolved_fields,omitempty"`

	// SyncOutUnresolvedFields A list of fields that have not been resolved while syncing from
	// DevRev to external system of records
	SyncOutUnresolvedFields *[]UpdateStagedUnresolvedField `json:"sync_out_unresolved_fields,omitempty"`

	// UnresolvedFields A list of fields that have not been resolved, which is causing the
	// record to be staged
	UnresolvedFields *[]string `json:"unresolved_fields,omitempty"`
}

// UpdateStagedUnresolvedField Update object for StagedUnresolvedField.
type UpdateStagedUnresolvedField struct {
	// DevrevFieldName DevRev field name of the object's attribute.
	DevrevFieldName *string `json:"devrev_field_name,omitempty"`

	// ExternalDisplayName External field name as seen by the end user.
	ExternalDisplayName *string `json:"external_display_name,omitempty"`

	// ExternalFieldName Api name of the external object's field.
	ExternalFieldName *string `json:"external_field_name,omitempty"`
}

// UpdateSyncIn defines model for update-sync-in.
type UpdateSyncIn struct {
	// Status Status of the sync for the object.
	Status *SyncInStatus `json:"status,omitempty"`

	// SyncDate Timestamp when the object was synced in/from DevRev.
	SyncDate *time.Time `json:"sync_date,omitempty"`

	// SyncHistory Id of the sync_history when the object was synced.
	SyncHistory *string `json:"sync_history,omitempty"`

	// SyncUnit Id of the sync_unit to which the object belongs.
	SyncUnit *string `json:"sync_unit,omitempty"`
}

// UpdateSyncMetadata defines model for update-sync-metadata.
type UpdateSyncMetadata struct {
	// ExternalReference External record URL.
	ExternalReference *string        `json:"external_reference,omitempty"`
	LastSyncIn        *UpdateSyncIn  `json:"last_sync_in,omitempty"`
	LastSyncOut       *UpdateSyncOut `json:"last_sync_out,omitempty"`

	// OriginSystem Where the record was first created.
	OriginSystem *string `json:"origin_system,omitempty"`
}

// UpdateSyncOut defines model for update-sync-out.
type UpdateSyncOut struct {
	// Status Status of the sync for the object.
	Status *SyncOutStatus `json:"status,omitempty"`

	// SyncDate Timestamp when the object was synced in/from DevRev.
	SyncDate *time.Time `json:"sync_date,omitempty"`

	// SyncHistory Id of the sync_history when the object was synced.
	SyncHistory *string `json:"sync_history,omitempty"`

	// SyncUnit Id of the sync_unit to which the object belongs.
	SyncUnit *string `json:"sync_unit,omitempty"`
}

// UpdateTagWithValue Update object for TagWithValue.
type UpdateTagWithValue struct {
	// TagId ID of the referenced tag
	TagId *string `json:"tag_id,omitempty"`

	// Value Value associated with the tag for the object.
	Value *string `json:"value,omitempty"`
}

// UpdateUserPreferences Update object for UserPreferences.
type UpdateUserPreferences struct {
	// GeneralPreferences Update object for GeneralPreferencesGroup.
	GeneralPreferences *UpdateGeneralPreferencesGroup `json:"general_preferences,omitempty"`
}

// UserBase defines model for user-base.
type UserBase struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// PhoneNumbers Phone numbers of the user.
	PhoneNumbers    *[]string    `json:"phone_numbers,omitempty"`
	PrimaryIdentity *UserSummary `json:"primary_identity,omitempty"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`
}

// UserBaseSummary defines model for user-base-summary.
type UserBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DisplayName The user's display name. The name is non-unique and mutable.
	DisplayName    *string          `json:"display_name,omitempty"`
	DisplayPicture *ArtifactSummary `json:"display_picture,omitempty"`

	// Email Email address of the user.
	Email *string `json:"email,omitempty"`

	// FullName Full name of the user.
	FullName *string `json:"full_name,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// State State of the user.
	State *UserState `json:"state,omitempty"`
}

// UserPreferences defines model for user-preferences.
type UserPreferences struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// GeneralPreferences Preferences group for General settings.
	GeneralPreferences *GeneralPreferencesGroup `json:"general_preferences,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`
}

// UserPreferencesSummary defines model for user-preferences-summary.
type UserPreferencesSummary = PreferencesBaseSummary

// UserSearchSummary defines model for user-search-summary.
type UserSearchSummary struct {
	// Comments Comments on the work.
	Comments *[]CommentSearchSummary `json:"comments,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string     `json:"snippet,omitempty"`
	User    UserSummary `json:"user"`
}

// UserSkill Skill associated with the user.
type UserSkill struct {
	// Name Name of the skill.
	Name *string `json:"name,omitempty"`
}

// UserState State of the user.
type UserState string

// UserSummary defines model for user-summary.
type UserSummary struct {
	Type  UserType `json:"type"`
	union json.RawMessage
}

// UserType defines model for user-type.
type UserType string

// ViewOverride UI hint overrides for a view.
type ViewOverride struct {
	// DisplayName The display name of the field.
	DisplayName *string `json:"display_name,omitempty"`

	// IsGroupable Whether the field is groupable in the UI.
	IsGroupable *bool `json:"is_groupable,omitempty"`

	// IsHidden Whether the field is hidden in the UI.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsRequired Whether the field is mandatory.
	IsRequired *bool `json:"is_required,omitempty"`

	// Placeholder A placeholder for the field.
	Placeholder *string `json:"placeholder,omitempty"`

	// Tooltip Tooltip for the field.
	Tooltip *string `json:"tooltip,omitempty"`

	// ViewName The name of the view.
	ViewName *string `json:"view_name,omitempty"`
}

// VistaBaseSummary defines model for vista-base-summary.
type VistaBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Name Name of the vista.
	Name string `json:"name"`
}

// VistaGroupItemState Defines the state of the group item.
type VistaGroupItemState string

// VistaGroupItemSummary Vista group item.
type VistaGroupItemSummary struct {
	// EndDate Timestamp when the vista ends.
	EndDate *time.Time `json:"end_date,omitempty"`

	// Id ID of the group item in don v2 format.
	Id string `json:"id"`

	// Name Name of the group.
	Name string `json:"name"`

	// StartDate Timestamp when the vista starts.
	StartDate *time.Time `json:"start_date,omitempty"`

	// State Defines the state of the group item.
	State *VistaGroupItemState `json:"state,omitempty"`

	// Type Type of the group object.
	Type VistaGroupItemType `json:"type"`
}

// VistaGroupItemType Type of the group object.
type VistaGroupItemType string

// VistaSearchSummary defines model for vista-search-summary.
type VistaSearchSummary struct {
	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string `json:"snippet,omitempty"`

	// Vista Represents a collection of DevRev objects.
	Vista VistaSummary `json:"vista"`
}

// VistaSummary Represents a collection of DevRev objects.
type VistaSummary struct {
	// Type Type of vista object.
	Type  VistaType `json:"type"`
	union json.RawMessage
}

// VistaType Type of vista object.
type VistaType string

// VisualizationAxisColor The color for an axis. This can be a single color or a gradient.
type VisualizationAxisColor struct {
	// KeyLookup The key lookup color.
	KeyLookup *[]VisualizationAxisColorKeyLookup `json:"key_lookup,omitempty"`

	// Static The static color.
	Static *string `json:"static,omitempty"`

	// Type The type of the color.
	Type VisualizationAxisColorType `json:"type"`
}

// VisualizationAxisColorKeyLookup The key lookup color for an axis. This is used to map a value to a
// color.
type VisualizationAxisColorKeyLookup struct {
	// Key The key to map to a color.
	Key string `json:"key"`

	// Value The color value.
	Value string `json:"value"`
}

// VisualizationAxisColorType The type of the color.
type VisualizationAxisColorType string

// VisualizationAxisDrillThrough The drill through configuration for an axis.
type VisualizationAxisDrillThrough = map[string]interface{}

// VisualizationScrollbar The scrollbar configuration for chart.
type VisualizationScrollbar = map[string]interface{}

// WebCrawlerJob defines model for web-crawler-job.
type WebCrawlerJob struct {
	// AcceptRegexs URL patterns to accept (an empty value means accept all URLs)
	// subject to explicit rejects (if any).
	AcceptRegexs *[]string    `json:"accept_regexs,omitempty"`
	CreatedBy    *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// Description Description of the web crawler job.
	Description *string `json:"description,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// DomainNames Domain names to crawl URLs for. If this field is not set, it is
	// inferred based on the domain names in the seed set of URLs.
	DomainNames *[]string `json:"domain_names,omitempty"`

	// Frequency Number of days between re-sync job runs.
	Frequency *int32 `json:"frequency,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// MaxDepth Specifies the maximum recursion depth from the seed URL that we
	// will crawl. If this value is -1, there is no limit on recursion
	// depth.
	MaxDepth   *int32       `json:"max_depth,omitempty"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// NoParent Specifies whether we should never ascend to the parent directory
	// when crawling from a seed set URL.
	NoParent *bool `json:"no_parent,omitempty"`

	// NotifyOnComplete Whether to notify via email.
	NotifyOnComplete *bool `json:"notify_on_complete,omitempty"`

	// NumBytes Number of bytes stored.
	NumBytes *int32 `json:"num_bytes,omitempty"`

	// NumTimeoutUrls Number of URLs that timed out.
	NumTimeoutUrls *int32 `json:"num_timeout_urls,omitempty"`

	// NumUrlsScraped Number of URLs whose webpage are scraped.
	NumUrlsScraped *int32 `json:"num_urls_scraped,omitempty"`

	// RejectRegexs URL patterns to reject (an empty value means no explicit
	// rejections).
	RejectRegexs *[]string `json:"reject_regexs,omitempty"`

	// SitemapIndexUrls Sitemap index URLs. The URLs in the referenced sitemaps add to the
	// seed set of URLs to crawl from.
	SitemapIndexUrls *[]string `json:"sitemap_index_urls,omitempty"`

	// SitemapUrls Sitemap URLs. The URLs in the sitemap add to the seed set of URLs
	// to crawl from.
	SitemapUrls *[]string `json:"sitemap_urls,omitempty"`

	// State State of the web crawler job.
	State *WebCrawlerJobState `json:"state,omitempty"`

	// Urls URLs to add to the seed set of URLs to crawl from.
	Urls *[]string `json:"urls,omitempty"`

	// UserAgent User agent to use for crawling websites in this job.
	UserAgent *string `json:"user_agent,omitempty"`
}

// WebCrawlerJobState State of the web crawler job.
type WebCrawlerJobState string

// WebCrawlerJobsControlRequest The request to resume a web crawler job.
type WebCrawlerJobsControlRequest struct {
	Action WebCrawlerJobsControlRequestAction `json:"action"`

	// Id The ID of the job.
	Id string `json:"id"`
}

// WebCrawlerJobsControlRequestAction defines model for web-crawler-jobs-control-request-action.
type WebCrawlerJobsControlRequestAction string

// WebCrawlerJobsControlResponseBody The response to resume a web crawler job.
type WebCrawlerJobsControlResponseBody struct {
	WebCrawlerJob WebCrawlerJob `json:"web_crawler_job"`
}

// WebCrawlerJobsCreateRequest The request to create a web crawler job which will create webpages as
// artifacts.
type WebCrawlerJobsCreateRequest struct {
	// AcceptRegex The regex a URL must satisfy to be crawled.
	// Deprecated:
	AcceptRegex *string `json:"accept_regex,omitempty"`

	// AcceptRegexes The list of regexes a URL must satisfy to be crawled.
	AcceptRegexes *[]string `json:"accept_regexes,omitempty"`

	// AppliesToParts The parts to which created webpage/articles during this crawler job
	// will be linked to.
	AppliesToParts []string `json:"applies_to_parts"`

	// Description The description of the job.
	Description *string `json:"description,omitempty"`

	// DomainNames The list of allowed domain names to crawl.
	DomainNames *[]string `json:"domain_names,omitempty"`

	// Frequency Number of days between re-sync job runs. If 0, the job will run
	// only once.
	Frequency *int32 `json:"frequency,omitempty"`

	// MaxDepth The maximum depth to crawl.
	MaxDepth *int32 `json:"max_depth,omitempty"`

	// NotifyOnComplete Whether to notify the user when the job is complete. Default is
	// true.
	NotifyOnComplete *bool `json:"notify_on_complete,omitempty"`

	// RejectRegex The regex which if satisfied by a URL results in rejection of the
	// URL. If a URL matches both accept and reject regexes, it is
	// rejected.
	// Deprecated:
	RejectRegex *string `json:"reject_regex,omitempty"`

	// RejectRegexes The list of regexes which if satisfied by a URL results in
	// rejection of the URL. If a URL matches both accept and reject
	// regexes, it is rejected.
	RejectRegexes *[]string `json:"reject_regexes,omitempty"`

	// SitemapIndexUrls The list of sitemap index URLs to crawl.
	SitemapIndexUrls *[]string `json:"sitemap_index_urls,omitempty"`

	// SitemapUrls The list of sitemap URLs to crawl.
	SitemapUrls *[]string `json:"sitemap_urls,omitempty"`

	// Urls The list of URLs to crawl.
	Urls *[]string `json:"urls,omitempty"`

	// UserAgent User agent to use for crawling websites in this job.
	UserAgent *string `json:"user_agent,omitempty"`
}

// WebCrawlerJobsCreateResponseBody The response to create a web crawler job.
type WebCrawlerJobsCreateResponseBody struct {
	WebCrawlerJob WebCrawlerJob `json:"web_crawler_job"`
}

// WebCrawlerJobsGetRequest The request to get a web crawler job.
type WebCrawlerJobsGetRequest struct {
	// Id The ID of the job.
	Id string `json:"id"`
}

// WebCrawlerJobsGetResponseBody The response to get a web crawler job.
type WebCrawlerJobsGetResponseBody struct {
	WebCrawlerJob WebCrawlerJob `json:"web_crawler_job"`
}

// WebCrawlerJobsListRequest The request to list web crawler jobs.
type WebCrawlerJobsListRequest struct {
	// CreatedBy Filters for web crawler jobs created by any of the provided users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of web crawler jobs to return. The default is
	// '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter `json:"modified_date,omitempty"`
}

// WebCrawlerJobsListResponseBody The response to list web crawler jobs.
type WebCrawlerJobsListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// WebCrawlerJobs The list of jobs.
	WebCrawlerJobs []WebCrawlerJob `json:"web_crawler_jobs"`
}

// Webhook defines model for webhook.
type Webhook struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// EventTypes The event types that the webhook will receive.
	EventTypes *[]WebhookEventType `json:"event_types,omitempty"`

	// Headers Headers that are provided with every webhook invocation.
	Headers *[]WebhookHeader `json:"headers,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Secret The secret to use for verifying webhook events.
	Secret []byte `json:"secret"`

	// Status The status of the webhook.
	Status WebhookStatus `json:"status"`

	// Url The URL of the webhook endpoint.
	Url string `json:"url"`
}

// WebhookEventRequest defines model for webhook-event-request.
type WebhookEventRequest struct {
	AccountCreated           *EventAccountCreated      `json:"account_created,omitempty"`
	AccountDeleted           *EventAccountDeleted      `json:"account_deleted,omitempty"`
	AccountUpdated           *EventAccountUpdated      `json:"account_updated,omitempty"`
	EventAiAgentResponseBody *EventAiAgentResponseBody `json:"ai_agent_response,omitempty"`
	ConversationCreated      *EventConversationCreated `json:"conversation_created,omitempty"`
	ConversationDeleted      *EventConversationDeleted `json:"conversation_deleted,omitempty"`
	ConversationUpdated      *EventConversationUpdated `json:"conversation_updated,omitempty"`
	DashboardCreated         *EventDashboardCreated    `json:"dashboard_created,omitempty"`
	DashboardDeleted         *EventDashboardDeleted    `json:"dashboard_deleted,omitempty"`
	DashboardUpdated         *EventDashboardUpdated    `json:"dashboard_updated,omitempty"`
	DevUserCreated           *EventDevUserCreated      `json:"dev_user_created,omitempty"`
	DevUserDeleted           *EventDevUserDeleted      `json:"dev_user_deleted,omitempty"`
	DevUserUpdated           *EventDevUserUpdated      `json:"dev_user_updated,omitempty"`
	GroupCreated             *EventGroupCreated        `json:"group_created,omitempty"`
	GroupDeleted             *EventGroupDeleted        `json:"group_deleted,omitempty"`
	GroupMemberAdded         *EventGroupMemberAdded    `json:"group_member_added,omitempty"`
	GroupMemberRemoved       *EventGroupMemberRemoved  `json:"group_member_removed,omitempty"`
	GroupUpdated             *EventGroupUpdated        `json:"group_updated,omitempty"`

	// Id The event's ID.
	Id                    string                      `json:"id"`
	IncidentCreated       *EventIncidentCreated       `json:"incident_created,omitempty"`
	IncidentDeleted       *EventIncidentDeleted       `json:"incident_deleted,omitempty"`
	IncidentUpdated       *EventIncidentUpdated       `json:"incident_updated,omitempty"`
	LinkCreated           *EventLinkCreated           `json:"link_created,omitempty"`
	LinkDeleted           *EventLinkDeleted           `json:"link_deleted,omitempty"`
	LinkUpdated           *EventLinkUpdated           `json:"link_updated,omitempty"`
	PartCreated           *EventPartCreated           `json:"part_created,omitempty"`
	PartDeleted           *EventPartDeleted           `json:"part_deleted,omitempty"`
	PartUpdated           *EventPartUpdated           `json:"part_updated,omitempty"`
	QuestionAnswerCreated *EventQuestionAnswerCreated `json:"question_answer_created,omitempty"`
	QuestionAnswerDeleted *EventQuestionAnswerDeleted `json:"question_answer_deleted,omitempty"`
	QuestionAnswerUpdated *EventQuestionAnswerUpdated `json:"question_answer_updated,omitempty"`
	RevOrgCreated         *EventRevOrgCreated         `json:"rev_org_created,omitempty"`
	RevOrgDeleted         *EventRevOrgDeleted         `json:"rev_org_deleted,omitempty"`
	RevOrgUpdated         *EventRevOrgUpdated         `json:"rev_org_updated,omitempty"`
	RevUserCreated        *EventRevUserCreated        `json:"rev_user_created,omitempty"`
	RevUserDeleted        *EventRevUserDeleted        `json:"rev_user_deleted,omitempty"`
	RevUserUpdated        *EventRevUserUpdated        `json:"rev_user_updated,omitempty"`
	SlaTrackerCreated     *EventSlaTrackerCreated     `json:"sla_tracker_created,omitempty"`
	SlaTrackerDeleted     *EventSlaTrackerDeleted     `json:"sla_tracker_deleted,omitempty"`
	SlaTrackerFetched     *EventSlaTrackerFetched     `json:"sla_tracker_fetched,omitempty"`
	SlaTrackerUpdated     *EventSlaTrackerUpdated     `json:"sla_tracker_updated,omitempty"`
	SurveyCreated         *EventSurveyCreated         `json:"survey_created,omitempty"`
	SurveyDeleted         *EventSurveyDeleted         `json:"survey_deleted,omitempty"`
	SurveyResponseCreated *EventSurveyResponseCreated `json:"survey_response_created,omitempty"`
	SurveyResponseDeleted *EventSurveyResponseDeleted `json:"survey_response_deleted,omitempty"`
	SurveyResponseUpdated *EventSurveyResponseUpdated `json:"survey_response_updated,omitempty"`
	SurveyUpdated         *EventSurveyUpdated         `json:"survey_updated,omitempty"`
	SyncHistoryCreated    *EventSyncHistoryCreated    `json:"sync_history_created,omitempty"`
	SyncHistoryDeleted    *EventSyncHistoryDeleted    `json:"sync_history_deleted,omitempty"`
	SyncHistoryUpdated    *EventSyncHistoryUpdated    `json:"sync_history_updated,omitempty"`
	TagCreated            *EventTagCreated            `json:"tag_created,omitempty"`
	TagDeleted            *EventTagDeleted            `json:"tag_deleted,omitempty"`
	TagUpdated            *EventTagUpdated            `json:"tag_updated,omitempty"`
	TimelineEntryCreated  *EventTimelineEntryCreated  `json:"timeline_entry_created,omitempty"`
	TimelineEntryDeleted  *EventTimelineEntryDeleted  `json:"timeline_entry_deleted,omitempty"`
	TimelineEntryUpdated  *EventTimelineEntryUpdated  `json:"timeline_entry_updated,omitempty"`

	// Timestamp Timestamp of the webhook's invocation for the event. Note this
	// should be used to protect against replay attacks, where the event
	// should only be processed if the timestamp isn't stale by several
	// seconds.
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Type The event types that the webhook will receive.
	Type           *WebhookEventType    `json:"type,omitempty"`
	Verify         *WebhookEventVerify  `json:"verify,omitempty"`
	WebhookCreated *EventWebhookCreated `json:"webhook_created,omitempty"`
	WebhookDeleted *EventWebhookDeleted `json:"webhook_deleted,omitempty"`

	// WebhookId ID of the webhook for the event.
	WebhookId      string               `json:"webhook_id"`
	WebhookUpdated *EventWebhookUpdated `json:"webhook_updated,omitempty"`
	WidgetCreated  *EventWidgetCreated  `json:"widget_created,omitempty"`
	WidgetDeleted  *EventWidgetDeleted  `json:"widget_deleted,omitempty"`
	WidgetUpdated  *EventWidgetUpdated  `json:"widget_updated,omitempty"`
	WorkCreated    *EventWorkCreated    `json:"work_created,omitempty"`
	WorkDeleted    *EventWorkDeleted    `json:"work_deleted,omitempty"`
	WorkFetched    *EventWorkFetched    `json:"work_fetched,omitempty"`
	WorkUpdated    *EventWorkUpdated    `json:"work_updated,omitempty"`
}

// WebhookEventResponseBody defines model for webhook-event-response.
type WebhookEventResponseBody struct {
	// Challenge The challenge from the "verify" request, otherwise this should not
	// be set for other request types.
	Challenge *[]byte `json:"challenge,omitempty"`
}

// WebhookEventType The event types that the webhook will receive.
type WebhookEventType string

// WebhookEventVerify defines model for webhook-event-verify.
type WebhookEventVerify struct {
	// Challenge The challenge that must be echoed in the response.
	Challenge []byte `json:"challenge"`
}

// WebhookHeader Defines a header that's provided with every webhook invocation.
type WebhookHeader struct {
	// Name The name of the header. Only alphanumeric ASCII characters,
	// hyphens, and underscores are permitted.
	Name string `json:"name"`

	// Value The header's value.
	Value string `json:"value"`
}

// WebhookStatus The status of the webhook.
type WebhookStatus string

// WebhookSummary defines model for webhook-summary.
type WebhookSummary = AtomBaseSummary

// WebhooksCreateRequest The request to create a new webhook.
type WebhooksCreateRequest struct {
	// EventTypes The event types that the webhook endpoint will receive.
	EventTypes *[]WebhookEventType `json:"event_types,omitempty"`

	// Headers The headers to include in every webhook invocation.
	Headers *[]WebhookHeader `json:"headers,omitempty"`

	// Secret The secret to use when verifying webhook events. If provided, the
	// secret must be between 8 and 32 bytes (inclusive). If not set, a
	// secret will be automatically generated and provided in the
	// response.
	Secret *[]byte `json:"secret,omitempty"`

	// Url The URL of the webhook endpoint.
	Url string `json:"url"`
}

// WebhooksCreateResponseBody The response to creating a new webhook.
type WebhooksCreateResponseBody struct {
	Webhook Webhook `json:"webhook"`
}

// WebhooksDeleteRequest The request to delete a webhook.
type WebhooksDeleteRequest struct {
	// Id ID for the webhook.
	Id string `json:"id"`
}

// WebhooksDeleteResponseBody The response to deleting the webhook.
type WebhooksDeleteResponseBody = map[string]interface{}

// WebhooksFetchRequest The request to fetch an object for a webhook.
type WebhooksFetchRequest struct {
	// Id The ID of the webhook to fetch the object for.
	Id string `json:"id"`

	// Object The ID of the object to fetch for the webhook.
	Object string `json:"object"`
}

// WebhooksFetchResponseBody The response to fetching an object for a webhook.
type WebhooksFetchResponseBody = map[string]interface{}

// WebhooksGetRequest The request to get a webhook's information.
type WebhooksGetRequest struct {
	// Id ID for the webhook.
	Id string `json:"id"`
}

// WebhooksGetResponseBody The response to getting the information for the webhook.
type WebhooksGetResponseBody struct {
	Webhook Webhook `json:"webhook"`
}

// WebhooksListRequest The request to list the webhooks.
type WebhooksListRequest = map[string]interface{}

// WebhooksListResponseBody The response to listing the webhooks.
type WebhooksListResponseBody struct {
	// Webhooks The list of webhooks.
	Webhooks []Webhook `json:"webhooks"`
}

// WebhooksUpdateAction The action to update the webhook's status.
type WebhooksUpdateAction string

// WebhooksUpdateRequest The request to update a webhook.
type WebhooksUpdateRequest struct {
	// Action The action to update the webhook's status.
	Action     *WebhooksUpdateAction            `json:"action,omitempty"`
	EventTypes *WebhooksUpdateRequestEventTypes `json:"event_types,omitempty"`
	Headers    *WebhooksUpdateRequestHeaders    `json:"headers,omitempty"`

	// Id ID for the webhook.
	Id string `json:"id"`

	// Secret If provided, updates the secret that's used when verifying webhook
	// events, which must be between 8 and 32 bytes (inclusive). Otherwise
	// if empty, then a new secret is generated. If the webhook is active,
	// then its status will transition to the 'unverified' state and it
	// won't receive any object events until successfully verified.
	Secret *[]byte `json:"secret,omitempty"`

	// Url The webhook's updated URL. If the webhook is active, then the
	// webhook's status will transition to the 'unverified' state and it
	// won't receive any object events until successfully verified.
	Url *string `json:"url,omitempty"`
}

// WebhooksUpdateRequestEventTypes defines model for webhooks-update-request-event-types.
type WebhooksUpdateRequestEventTypes struct {
	// Add The event types to add. If a provided event type is already set for
	// the webhook, then nothing is done. Note this is mutually exclusive
	// with 'set'.
	Add *[]WebhookEventType `json:"add,omitempty"`

	// Remove The event types to remove. If a provided event type isn't set for
	// the webhook, then nothing is done. Note this is mutually exclusive
	// with 'set'.
	Remove *[]WebhookEventType `json:"remove,omitempty"`

	// Set The updated event types, which will replace the webhook's current
	// event types. Note this is mutually exclusive with 'add' and
	// 'remove'.
	Set *[]WebhookEventType `json:"set,omitempty"`
}

// WebhooksUpdateRequestHeaders defines model for webhooks-update-request-headers.
type WebhooksUpdateRequestHeaders struct {
	// Add The headers to be added to every webhook invocation. If a provided
	// header is already specified for the webhook, its value is replaced.
	Add *[]WebhookHeader `json:"add,omitempty"`

	// Remove The headers to be removed from every webhook invocation. If a
	// provided header is not specified for the webhook, then it's
	// ignored.
	Remove *[]string `json:"remove,omitempty"`

	// Set Sets the headers to include in every webhook invocation.
	Set *[]WebhookHeader `json:"set,omitempty"`
}

// WebhooksUpdateResponseBody The response to updating the webhook.
type WebhooksUpdateResponseBody struct {
	Webhook Webhook `json:"webhook"`
}

// WeeklyOrgSchedule The schedule for each week.
type WeeklyOrgSchedule = map[string]interface{}

// Widget defines model for widget.
type Widget struct {
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// DataSources Data sources provide the backing data tables for the widget.
	DataSources *[]WidgetDataSource `json:"data_sources,omitempty"`

	// Description A brief summary of what the widget displays or represents.
	Description string `json:"description"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// IsDraft Whether the widget is a draft widget.
	IsDraft *bool `json:"is_draft,omitempty"`

	// IsSystem Whether the widget is a system widget.
	IsSystem *bool `json:"is_system,omitempty"`

	// Layout Layout of the widget. It determines the organization of the sub
	// widgets.
	Layout     []GridLayout `json:"layout"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Name A unique identifying name for the widget (optional).
	Name *string `json:"name,omitempty"`

	// SubWidgets A list of sub-widgets that the widget contains. Each widget can
	// contain  multiple sub-widgets.
	SubWidgets []SubWidget `json:"sub_widgets"`

	// Title The title of the widget.
	Title string `json:"title"`
}

// WidgetApiDataSource An API-backed data source.
type WidgetApiDataSource struct {
	// Include Object IDs to include in the data source.
	Include *[]WorkSummary `json:"include,omitempty"`

	// IsCustomLeafType Indicates if the leaf type is custom.
	IsCustomLeafType *bool `json:"is_custom_leaf_type,omitempty"`

	// LeafType The object's type.
	LeafType *string `json:"leaf_type,omitempty"`

	// Subtypes The subtypes of the object.
	Subtypes *[]string `json:"subtypes,omitempty"`
}

// WidgetColumnProjection A widget column projection.
type WidgetColumnProjection struct {
	// CustomField A custom field widget column projection.
	CustomField *CustomFieldWidgetColumnProjection `json:"custom_field,omitempty"`

	// DevrevSchema Set of field attributes.
	DevrevSchema SchemaFieldDescriptor `json:"devrev_schema"`

	// HasCustomExpression Whether the column has a custom expression.
	HasCustomExpression *bool `json:"has_custom_expression,omitempty"`

	// IsDerived Whether the column is derived.
	IsDerived *bool `json:"is_derived,omitempty"`

	// MeerkatSchema A meerkat specific column projection.
	MeerkatSchema *MeerkatWidgetColumnProjection `json:"meerkat_schema,omitempty"`

	// ReferenceName The reference name of the column.
	ReferenceName string `json:"reference_name"`

	// Type The type of the column.
	Type *WidgetColumnProjectionType `json:"type,omitempty"`
}

// WidgetColumnProjectionType The type of the column.
type WidgetColumnProjectionType string

// WidgetDataSource A data source for a widget.
type WidgetDataSource struct {
	// Api An API-backed data source.
	Api *WidgetApiDataSource `json:"api,omitempty"`

	// DataSource The ID of the data source. Meant to be set when the type is
	// data_source.
	DataSource *string `json:"data_source,omitempty"`

	// Dimensions The dimensions (or the extended dimensions) provided by the data
	// source.  These are the categories that can be used to group or
	// segment the measures.
	Dimensions *[]WidgetColumnProjection `json:"dimensions,omitempty"`

	// ExternalDataSource An referenced data source for a widget.
	ExternalDataSource *WidgetDataSourceReference `json:"external_data_source,omitempty"`

	// Joins A list of possible joins for the data source. Follows foreign key
	// semantics.
	Joins *[]DataSourceJoin `json:"joins,omitempty"`

	// Measures The measures (or the extended measures) provided by the data
	// source.  These are the numerical values that can be analyzed.
	Measures *[]WidgetColumnProjection `json:"measures,omitempty"`

	// Oasis An oasis backed data source.
	Oasis *WidgetOasisDataSource `json:"oasis,omitempty"`

	// ReferenceName The reference name of the data source.
	ReferenceName string `json:"reference_name"`

	// Type The type of the data source.
	Type WidgetDataSourceType `json:"type"`
}

// WidgetDataSourceReference An referenced data source for a widget.
type WidgetDataSourceReference struct {
	// DatasetProjections The column projections for the data source. These are the columns
	// that are  projected from the datasets.
	DatasetProjections *[]WidgetOasisDatasetColumnProjection `json:"dataset_projections,omitempty"`

	// Id The id of the data source.
	Id string `json:"id"`
}

// WidgetDataSourceType The type of the data source.
type WidgetDataSourceType string

// WidgetGroupByConfig The configuration for group_by operation.
type WidgetGroupByConfig struct {
	// Key The key on which group_by is applied.
	Key *string `json:"key,omitempty"`

	// Limit The maximum number of unique values that can be returned for the
	// key.
	Limit *int32 `json:"limit,omitempty"`
}

// WidgetOasisDataSource An oasis backed data source.
type WidgetOasisDataSource struct {
	// Datasets List of datasets used by the data source.
	Datasets *[]string `json:"datasets,omitempty"`

	// Projections The column projections for the data source. These are the columns
	// that are  projected from the datasets.
	Projections *[]WidgetOasisDatasetColumnProjection `json:"projections,omitempty"`

	// SqlQuery The base SQL query that constructs the view for the data source.
	// The SQL can reference the datasets using their aliases.
	SqlQuery string `json:"sql_query"`
}

// WidgetOasisDatasetColumn An oasis dataset column.
type WidgetOasisDatasetColumn struct {
	// CustomField A custom field widget column projection.
	CustomField *CustomFieldWidgetColumnProjection `json:"custom_field,omitempty"`

	// Name The name of the column.
	Name string `json:"name"`
}

// WidgetOasisDatasetColumnProjection An oasis dataset column projection.
type WidgetOasisDatasetColumnProjection struct {
	// Columns The column name.
	Columns []WidgetOasisDatasetColumn `json:"columns"`

	// Dataset The dataset ID.
	Dataset string `json:"dataset"`
}

// WidgetPvpConfig Configuration settings for enabling and customizing PVP (past vs.
// present) value in widgets.
type WidgetPvpConfig struct {
	// Enabled Indicates whether PVP is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// InvertCorrelationColor Specifies whether the color scheme for PVP is inverted.
	InvertCorrelationColor *bool `json:"invert_correlation_color,omitempty"`
}

// WidgetQuery The query for a widget. This includes measures and dimensions to be
// visualized.
type WidgetQuery struct {
	// Dimensions The dimensions for the query, which are the categories to group or
	// segment the measures. Usually these are the X-axis values in a
	// visualization.
	Dimensions *[]string `json:"dimensions,omitempty"`

	// Filters Set of filters to apply on the widgets. These filters are applied
	// on top of the dashboard level filters.
	Filters *[]DashboardFilter `json:"filters,omitempty"`

	// Joins Join paths to use for the query.
	Joins *[]WidgetQueryJoins `json:"joins,omitempty"`

	// Limit The maximum number of records to return. This is used to limit the
	// amount of data  returned by the query.
	Limit *int32 `json:"limit,omitempty"`

	// Measures The measures for the query, which are the numerical values to be
	// analyzed. Usually these are the Y-axis values in a visualization.
	Measures *[]string `json:"measures,omitempty"`

	// OrderBy The order in which the data should be returned. This is used to
	// sort the data returned by the query.
	OrderBy *[]WidgetQueryOrderBy `json:"order_by,omitempty"`
}

// WidgetQueryJoins A list of possible joins for the data source. Follows foreign key
// semantics.
type WidgetQueryJoins struct {
	// Path A list of joins.
	Path []string `json:"path"`
}

// WidgetQueryOrderBy The order in which the data should be returned. This is used to sort
// the data returned by the query.
type WidgetQueryOrderBy struct {
	// Direction The direction of the sort.
	Direction WidgetQueryOrderByDirection `json:"direction"`

	// ReferenceName The column to sort by.
	ReferenceName string `json:"reference_name"`
}

// WidgetQueryOrderByDirection The direction of the sort.
type WidgetQueryOrderByDirection string

// WidgetSummary defines model for widget-summary.
type WidgetSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// Title The title of the widget.
	Title string `json:"title"`
}

// WidgetVisualization The visualization for a widget. This includes the type of visualization
// and any  configuration specific to that type.
type WidgetVisualization struct {
	// Bar A bar chart visualization configuration. Includes metadata specific to
	// bar charts.
	Bar *BarWidgetVisualization `json:"bar,omitempty"`

	// Column A column chart visualization configuration. Includes metadata specific
	// to column charts.
	Column *ColumnWidgetVisualization `json:"column,omitempty"`

	// Donut A donut chart visualization configuration. Includes metadata specific
	// to donut charts.
	Donut *DonutWidgetVisualization `json:"donut,omitempty"`

	// Heatmap A heatmap chart visualization configuration. Includes metadata specific
	// to heatmap charts.
	Heatmap *HeatmapWidgetVisualization `json:"heatmap,omitempty"`

	// Kanban A kanban visualization configuration. Includes metadata specific to
	// kanban.
	Kanban *KanbanWidgetVisualization `json:"kanban,omitempty"`

	// Line A line chart visualization configuration. Includes metadata specific to
	// line charts.
	Line *LineWidgetVisualization `json:"line,omitempty"`

	// Metric A metric visualization configuration. Includes metadata specific to
	// metrics.
	Metric *MetricWidgetVisualization `json:"metric,omitempty"`

	// PackedBubble A Packed Bubble chart visualization configuration. Includes metadata
	// specific to packed bubble charts.
	PackedBubble *PackedBubbleWidgetVisualization `json:"packed_bubble,omitempty"`

	// Pie A pie chart visualization configuration. Includes metadata specific to
	// pie charts.
	Pie *PieWidgetVisualization `json:"pie,omitempty"`

	// RichText The configuration for a rich text visualization.
	RichText *RichTextWidgetVisualization `json:"rich_text,omitempty"`

	// Scatter A Scatter chart visualization configuration. Includes metadata specific
	// to scatter charts.
	Scatter *ScatterWidgetVisualization `json:"scatter,omitempty"`

	// Table A table visualization configuration. Includes metadata specific to
	// tables.
	Table *TableWidgetVisualization `json:"table,omitempty"`

	// Type The type of the visualization, such as line, bar, pie, etc.
	Type WidgetVisualizationType `json:"type"`
}

// WidgetVisualizationType The type of the visualization, such as line, bar, pie, etc.
type WidgetVisualizationType string

// WidgetsGetRequest The request to get a widget.
type WidgetsGetRequest struct {
	// Id The requested widget's ID.
	Id string `json:"id"`
}

// WidgetsGetResponseBody The response to a widget get request.
type WidgetsGetResponseBody struct {
	Widget Widget `json:"widget"`
}

// Work defines model for work.
type Work struct {
	Type  WorkType `json:"type"`
	union json.RawMessage
}

// WorkBase defines model for work-base.
type WorkBase struct {
	// ActualCloseDate Timestamp when the work was actually completed.
	ActualCloseDate *time.Time   `json:"actual_close_date,omitempty"`
	AppliesToPart   *PartSummary `json:"applies_to_part,omitempty"`

	// Artifacts The artifacts attached to the work item.
	Artifacts *[]ArtifactSummary `json:"artifacts,omitempty"`

	// Body Body of the work object.
	Body      *string      `json:"body,omitempty"`
	CreatedBy *UserSummary `json:"created_by,omitempty"`

	// CreatedDate Timestamp when the object was created.
	CreatedDate *time.Time `json:"created_date,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments Custom schema fragments.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id         string       `json:"id"`
	ModifiedBy *UserSummary `json:"modified_by,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// ReportedBy Users that reported the work.
	ReportedBy *[]UserSummary `json:"reported_by,omitempty"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStage `json:"stage,omitempty"`

	// StockSchemaFragment Stock schema fragment.
	StockSchemaFragment *string `json:"stock_schema_fragment,omitempty"`

	// Subtype Subtype corresponding to the custom type fragment.
	Subtype *string `json:"subtype,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadata `json:"sync_metadata,omitempty"`

	// Tags Tags associated with the object.
	Tags *[]TagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// WorkBaseSummary defines model for work-base-summary.
type WorkBaseSummary struct {
	// DisplayId Human-readable object ID unique to the Dev organization.
	DisplayId *string `json:"display_id,omitempty"`

	// Id Globally unique object ID.
	Id string `json:"id"`

	// OwnedBy The users that own the work.
	OwnedBy []UserSummary `json:"owned_by"`

	// Stage Describes the current stage of a work item.
	Stage *LegacyStageSummary `json:"stage,omitempty"`

	// SyncMetadata Sync information for records synced into/from DevRev.
	SyncMetadata *SyncMetadataSummary `json:"sync_metadata,omitempty"`

	// Title Title of the work object.
	Title string `json:"title"`
}

// WorkSearchSummary defines model for work-search-summary.
type WorkSearchSummary struct {
	// Comments Comments on the work.
	Comments *[]CommentSearchSummary `json:"comments,omitempty"`

	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet *string     `json:"snippet,omitempty"`
	Work    WorkSummary `json:"work"`
}

// WorkSummary defines model for work-summary.
type WorkSummary struct {
	Type  WorkType `json:"type"`
	union json.RawMessage
}

// WorkType defines model for work-type.
type WorkType string

// WorkflowRunSummary defines model for workflow-run-summary.
type WorkflowRunSummary = AtomBaseSummary

// WorkflowSearchSummary defines model for workflow-search-summary.
type WorkflowSearchSummary struct {
	// ModifiedDate Timestamp when the object was last modified.
	ModifiedDate *time.Time `json:"modified_date,omitempty"`

	// Snippet Concatenated text snippets from all search hits for this object.
	// This may contain duplicate content.
	Snippet  *string         `json:"snippet,omitempty"`
	Workflow WorkflowSummary `json:"workflow"`
}

// WorkflowSummary defines model for workflow-summary.
type WorkflowSummary = AtomBaseSummary

// WorksCreateRequest defines model for works-create-request.
type WorksCreateRequest struct {
	// AppliesToPart The [part](https://devrev.ai/docs/product/parts) that the work
	// applies to. Specifying a part is required when creating tickets and
	// issues.
	AppliesToPart string `json:"applies_to_part"`

	// Artifacts The IDs of the artifacts to associate with the work item.
	Artifacts *[]string `json:"artifacts,omitempty"`

	// Body Body of the work object.
	Body *string `json:"body,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments The custom schema fragments to use.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// OwnedBy The users that own the work.
	OwnedBy []string `json:"owned_by"`

	// ReportedBy The users that reported the work.
	ReportedBy *[]string `json:"reported_by,omitempty"`

	// Stage Sets an object's initial stage.
	Stage *StageInit `json:"stage,omitempty"`

	// StageValidationOptions The type of stage validations options when creating a work item.
	StageValidationOptions *[]StageValidationOptionForCreate `json:"stage_validation_options,omitempty"`

	// Tags Tags associated with the work item.
	Tags *[]SetTagWithValue `json:"tags,omitempty"`

	// TargetCloseDate Timestamp for when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date,omitempty"`

	// Title Title of the work object.
	Title string   `json:"title"`
	Type  WorkType `json:"type"`
	union json.RawMessage
}

// WorksCreateRequestIssue defines model for works-create-request-issue.
type WorksCreateRequestIssue struct {
	// DevelopedWith The IDs of the parts associated with issue.
	DevelopedWith *[]string `json:"developed_with,omitempty"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *IssuePriority `json:"priority,omitempty"`

	// PriorityV2 Priority enum id of the work based upon impact and criticality. The
	// allowed ids can be extended by the user. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "P0",
	//     "ordinal": 1,
	//     "overridable": true
	//   },
	//   {
	//     "id": 2,
	//     "label": "P1",
	//     "ordinal": 2,
	//     "overridable": true
	//   },
	//   {
	//     "id": 3,
	//     "label": "P2",
	//     "ordinal": 3,
	//     "overridable": true
	//   },
	//   {
	//     "id": 4,
	//     "label": "P3",
	//     "ordinal": 4,
	//     "overridable": true
	//   }
	// ```
	PriorityV2 *int64 `json:"priority_v2,omitempty"`

	// Sprint The sprint that the issue belongs to.
	Sprint *string `json:"sprint,omitempty"`

	// TargetStartDate Timestamp for when the work is expected to start.
	TargetStartDate *time.Time `json:"target_start_date,omitempty"`
}

// WorksCreateRequestOpportunity defines model for works-create-request-opportunity.
type WorksCreateRequestOpportunity struct {
	// Account The ID of the account that the opportunity is associated with.
	Account string `json:"account"`

	// Amount Total opportunity amount.
	Amount *float64 `json:"amount,omitempty"`

	// AnnualContractValue The money value to create.
	AnnualContractValue *SetMoney `json:"annual_contract_value,omitempty"`

	// Contacts Contacts involved in the opportunity.
	Contacts *[]string `json:"contacts,omitempty"`

	// CustomerBudget Budget of the customer.
	CustomerBudget *float64 `json:"customer_budget,omitempty"`

	// ForecastCategory Forecast category of the opportunity.
	ForecastCategory *OpportunityForecastCategory `json:"forecast_category,omitempty"`

	// ForecastCategoryV2 Forecast category enum ID of an opportunity. The allowed ids can be
	// extended by the user. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "Omitted",
	//     "ordinal": 1,
	//     "overridable": true
	//   },
	//   {
	//     "id": 2,
	//     "label": "Pipeline",
	//     "ordinal": 2,
	//     "overridable": true
	//   },
	//   {
	//     "id": 3,
	//     "label": "Upside",
	//     "ordinal": 3,
	//     "overridable": true
	//   },
	//   {
	//     "id": 4,
	//     "label": "Strong Upside",
	//     "ordinal": 4,
	//     "overridable": true
	//   },
	//   {
	//     "id": 5,
	//     "label": "Commit",
	//     "ordinal": 5,
	//     "overridable": true
	//   },
	//   {
	//     "id": 6,
	//     "label": "Won",
	//     "ordinal": 6,
	//     "overridable": true
	//   }
	// ```
	ForecastCategoryV2 *int64 `json:"forecast_category_v2,omitempty"`

	// Priority Priority of the opportunity.
	Priority *OpportunityPriority `json:"priority,omitempty"`

	// Probability The probability of winning the deal, lies between 0.0 and 1.0.
	Probability *float64 `json:"probability,omitempty"`

	// Value The money value to create.
	Value *SetMoney `json:"value,omitempty"`
}

// WorksCreateRequestTask defines model for works-create-request-task.
type WorksCreateRequestTask struct {
	// Embedded Whether the task is embedded in the work.
	Embedded *bool `json:"embedded,omitempty"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *TaskPriority `json:"priority,omitempty"`

	// StartDate Timestamp when the task was started.
	StartDate *time.Time `json:"start_date,omitempty"`
}

// WorksCreateRequestTicket defines model for works-create-request-ticket.
type WorksCreateRequestTicket struct {
	// Account The account that the ticket is associated with.
	Account *string `json:"account,omitempty"`

	// Channels Channels of the ticket.
	Channels *[]TicketChannels `json:"channels,omitempty"`

	// ChannelsV2 Channel IDs of the ticket.
	ChannelsV2 *[]string `json:"channels_v2,omitempty"`

	// Group The group that the ticket is associated with.
	Group *string `json:"group,omitempty"`

	// IsSpam Whether the ticket is spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// NeedsResponse Whether the ticket needs a response.
	NeedsResponse *bool `json:"needs_response,omitempty"`

	// RevOrg The Rev organization that the ticket is associated with.
	RevOrg *string `json:"rev_org,omitempty"`

	// Severity Severity of the ticket.
	Severity *TicketSeverity `json:"severity,omitempty"`

	// SourceChannel The source channel of the ticket.
	SourceChannel *string `json:"source_channel,omitempty"`

	// SourceChannelV2 Source channel ID of the ticket.
	SourceChannelV2 *string `json:"source_channel_v2,omitempty"`
}

// WorksCreateResponseBody defines model for works-create-response.
type WorksCreateResponseBody struct {
	Work Work `json:"work"`
}

// WorksDeleteRequest defines model for works-delete-request.
type WorksDeleteRequest struct {
	// Id The work's ID.
	Id string `json:"id"`
}

// WorksDeleteResponseBody defines model for works-delete-response.
type WorksDeleteResponseBody = map[string]interface{}

// WorksExportRequest defines model for works-export-request.
type WorksExportRequest struct {
	// ActualCloseDate Provides ways to specify date ranges on objects.
	ActualCloseDate *DateFilter `json:"actual_close_date,omitempty"`

	// AppliesToPart Filters for work belonging to any of the provided parts.
	AppliesToPart *[]string `json:"applies_to_part,omitempty"`

	// CreatedBy Filters for work created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// First The number of work items to return. The default is '50', the
	// maximum is '5000'.
	First *int32            `json:"first,omitempty"`
	Issue *WorksFilterIssue `json:"issue,omitempty"`

	// ModifiedBy Filters for work modified by any of these users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter             `json:"modified_date,omitempty"`
	Opportunity  *WorksFilterOpportunity `json:"opportunity,omitempty"`

	// OwnedBy Filters for work owned by any of these users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// ReportedBy Filters for work reported by any of these users.
	ReportedBy *[]string `json:"reported_by,omitempty"`

	// SortBy Fields to sort the work items by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stage The filter for stages.
	Stage      *StageFilter      `json:"stage,omitempty"`
	StagedInfo *StagedInfoFilter `json:"staged_info,omitempty"`

	// State Filters for work with any of the provided states.
	State        *[]string           `json:"state,omitempty"`
	SyncMetadata *SyncMetadataFilter `json:"sync_metadata,omitempty"`

	// Tags Filters for work with any of the provided tags.
	Tags *[]string `json:"tags,omitempty"`

	// TargetCloseDate Provides ways to specify date ranges on objects.
	TargetCloseDate *DateFilter        `json:"target_close_date,omitempty"`
	Ticket          *WorksFilterTicket `json:"ticket,omitempty"`

	// Type Filters for work of the provided types.
	Type *[]WorkType `json:"type,omitempty"`
}

// WorksExportResponseBody defines model for works-export-response.
type WorksExportResponseBody struct {
	// Works The resulting collection of work items.
	Works []Work `json:"works"`
}

// WorksFilterIssue defines model for works-filter-issue.
type WorksFilterIssue struct {
	// Accounts Filters for issues with any of the provided accounts.
	Accounts *[]string `json:"accounts,omitempty"`

	// ActualStartDate Provides ways to specify date ranges on objects.
	ActualStartDate *DateFilter `json:"actual_start_date,omitempty"`

	// Priority Filters for issues with any of the provided priorities.
	Priority *[]IssuePriority `json:"priority,omitempty"`

	// PriorityV2 Filters for issues with any of the provided priority enum ids.
	PriorityV2 *[]int64 `json:"priority_v2,omitempty"`

	// RevOrgs Filters for issues with any of the provided Rev organizations.
	RevOrgs *[]string `json:"rev_orgs,omitempty"`

	// SlaSummary The filter for SLA summary.
	SlaSummary *SlaSummaryFilter `json:"sla_summary,omitempty"`

	// Sprint Filters for issues with any of the sprint.
	Sprint *[]string `json:"sprint,omitempty"`

	// Subtype Filters for issues with any of the provided subtypes.
	Subtype *[]string `json:"subtype,omitempty"`

	// TargetStartDate Provides ways to specify date ranges on objects.
	TargetStartDate *DateFilter `json:"target_start_date,omitempty"`
}

// WorksFilterOpportunity defines model for works-filter-opportunity.
type WorksFilterOpportunity struct {
	// Account Filters for opportunities belonging to any of the provided
	// accounts.
	Account *[]string `json:"account,omitempty"`

	// Contacts Filters for opportunities with any of the provided contacts.
	Contacts *[]string `json:"contacts,omitempty"`

	// ForecastCategoryV2 Filters for opportunities with any of the provided forecast
	// category enum IDs.
	ForecastCategoryV2 *[]int64 `json:"forecast_category_v2,omitempty"`

	// Subtype Filters for opportunity with any of the provided subtypes.
	Subtype *[]string `json:"subtype,omitempty"`
}

// WorksFilterTicket defines model for works-filter-ticket.
type WorksFilterTicket struct {
	// Brand Filters for tickets that are associated with any of the brands.
	Brand *[]string `json:"brand,omitempty"`

	// Channels Filters for tickets with any of the provided channels.
	Channels *[]TicketChannels `json:"channels,omitempty"`

	// ChannelsV2 Filters for tickets that are associated with any of the channels.
	ChannelsV2 *[]string `json:"channels_v2,omitempty"`

	// Group Filters for tickets belonging to specific groups.
	Group *[]string `json:"group,omitempty"`

	// IsFrozen Filters for frozen tickets.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// IsSpam Filters for tickets that are spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// NeedsResponse Filters for tickets that need response.
	NeedsResponse *bool `json:"needs_response,omitempty"`

	// RevOrg Filters for tickets that are associated with any of the provided
	// Rev organizations.
	RevOrg *[]string `json:"rev_org,omitempty"`

	// Severity Filters for tickets with any of the provided severities.
	Severity *[]TicketSeverity `json:"severity,omitempty"`

	// SlaSummary The filter for SLA summary.
	SlaSummary *SlaSummaryFilter `json:"sla_summary,omitempty"`

	// SourceChannel Filters for tickets with any of the provided source channels.
	SourceChannel *[]string `json:"source_channel,omitempty"`

	// SourceChannelV2 Filters for tickets that are associated with any of the source
	// channels.
	SourceChannelV2 *[]string `json:"source_channel_v2,omitempty"`

	// Subtype Filters for tickets with any of the provided subtypes.
	Subtype *[]string `json:"subtype,omitempty"`

	// Surveys The filter for survey aggregation.
	Surveys *SurveyAggregationFilter `json:"surveys,omitempty"`
}

// WorksGetRequest defines model for works-get-request.
type WorksGetRequest struct {
	// Id The work's ID.
	Id string `json:"id"`
}

// WorksGetResponseBody defines model for works-get-response.
type WorksGetResponseBody struct {
	Work Work `json:"work"`
}

// WorksListRequest defines model for works-list-request.
type WorksListRequest struct {
	// ActualCloseDate Provides ways to specify date ranges on objects.
	ActualCloseDate *DateFilter `json:"actual_close_date,omitempty"`

	// AppliesToPart Filters for work belonging to any of the provided parts.
	AppliesToPart *[]string `json:"applies_to_part,omitempty"`

	// CreatedBy Filters for work created by any of these users.
	CreatedBy *[]string `json:"created_by,omitempty"`

	// CreatedDate Provides ways to specify date ranges on objects.
	CreatedDate *DateFilter `json:"created_date,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then
	// iteration starts from the beginning.
	Cursor *string `json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`
	Issue        *WorksFilterIssue       `json:"issue,omitempty"`

	// Limit The maximum number of works to return. The default is '50'.
	Limit *int32 `json:"limit,omitempty"`

	// Mode The iteration mode to use. If "after", then entries after the provided
	// cursor will be returned, or if no cursor is provided, then from the
	// beginning. If "before", then entries before the provided cursor will be
	// returned, or if no cursor is provided, then from the end. Entries will
	// always be returned in the specified sort-by order.
	Mode *ListMode `json:"mode,omitempty"`

	// ModifiedBy Filters for work modified by any of these users.
	ModifiedBy *[]string `json:"modified_by,omitempty"`

	// ModifiedDate Provides ways to specify date ranges on objects.
	ModifiedDate *DateFilter             `json:"modified_date,omitempty"`
	Opportunity  *WorksFilterOpportunity `json:"opportunity,omitempty"`

	// OwnedBy Filters for work owned by any of these users.
	OwnedBy *[]string `json:"owned_by,omitempty"`

	// ReportedBy Filters for work reported by any of these users.
	ReportedBy *[]string `json:"reported_by,omitempty"`

	// SortBy Fields to sort the works by and the direction to sort them.
	SortBy *[]string `json:"sort_by,omitempty"`

	// Stage The filter for stages.
	Stage      *StageFilter      `json:"stage,omitempty"`
	StagedInfo *StagedInfoFilter `json:"staged_info,omitempty"`

	// State Filters for work with any of the provided states.
	State        *[]string           `json:"state,omitempty"`
	SyncMetadata *SyncMetadataFilter `json:"sync_metadata,omitempty"`

	// Tags Filters for work with any of the provided tags.
	Tags *[]string `json:"tags,omitempty"`

	// TargetCloseDate Provides ways to specify date ranges on objects.
	TargetCloseDate *DateFilter        `json:"target_close_date,omitempty"`
	Ticket          *WorksFilterTicket `json:"ticket,omitempty"`

	// Type Filters for work of the provided types.
	Type *[]WorkType `json:"type,omitempty"`
}

// WorksListResponseBody defines model for works-list-response.
type WorksListResponseBody struct {
	// NextCursor The cursor used to iterate subsequent results in accordance to the
	// sort order. If not set, then no later elements exist.
	NextCursor *string `json:"next_cursor,omitempty"`

	// PrevCursor The cursor used to iterate preceding results in accordance to the
	// sort order. If not set, then no prior elements exist.
	PrevCursor *string `json:"prev_cursor,omitempty"`

	// Works The list of works.
	Works []Work `json:"works"`
}

// WorksUpdateRequest defines model for works-update-request.
type WorksUpdateRequest struct {
	// AppliesToPart Updates the part that the work item applies to.
	AppliesToPart *string                      `json:"applies_to_part,omitempty"`
	Artifacts     *WorksUpdateRequestArtifacts `json:"artifacts,omitempty"`

	// Body Updated body of the work object, or unchanged if not provided.
	Body *string `json:"body,omitempty"`

	// CustomFields Custom fields.
	CustomFields *map[string]interface{} `json:"custom_fields,omitempty"`

	// CustomSchemaFragments The custom schema fragments to use.
	CustomSchemaFragments *[]string `json:"custom_schema_fragments,omitempty"`

	// CustomSchemaSpec Custom schemas described using identifiers. Each custom field in the
	// request must have the corresponding schema specified; omission results
	// in a Bad Request error. If a custom schema is not included in the
	// specifier, it remains unchanged. For surfaces with human interactors,
	// it is recommended to provide tenant_fragment: true and
	// validate_required_fields: true.
	CustomSchemaSpec *CustomSchemaSpec `json:"custom_schema_spec,omitempty"`

	// Id The work's ID.
	Id         string                        `json:"id"`
	OwnedBy    *WorksUpdateRequestOwnedBy    `json:"owned_by,omitempty"`
	ReportedBy *WorksUpdateRequestReportedBy `json:"reported_by,omitempty"`

	// Stage Updates an object's stage.
	Stage *StageUpdate `json:"stage,omitempty"`

	// StageValidationOptions The type of stage validations options when updating the stage or
	// the stage diagram of an object.
	StageValidationOptions *[]StageValidationOptionForUpdate   `json:"stage_validation_options,omitempty"`
	StagedInfo             *WorksUpdateRequestStagedInfoUpdate `json:"staged_info,omitempty"`
	Tags                   *WorksUpdateRequestTags             `json:"tags,omitempty"`

	// TargetCloseDate Updates the timestamp for when the work is expected to be complete.
	TargetCloseDate *time.Time `json:"target_close_date"`

	// Title Updated title of the work object, or unchanged if not provided.
	Title *string   `json:"title,omitempty"`
	Type  *WorkType `json:"type,omitempty"`
	union json.RawMessage
}

// WorksUpdateRequestArtifacts defines model for works-update-request-artifacts.
type WorksUpdateRequestArtifacts struct {
	// Add Adds the provided artifacts (if not already present) to the field.
	Add *[]string `json:"add,omitempty"`

	// Remove Removes the provided artifacts (if they exist) from the field.
	Remove *[]string `json:"remove,omitempty"`

	// Set Sets the field to the provided artifacts.
	Set *[]string `json:"set,omitempty"`
}

// WorksUpdateRequestIssue defines model for works-update-request-issue.
type WorksUpdateRequestIssue struct {
	DevelopedWith *WorksUpdateRequestIssueDevelopedWith `json:"developed_with,omitempty"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *IssuePriority `json:"priority,omitempty"`

	// PriorityV2 Priority enum id of the work based upon impact and criticality. The
	// allowed ids can be extended by the user. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "P0",
	//     "ordinal": 1,
	//     "overridable": true
	//   },
	//   {
	//     "id": 2,
	//     "label": "P1",
	//     "ordinal": 2,
	//     "overridable": true
	//   },
	//   {
	//     "id": 3,
	//     "label": "P2",
	//     "ordinal": 3,
	//     "overridable": true
	//   },
	//   {
	//     "id": 4,
	//     "label": "P3",
	//     "ordinal": 4,
	//     "overridable": true
	//   }
	// ```
	PriorityV2 *int64 `json:"priority_v2,omitempty"`

	// Sprint Updates the sprint that the issue belongs to.
	Sprint *string `json:"sprint"`

	// TargetStartDate Updates the timestamp for when the work is expected to start.
	TargetStartDate *time.Time `json:"target_start_date"`
}

// WorksUpdateRequestIssueDevelopedWith defines model for works-update-request-issue-developed-with.
type WorksUpdateRequestIssueDevelopedWith struct {
	// Set Sets the IDs of the parts associated with issue.
	Set *[]string `json:"set,omitempty"`
}

// WorksUpdateRequestOpportunity defines model for works-update-request-opportunity.
type WorksUpdateRequestOpportunity struct {
	// Account Updates the account that the opportunity is associated with.
	Account *string `json:"account,omitempty"`

	// Amount Updates the total opportunity amount.
	Amount *float64 `json:"amount"`

	// AnnualContractValue The money value to create.
	AnnualContractValue *SetMoney                              `json:"annual_contract_value,omitempty"`
	Contacts            *WorksUpdateRequestOpportunityContacts `json:"contacts,omitempty"`

	// CustomerBudget Updates the customer budget.
	CustomerBudget *float64 `json:"customer_budget"`

	// ForecastCategoryV2 Forecast category enum ID of an opportunity. The allowed ids can be
	// extended by the user. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "Omitted",
	//     "ordinal": 1,
	//     "overridable": true
	//   },
	//   {
	//     "id": 2,
	//     "label": "Pipeline",
	//     "ordinal": 2,
	//     "overridable": true
	//   },
	//   {
	//     "id": 3,
	//     "label": "Upside",
	//     "ordinal": 3,
	//     "overridable": true
	//   },
	//   {
	//     "id": 4,
	//     "label": "Strong Upside",
	//     "ordinal": 4,
	//     "overridable": true
	//   },
	//   {
	//     "id": 5,
	//     "label": "Commit",
	//     "ordinal": 5,
	//     "overridable": true
	//   },
	//   {
	//     "id": 6,
	//     "label": "Won",
	//     "ordinal": 6,
	//     "overridable": true
	//   }
	// ```
	ForecastCategoryV2 *int64 `json:"forecast_category_v2,omitempty"`

	// Probability Updates the probability of winning the deal, lies between 0.0 and
	// 1.0.
	Probability *float64 `json:"probability"`

	// Value The money value to create.
	Value *SetMoney `json:"value,omitempty"`
}

// WorksUpdateRequestOpportunityContacts defines model for works-update-request-opportunity-contacts.
type WorksUpdateRequestOpportunityContacts struct {
	// Set Sets the contact IDs to the provided contact IDs.
	Set []string `json:"set"`
}

// WorksUpdateRequestOwnedBy defines model for works-update-request-owned-by.
type WorksUpdateRequestOwnedBy struct {
	// Set Sets the owner IDs to the provided user IDs. This must not be
	// empty.
	Set *[]string `json:"set,omitempty"`
}

// WorksUpdateRequestReportedBy defines model for works-update-request-reported-by.
type WorksUpdateRequestReportedBy struct {
	// Set Sets the users that reported the work to the provided user IDs.
	Set *[]string `json:"set,omitempty"`
}

// WorksUpdateRequestStagedInfoUpdate defines model for works-update-request-staged-info-update.
type WorksUpdateRequestStagedInfoUpdate struct {
	// SyncInUnresolvedFields Updates the sync in unresolved fields of the staged work.
	SyncInUnresolvedFields *[]WorksUpdateRequestStagedInfoUpdateUnresolvedField `json:"sync_in_unresolved_fields,omitempty"`

	// SyncOutUnresolvedFields Updates the sync out unresolved fields of the staged work.
	SyncOutUnresolvedFields *[]WorksUpdateRequestStagedInfoUpdateUnresolvedField `json:"sync_out_unresolved_fields,omitempty"`

	// UnresolvedFields Updates the unresolved fields of the staged work.
	UnresolvedFields *[]string `json:"unresolved_fields,omitempty"`
}

// WorksUpdateRequestStagedInfoUpdateUnresolvedField defines model for works-update-request-staged-info-update-unresolved-field.
type WorksUpdateRequestStagedInfoUpdateUnresolvedField struct {
	// DevrevFieldName DevRev field name of the object's attribute.
	DevrevFieldName *string `json:"devrev_field_name,omitempty"`

	// ExternalDisplayName External field name as seen by the end user.
	ExternalDisplayName *string `json:"external_display_name,omitempty"`

	// ExternalFieldName Api name of the external object's field.
	ExternalFieldName *string `json:"external_field_name,omitempty"`
}

// WorksUpdateRequestTags defines model for works-update-request-tags.
type WorksUpdateRequestTags struct {
	// Add Adds the provided tags on the work item.
	Add *[]AddTagWithValue `json:"add,omitempty"`

	// Remove Removes the provided tags on the work item.
	Remove *[]RemoveTagWithValue `json:"remove,omitempty"`

	// Set Sets the provided tags on the work item.
	Set *[]SetTagWithValue `json:"set,omitempty"`
}

// WorksUpdateRequestTask defines model for works-update-request-task.
type WorksUpdateRequestTask struct {
	// Embedded Whether the task is embedded in the work.
	Embedded *bool `json:"embedded,omitempty"`

	// Priority Priority of the work based upon impact and criticality.
	Priority *TaskPriority `json:"priority,omitempty"`

	// StartDate Timestamp when the task was started.
	StartDate *time.Time `json:"start_date,omitempty"`
}

// WorksUpdateRequestTicket defines model for works-update-request-ticket.
type WorksUpdateRequestTicket struct {
	// Account Updates the account that the ticket is associated with.
	Account  *string                           `json:"account"`
	Channels *WorksUpdateRequestTicketChannels `json:"channels,omitempty"`

	// ChannelsV2 Updates channel IDs of the ticket.
	ChannelsV2 *[]string `json:"channels_v2,omitempty"`

	// Group Updates the group that the ticket is associated with.
	Group *string `json:"group"`

	// IsArchived Whether the ticket is archived.
	IsArchived *bool `json:"is_archived,omitempty"`

	// IsFrozen Whether the ticket is frozen.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// IsSpam Updates whether the ticket is spam.
	IsSpam *bool `json:"is_spam,omitempty"`

	// NeedsResponse Updates whether the ticket needs a response.
	NeedsResponse *bool `json:"needs_response,omitempty"`

	// RevOrg Updates the Rev organization that the ticket is associated with.
	RevOrg *string `json:"rev_org"`

	// Sentiment The enum ID for the sentiment of the ticket. The allowed ids can be
	// extended by the user. Stock allowed values:
	// ```
	//   {
	//     "id": 1,
	//     "label": "Delighted",
	//     "ordinal": 1,
	//     "overridable": true
	//   },
	//   {
	//     "id": 2,
	//     "label": "Happy",
	//     "ordinal": 2,
	//     "overridable": true
	//   },
	//   {
	//     "id": 3,
	//     "label": "Neutral",
	//     "ordinal": 3,
	//     "overridable": true
	//   },
	//   {
	//     "id": 4,
	//     "label": "Unhappy",
	//     "ordinal": 4,
	//     "overridable": true
	//   },
	//   {
	//     "id": 5,
	//     "label": "Frustrated",
	//     "ordinal": 5,
	//     "overridable": true
	//   }
	// ```
	Sentiment *int64 `json:"sentiment,omitempty"`

	// SentimentModifiedDate Timestamp at which sentiment was last modified.
	SentimentModifiedDate *time.Time `json:"sentiment_modified_date,omitempty"`

	// SentimentSummary Summary justifying the current sentiment.
	SentimentSummary *string `json:"sentiment_summary,omitempty"`

	// Severity Severity of the ticket.
	Severity *TicketSeverity `json:"severity,omitempty"`

	// SourceChannelV2 Updates the source channel of the ticket.
	SourceChannelV2 *string `json:"source_channel_v2"`
}

// WorksUpdateRequestTicketChannels defines model for works-update-request-ticket-channels.
type WorksUpdateRequestTicketChannels struct {
	// Set Sets the channels to the provided channels.
	Set *[]TicketChannels `json:"set,omitempty"`
}

// WorksUpdateResponseBody defines model for works-update-response.
type WorksUpdateResponseBody struct {
	Work Work `json:"work"`
}

// BadRequest Describes a error due to a bad request by the client.
type BadRequest = ErrorBadRequest

// Conflict defines model for conflict.
type Conflict = ErrorConflict

// Forbidden defines model for forbidden.
type Forbidden = ErrorForbidden

// InternalServerError defines model for internal-server-error.
type InternalServerError = ErrorInternalServerError

// NotFound defines model for not-found.
type NotFound = ErrorNotFound

// ServiceUnavailable defines model for service-unavailable.
type ServiceUnavailable = ErrorServiceUnavailable

// TooManyRequests defines model for too-many-requests.
type TooManyRequests = ErrorTooManyRequests

// Unauthorized defines model for unauthorized.
type Unauthorized = ErrorUnauthorized

// AccountsExportParams defines parameters for AccountsExport.
type AccountsExportParams struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `form:"display_name,omitempty" json:"display_name,omitempty"`

	// Domains Domains for accounts to be filtered.
	Domains *[]string `form:"domains,omitempty" json:"domains,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string `form:"external_refs,omitempty" json:"external_refs,omitempty"`

	// First The number of accounts to return. The default is '50'.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// OwnedBy Filters for accounts owned by the specified user(s).
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// SortBy Fields to sort the accounts by and the direction to sort them in.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `form:"stage,omitempty" json:"stage,omitempty"`

	// Subtype Subtypes of the accounts to be filtered.
	Subtype *[]string `form:"subtype,omitempty" json:"subtype,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `form:"tier,omitempty" json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `form:"websites,omitempty" json:"websites,omitempty"`
}

// AccountsGetParams defines parameters for AccountsGet.
type AccountsGetParams struct {
	// Id The ID of the account to be retrieved.
	Id string `form:"id" json:"id"`
}

// AccountsListParams defines parameters for AccountsList.
type AccountsListParams struct {
	// CreatedBy Filters for accounts created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// DisplayName Array of display names of accounts to be filtered.
	DisplayName *[]string `form:"display_name,omitempty" json:"display_name,omitempty"`

	// Domains Domains for accounts to be filtered.
	Domains *[]string `form:"domains,omitempty" json:"domains,omitempty"`

	// ExternalRefs Array of references of accounts to be filtered.
	ExternalRefs *[]string `form:"external_refs,omitempty" json:"external_refs,omitempty"`

	// Limit The maximum number of accounts to return per page. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// OwnedBy Filters for accounts owned by the specified user(s).
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// SortBy Fields to sort the accounts by and the direction to sort them in.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Stage Filters for accounts on specified stages.
	Stage *[]string `form:"stage,omitempty" json:"stage,omitempty"`

	// Subtype Subtypes of the accounts to be filtered.
	Subtype *[]string `form:"subtype,omitempty" json:"subtype,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Tier Tier of the accounts to be filtered.
	Tier *[]string `form:"tier,omitempty" json:"tier,omitempty"`

	// Websites Array of websites of accounts to be filtered.
	Websites *[]string `form:"websites,omitempty" json:"websites,omitempty"`
}

// AirdropSyncUnitsGetParams defines parameters for AirdropSyncUnitsGet.
type AirdropSyncUnitsGetParams struct {
	// Id Requested sync unit ID.
	Id string `form:"id" json:"id"`
}

// AirdropSyncUnitsHistoryParams defines parameters for AirdropSyncUnitsHistory.
type AirdropSyncUnitsHistoryParams struct {
	// Id Sync unit that will be used for sync history listing.
	Id string `form:"id" json:"id"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// FilterHasErrorsOrWarnings Filter for sync runs that have errors.
	FilterHasErrorsOrWarnings *bool `form:"filter.has_errors_or_warnings,omitempty" json:"filter.has_errors_or_warnings,omitempty"`

	// FilterMode Mode of the sync run.
	FilterMode *[]SyncRunMode `form:"filter.mode,omitempty" json:"filter.mode,omitempty"`

	// FilterStartedBy User who started the sync run.
	FilterStartedBy *[]SyncRunStartedBy `form:"filter.started_by,omitempty" json:"filter.started_by,omitempty"`

	// FilterState State of the sync run.
	FilterState *[]SyncRunProgressState `form:"filter.state,omitempty" json:"filter.state,omitempty"`

	// Limit The maximum number of items to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`
}

// ArticlesCountParams defines parameters for ArticlesCount.
type ArticlesCountParams struct {
	// Ancestor The ancestor directory of the articles.
	Ancestor *string `form:"ancestor,omitempty" json:"ancestor,omitempty"`

	// AppliesToParts Filters for articles belonging to any of the provided parts.
	AppliesToParts *[]string `form:"applies_to_parts,omitempty" json:"applies_to_parts,omitempty"`

	// ArticleType Filter for the type of articles. If this is not provided, then
	// articles that are not content blocks are returned.
	ArticleType *[]ArticleType `form:"article_type,omitempty" json:"article_type,omitempty"`

	// AuthoredBy Filters for articles authored by any of the provided users.
	AuthoredBy *[]string `form:"authored_by,omitempty" json:"authored_by,omitempty"`

	// Brands Filters for articles belonging to any of the provided brands.
	Brands *[]string `form:"brands,omitempty" json:"brands,omitempty"`

	// CreatedBy Filters for articles created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// ModifiedBy Filters for articles modified by any of the provided users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`

	// OwnedBy Filters for articles owned by any of the provided users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// Scope Filter for the scope of the articles.
	Scope *[]int64 `form:"scope,omitempty" json:"scope,omitempty"`

	// SharedWithMember ID of the group/member with whom the item is shared.
	SharedWithMember *string `form:"shared_with.member,omitempty" json:"shared_with.member,omitempty"`

	// SharedWithRole Role ID of the group/member with whom the item is shared.
	SharedWithRole *string `form:"shared_with.role,omitempty" json:"shared_with.role,omitempty"`

	// Tags Filters for article with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// GetArticleParams defines parameters for GetArticle.
type GetArticleParams struct {
	// Id The ID of the required article.
	Id string `form:"id" json:"id"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `form:"dev_org,omitempty" json:"dev_org,omitempty"`
}

// ListArticlesParams defines parameters for ListArticles.
type ListArticlesParams struct {
	// AppliesToParts Filters for articles belonging to any of the provided parts.
	AppliesToParts *[]string `form:"applies_to_parts,omitempty" json:"applies_to_parts,omitempty"`

	// ArticleType Filter for the type of articles. If this is not provided, then
	// articles that are not content blocks are returned.
	ArticleType *[]ArticleType `form:"article_type,omitempty" json:"article_type,omitempty"`

	// AuthoredBy Filters for articles authored by any of the provided users.
	AuthoredBy *[]string `form:"authored_by,omitempty" json:"authored_by,omitempty"`

	// Brands Filters for articles belonging to any of the provided brands.
	Brands *[]string `form:"brands,omitempty" json:"brands,omitempty"`

	// CreatedBy Filters for articles created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `form:"dev_org,omitempty" json:"dev_org,omitempty"`

	// Limit The maximum number of articles to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedBy Filters for articles modified by any of the provided users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`

	// OwnedBy Filters for articles owned by any of the provided users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// Scope Filter for the scope of the articles.
	Scope *[]int64 `form:"scope,omitempty" json:"scope,omitempty"`

	// SharedWithMember ID of the group/member with whom the item is shared.
	SharedWithMember *string `form:"shared_with.member,omitempty" json:"shared_with.member,omitempty"`

	// SharedWithRole Role ID of the group/member with whom the item is shared.
	SharedWithRole *string `form:"shared_with.role,omitempty" json:"shared_with.role,omitempty"`

	// Tags Filters for article with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ArtifactsGetParams defines parameters for ArtifactsGet.
type ArtifactsGetParams struct {
	// Id The requested artifact's ID.
	Id string `form:"id" json:"id"`

	// Version The version of the artifact that needs to be fetched.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// ArtifactsListParams defines parameters for ArtifactsList.
type ArtifactsListParams struct {
	// ParentId The ID of the object to filter artifacts.
	ParentId *string `form:"parent_id,omitempty" json:"parent_id,omitempty"`
}

// ArtifactsLocateParams defines parameters for ArtifactsLocate.
type ArtifactsLocateParams struct {
	// Id The ID of the artifact to get the URL for.
	Id string `form:"id" json:"id"`

	// Version The version of the artifact that needs to be fetched.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// AtomsGetParams defines parameters for AtomsGet.
type AtomsGetParams struct {
	// Id The ID of the object to get.
	Id string `form:"id" json:"id"`
}

// AuthTokensGetParams defines parameters for AuthTokensGet.
type AuthTokensGetParams struct {
	// TokenId The unique identifier of the token under a given Dev organization.
	TokenId string `form:"token_id" json:"token_id"`
}

// AuthTokensListParams defines parameters for AuthTokensList.
type AuthTokensListParams struct {
	// ClientId An identifier that represents the application, which requested the
	// token. Only relevant for application access tokens.
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`

	// RequestedTokenType The type of the requested token. If no value is specified, the
	// response will include tokens of all the types.
	RequestedTokenType *AuthTokenRequestedTokenType `form:"requested_token_type,omitempty" json:"requested_token_type,omitempty"`

	// Subject The subject associated with the token. In the absence of this
	// parameter, the ID of the authenticated entity is treated as the
	// subject.
	Subject *string `form:"subject,omitempty" json:"subject,omitempty"`
}

// BrandsGetParams defines parameters for BrandsGet.
type BrandsGetParams struct {
	// Id The ID of the brand to be retrieved.
	Id string `form:"id" json:"id"`
}

// BrandsListParams defines parameters for BrandsList.
type BrandsListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// ChatsGetParams defines parameters for ChatsGet.
type ChatsGetParams struct {
	// Id The chat's ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// CodeChangesGetParams defines parameters for CodeChangesGet.
type CodeChangesGetParams struct {
	// Id The code change object ID.
	Id string `form:"id" json:"id"`
}

// CodeChangesListParams defines parameters for CodeChangesList.
type CodeChangesListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of code change objects to return. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`
}

// CommandsGetParams defines parameters for CommandsGet.
type CommandsGetParams struct {
	// Id The command's ID.
	Id string `form:"id" json:"id"`
}

// CommandsListParams defines parameters for CommandsList.
type CommandsListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// ExecutorType Filtering based on executor_type.
	ExecutorType *[]CommandActionExecutorType `form:"executor_type,omitempty" json:"executor_type,omitempty"`

	// Limit The maximum number of commands to return per page. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Namespace Filter commands based on namespace.
	Namespace *[]string `form:"namespace,omitempty" json:"namespace,omitempty"`

	// SortBy List of fields to sort the commands items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SourceObjectId ID of the object where command is invoked (work/part/conversation).
	SourceObjectId *string `form:"source_object_id,omitempty" json:"source_object_id,omitempty"`

	// Status Filter commands based on status.
	Status *[]CommandStatus `form:"status,omitempty" json:"status,omitempty"`
}

// ContentTemplateGetParams defines parameters for ContentTemplateGet.
type ContentTemplateGetParams struct {
	// Id The content template's ID.
	Id string `form:"id" json:"id"`
}

// ContentTemplateListParams defines parameters for ContentTemplateList.
type ContentTemplateListParams struct {
	// CreatedBy Filters for content template created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of content template to return. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Name Filters for content template based on name.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// SortBy Fields to sort the content template by and the direction to sort
	// them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Type Filters for content template of the provided types.
	Type *[]ContentTemplateType `form:"type,omitempty" json:"type,omitempty"`
}

// ConversationsExportParams defines parameters for ConversationsExport.
type ConversationsExportParams struct {
	// AppliesToParts Filters for conversations belonging to any of the provided parts.
	AppliesToParts *[]string `form:"applies_to_parts,omitempty" json:"applies_to_parts,omitempty"`

	// Brand Filters for tickets that are associated with any of the brands.
	Brand *[]string `form:"brand,omitempty" json:"brand,omitempty"`

	// Channels Filters for conversations that are associated with any of the
	// channels.
	Channels *[]string `form:"channels,omitempty" json:"channels,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// First The number of conversation items to return. The default is '50', the
	// maximum is '5000'.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// Group Filters for conversation that belong to the given groups.
	Group *[]string `form:"group,omitempty" json:"group,omitempty"`

	// IsCreatorVerified Filters for conversations that are created by verified users.
	IsCreatorVerified *bool `form:"is_creator_verified,omitempty" json:"is_creator_verified,omitempty"`

	// IsFrozen Filters for conversations that are frozen.
	IsFrozen *bool `form:"is_frozen,omitempty" json:"is_frozen,omitempty"`

	// IsSpam Filters for conversations that are spam.
	IsSpam *bool `form:"is_spam,omitempty" json:"is_spam,omitempty"`

	// Members Filters for conversations where these users are participants.
	Members *[]string `form:"members,omitempty" json:"members,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// OwnedBy Filters for conversations owned by any of these users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// RevOrg Filters for conversations that are associated with any of the
	// provided Rev organizations.
	RevOrg *[]string `form:"rev_org,omitempty" json:"rev_org,omitempty"`

	// RevOrgs Filters for conversations that are associated with any of the
	// provided Rev organizations.
	RevOrgs *[]string `form:"rev_orgs,omitempty" json:"rev_orgs,omitempty"`

	// SlaSummaryStage Filters for records with any of the provided SLA stages.
	SlaSummaryStage *[]SlaSummaryStage `form:"sla_summary.stage,omitempty" json:"sla_summary.stage,omitempty"`

	// SourceChannel Filters for conversations with any of the provided source channels.
	SourceChannel *[]string `form:"source_channel,omitempty" json:"source_channel,omitempty"`

	// SourceChannelV2 Filters for conversations that are associated with the source
	// channel.
	SourceChannelV2 *[]string `form:"source_channel_v2,omitempty" json:"source_channel_v2,omitempty"`

	// SourceChannels Filters for conversations with any of the provided source channels.
	SourceChannels *[]string `form:"source_channels,omitempty" json:"source_channels,omitempty"`

	// StageName Filters for records in the provided stage(s) by name.
	StageName *[]string `form:"stage.name,omitempty" json:"stage.name,omitempty"`

	// State Filters for conversations with any of the provided states.
	State *[]string `form:"state,omitempty" json:"state,omitempty"`

	// Subtype Filters for conversation with any of the provided subtypes.
	Subtype *[]string `form:"subtype,omitempty" json:"subtype,omitempty"`

	// Tags Filters for conversations with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// TagsV2Id The ID of the tag.
	TagsV2Id *string `form:"tags_v2.id,omitempty" json:"tags_v2.id,omitempty"`

	// TagsV2Value The value for the object's association with the tag. If specified,
	// the value must be one that's specified in the tag's allowed values.
	TagsV2Value *string `form:"tags_v2.value,omitempty" json:"tags_v2.value,omitempty"`
}

// ConversationsGetParams defines parameters for ConversationsGet.
type ConversationsGetParams struct {
	// Id The requested conversation's ID.
	Id string `form:"id" json:"id"`
}

// ConversationsListParams defines parameters for ConversationsList.
type ConversationsListParams struct {
	// AppliesToParts Filters for conversations belonging to any of the provided parts.
	AppliesToParts *[]string `form:"applies_to_parts,omitempty" json:"applies_to_parts,omitempty"`

	// Brand Filters for tickets that are associated with any of the brands.
	Brand *[]string `form:"brand,omitempty" json:"brand,omitempty"`

	// Channels Filters for conversations that are associated with any of the
	// channels.
	Channels *[]string `form:"channels,omitempty" json:"channels,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Group Filters for conversation that belong to the given groups.
	Group *[]string `form:"group,omitempty" json:"group,omitempty"`

	// IsCreatorVerified Filters for conversations that are created by verified users.
	IsCreatorVerified *bool `form:"is_creator_verified,omitempty" json:"is_creator_verified,omitempty"`

	// IsFrozen Filters for conversations that are frozen.
	IsFrozen *bool `form:"is_frozen,omitempty" json:"is_frozen,omitempty"`

	// IsSpam Filters for conversations that are spam.
	IsSpam *bool `form:"is_spam,omitempty" json:"is_spam,omitempty"`

	// Limit The maximum number of conversations to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Members Filters for conversations where these users are participants.
	Members *[]string `form:"members,omitempty" json:"members,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// OwnedBy Filters for conversations owned by any of these users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// RevOrg Filters for conversations that are associated with any of the
	// provided Rev organizations.
	RevOrg *[]string `form:"rev_org,omitempty" json:"rev_org,omitempty"`

	// RevOrgs Filters for conversations that are associated with any of the
	// provided Rev organizations.
	RevOrgs *[]string `form:"rev_orgs,omitempty" json:"rev_orgs,omitempty"`

	// SlaSummaryStage Filters for records with any of the provided SLA stages.
	SlaSummaryStage *[]SlaSummaryStage `form:"sla_summary.stage,omitempty" json:"sla_summary.stage,omitempty"`

	// SourceChannel Filters for conversations with any of the provided source channels.
	SourceChannel *[]string `form:"source_channel,omitempty" json:"source_channel,omitempty"`

	// SourceChannelV2 Filters for conversations that are associated with the source
	// channel.
	SourceChannelV2 *[]string `form:"source_channel_v2,omitempty" json:"source_channel_v2,omitempty"`

	// SourceChannels Filters for conversations with any of the provided source channels.
	SourceChannels *[]string `form:"source_channels,omitempty" json:"source_channels,omitempty"`

	// StageName Filters for records in the provided stage(s) by name.
	StageName *[]string `form:"stage.name,omitempty" json:"stage.name,omitempty"`

	// State Filters for conversations with any of the provided states.
	State *[]string `form:"state,omitempty" json:"state,omitempty"`

	// Subtype Filters for conversation with any of the provided subtypes.
	Subtype *[]string `form:"subtype,omitempty" json:"subtype,omitempty"`

	// Tags Filters for conversations with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// TagsV2Id The ID of the tag.
	TagsV2Id *string `form:"tags_v2.id,omitempty" json:"tags_v2.id,omitempty"`

	// TagsV2Value The value for the object's association with the tag. If specified,
	// the value must be one that's specified in the tag's allowed values.
	TagsV2Value *string `form:"tags_v2.value,omitempty" json:"tags_v2.value,omitempty"`
}

// CustomObjectsCountParams defines parameters for CustomObjectsCount.
type CustomObjectsCountParams struct {
	// LeafType Leaf type to filter.
	LeafType string `form:"leaf_type" json:"leaf_type"`

	// Filters List of filters to apply.
	Filters *[]interface{} `form:"filters,omitempty" json:"filters,omitempty"`
}

// CustomObjectsGetParams defines parameters for CustomObjectsGet.
type CustomObjectsGetParams struct {
	// Id The ID of the custom object to get.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// CustomObjectsListParams defines parameters for CustomObjectsList.
type CustomObjectsListParams struct {
	// LeafType Leaf type to filter.
	LeafType string `form:"leaf_type" json:"leaf_type"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Filter List of filters to apply.
	Filter *[]interface{} `form:"filter,omitempty" json:"filter,omitempty"`

	// Filters List of filters to apply.
	Filters *[]interface{} `form:"filters,omitempty" json:"filters,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// DevOrgAuthConnectionsGetParams defines parameters for DevOrgAuthConnectionsGet.
type DevOrgAuthConnectionsGetParams struct {
	// Id ID of the authentication connection.
	Id string `form:"id" json:"id"`
}

// DevUsersGetParams defines parameters for DevUsersGet.
type DevUsersGetParams struct {
	// Id User ID of the requested Dev user.
	Id string `form:"id" json:"id"`
}

// DevUsersListParams defines parameters for DevUsersList.
type DevUsersListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Email Filters Dev users based on email addresses.
	Email *[]string `form:"email,omitempty" json:"email,omitempty"`

	// ExternalIdentityId Unique ID of the user in the external source.
	ExternalIdentityId *string `form:"external_identity.id,omitempty" json:"external_identity.id,omitempty"`

	// ExternalIdentityIssuer Issuer of the external identity of the user.
	ExternalIdentityIssuer *string `form:"external_identity.issuer,omitempty" json:"external_identity.issuer,omitempty"`

	// Limit The maximum number of Dev users to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// SortBy Fields to sort the Dev users by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// State Filters Dev users based on state.
	State *[]UserState `form:"state,omitempty" json:"state,omitempty"`
}

// DirectoriesCountParams defines parameters for DirectoriesCount.
type DirectoriesCountParams struct {
	// CreatedBy Filters for directories created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// ModifiedBy Filters for directories modified by any of the provided users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`
}

// DirectoriesGetParams defines parameters for DirectoriesGet.
type DirectoriesGetParams struct {
	// Id The ID of the requested directory.
	Id string `form:"id" json:"id"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `form:"dev_org,omitempty" json:"dev_org,omitempty"`
}

// DirectoriesListParams defines parameters for DirectoriesList.
type DirectoriesListParams struct {
	// CreatedBy Filters for directories created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// DevOrg Optional Dev Org ID for the unauthenticated user.
	DevOrg *string `form:"dev_org,omitempty" json:"dev_org,omitempty"`

	// Limit The maximum number of directories to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedBy Filters for directories modified by any of the provided users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`
}

// EngagementsCountParams defines parameters for EngagementsCount.
type EngagementsCountParams struct {
	// ExternalRef Filters for meetings with the provided external_refs.
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// Members Filters for engagement of the provided members.
	Members *[]string `form:"members,omitempty" json:"members,omitempty"`

	// Parent Filters for engagements with the provided parent.
	Parent *[]string `form:"parent,omitempty" json:"parent,omitempty"`

	// Type Filters for engagement of the provided types.
	Type *[]EngagementType `form:"type,omitempty" json:"type,omitempty"`
}

// EngagementsGetParams defines parameters for EngagementsGet.
type EngagementsGetParams struct {
	// Id The engagement ID.
	Id string `form:"id" json:"id"`
}

// EngagementsListParams defines parameters for EngagementsList.
type EngagementsListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// ExternalRef Filters for meetings with the provided external_refs.
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// Limit The maximum number of engagements to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Members Filters for engagement of the provided members.
	Members *[]string `form:"members,omitempty" json:"members,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Parent Filters for engagements with the provided parent.
	Parent *[]string `form:"parent,omitempty" json:"parent,omitempty"`

	// SortBy Fields to sort the engagements by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Type Filters for engagement of the provided types.
	Type *[]EngagementType `form:"type,omitempty" json:"type,omitempty"`
}

// EventSourcesGetParams defines parameters for EventSourcesGet.
type EventSourcesGetParams struct {
	// Id The event source's ID.
	Id string `form:"id" json:"id"`
}

// GroupsGetParams defines parameters for GroupsGet.
type GroupsGetParams struct {
	// Id The ID of the group to get.
	Id string `form:"id" json:"id"`
}

// GroupsListParams defines parameters for GroupsList.
type GroupsListParams struct {
	// CreatedBy Filters the groups on the basis of creator.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// GroupType Filters the groups based on the group type.
	GroupType *[]GroupType `form:"group_type,omitempty" json:"group_type,omitempty"`

	// IngestionSource Filter groups by ingestion source(s).
	IngestionSource *[]GroupIngestionSource `form:"ingestion_source,omitempty" json:"ingestion_source,omitempty"`

	// IsDefault Whether to fetch default or custom groups.
	IsDefault *bool `form:"is_default,omitempty" json:"is_default,omitempty"`

	// Limit The maximum number of groups to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberType Filters the groups on basis of member type.
	MemberType *[]GroupMemberType `form:"member_type,omitempty" json:"member_type,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Name Filters the groups on the basis of group name.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// SortBy Comma-separated fields to sort the groups by.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SyncMetadataExternalReference Filters for issues with this specific external reference.
	SyncMetadataExternalReference *[]string `form:"sync_metadata.external_reference,omitempty" json:"sync_metadata.external_reference,omitempty"`

	// SyncMetadataLastSyncInStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncInStatus *[]SyncMetadataFilterSyncInFilterStatus `form:"sync_metadata.last_sync_in.status,omitempty" json:"sync_metadata.last_sync_in.status,omitempty"`

	// SyncMetadataLastSyncInSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncInSyncHistory *[]string `form:"sync_metadata.last_sync_in.sync_history,omitempty" json:"sync_metadata.last_sync_in.sync_history,omitempty"`

	// SyncMetadataLastSyncInSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncInSyncUnit *[]string `form:"sync_metadata.last_sync_in.sync_unit,omitempty" json:"sync_metadata.last_sync_in.sync_unit,omitempty"`

	// SyncMetadataLastSyncOutStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncOutStatus *[]SyncMetadataFilterSyncOutFilterStatus `form:"sync_metadata.last_sync_out.status,omitempty" json:"sync_metadata.last_sync_out.status,omitempty"`

	// SyncMetadataLastSyncOutSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncOutSyncHistory *[]string `form:"sync_metadata.last_sync_out.sync_history,omitempty" json:"sync_metadata.last_sync_out.sync_history,omitempty"`

	// SyncMetadataLastSyncOutSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncOutSyncUnit *[]string `form:"sync_metadata.last_sync_out.sync_unit,omitempty" json:"sync_metadata.last_sync_out.sync_unit,omitempty"`

	// SyncMetadataOriginSystem Filters for issues synced from this specific origin system.
	SyncMetadataOriginSystem *[]string `form:"sync_metadata.origin_system,omitempty" json:"sync_metadata.origin_system,omitempty"`
}

// GroupMembersListParams defines parameters for GroupMembersList.
type GroupMembersListParams struct {
	// Group ID of the group for which to list members.
	Group string `form:"group" json:"group"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of members to return. If not set, then the default
	// is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`
}

// IncidentsGetParams defines parameters for IncidentsGet.
type IncidentsGetParams struct {
	// Id The ID of the incident to get.
	Id string `form:"id" json:"id"`
}

// IncidentsGroupParams defines parameters for IncidentsGroup.
type IncidentsGroupParams struct {
	// GroupBy The field to group the incidents by.
	GroupBy string `form:"group_by" json:"group_by"`

	// AppliesToParts Filters for incidents that apply to any of the provided parts.
	AppliesToParts *[]string `form:"applies_to_parts,omitempty" json:"applies_to_parts,omitempty"`

	// CreatedBy Filters for incidents created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Limit The maximum number of groups to return. If not set, then the default
	// is '10'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// LimitPerGroup The maximum number of incidents to return for an individual group.
	// The default is '50'.
	LimitPerGroup *int32 `form:"limit_per_group,omitempty" json:"limit_per_group,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// OwnedBy Filters for incidents owned by any of the provided users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// Pia Filters for incidents with any of the provided PIAs.
	Pia *[]string `form:"pia,omitempty" json:"pia,omitempty"`

	// Playbooks Filters for incidents with any of the provided playbooks.
	Playbooks *[]string `form:"playbooks,omitempty" json:"playbooks,omitempty"`

	// RelatedDocs Filters for incidents with any of the provided related docs.
	RelatedDocs *[]string `form:"related_docs,omitempty" json:"related_docs,omitempty"`

	// ReportedBy Filters for incidents with any of the provided reporters.
	ReportedBy *[]int64 `form:"reported_by,omitempty" json:"reported_by,omitempty"`

	// Severity Filters for incidents containing any of the provided severities.
	Severity *[]int64 `form:"severity,omitempty" json:"severity,omitempty"`

	// SortBy Comma-separated fields to sort the incidents by.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Source Filters for incidents with any of the provided sources.
	Source *[]int64 `form:"source,omitempty" json:"source,omitempty"`

	// Stage Filters for incidents in any of the provided stages.
	Stage *[]string `form:"stage,omitempty" json:"stage,omitempty"`

	// StagedInfoIsStaged Filters for issues that are staged.
	StagedInfoIsStaged *bool `form:"staged_info.is_staged,omitempty" json:"staged_info.is_staged,omitempty"`

	// Subtype Filters for incidents with any of the provided subtypes.
	Subtype *[]string `form:"subtype,omitempty" json:"subtype,omitempty"`

	// SyncMetadataExternalReference Filters for issues with this specific external reference.
	SyncMetadataExternalReference *[]string `form:"sync_metadata.external_reference,omitempty" json:"sync_metadata.external_reference,omitempty"`

	// SyncMetadataLastSyncInStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncInStatus *[]SyncMetadataFilterSyncInFilterStatus `form:"sync_metadata.last_sync_in.status,omitempty" json:"sync_metadata.last_sync_in.status,omitempty"`

	// SyncMetadataLastSyncInSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncInSyncHistory *[]string `form:"sync_metadata.last_sync_in.sync_history,omitempty" json:"sync_metadata.last_sync_in.sync_history,omitempty"`

	// SyncMetadataLastSyncInSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncInSyncUnit *[]string `form:"sync_metadata.last_sync_in.sync_unit,omitempty" json:"sync_metadata.last_sync_in.sync_unit,omitempty"`

	// SyncMetadataLastSyncOutStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncOutStatus *[]SyncMetadataFilterSyncOutFilterStatus `form:"sync_metadata.last_sync_out.status,omitempty" json:"sync_metadata.last_sync_out.status,omitempty"`

	// SyncMetadataLastSyncOutSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncOutSyncHistory *[]string `form:"sync_metadata.last_sync_out.sync_history,omitempty" json:"sync_metadata.last_sync_out.sync_history,omitempty"`

	// SyncMetadataLastSyncOutSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncOutSyncUnit *[]string `form:"sync_metadata.last_sync_out.sync_unit,omitempty" json:"sync_metadata.last_sync_out.sync_unit,omitempty"`

	// SyncMetadataOriginSystem Filters for issues synced from this specific origin system.
	SyncMetadataOriginSystem *[]string `form:"sync_metadata.origin_system,omitempty" json:"sync_metadata.origin_system,omitempty"`

	// Title Filters for incidents by the provided titles.
	Title *[]string `form:"title,omitempty" json:"title,omitempty"`
}

// IncidentsListParams defines parameters for IncidentsList.
type IncidentsListParams struct {
	// AppliesToParts Filters for incidents that apply to any of the provided parts.
	AppliesToParts *[]string `form:"applies_to_parts,omitempty" json:"applies_to_parts,omitempty"`

	// CreatedBy Filters for incidents created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// OwnedBy Filters for incidents owned by any of the provided users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// Pia Filters for incidents with any of the provided PIAs.
	Pia *[]string `form:"pia,omitempty" json:"pia,omitempty"`

	// Playbooks Filters for incidents with any of the provided playbooks.
	Playbooks *[]string `form:"playbooks,omitempty" json:"playbooks,omitempty"`

	// RelatedDocs Filters for incidents with any of the provided related docs.
	RelatedDocs *[]string `form:"related_docs,omitempty" json:"related_docs,omitempty"`

	// ReportedBy Filters for incidents with any of the provided reporters.
	ReportedBy *[]int64 `form:"reported_by,omitempty" json:"reported_by,omitempty"`

	// Severity Filters for incidents containing any of the provided severities.
	Severity *[]int64 `form:"severity,omitempty" json:"severity,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Source Filters for incidents with any of the provided sources.
	Source *[]int64 `form:"source,omitempty" json:"source,omitempty"`

	// Stage Filters for incidents in any of the provided stages.
	Stage *[]string `form:"stage,omitempty" json:"stage,omitempty"`

	// StagedInfoIsStaged Filters for issues that are staged.
	StagedInfoIsStaged *bool `form:"staged_info.is_staged,omitempty" json:"staged_info.is_staged,omitempty"`

	// Subtype Filters for incidents with any of the provided subtypes.
	Subtype *[]string `form:"subtype,omitempty" json:"subtype,omitempty"`

	// SyncMetadataExternalReference Filters for issues with this specific external reference.
	SyncMetadataExternalReference *[]string `form:"sync_metadata.external_reference,omitempty" json:"sync_metadata.external_reference,omitempty"`

	// SyncMetadataLastSyncInStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncInStatus *[]SyncMetadataFilterSyncInFilterStatus `form:"sync_metadata.last_sync_in.status,omitempty" json:"sync_metadata.last_sync_in.status,omitempty"`

	// SyncMetadataLastSyncInSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncInSyncHistory *[]string `form:"sync_metadata.last_sync_in.sync_history,omitempty" json:"sync_metadata.last_sync_in.sync_history,omitempty"`

	// SyncMetadataLastSyncInSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncInSyncUnit *[]string `form:"sync_metadata.last_sync_in.sync_unit,omitempty" json:"sync_metadata.last_sync_in.sync_unit,omitempty"`

	// SyncMetadataLastSyncOutStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncOutStatus *[]SyncMetadataFilterSyncOutFilterStatus `form:"sync_metadata.last_sync_out.status,omitempty" json:"sync_metadata.last_sync_out.status,omitempty"`

	// SyncMetadataLastSyncOutSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncOutSyncHistory *[]string `form:"sync_metadata.last_sync_out.sync_history,omitempty" json:"sync_metadata.last_sync_out.sync_history,omitempty"`

	// SyncMetadataLastSyncOutSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncOutSyncUnit *[]string `form:"sync_metadata.last_sync_out.sync_unit,omitempty" json:"sync_metadata.last_sync_out.sync_unit,omitempty"`

	// SyncMetadataOriginSystem Filters for issues synced from this specific origin system.
	SyncMetadataOriginSystem *[]string `form:"sync_metadata.origin_system,omitempty" json:"sync_metadata.origin_system,omitempty"`

	// Title Filters for incidents by the provided titles.
	Title *[]string `form:"title,omitempty" json:"title,omitempty"`
}

// KeyringsCreateCallbackParams defines parameters for KeyringsCreateCallback.
type KeyringsCreateCallbackParams struct {
	// Code Code to exchange for an access token.
	Code string `form:"code" json:"code"`

	// State State value given to the authorization request.
	State string `form:"state" json:"state"`
}

// CustomLinkTypeGetParams defines parameters for CustomLinkTypeGet.
type CustomLinkTypeGetParams struct {
	// Id The ID of the custom link type to get.
	Id string `form:"id" json:"id"`
}

// CustomLinkTypeListParams defines parameters for CustomLinkTypeList.
type CustomLinkTypeListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Deprecated Whether only deprecated link types should be filtered.
	Deprecated *bool `form:"deprecated,omitempty" json:"deprecated,omitempty"`

	// IsDeprecated Whether only deprecated link types should be filtered.
	IsDeprecated *bool `form:"is_deprecated,omitempty" json:"is_deprecated,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Name The list of link type names.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SourceTypesV2IsCustomLeafType True when the descriptor describes a custom leaf type.
	SourceTypesV2IsCustomLeafType *bool `form:"source_types_v2.is_custom_leaf_type,omitempty" json:"source_types_v2.is_custom_leaf_type,omitempty"`

	// SourceTypesV2LeafOnly Set to true when only the specified leaf type (no subtypes) is
	// allowed as a link target.
	SourceTypesV2LeafOnly *bool `form:"source_types_v2.leaf_only,omitempty" json:"source_types_v2.leaf_only,omitempty"`

	// SourceTypesV2LeafType Leaf type of the target objects.
	SourceTypesV2LeafType *string `form:"source_types_v2.leaf_type,omitempty" json:"source_types_v2.leaf_type,omitempty"`

	// SourceTypesV2Subtype Specific subtype of the target objects.
	SourceTypesV2Subtype *string `form:"source_types_v2.subtype,omitempty" json:"source_types_v2.subtype,omitempty"`

	// TargetTypesV2IsCustomLeafType True when the descriptor describes a custom leaf type.
	TargetTypesV2IsCustomLeafType *bool `form:"target_types_v2.is_custom_leaf_type,omitempty" json:"target_types_v2.is_custom_leaf_type,omitempty"`

	// TargetTypesV2LeafOnly Set to true when only the specified leaf type (no subtypes) is
	// allowed as a link target.
	TargetTypesV2LeafOnly *bool `form:"target_types_v2.leaf_only,omitempty" json:"target_types_v2.leaf_only,omitempty"`

	// TargetTypesV2LeafType Leaf type of the target objects.
	TargetTypesV2LeafType *string `form:"target_types_v2.leaf_type,omitempty" json:"target_types_v2.leaf_type,omitempty"`

	// TargetTypesV2Subtype Specific subtype of the target objects.
	TargetTypesV2Subtype *string `form:"target_types_v2.subtype,omitempty" json:"target_types_v2.subtype,omitempty"`
}

// LinksGetParams defines parameters for LinksGet.
type LinksGetParams struct {
	// Id The requested link's ID.
	Id string `form:"id" json:"id"`
}

// LinksListParams defines parameters for LinksList.
type LinksListParams struct {
	// Object The ID of the object to list the links for.
	Object string `form:"object" json:"object"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Direction The direction of the links to list, otherwise if not present, then
	// links in both directions (source and target) are included.
	Direction *LinksDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// Limit The maximum number of links to return. If not set, then the default
	// is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkType The link type(s) to filter for, otherwise if not present, all link
	// types are included.
	LinkType *[]LinkType `form:"link_type,omitempty" json:"link_type,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ObjectTypes The object types to filter for, otherwise if not present, all object
	// types are included.
	ObjectTypes *[]LinkEndpointType `form:"object_types,omitempty" json:"object_types,omitempty"`

	// Types The link types to filter for, otherwise if not present, all link
	// types are included.
	Types *[]LinkType `form:"types,omitempty" json:"types,omitempty"`
}

// MeetingsCountParams defines parameters for MeetingsCount.
type MeetingsCountParams struct {
	// Channel Filters for meeting on specified channels.
	Channel *[]MeetingChannel `form:"channel,omitempty" json:"channel,omitempty"`

	// CreatedBy Filters for meetings created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CustomFields Filters for meeting on custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// ExternalRef Filters for meetings with the provided external_ref(s).
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// LinksLinkType Filters for link type in links associated with the meeting.
	LinksLinkType *string `form:"links.link_type,omitempty" json:"links.link_type,omitempty"`

	// LinksTarget Filters for target id in links associated with the meeting.
	LinksTarget *string `form:"links.target,omitempty" json:"links.target,omitempty"`

	// LinksTargetObjectType Filters for target object type in links associated with the meeting.
	LinksTargetObjectType *string `form:"links.target_object_type,omitempty" json:"links.target_object_type,omitempty"`

	// Members Filter for meeting on specified Member Ids.
	Members *[]string `form:"members,omitempty" json:"members,omitempty"`

	// Organizer Filter for meeting on specified organizers.
	Organizer *[]string `form:"organizer,omitempty" json:"organizer,omitempty"`

	// Parent Filters for meetings with the provided parent.
	Parent *[]string `form:"parent,omitempty" json:"parent,omitempty"`

	// State Filters for meeting on specified state or outcomes.
	State *[]MeetingState `form:"state,omitempty" json:"state,omitempty"`

	// Tags Filters for meeting by tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// MeetingsGetParams defines parameters for MeetingsGet.
type MeetingsGetParams struct {
	// Id The meeting's ID.
	Id string `form:"id" json:"id"`
}

// MeetingsListParams defines parameters for MeetingsList.
type MeetingsListParams struct {
	// Channel Filters for meeting on specified channels.
	Channel *[]MeetingChannel `form:"channel,omitempty" json:"channel,omitempty"`

	// CreatedBy Filters for meetings created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for meeting on custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// ExternalRef Filters for meetings with the provided external_ref(s).
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// Limit The maximum number of meetings to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// LinksLinkType Filters for link type in links associated with the meeting.
	LinksLinkType *string `form:"links.link_type,omitempty" json:"links.link_type,omitempty"`

	// LinksTarget Filters for target id in links associated with the meeting.
	LinksTarget *string `form:"links.target,omitempty" json:"links.target,omitempty"`

	// LinksTargetObjectType Filters for target object type in links associated with the meeting.
	LinksTargetObjectType *string `form:"links.target_object_type,omitempty" json:"links.target_object_type,omitempty"`

	// Members Filter for meeting on specified Member Ids.
	Members *[]string `form:"members,omitempty" json:"members,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Organizer Filter for meeting on specified organizers.
	Organizer *[]string `form:"organizer,omitempty" json:"organizer,omitempty"`

	// Parent Filters for meetings with the provided parent.
	Parent *[]string `form:"parent,omitempty" json:"parent,omitempty"`

	// SortBy Fields to sort the meetings by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// State Filters for meeting on specified state or outcomes.
	State *[]MeetingState `form:"state,omitempty" json:"state,omitempty"`

	// Tags Filters for meeting by tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// MetricDefinitionsGetParams defines parameters for MetricDefinitionsGet.
type MetricDefinitionsGetParams struct {
	// Id The ID of the metric definition to get.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name The unique human readable name of the metric.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// MetricDefinitionsListParams defines parameters for MetricDefinitionsList.
type MetricDefinitionsListParams struct {
	// AppliesToType The type of objects the metric definition applies to.
	AppliesToType *[]MetricDefinitionAppliesTo `form:"applies_to_type,omitempty" json:"applies_to_type,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// IncludeCustomMetrics Whether to include custom metrics in the response. If not set, then
	// custom metrics are excluded.
	IncludeCustomMetrics *bool `form:"include_custom_metrics,omitempty" json:"include_custom_metrics,omitempty"`

	// Limit The maximum number of records to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// SortBy Fields to sort the records by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Status The status of the metric definition.
	Status *[]MetricDefinitionStatus `form:"status,omitempty" json:"status,omitempty"`

	// Type The type of metric definitions sought.
	Type *[]MetricDefinitionMetricType `form:"type,omitempty" json:"type,omitempty"`
}

// MetricTrackersGetParams defines parameters for MetricTrackersGet.
type MetricTrackersGetParams struct {
	// Metric The ID of the metric that is being tracked.
	Metric string `form:"metric" json:"metric"`

	// Object The ID of the underlying object on which the metric is being tracked.
	Object string `form:"object" json:"object"`
}

// OrgScheduleFragmentsGetParams defines parameters for OrgScheduleFragmentsGet.
type OrgScheduleFragmentsGetParams struct {
	// Id Organization schedule Fragment ID.
	Id string `form:"id" json:"id"`
}

// OrgSchedulesEvaluateParams defines parameters for OrgSchedulesEvaluate.
type OrgSchedulesEvaluateParams struct {
	// Id Organization schedule ID.
	Id string `form:"id" json:"id"`

	// Instants Time instants to evaluate the organization schedule for.
	Instants []time.Time `form:"instants" json:"instants"`
}

// OrgSchedulesGetParams defines parameters for OrgSchedulesGet.
type OrgSchedulesGetParams struct {
	// Id Organization schedule ID.
	Id string `form:"id" json:"id"`
}

// OrgSchedulesListParams defines parameters for OrgSchedulesList.
type OrgSchedulesListParams struct {
	// CreatedById Creator ID the filter matches.
	CreatedById *[]string `form:"created_by_id,omitempty" json:"created_by_id,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Max number of organization schedules returned in a page. Default is
	// 50.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Status The organization schedule statuses the filter matches.
	Status *[]OrgScheduleStatus `form:"status,omitempty" json:"status,omitempty"`
}

// PartsGetParams defines parameters for PartsGet.
type PartsGetParams struct {
	// Id The ID of the part to retrieve.
	Id string `form:"id" json:"id"`
}

// PartsListParams defines parameters for PartsList.
type PartsListParams struct {
	// CreatedBy Filters for parts created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// EnhancementAccounts Filters for enhancement by its accounts.
	EnhancementAccounts *[]string `form:"enhancement.accounts,omitempty" json:"enhancement.accounts,omitempty"`

	// EnhancementActualCloseDateAfter Filters for objects created after the provided timestamp (inclusive).
	EnhancementActualCloseDateAfter *time.Time `form:"enhancement.actual_close_date.after,omitempty" json:"enhancement.actual_close_date.after,omitempty"`

	// EnhancementActualCloseDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	EnhancementActualCloseDateBefore *time.Time `form:"enhancement.actual_close_date.before,omitempty" json:"enhancement.actual_close_date.before,omitempty"`

	// EnhancementActualStartDateAfter Filters for objects created after the provided timestamp (inclusive).
	EnhancementActualStartDateAfter *time.Time `form:"enhancement.actual_start_date.after,omitempty" json:"enhancement.actual_start_date.after,omitempty"`

	// EnhancementActualStartDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	EnhancementActualStartDateBefore *time.Time `form:"enhancement.actual_start_date.before,omitempty" json:"enhancement.actual_start_date.before,omitempty"`

	// EnhancementOpportunities Filters for enhancement by its opportunities.
	EnhancementOpportunities *[]string `form:"enhancement.opportunities,omitempty" json:"enhancement.opportunities,omitempty"`

	// EnhancementRevScoreTier Filters for enhancement by its rev score tier.
	EnhancementRevScoreTier *[]EnhancementRevScoreTier `form:"enhancement.rev_score_tier,omitempty" json:"enhancement.rev_score_tier,omitempty"`

	// EnhancementStageV2 List of IDs of the custom stages which will be used for filtering.
	EnhancementStageV2 *[]string `form:"enhancement.stage_v2,omitempty" json:"enhancement.stage_v2,omitempty"`

	// EnhancementStateV2 Filters for part with any of the provided custom states.
	EnhancementStateV2 *[]string `form:"enhancement.state_v2,omitempty" json:"enhancement.state_v2,omitempty"`

	// EnhancementTargetCloseDateAfter Filters for objects created after the provided timestamp (inclusive).
	EnhancementTargetCloseDateAfter *time.Time `form:"enhancement.target_close_date.after,omitempty" json:"enhancement.target_close_date.after,omitempty"`

	// EnhancementTargetCloseDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	EnhancementTargetCloseDateBefore *time.Time `form:"enhancement.target_close_date.before,omitempty" json:"enhancement.target_close_date.before,omitempty"`

	// EnhancementTargetStartDateAfter Filters for objects created after the provided timestamp (inclusive).
	EnhancementTargetStartDateAfter *time.Time `form:"enhancement.target_start_date.after,omitempty" json:"enhancement.target_start_date.after,omitempty"`

	// EnhancementTargetStartDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	EnhancementTargetStartDateBefore *time.Time `form:"enhancement.target_start_date.before,omitempty" json:"enhancement.target_start_date.before,omitempty"`

	// EnhancementTickets Filters for enhancement by its tickets.
	EnhancementTickets *[]string `form:"enhancement.tickets,omitempty" json:"enhancement.tickets,omitempty"`

	// Limit The maximum number of parts to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedBy Filters for parts modified by any of these users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`

	// Name Filters for parts of the provided name(s).
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// OwnedBy Filters for parts owned by any of these users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// ParentPartLevel Number of levels to fetch the part hierarchy up to.
	ParentPartLevel *int32 `form:"parent_part.level,omitempty" json:"parent_part.level,omitempty"`

	// ParentPartParts Part IDs to fetch the hierarchy for. Required if any parent_part.*
	// fields are provided.
	ParentPartParts *[]string `form:"parent_part.parts,omitempty" json:"parent_part.parts,omitempty"`

	// Subtype Filters for subtypes.
	Subtype *[]string `form:"subtype,omitempty" json:"subtype,omitempty"`

	// Tags Filters for part with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Type Filters for parts of the provided type(s).
	Type *[]PartType `form:"type,omitempty" json:"type,omitempty"`
}

// PreferencesGetParams defines parameters for PreferencesGet.
type PreferencesGetParams struct {
	// Object The ID of the target object for which preferences object is to be
	// fetched.
	Object string `form:"object" json:"object"`

	// Type Type of the preference object to be fetched.
	Type PreferencesType `form:"type" json:"type"`

	// LanguageCode Language code for which to get the preferences for.
	LanguageCode *string `form:"language_code,omitempty" json:"language_code,omitempty"`
}

// GetQuestionAnswerParams defines parameters for GetQuestionAnswer.
type GetQuestionAnswerParams struct {
	// Id The ID of the required question-answer.
	Id string `form:"id" json:"id"`
}

// ListQuestionAnswersParams defines parameters for ListQuestionAnswers.
type ListQuestionAnswersParams struct {
	// AppliesToArticles Filters for question-answer belonging to any of the provided
	// articles.
	AppliesToArticles *[]string `form:"applies_to_articles,omitempty" json:"applies_to_articles,omitempty"`

	// AppliesToParts Filters for question-answer belonging to any of the provided parts.
	AppliesToParts *[]string `form:"applies_to_parts,omitempty" json:"applies_to_parts,omitempty"`

	// CreatedBy Filters for question-answers created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of question-answers to return. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// OwnedBy Filters for question-answers owned by any of the provided users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`
}

// ReactionsListParams defines parameters for ReactionsList.
type ReactionsListParams struct {
	// Emoji The emoji to list the reactors for. This can be the short name of the
	// emoji (e.g. "joy"), or the code point (e.g. "1f602").
	Emoji string `form:"emoji" json:"emoji"`

	// Object The ID of the object to list reactors for.
	Object string `form:"object" json:"object"`

	// Cursor The cursor to resume iteration from, otherwise if not provided, then
	// iteration starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of reactors to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// RecordTemplateGetParams defines parameters for RecordTemplateGet.
type RecordTemplateGetParams struct {
	// Id The ID of the record template.
	Id string `form:"id" json:"id"`
}

// RevOrgsGetParams defines parameters for RevOrgsGet.
type RevOrgsGetParams struct {
	// Account The ID of account for which default Rev organization is to be
	// fetched.
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Id The ID of the required Rev organization.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// RevOrgsListParams defines parameters for RevOrgsList.
type RevOrgsListParams struct {
	// Account Filters by account.
	Account *[]string `form:"account,omitempty" json:"account,omitempty"`

	// CreatedBy Filters by creator.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFieldFilter Filters on custom fields. Input will be of the format
	// (custom_field_filter=field_name1:val1,val2,val3&custom_field_filter=field_name2:val1,val2).
	CustomFieldFilter *[]string `form:"custom_field_filter,omitempty" json:"custom_field_filter,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// DisplayName Array of display names of Rev orgs to be filtered.
	DisplayName *[]string `form:"display_name,omitempty" json:"display_name,omitempty"`

	// ExternalRef List of external refs to filter Rev organizations for.
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// Limit The maximum number of Rev organizations to be retrieved per page.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// SortBy Fields to sort the Rev organizations by and the direction to sort
	// them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// RevUsersAssociationsListParams defines parameters for RevUsersAssociationsList.
type RevUsersAssociationsListParams struct {
	// RevUserId The ID of Rev user to list all associations of.
	RevUserId string `form:"rev_user_id" json:"rev_user_id"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of Associations to return per page. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`
}

// RevUsersGetParams defines parameters for RevUsersGet.
type RevUsersGetParams struct {
	// Id The ID of Rev user to be retrieved.
	Id string `form:"id" json:"id"`
}

// RevUsersListParams defines parameters for RevUsersList.
type RevUsersListParams struct {
	// Associations Filters for Rev users with specified associations
	// (account/workspace).
	Associations *[]string `form:"associations,omitempty" json:"associations,omitempty"`

	// CreatedBy Filters for Rev users that were created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Email List of emails of Rev users to be filtered.
	Email *[]string `form:"email,omitempty" json:"email,omitempty"`

	// ExternalRef List of external refs to filter Rev users for.
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// ExternalRefs Filters for Rev users with the provided external_refs.
	ExternalRefs *[]string `form:"external_refs,omitempty" json:"external_refs,omitempty"`

	// IsVerified Value of is_verified field to filter the Rev users.
	IsVerified *bool `form:"is_verified,omitempty" json:"is_verified,omitempty"`

	// Limit The maximum number of Rev users to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// PhoneNumbers List of phone numbers, in E.164 format, to filter Rev users on.
	PhoneNumbers *[]string `form:"phone_numbers,omitempty" json:"phone_numbers,omitempty"`

	// RevOrg List of IDs of Rev organizations to be filtered.
	RevOrg *[]string `form:"rev_org,omitempty" json:"rev_org,omitempty"`

	// SortBy Fields to sort the Rev users by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// RevUsersScanParams defines parameters for RevUsersScan.
type RevUsersScanParams struct {
	// Associations Filters for Rev users with specified associations
	// (account/workspace).
	Associations *[]string `form:"associations,omitempty" json:"associations,omitempty"`

	// CreatedBy Filters for Rev users that were created by the specified user(s).
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration, otherwise the beginning if not
	// provided.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// Email List of emails of Rev users to be filtered.
	Email *[]string `form:"email,omitempty" json:"email,omitempty"`

	// ExternalRef List of external refs to filter Rev users for.
	ExternalRef *[]string `form:"external_ref,omitempty" json:"external_ref,omitempty"`

	// ExternalRefs Filters for Rev users with the provided external_refs.
	ExternalRefs *[]string `form:"external_refs,omitempty" json:"external_refs,omitempty"`

	// IsVerified Value of is_verified field to filter the Rev users.
	IsVerified *bool `form:"is_verified,omitempty" json:"is_verified,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// PhoneNumbers List of phone numbers, in E.164 format, to filter Rev users on.
	PhoneNumbers *[]string `form:"phone_numbers,omitempty" json:"phone_numbers,omitempty"`

	// RevOrg List of IDs of Rev organizations to be filtered.
	RevOrg *[]string `form:"rev_org,omitempty" json:"rev_org,omitempty"`

	// Tags List of tags to be filtered.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// AggregatedSchemaGetParams defines parameters for AggregatedSchemaGet.
type AggregatedSchemaGetParams struct {
	// CustomSchemaFragmentIds The list of custom schema fragment DONs which are to be aggregated.
	CustomSchemaFragmentIds *[]string `form:"custom_schema_fragment_ids,omitempty" json:"custom_schema_fragment_ids,omitempty"`

	// CustomSchemaSpecApps List of apps.
	CustomSchemaSpecApps *[]string `form:"custom_schema_spec.apps,omitempty" json:"custom_schema_spec.apps,omitempty"`

	// CustomSchemaSpecSubtype Name of the subtype.
	CustomSchemaSpecSubtype *string `form:"custom_schema_spec.subtype,omitempty" json:"custom_schema_spec.subtype,omitempty"`

	// IsCustomLeafType Whether the leaf type corresponds to a custom object.
	IsCustomLeafType *bool `form:"is_custom_leaf_type,omitempty" json:"is_custom_leaf_type,omitempty"`

	// LeafType The leaf type. Used for inferring the default stage diagram and
	// tenant fragment ID.
	LeafType *string `form:"leaf_type,omitempty" json:"leaf_type,omitempty"`

	// StockSchemaFragmentId The stock schema fragment which is to be aggregated.
	StockSchemaFragmentId *string `form:"stock_schema_fragment_id,omitempty" json:"stock_schema_fragment_id,omitempty"`
}

// CustomSchemaFragmentsGetParams defines parameters for CustomSchemaFragmentsGet.
type CustomSchemaFragmentsGetParams struct {
	// Id The ID of the custom schema fragment.
	Id string `form:"id" json:"id"`
}

// CustomSchemaFragmentsListParams defines parameters for CustomSchemaFragmentsList.
type CustomSchemaFragmentsListParams struct {
	// App The list of app names.
	App *[]string `form:"app,omitempty" json:"app,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Deprecated Whether only deprecated fragments should be filtered.
	Deprecated *bool `form:"deprecated,omitempty" json:"deprecated,omitempty"`

	// IsCustomLeafType Whether the leaf type corresponds to a custom object
	IsCustomLeafType *bool `form:"is_custom_leaf_type,omitempty" json:"is_custom_leaf_type,omitempty"`

	// IsDeprecated Whether the fragment has been deprecated.
	IsDeprecated *bool `form:"is_deprecated,omitempty" json:"is_deprecated,omitempty"`

	// LeafType The list of leaf types.
	LeafType *[]string `form:"leaf_type,omitempty" json:"leaf_type,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Prune List of fields which are not required in the payload and can be
	// pruned away.
	Prune *[]CustomSchemaFragmentsListRequestPrune `form:"prune,omitempty" json:"prune,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Subtype The list of subtypes.
	Subtype *[]string `form:"subtype,omitempty" json:"subtype,omitempty"`

	// Types Filters for custom schema fragment of the provided types.
	Types *[]CustomSchemaFragmentType `form:"types,omitempty" json:"types,omitempty"`
}

// StockSchemaFragmentsGetParams defines parameters for StockSchemaFragmentsGet.
type StockSchemaFragmentsGetParams struct {
	// Id The ID of the stock schema fragment.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// LeafType The leaf type this fragment applies to.
	LeafType *string `form:"leaf_type,omitempty" json:"leaf_type,omitempty"`
}

// StockSchemaFragmentsListParams defines parameters for StockSchemaFragmentsList.
type StockSchemaFragmentsListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// FilterPreset Filter preset to specify whether to filter only customization enabled
	// leaf types.
	FilterPreset *StockSchemaFragmentsListRequestFilterPreset `form:"filter_preset,omitempty" json:"filter_preset,omitempty"`

	// LeafType The list of leaf types.
	LeafType *[]string `form:"leaf_type,omitempty" json:"leaf_type,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Prune List of fields which are not required in the payload and can be
	// pruned away.
	Prune *[]StockSchemaFragmentsListRequestPrune `form:"prune,omitempty" json:"prune,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// SubtypesListParams defines parameters for SubtypesList.
type SubtypesListParams struct {
	// LeafType Leaf type for which subtypes are required.
	LeafType *string `form:"leaf_type,omitempty" json:"leaf_type,omitempty"`

	// LeafTypes List of leaf types for which subtypes are required.
	LeafTypes *[]string `form:"leaf_types,omitempty" json:"leaf_types,omitempty"`
}

// SearchCoreParams defines parameters for SearchCore.
type SearchCoreParams struct {
	// Query The query string. Search query language:
	// https://docs.devrev.ai/product/search#fields
	Query string `form:"query" json:"query"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of items to return in a page. The default is '10'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Namespaces The namespaces to search in.
	Namespaces *[]SearchNamespace `form:"namespaces,omitempty" json:"namespaces,omitempty"`

	// SortBy The property on which to sort the search results. The default is
	// RELEVANCE.
	SortBy *SearchSortByParam `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortOrder Sorting order. The default is DESCENDING.
	SortOrder *SearchSortOrderParam `form:"sort_order,omitempty" json:"sort_order,omitempty"`
}

// SearchHybridParams defines parameters for SearchHybrid.
type SearchHybridParams struct {
	// Namespace The hybrid namespace to search in.
	Namespace SearchHybridNamespace `form:"namespace" json:"namespace"`

	// Query The query string.
	Query string `form:"query" json:"query"`

	// Limit The maximum number of items to return in a page. The default is '10'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SemanticWeight The weightage for semantic search. Values between 0 and 1 are
	// accepted.
	SemanticWeight *float32 `form:"semantic_weight,omitempty" json:"semantic_weight,omitempty"`
}

// ServiceAccountsGetParams defines parameters for ServiceAccountsGet.
type ServiceAccountsGetParams struct {
	// Id The ID of the requested service account.
	Id string `form:"id" json:"id"`
}

// SlaTrackersGetParams defines parameters for SlaTrackersGet.
type SlaTrackersGetParams struct {
	// Id The ID of the SLA tracker to get.
	Id string `form:"id" json:"id"`
}

// SlaTrackersListParams defines parameters for SlaTrackersList.
type SlaTrackersListParams struct {
	// CreatedDateAfter Filters for objects created after the provided timestamp (inclusive).
	CreatedDateAfter *time.Time `form:"created_date.after,omitempty" json:"created_date.after,omitempty"`

	// CreatedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	CreatedDateBefore *time.Time `form:"created_date.before,omitempty" json:"created_date.before,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of SLA trackers to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedDateAfter Filters for objects created after the provided timestamp (inclusive).
	ModifiedDateAfter *time.Time `form:"modified_date.after,omitempty" json:"modified_date.after,omitempty"`

	// ModifiedDateBefore Filters for objects created before the provided timestamp
	// (inclusive).
	ModifiedDateBefore *time.Time `form:"modified_date.before,omitempty" json:"modified_date.before,omitempty"`

	// SortBy Fields to sort the SLA Trackers by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Stage The SLA tracker stages the filter matches.
	Stage *[]string `form:"stage,omitempty" json:"stage,omitempty"`

	// Status The SLA tracker statuses the filter matches.
	Status *[]string `form:"status,omitempty" json:"status,omitempty"`
}

// SlasGetParams defines parameters for SlasGet.
type SlasGetParams struct {
	// Id The ID of the SLA to get.
	Id string `form:"id" json:"id"`
}

// SlasListParams defines parameters for SlasList.
type SlasListParams struct {
	// AppliesTo The object types the SLA applies to.
	AppliesTo *[]SlaAppliesTo `form:"applies_to,omitempty" json:"applies_to,omitempty"`

	// AppliesToOp The Filter operator to be applied on the applies to object types
	// filter.
	AppliesToOp *SlasFilterAppliesToOperatorType `form:"applies_to_op,omitempty" json:"applies_to_op,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of SLAs to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// SlaType The SLA types the filter matches.
	SlaType *[]SlaType `form:"sla_type,omitempty" json:"sla_type,omitempty"`

	// SortBy Fields to sort the SLAs by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Status The SLA statuses the filter matches.
	Status *[]SlaStatus `form:"status,omitempty" json:"status,omitempty"`
}

// SnapInsResourcesParams defines parameters for SnapInsResources.
type SnapInsResourcesParams struct {
	// Id The ID of the snap-in to get resources for.
	Id string `form:"id" json:"id"`

	// User The ID of the user to get resources for.
	User string `form:"user" json:"user"`
}

// StageDiagramsGetParams defines parameters for StageDiagramsGet.
type StageDiagramsGetParams struct {
	// Id The ID of the stage diagram to get.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// IsCustomLeafType Whether the leaf type corresponds to a custom object. Specify this
	// along with leaf_type to get the default custom object stage diagram.
	IsCustomLeafType *bool `form:"is_custom_leaf_type,omitempty" json:"is_custom_leaf_type,omitempty"`

	// LeafType The leaf type. Should be specified to retrieve the default stage
	// diagram for the leaf type. If not provided, then id is used.
	LeafType *string `form:"leaf_type,omitempty" json:"leaf_type,omitempty"`
}

// StageDiagramsListParams defines parameters for StageDiagramsList.
type StageDiagramsListParams struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided, then
	// iteration starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// IsCustomLeafType Whether only custom object stage diagrams should be filtered.
	IsCustomLeafType *bool `form:"is_custom_leaf_type,omitempty" json:"is_custom_leaf_type,omitempty"`

	// LeafType The list of leaf types.
	LeafType *[]string `form:"leaf_type,omitempty" json:"leaf_type,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Name The list of stage diagram names.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// CustomStagesGetParams defines parameters for CustomStagesGet.
type CustomStagesGetParams struct {
	// Id The ID of the custom stage to get.
	Id string `form:"id" json:"id"`
}

// CustomStagesListParams defines parameters for CustomStagesList.
type CustomStagesListParams struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided, then
	// iteration starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Name The list of stage names.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// Ordinal The list of stage ordinals.
	Ordinal *[]int32 `form:"ordinal,omitempty" json:"ordinal,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// CustomStatesGetParams defines parameters for CustomStatesGet.
type CustomStatesGetParams struct {
	// Id The ID of the custom state to get.
	Id string `form:"id" json:"id"`
}

// CustomStatesListParams defines parameters for CustomStatesList.
type CustomStatesListParams struct {
	// Cursor The cursor to resume iteration from, otherwise if not provided, then
	// iteration starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// IsFinal Whether only final states should be filtered.
	IsFinal *bool `form:"is_final,omitempty" json:"is_final,omitempty"`

	// Limit The maximum number of items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Name The list of state names.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// Ordinal The list of state ordinals.
	Ordinal *[]int32 `form:"ordinal,omitempty" json:"ordinal,omitempty"`

	// SortBy The list of fields to sort the items by and how to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// SubscribersListParams defines parameters for SubscribersList.
type SubscribersListParams struct {
	// Id The object's ID.
	Id string `form:"id" json:"id"`

	// Cursor The cursor to resume iteration from, otherwise if not provided, then
	// iteration starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of subscribers to return. If not set or `<= 0`,
	// then this defaults to `50`.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SurveysGetParams defines parameters for SurveysGet.
type SurveysGetParams struct {
	// Id The ID of the survey to get.
	Id string `form:"id" json:"id"`
}

// SurveysListParams defines parameters for SurveysList.
type SurveysListParams struct {
	// CreatedBy Filters for surveys created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of surveys to return. If not set, then the default
	// is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Name Filters for surveys by name(s).
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// SortBy Fields to sort the surveys by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// SurveysResponsesListParams defines parameters for SurveysResponsesList.
type SurveysResponsesListParams struct {
	// CreatedBy Filters for survey responses created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// DispatchIds Filters for survey responses associated with these unique IDs.
	DispatchIds *[]string `form:"dispatch_ids,omitempty" json:"dispatch_ids,omitempty"`

	// Limit The maximum number of survey responses to return. If not set, then
	// the default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Objects Filters for survey responses created for the objects.
	Objects *[]string `form:"objects,omitempty" json:"objects,omitempty"`

	// Recipient Filters for survey responses dispatched to any of these users.
	Recipient *[]string `form:"recipient,omitempty" json:"recipient,omitempty"`

	// SortBy Fields to sort the survey responses by and the direction to sort
	// them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Stages Filters for survey response stages.
	Stages *[]int64 `form:"stages,omitempty" json:"stages,omitempty"`

	// Surveys Filters for survey responses for the provided survey IDs.
	Surveys *[]string `form:"surveys,omitempty" json:"surveys,omitempty"`
}

// SysUsersListParams defines parameters for SysUsersList.
type SysUsersListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of system users to return. Value can range from
	// '1' to '100', with a default of '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// SortBy Fields to sort the system users by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// TagsGetParams defines parameters for TagsGet.
type TagsGetParams struct {
	// Id The requested tag's ID.
	Id string `form:"id" json:"id"`
}

// TagsListParams defines parameters for TagsList.
type TagsListParams struct {
	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of tags to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Name Filters for tags with the provided names.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// SortBy Fields to sort tags by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// TimelineEntriesGetParams defines parameters for TimelineEntriesGet.
type TimelineEntriesGetParams struct {
	// Id The ID of the timeline entry to get.
	Id string `form:"id" json:"id"`

	// ExternalRef If set, then gets the entry with the given external reference for the
	// provided entry ID's timeline.
	ExternalRef *string `form:"external_ref,omitempty" json:"external_ref,omitempty"`
}

// TimelineEntriesListParams defines parameters for TimelineEntriesList.
type TimelineEntriesListParams struct {
	// Object The ID of the object to list timeline entries for.
	Object string `form:"object" json:"object"`

	// Collections The collection(s) to list entries from, otherwise if not provided,
	// all entries are returned.
	Collections *[]TimelineEntriesCollection `form:"collections,omitempty" json:"collections,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Labels Filters for entries containing at least one of the provided labels,
	// otherwise if no labels are provided, then no label filtering is done.
	Labels *[]string `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit The maximum number of entries to return. If not set, then this
	// defaults to `50`.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Visibility The visibility of the timeline entries to filter for. Note this is a
	// strict filter, such that only entries with the exact visibilities
	// specified will be returned.
	Visibility *[]TimelineEntryVisibility `form:"visibility,omitempty" json:"visibility,omitempty"`
}

// UomsCountParams defines parameters for UomsCount.
type UomsCountParams struct {
	// AggregationTypes List of aggregation types for filtering list of UOMs.
	AggregationTypes *[]AggregationDetailAggregationType `form:"aggregation_types,omitempty" json:"aggregation_types,omitempty"`

	// Ids List of Unit of Measurement (UOM) DONs to be used in filtering
	// complete list of UOMs defined in a Dev Org.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// MetricNames List of metric names for filtering list of UOMs.
	MetricNames *[]string `form:"metric_names,omitempty" json:"metric_names,omitempty"`

	// PartIds List of part IDs for filtering list of UOMs.
	PartIds *[]string `form:"part_ids,omitempty" json:"part_ids,omitempty"`

	// ProductIds List of product IDs for filtering list of UOMs.
	ProductIds *[]string `form:"product_ids,omitempty" json:"product_ids,omitempty"`

	// UnitTypes List of unit types for filtering list of UOMs.
	UnitTypes *[]UnitType `form:"unit_types,omitempty" json:"unit_types,omitempty"`
}

// UomsGetParams defines parameters for UomsGet.
type UomsGetParams struct {
	// Id The Unit of Measurement (UOM)'s DON.
	Id string `form:"id" json:"id"`
}

// UomsListParams defines parameters for UomsList.
type UomsListParams struct {
	// AggregationTypes List of aggregation types for filtering list of UOMs.
	AggregationTypes *[]AggregationDetailAggregationType `form:"aggregation_types,omitempty" json:"aggregation_types,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Ids List of Unit of Measurement (UOM) DONs to be used in filtering
	// complete list of UOMs defined in a Dev Org.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit The maximum number of UOMs to be returned in a response. The default
	// is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// MetricNames List of metric names for filtering list of UOMs.
	MetricNames *[]string `form:"metric_names,omitempty" json:"metric_names,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// PartIds List of part IDs for filtering list of UOMs.
	PartIds *[]string `form:"part_ids,omitempty" json:"part_ids,omitempty"`

	// ProductIds List of product IDs for filtering list of UOMs.
	ProductIds *[]string `form:"product_ids,omitempty" json:"product_ids,omitempty"`

	// SortBy Fields to sort the Unit Of Measuments (UOMs) by and the direction to
	// sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// UnitTypes List of unit types for filtering list of UOMs.
	UnitTypes *[]UnitType `form:"unit_types,omitempty" json:"unit_types,omitempty"`
}

// GetWebCrawlerJobParams defines parameters for GetWebCrawlerJob.
type GetWebCrawlerJobParams struct {
	// Id The ID of the job.
	Id string `form:"id" json:"id"`
}

// ListWebCrawlerJobsParams defines parameters for ListWebCrawlerJobs.
type ListWebCrawlerJobsParams struct {
	// CreatedBy Filters for web crawler jobs created by any of the provided users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The maximum number of web crawler jobs to return. The default is
	// '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`
}

// WebhooksGetParams defines parameters for WebhooksGet.
type WebhooksGetParams struct {
	// Id ID for the webhook.
	Id string `form:"id" json:"id"`
}

// WidgetsGetParams defines parameters for WidgetsGet.
type WidgetsGetParams struct {
	// Id The requested widget's ID.
	Id string `form:"id" json:"id"`
}

// WorksExportParams defines parameters for WorksExport.
type WorksExportParams struct {
	// AppliesToPart Filters for work belonging to any of the provided parts.
	AppliesToPart *[]string `form:"applies_to_part,omitempty" json:"applies_to_part,omitempty"`

	// CreatedBy Filters for work created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// First The number of work items to return. The default is '50', the maximum
	// is '5000'.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// IssueAccounts Filters for issues with any of the provided accounts.
	IssueAccounts *[]string `form:"issue.accounts,omitempty" json:"issue.accounts,omitempty"`

	// IssuePriority Filters for issues with any of the provided priorities.
	IssuePriority *[]IssuePriority `form:"issue.priority,omitempty" json:"issue.priority,omitempty"`

	// IssuePriorityV2 Filters for issues with any of the provided priority enum ids.
	IssuePriorityV2 *[]int64 `form:"issue.priority_v2,omitempty" json:"issue.priority_v2,omitempty"`

	// IssueRevOrgs Filters for issues with any of the provided Rev organizations.
	IssueRevOrgs *[]string `form:"issue.rev_orgs,omitempty" json:"issue.rev_orgs,omitempty"`

	// IssueSlaSummaryStage Filters for records with any of the provided SLA stages.
	IssueSlaSummaryStage *[]SlaSummaryStage `form:"issue.sla_summary.stage,omitempty" json:"issue.sla_summary.stage,omitempty"`

	// IssueSprint Filters for issues with any of the sprint.
	IssueSprint *[]string `form:"issue.sprint,omitempty" json:"issue.sprint,omitempty"`

	// IssueSubtype Filters for issues with any of the provided subtypes.
	IssueSubtype *[]string `form:"issue.subtype,omitempty" json:"issue.subtype,omitempty"`

	// ModifiedBy Filters for work modified by any of these users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`

	// OpportunityAccount Filters for opportunities belonging to any of the provided accounts.
	OpportunityAccount *[]string `form:"opportunity.account,omitempty" json:"opportunity.account,omitempty"`

	// OpportunityContacts Filters for opportunities with any of the provided contacts.
	OpportunityContacts *[]string `form:"opportunity.contacts,omitempty" json:"opportunity.contacts,omitempty"`

	// OpportunityForecastCategoryV2 Filters for opportunities with any of the provided forecast category
	// enum IDs.
	OpportunityForecastCategoryV2 *[]int64 `form:"opportunity.forecast_category_v2,omitempty" json:"opportunity.forecast_category_v2,omitempty"`

	// OpportunitySubtype Filters for opportunity with any of the provided subtypes.
	OpportunitySubtype *[]string `form:"opportunity.subtype,omitempty" json:"opportunity.subtype,omitempty"`

	// OwnedBy Filters for work owned by any of these users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// ReportedBy Filters for work reported by any of these users.
	ReportedBy *[]string `form:"reported_by,omitempty" json:"reported_by,omitempty"`

	// SortBy Fields to sort the work items by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// StageName Filters for records in the provided stage(s) by name.
	StageName *[]string `form:"stage.name,omitempty" json:"stage.name,omitempty"`

	// StagedInfoIsStaged Filters for issues that are staged.
	StagedInfoIsStaged *bool `form:"staged_info.is_staged,omitempty" json:"staged_info.is_staged,omitempty"`

	// State Filters for work with any of the provided states.
	State *[]string `form:"state,omitempty" json:"state,omitempty"`

	// SyncMetadataExternalReference Filters for issues with this specific external reference.
	SyncMetadataExternalReference *[]string `form:"sync_metadata.external_reference,omitempty" json:"sync_metadata.external_reference,omitempty"`

	// SyncMetadataLastSyncInStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncInStatus *[]SyncMetadataFilterSyncInFilterStatus `form:"sync_metadata.last_sync_in.status,omitempty" json:"sync_metadata.last_sync_in.status,omitempty"`

	// SyncMetadataLastSyncInSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncInSyncHistory *[]string `form:"sync_metadata.last_sync_in.sync_history,omitempty" json:"sync_metadata.last_sync_in.sync_history,omitempty"`

	// SyncMetadataLastSyncInSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncInSyncUnit *[]string `form:"sync_metadata.last_sync_in.sync_unit,omitempty" json:"sync_metadata.last_sync_in.sync_unit,omitempty"`

	// SyncMetadataLastSyncOutStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncOutStatus *[]SyncMetadataFilterSyncOutFilterStatus `form:"sync_metadata.last_sync_out.status,omitempty" json:"sync_metadata.last_sync_out.status,omitempty"`

	// SyncMetadataLastSyncOutSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncOutSyncHistory *[]string `form:"sync_metadata.last_sync_out.sync_history,omitempty" json:"sync_metadata.last_sync_out.sync_history,omitempty"`

	// SyncMetadataLastSyncOutSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncOutSyncUnit *[]string `form:"sync_metadata.last_sync_out.sync_unit,omitempty" json:"sync_metadata.last_sync_out.sync_unit,omitempty"`

	// SyncMetadataOriginSystem Filters for issues synced from this specific origin system.
	SyncMetadataOriginSystem *[]string `form:"sync_metadata.origin_system,omitempty" json:"sync_metadata.origin_system,omitempty"`

	// Tags Filters for work with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// TicketBrand Filters for tickets that are associated with any of the brands.
	TicketBrand *[]string `form:"ticket.brand,omitempty" json:"ticket.brand,omitempty"`

	// TicketChannels Filters for tickets with any of the provided channels.
	TicketChannels *[]TicketChannels `form:"ticket.channels,omitempty" json:"ticket.channels,omitempty"`

	// TicketChannelsV2 Filters for tickets that are associated with any of the channels.
	TicketChannelsV2 *[]string `form:"ticket.channels_v2,omitempty" json:"ticket.channels_v2,omitempty"`

	// TicketGroup Filters for tickets belonging to specific groups.
	TicketGroup *[]string `form:"ticket.group,omitempty" json:"ticket.group,omitempty"`

	// TicketIsFrozen Filters for frozen tickets.
	TicketIsFrozen *bool `form:"ticket.is_frozen,omitempty" json:"ticket.is_frozen,omitempty"`

	// TicketIsSpam Filters for tickets that are spam.
	TicketIsSpam *bool `form:"ticket.is_spam,omitempty" json:"ticket.is_spam,omitempty"`

	// TicketNeedsResponse Filters for tickets that need response.
	TicketNeedsResponse *bool `form:"ticket.needs_response,omitempty" json:"ticket.needs_response,omitempty"`

	// TicketRevOrg Filters for tickets that are associated with any of the provided Rev
	// organizations.
	TicketRevOrg *[]string `form:"ticket.rev_org,omitempty" json:"ticket.rev_org,omitempty"`

	// TicketSeverity Filters for tickets with any of the provided severities.
	TicketSeverity *[]TicketSeverity `form:"ticket.severity,omitempty" json:"ticket.severity,omitempty"`

	// TicketSlaSummaryStage Filters for records with any of the provided SLA stages.
	TicketSlaSummaryStage *[]SlaSummaryStage `form:"ticket.sla_summary.stage,omitempty" json:"ticket.sla_summary.stage,omitempty"`

	// TicketSourceChannel Filters for tickets with any of the provided source channels.
	TicketSourceChannel *[]string `form:"ticket.source_channel,omitempty" json:"ticket.source_channel,omitempty"`

	// TicketSourceChannelV2 Filters for tickets that are associated with any of the source
	// channels.
	TicketSourceChannelV2 *[]string `form:"ticket.source_channel_v2,omitempty" json:"ticket.source_channel_v2,omitempty"`

	// TicketSubtype Filters for tickets with any of the provided subtypes.
	TicketSubtype *[]string `form:"ticket.subtype,omitempty" json:"ticket.subtype,omitempty"`

	// Type Filters for work of the provided types.
	Type *[]WorkType `form:"type,omitempty" json:"type,omitempty"`
}

// WorksGetParams defines parameters for WorksGet.
type WorksGetParams struct {
	// Id The work's ID.
	Id string `form:"id" json:"id"`
}

// WorksListParams defines parameters for WorksList.
type WorksListParams struct {
	// AppliesToPart Filters for work belonging to any of the provided parts.
	AppliesToPart *[]string `form:"applies_to_part,omitempty" json:"applies_to_part,omitempty"`

	// CreatedBy Filters for work created by any of these users.
	CreatedBy *[]string `form:"created_by,omitempty" json:"created_by,omitempty"`

	// Cursor The cursor to resume iteration from. If not provided, then iteration
	// starts from the beginning.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CustomFields Filters for custom fields.
	CustomFields *map[string]interface{} `form:"custom_fields,omitempty" json:"custom_fields,omitempty"`

	// IssueAccounts Filters for issues with any of the provided accounts.
	IssueAccounts *[]string `form:"issue.accounts,omitempty" json:"issue.accounts,omitempty"`

	// IssuePriority Filters for issues with any of the provided priorities.
	IssuePriority *[]IssuePriority `form:"issue.priority,omitempty" json:"issue.priority,omitempty"`

	// IssuePriorityV2 Filters for issues with any of the provided priority enum ids.
	IssuePriorityV2 *[]int64 `form:"issue.priority_v2,omitempty" json:"issue.priority_v2,omitempty"`

	// IssueRevOrgs Filters for issues with any of the provided Rev organizations.
	IssueRevOrgs *[]string `form:"issue.rev_orgs,omitempty" json:"issue.rev_orgs,omitempty"`

	// IssueSlaSummaryStage Filters for records with any of the provided SLA stages.
	IssueSlaSummaryStage *[]SlaSummaryStage `form:"issue.sla_summary.stage,omitempty" json:"issue.sla_summary.stage,omitempty"`

	// IssueSprint Filters for issues with any of the sprint.
	IssueSprint *[]string `form:"issue.sprint,omitempty" json:"issue.sprint,omitempty"`

	// IssueSubtype Filters for issues with any of the provided subtypes.
	IssueSubtype *[]string `form:"issue.subtype,omitempty" json:"issue.subtype,omitempty"`

	// Limit The maximum number of works to return. The default is '50'.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Mode The iteration mode to use, otherwise if not set, then "after" is
	// used.
	Mode *ListMode `form:"mode,omitempty" json:"mode,omitempty"`

	// ModifiedBy Filters for work modified by any of these users.
	ModifiedBy *[]string `form:"modified_by,omitempty" json:"modified_by,omitempty"`

	// OpportunityAccount Filters for opportunities belonging to any of the provided accounts.
	OpportunityAccount *[]string `form:"opportunity.account,omitempty" json:"opportunity.account,omitempty"`

	// OpportunityContacts Filters for opportunities with any of the provided contacts.
	OpportunityContacts *[]string `form:"opportunity.contacts,omitempty" json:"opportunity.contacts,omitempty"`

	// OpportunityForecastCategoryV2 Filters for opportunities with any of the provided forecast category
	// enum IDs.
	OpportunityForecastCategoryV2 *[]int64 `form:"opportunity.forecast_category_v2,omitempty" json:"opportunity.forecast_category_v2,omitempty"`

	// OpportunitySubtype Filters for opportunity with any of the provided subtypes.
	OpportunitySubtype *[]string `form:"opportunity.subtype,omitempty" json:"opportunity.subtype,omitempty"`

	// OwnedBy Filters for work owned by any of these users.
	OwnedBy *[]string `form:"owned_by,omitempty" json:"owned_by,omitempty"`

	// ReportedBy Filters for work reported by any of these users.
	ReportedBy *[]string `form:"reported_by,omitempty" json:"reported_by,omitempty"`

	// SortBy Fields to sort the works by and the direction to sort them.
	SortBy *[]string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// StageName Filters for records in the provided stage(s) by name.
	StageName *[]string `form:"stage.name,omitempty" json:"stage.name,omitempty"`

	// StagedInfoIsStaged Filters for issues that are staged.
	StagedInfoIsStaged *bool `form:"staged_info.is_staged,omitempty" json:"staged_info.is_staged,omitempty"`

	// State Filters for work with any of the provided states.
	State *[]string `form:"state,omitempty" json:"state,omitempty"`

	// SyncMetadataExternalReference Filters for issues with this specific external reference.
	SyncMetadataExternalReference *[]string `form:"sync_metadata.external_reference,omitempty" json:"sync_metadata.external_reference,omitempty"`

	// SyncMetadataLastSyncInStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncInStatus *[]SyncMetadataFilterSyncInFilterStatus `form:"sync_metadata.last_sync_in.status,omitempty" json:"sync_metadata.last_sync_in.status,omitempty"`

	// SyncMetadataLastSyncInSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncInSyncHistory *[]string `form:"sync_metadata.last_sync_in.sync_history,omitempty" json:"sync_metadata.last_sync_in.sync_history,omitempty"`

	// SyncMetadataLastSyncInSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncInSyncUnit *[]string `form:"sync_metadata.last_sync_in.sync_unit,omitempty" json:"sync_metadata.last_sync_in.sync_unit,omitempty"`

	// SyncMetadataLastSyncOutStatus Filters for works with selected sync statuses.
	SyncMetadataLastSyncOutStatus *[]SyncMetadataFilterSyncOutFilterStatus `form:"sync_metadata.last_sync_out.status,omitempty" json:"sync_metadata.last_sync_out.status,omitempty"`

	// SyncMetadataLastSyncOutSyncHistory Filters for works modified with selected sync history.
	SyncMetadataLastSyncOutSyncHistory *[]string `form:"sync_metadata.last_sync_out.sync_history,omitempty" json:"sync_metadata.last_sync_out.sync_history,omitempty"`

	// SyncMetadataLastSyncOutSyncUnit Filters for works modified with selected sync units.
	SyncMetadataLastSyncOutSyncUnit *[]string `form:"sync_metadata.last_sync_out.sync_unit,omitempty" json:"sync_metadata.last_sync_out.sync_unit,omitempty"`

	// SyncMetadataOriginSystem Filters for issues synced from this specific origin system.
	SyncMetadataOriginSystem *[]string `form:"sync_metadata.origin_system,omitempty" json:"sync_metadata.origin_system,omitempty"`

	// Tags Filters for work with any of the provided tags.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// TicketBrand Filters for tickets that are associated with any of the brands.
	TicketBrand *[]string `form:"ticket.brand,omitempty" json:"ticket.brand,omitempty"`

	// TicketChannels Filters for tickets with any of the provided channels.
	TicketChannels *[]TicketChannels `form:"ticket.channels,omitempty" json:"ticket.channels,omitempty"`

	// TicketChannelsV2 Filters for tickets that are associated with any of the channels.
	TicketChannelsV2 *[]string `form:"ticket.channels_v2,omitempty" json:"ticket.channels_v2,omitempty"`

	// TicketGroup Filters for tickets belonging to specific groups.
	TicketGroup *[]string `form:"ticket.group,omitempty" json:"ticket.group,omitempty"`

	// TicketIsFrozen Filters for frozen tickets.
	TicketIsFrozen *bool `form:"ticket.is_frozen,omitempty" json:"ticket.is_frozen,omitempty"`

	// TicketIsSpam Filters for tickets that are spam.
	TicketIsSpam *bool `form:"ticket.is_spam,omitempty" json:"ticket.is_spam,omitempty"`

	// TicketNeedsResponse Filters for tickets that need response.
	TicketNeedsResponse *bool `form:"ticket.needs_response,omitempty" json:"ticket.needs_response,omitempty"`

	// TicketRevOrg Filters for tickets that are associated with any of the provided Rev
	// organizations.
	TicketRevOrg *[]string `form:"ticket.rev_org,omitempty" json:"ticket.rev_org,omitempty"`

	// TicketSeverity Filters for tickets with any of the provided severities.
	TicketSeverity *[]TicketSeverity `form:"ticket.severity,omitempty" json:"ticket.severity,omitempty"`

	// TicketSlaSummaryStage Filters for records with any of the provided SLA stages.
	TicketSlaSummaryStage *[]SlaSummaryStage `form:"ticket.sla_summary.stage,omitempty" json:"ticket.sla_summary.stage,omitempty"`

	// TicketSourceChannel Filters for tickets with any of the provided source channels.
	TicketSourceChannel *[]string `form:"ticket.source_channel,omitempty" json:"ticket.source_channel,omitempty"`

	// TicketSourceChannelV2 Filters for tickets that are associated with any of the source
	// channels.
	TicketSourceChannelV2 *[]string `form:"ticket.source_channel_v2,omitempty" json:"ticket.source_channel_v2,omitempty"`

	// TicketSubtype Filters for tickets with any of the provided subtypes.
	TicketSubtype *[]string `form:"ticket.subtype,omitempty" json:"ticket.subtype,omitempty"`

	// Type Filters for work of the provided types.
	Type *[]WorkType `form:"type,omitempty" json:"type,omitempty"`
}

// AccountsCreateJSONRequestBody defines body for AccountsCreate for application/json ContentType.
type AccountsCreateJSONRequestBody = AccountsCreateRequest

// AccountsDeleteJSONRequestBody defines body for AccountsDelete for application/json ContentType.
type AccountsDeleteJSONRequestBody = AccountsDeleteRequest

// AccountsExportPostJSONRequestBody defines body for AccountsExportPost for application/json ContentType.
type AccountsExportPostJSONRequestBody = AccountsExportRequest

// AccountsGetPostJSONRequestBody defines body for AccountsGetPost for application/json ContentType.
type AccountsGetPostJSONRequestBody = AccountsGetRequest

// AccountsListPostJSONRequestBody defines body for AccountsListPost for application/json ContentType.
type AccountsListPostJSONRequestBody = AccountsListRequest

// AccountsMergeJSONRequestBody defines body for AccountsMerge for application/json ContentType.
type AccountsMergeJSONRequestBody = AccountsMergeRequest

// AccountsUpdateJSONRequestBody defines body for AccountsUpdate for application/json ContentType.
type AccountsUpdateJSONRequestBody = AccountsUpdateRequest

// AiAgentEventsExecuteAsyncJSONRequestBody defines body for AiAgentEventsExecuteAsync for application/json ContentType.
type AiAgentEventsExecuteAsyncJSONRequestBody = AiAgentEventsExecuteAsyncRequest

// AirdropSyncUnitsGetPostJSONRequestBody defines body for AirdropSyncUnitsGetPost for application/json ContentType.
type AirdropSyncUnitsGetPostJSONRequestBody = AirdropSyncUnitsGetRequest

// AirdropSyncUnitsHistoryPostJSONRequestBody defines body for AirdropSyncUnitsHistoryPost for application/json ContentType.
type AirdropSyncUnitsHistoryPostJSONRequestBody = AirdropSyncUnitsHistoryRequest

// ArticlesCountPostJSONRequestBody defines body for ArticlesCountPost for application/json ContentType.
type ArticlesCountPostJSONRequestBody = ArticlesCountRequest

// CreateArticleJSONRequestBody defines body for CreateArticle for application/json ContentType.
type CreateArticleJSONRequestBody = ArticlesCreateRequest

// DeleteArticleJSONRequestBody defines body for DeleteArticle for application/json ContentType.
type DeleteArticleJSONRequestBody = ArticlesDeleteRequest

// GetArticlePostJSONRequestBody defines body for GetArticlePost for application/json ContentType.
type GetArticlePostJSONRequestBody = ArticlesGetRequest

// ListArticlesPostJSONRequestBody defines body for ListArticlesPost for application/json ContentType.
type ListArticlesPostJSONRequestBody = ArticlesListRequest

// UpdateArticleJSONRequestBody defines body for UpdateArticle for application/json ContentType.
type UpdateArticleJSONRequestBody = ArticlesUpdateRequest

// ArtifactsGetPostJSONRequestBody defines body for ArtifactsGetPost for application/json ContentType.
type ArtifactsGetPostJSONRequestBody = ArtifactsGetRequest

// ArtifactsListPostJSONRequestBody defines body for ArtifactsListPost for application/json ContentType.
type ArtifactsListPostJSONRequestBody = ArtifactsListRequest

// ArtifactsLocatePostJSONRequestBody defines body for ArtifactsLocatePost for application/json ContentType.
type ArtifactsLocatePostJSONRequestBody = ArtifactsLocateRequest

// ArtifactsPrepareJSONRequestBody defines body for ArtifactsPrepare for application/json ContentType.
type ArtifactsPrepareJSONRequestBody = ArtifactsPrepareRequest

// ArtifactsHardDeleteVersionJSONRequestBody defines body for ArtifactsHardDeleteVersion for application/json ContentType.
type ArtifactsHardDeleteVersionJSONRequestBody = ArtifactsHardDeleteVersionRequest

// ArtifactsVersionsPrepareJSONRequestBody defines body for ArtifactsVersionsPrepare for application/json ContentType.
type ArtifactsVersionsPrepareJSONRequestBody = ArtifactsVersionsPrepareRequest

// AtomsGetPostJSONRequestBody defines body for AtomsGetPost for application/json ContentType.
type AtomsGetPostJSONRequestBody = AtomsGetRequest

// ExportAuditLogsJSONRequestBody defines body for ExportAuditLogs for application/json ContentType.
type ExportAuditLogsJSONRequestBody = ExportAuditLogsRequest

// AuthTokensCreateJSONRequestBody defines body for AuthTokensCreate for application/json ContentType.
type AuthTokensCreateJSONRequestBody = AuthTokensCreateRequest

// AuthTokensDeleteJSONRequestBody defines body for AuthTokensDelete for application/json ContentType.
type AuthTokensDeleteJSONRequestBody = AuthTokensDeleteRequest

// AuthTokensGetPostJSONRequestBody defines body for AuthTokensGetPost for application/json ContentType.
type AuthTokensGetPostJSONRequestBody = AuthTokensGetRequest

// AuthTokensInfoPostJSONRequestBody defines body for AuthTokensInfoPost for application/json ContentType.
type AuthTokensInfoPostJSONRequestBody = AuthTokensInfoRequest

// AuthTokensListPostJSONRequestBody defines body for AuthTokensListPost for application/json ContentType.
type AuthTokensListPostJSONRequestBody = AuthTokensListRequest

// AuthTokensSelfDeleteJSONRequestBody defines body for AuthTokensSelfDelete for application/json ContentType.
type AuthTokensSelfDeleteJSONRequestBody = AuthTokensSelfDeleteRequest

// AuthTokensUpdateJSONRequestBody defines body for AuthTokensUpdate for application/json ContentType.
type AuthTokensUpdateJSONRequestBody = AuthTokensUpdateRequest

// BrandsCreateJSONRequestBody defines body for BrandsCreate for application/json ContentType.
type BrandsCreateJSONRequestBody = BrandsCreateRequest

// BrandsDeleteJSONRequestBody defines body for BrandsDelete for application/json ContentType.
type BrandsDeleteJSONRequestBody = BrandsDeleteRequest

// BrandsGetPostJSONRequestBody defines body for BrandsGetPost for application/json ContentType.
type BrandsGetPostJSONRequestBody = BrandsGetRequest

// BrandsListPostJSONRequestBody defines body for BrandsListPost for application/json ContentType.
type BrandsListPostJSONRequestBody = BrandsListRequest

// BrandsUpdateJSONRequestBody defines body for BrandsUpdate for application/json ContentType.
type BrandsUpdateJSONRequestBody = BrandsUpdateRequest

// ChatsCreateJSONRequestBody defines body for ChatsCreate for application/json ContentType.
type ChatsCreateJSONRequestBody = ChatsCreateRequest

// ChatsGetPostJSONRequestBody defines body for ChatsGetPost for application/json ContentType.
type ChatsGetPostJSONRequestBody = ChatsGetRequest

// ChatsUpdateJSONRequestBody defines body for ChatsUpdate for application/json ContentType.
type ChatsUpdateJSONRequestBody = ChatsUpdateRequest

// CodeChangesCreateJSONRequestBody defines body for CodeChangesCreate for application/json ContentType.
type CodeChangesCreateJSONRequestBody = CodeChangesCreateRequest

// CodeChangesDeleteJSONRequestBody defines body for CodeChangesDelete for application/json ContentType.
type CodeChangesDeleteJSONRequestBody = CodeChangesDeleteRequest

// CodeChangesGetPostJSONRequestBody defines body for CodeChangesGetPost for application/json ContentType.
type CodeChangesGetPostJSONRequestBody = CodeChangesGetRequest

// CodeChangesListPostJSONRequestBody defines body for CodeChangesListPost for application/json ContentType.
type CodeChangesListPostJSONRequestBody = CodeChangesListRequest

// CodeChangesUpdateJSONRequestBody defines body for CodeChangesUpdate for application/json ContentType.
type CodeChangesUpdateJSONRequestBody = CodeChangesUpdateRequest

// CommandsCreateJSONRequestBody defines body for CommandsCreate for application/json ContentType.
type CommandsCreateJSONRequestBody = CommandCreateRequest

// CommandsGetPostJSONRequestBody defines body for CommandsGetPost for application/json ContentType.
type CommandsGetPostJSONRequestBody = CommandGetRequest

// CommandsListPostJSONRequestBody defines body for CommandsListPost for application/json ContentType.
type CommandsListPostJSONRequestBody = CommandsListRequest

// CommandsUpdateJSONRequestBody defines body for CommandsUpdate for application/json ContentType.
type CommandsUpdateJSONRequestBody = CommandUpdateRequest

// ContentTemplateCreateJSONRequestBody defines body for ContentTemplateCreate for application/json ContentType.
type ContentTemplateCreateJSONRequestBody = ContentTemplateCreateRequest

// ContentTemplateGetPostJSONRequestBody defines body for ContentTemplateGetPost for application/json ContentType.
type ContentTemplateGetPostJSONRequestBody = ContentTemplateGetRequest

// ContentTemplateListPostJSONRequestBody defines body for ContentTemplateListPost for application/json ContentType.
type ContentTemplateListPostJSONRequestBody = ContentTemplateListRequest

// ConversationsCreateJSONRequestBody defines body for ConversationsCreate for application/json ContentType.
type ConversationsCreateJSONRequestBody = ConversationsCreateRequest

// ConversationsDeleteJSONRequestBody defines body for ConversationsDelete for application/json ContentType.
type ConversationsDeleteJSONRequestBody = ConversationsDeleteRequest

// ConversationsExportPostJSONRequestBody defines body for ConversationsExportPost for application/json ContentType.
type ConversationsExportPostJSONRequestBody = ConversationsExportRequest

// ConversationsGetPostJSONRequestBody defines body for ConversationsGetPost for application/json ContentType.
type ConversationsGetPostJSONRequestBody = ConversationsGetRequest

// ConversationsListPostJSONRequestBody defines body for ConversationsListPost for application/json ContentType.
type ConversationsListPostJSONRequestBody = ConversationsListRequest

// ConversationsUpdateJSONRequestBody defines body for ConversationsUpdate for application/json ContentType.
type ConversationsUpdateJSONRequestBody = ConversationsUpdateRequest

// CustomObjectsCountPostJSONRequestBody defines body for CustomObjectsCountPost for application/json ContentType.
type CustomObjectsCountPostJSONRequestBody = CustomObjectsCountRequest

// CustomObjectsCreateJSONRequestBody defines body for CustomObjectsCreate for application/json ContentType.
type CustomObjectsCreateJSONRequestBody = CustomObjectsCreateRequest

// CustomObjectsDeleteJSONRequestBody defines body for CustomObjectsDelete for application/json ContentType.
type CustomObjectsDeleteJSONRequestBody = CustomObjectsDeleteRequest

// CustomObjectsGetPostJSONRequestBody defines body for CustomObjectsGetPost for application/json ContentType.
type CustomObjectsGetPostJSONRequestBody = CustomObjectsGetRequest

// CustomObjectsListPostJSONRequestBody defines body for CustomObjectsListPost for application/json ContentType.
type CustomObjectsListPostJSONRequestBody = CustomObjectsListRequest

// CustomObjectsUpdateJSONRequestBody defines body for CustomObjectsUpdate for application/json ContentType.
type CustomObjectsUpdateJSONRequestBody = CustomObjectsUpdateRequest

// DevOrgAuthConnectionsCreateJSONRequestBody defines body for DevOrgAuthConnectionsCreate for application/json ContentType.
type DevOrgAuthConnectionsCreateJSONRequestBody = DevOrgAuthConnectionsCreateRequest

// DevOrgAuthConnectionsDeleteJSONRequestBody defines body for DevOrgAuthConnectionsDelete for application/json ContentType.
type DevOrgAuthConnectionsDeleteJSONRequestBody = DevOrgAuthConnectionsDeleteRequest

// DevOrgAuthConnectionsGetPostJSONRequestBody defines body for DevOrgAuthConnectionsGetPost for application/json ContentType.
type DevOrgAuthConnectionsGetPostJSONRequestBody = DevOrgAuthConnectionsGetRequest

// DevOrgAuthConnectionsListPostJSONRequestBody defines body for DevOrgAuthConnectionsListPost for application/json ContentType.
type DevOrgAuthConnectionsListPostJSONRequestBody = Empty

// DevOrgAuthConnectionsToggleJSONRequestBody defines body for DevOrgAuthConnectionsToggle for application/json ContentType.
type DevOrgAuthConnectionsToggleJSONRequestBody = DevOrgAuthConnectionsToggleRequest

// DevOrgAuthConnectionsUpdateJSONRequestBody defines body for DevOrgAuthConnectionsUpdate for application/json ContentType.
type DevOrgAuthConnectionsUpdateJSONRequestBody = DevOrgAuthConnectionsUpdateRequest

// DevOrgsGetPostJSONRequestBody defines body for DevOrgsGetPost for application/json ContentType.
type DevOrgsGetPostJSONRequestBody = DevOrgsGetRequest

// DevUsersActivateJSONRequestBody defines body for DevUsersActivate for application/json ContentType.
type DevUsersActivateJSONRequestBody = DevUsersActivateRequest

// DevUsersCreateJSONRequestBody defines body for DevUsersCreate for application/json ContentType.
type DevUsersCreateJSONRequestBody = DevUsersCreateRequest

// DevUsersDeactivateJSONRequestBody defines body for DevUsersDeactivate for application/json ContentType.
type DevUsersDeactivateJSONRequestBody = DevUsersDeactivateRequest

// DevUsersGetPostJSONRequestBody defines body for DevUsersGetPost for application/json ContentType.
type DevUsersGetPostJSONRequestBody = DevUsersGetRequest

// DevUsersIdentitiesLinkJSONRequestBody defines body for DevUsersIdentitiesLink for application/json ContentType.
type DevUsersIdentitiesLinkJSONRequestBody = DevUsersIdentitiesLinkRequest

// DevUsersIdentitiesUnlinkJSONRequestBody defines body for DevUsersIdentitiesUnlink for application/json ContentType.
type DevUsersIdentitiesUnlinkJSONRequestBody = DevUsersIdentitiesUnlinkRequest

// DevUsersListPostJSONRequestBody defines body for DevUsersListPost for application/json ContentType.
type DevUsersListPostJSONRequestBody = DevUsersListRequest

// DevUsersMergeJSONRequestBody defines body for DevUsersMerge for application/json ContentType.
type DevUsersMergeJSONRequestBody = DevUsersMergeRequest

// DevUsersSelfPostJSONRequestBody defines body for DevUsersSelfPost for application/json ContentType.
type DevUsersSelfPostJSONRequestBody = DevUsersSelfRequest

// DevUsersSelfUpdateJSONRequestBody defines body for DevUsersSelfUpdate for application/json ContentType.
type DevUsersSelfUpdateJSONRequestBody = DevUsersSelfUpdateRequest

// DevUsersUpdateJSONRequestBody defines body for DevUsersUpdate for application/json ContentType.
type DevUsersUpdateJSONRequestBody = DevUsersUpdateRequest

// DirectoriesCountPostJSONRequestBody defines body for DirectoriesCountPost for application/json ContentType.
type DirectoriesCountPostJSONRequestBody = DirectoriesCountRequest

// DirectoriesCreateJSONRequestBody defines body for DirectoriesCreate for application/json ContentType.
type DirectoriesCreateJSONRequestBody = DirectoriesCreateRequest

// DirectoriesDeleteJSONRequestBody defines body for DirectoriesDelete for application/json ContentType.
type DirectoriesDeleteJSONRequestBody = DirectoriesDeleteRequest

// DirectoriesGetPostJSONRequestBody defines body for DirectoriesGetPost for application/json ContentType.
type DirectoriesGetPostJSONRequestBody = DirectoriesGetRequest

// DirectoriesListPostJSONRequestBody defines body for DirectoriesListPost for application/json ContentType.
type DirectoriesListPostJSONRequestBody = DirectoriesListRequest

// DirectoriesUpdateJSONRequestBody defines body for DirectoriesUpdate for application/json ContentType.
type DirectoriesUpdateJSONRequestBody = DirectoriesUpdateRequest

// EngagementsCountPostJSONRequestBody defines body for EngagementsCountPost for application/json ContentType.
type EngagementsCountPostJSONRequestBody = EngagementsCountRequest

// EngagementsCreateJSONRequestBody defines body for EngagementsCreate for application/json ContentType.
type EngagementsCreateJSONRequestBody = EngagementsCreateRequest

// EngagementsDeleteJSONRequestBody defines body for EngagementsDelete for application/json ContentType.
type EngagementsDeleteJSONRequestBody = EngagementsDeleteRequest

// EngagementsGetPostJSONRequestBody defines body for EngagementsGetPost for application/json ContentType.
type EngagementsGetPostJSONRequestBody = EngagementsGetRequest

// EngagementsListPostJSONRequestBody defines body for EngagementsListPost for application/json ContentType.
type EngagementsListPostJSONRequestBody = EngagementsListRequest

// EngagementsUpdateJSONRequestBody defines body for EngagementsUpdate for application/json ContentType.
type EngagementsUpdateJSONRequestBody = EngagementsUpdateRequest

// EventSourcesGetPostJSONRequestBody defines body for EventSourcesGetPost for application/json ContentType.
type EventSourcesGetPostJSONRequestBody = EventSourceGetRequest

// EventSourcesScheduleEventJSONRequestBody defines body for EventSourcesScheduleEvent for application/json ContentType.
type EventSourcesScheduleEventJSONRequestBody = EventSourcesScheduleEventRequest

// EventSourcesDeleteScheduledEventJSONRequestBody defines body for EventSourcesDeleteScheduledEvent for application/json ContentType.
type EventSourcesDeleteScheduledEventJSONRequestBody = EventSourcesDeleteScheduledEventRequest

// GroupsCreateJSONRequestBody defines body for GroupsCreate for application/json ContentType.
type GroupsCreateJSONRequestBody = GroupsCreateRequest

// GroupsGetPostJSONRequestBody defines body for GroupsGetPost for application/json ContentType.
type GroupsGetPostJSONRequestBody = GroupsGetRequest

// GroupsListPostJSONRequestBody defines body for GroupsListPost for application/json ContentType.
type GroupsListPostJSONRequestBody = GroupsListRequest

// GroupMembersAddJSONRequestBody defines body for GroupMembersAdd for application/json ContentType.
type GroupMembersAddJSONRequestBody = GroupMembersAddRequest

// GroupMembersListPostJSONRequestBody defines body for GroupMembersListPost for application/json ContentType.
type GroupMembersListPostJSONRequestBody = GroupMembersListRequest

// GroupMembersRemoveJSONRequestBody defines body for GroupMembersRemove for application/json ContentType.
type GroupMembersRemoveJSONRequestBody = GroupMembersRemoveRequest

// GroupsUpdateJSONRequestBody defines body for GroupsUpdate for application/json ContentType.
type GroupsUpdateJSONRequestBody = GroupsUpdateRequest

// IncidentsCreateJSONRequestBody defines body for IncidentsCreate for application/json ContentType.
type IncidentsCreateJSONRequestBody = IncidentsCreateRequest

// IncidentsDeleteJSONRequestBody defines body for IncidentsDelete for application/json ContentType.
type IncidentsDeleteJSONRequestBody = IncidentsDeleteRequest

// IncidentsGetPostJSONRequestBody defines body for IncidentsGetPost for application/json ContentType.
type IncidentsGetPostJSONRequestBody = IncidentsGetRequest

// IncidentsGroupPostJSONRequestBody defines body for IncidentsGroupPost for application/json ContentType.
type IncidentsGroupPostJSONRequestBody = IncidentsGroupRequest

// IncidentsListPostJSONRequestBody defines body for IncidentsListPost for application/json ContentType.
type IncidentsListPostJSONRequestBody = IncidentsListRequest

// IncidentsUpdateJSONRequestBody defines body for IncidentsUpdate for application/json ContentType.
type IncidentsUpdateJSONRequestBody = IncidentsUpdateRequest

// KeyringsCreateCallbackPostJSONRequestBody defines body for KeyringsCreateCallbackPost for application/json ContentType.
type KeyringsCreateCallbackPostJSONRequestBody = KeyringsCreateCallbackRequest

// CustomLinkTypeCreateJSONRequestBody defines body for CustomLinkTypeCreate for application/json ContentType.
type CustomLinkTypeCreateJSONRequestBody = CustomLinkTypeCreateRequest

// CustomLinkTypeGetPostJSONRequestBody defines body for CustomLinkTypeGetPost for application/json ContentType.
type CustomLinkTypeGetPostJSONRequestBody = CustomLinkTypeGetRequest

// CustomLinkTypeListPostJSONRequestBody defines body for CustomLinkTypeListPost for application/json ContentType.
type CustomLinkTypeListPostJSONRequestBody = CustomLinkTypeListRequest

// CustomLinkTypeUpdateJSONRequestBody defines body for CustomLinkTypeUpdate for application/json ContentType.
type CustomLinkTypeUpdateJSONRequestBody = CustomLinkTypeUpdateRequest

// LinksCreateJSONRequestBody defines body for LinksCreate for application/json ContentType.
type LinksCreateJSONRequestBody = LinksCreateRequest

// LinksDeleteJSONRequestBody defines body for LinksDelete for application/json ContentType.
type LinksDeleteJSONRequestBody = LinksDeleteRequest

// LinksGetPostJSONRequestBody defines body for LinksGetPost for application/json ContentType.
type LinksGetPostJSONRequestBody = LinksGetRequest

// LinksListPostJSONRequestBody defines body for LinksListPost for application/json ContentType.
type LinksListPostJSONRequestBody = LinksListRequest

// LinksReplaceJSONRequestBody defines body for LinksReplace for application/json ContentType.
type LinksReplaceJSONRequestBody = LinksReplaceRequest

// MeetingsCountPostJSONRequestBody defines body for MeetingsCountPost for application/json ContentType.
type MeetingsCountPostJSONRequestBody = MeetingsCountRequest

// MeetingsCreateJSONRequestBody defines body for MeetingsCreate for application/json ContentType.
type MeetingsCreateJSONRequestBody = MeetingsCreateRequest

// MeetingsDeleteJSONRequestBody defines body for MeetingsDelete for application/json ContentType.
type MeetingsDeleteJSONRequestBody = MeetingsDeleteRequest

// MeetingsGetPostJSONRequestBody defines body for MeetingsGetPost for application/json ContentType.
type MeetingsGetPostJSONRequestBody = MeetingsGetRequest

// MeetingsListPostJSONRequestBody defines body for MeetingsListPost for application/json ContentType.
type MeetingsListPostJSONRequestBody = MeetingsListRequest

// MeetingsUpdateJSONRequestBody defines body for MeetingsUpdate for application/json ContentType.
type MeetingsUpdateJSONRequestBody = MeetingsUpdateRequest

// MetricActionExecuteJSONRequestBody defines body for MetricActionExecute for application/json ContentType.
type MetricActionExecuteJSONRequestBody = MetricActionExecuteRequest

// MetricDefinitionsCreateJSONRequestBody defines body for MetricDefinitionsCreate for application/json ContentType.
type MetricDefinitionsCreateJSONRequestBody = MetricDefinitionsCreateRequest

// MetricDefinitionsDeleteJSONRequestBody defines body for MetricDefinitionsDelete for application/json ContentType.
type MetricDefinitionsDeleteJSONRequestBody = MetricDefinitionsDeleteRequest

// MetricDefinitionsGetPostJSONRequestBody defines body for MetricDefinitionsGetPost for application/json ContentType.
type MetricDefinitionsGetPostJSONRequestBody = MetricDefinitionsGetRequest

// MetricDefinitionsListPostJSONRequestBody defines body for MetricDefinitionsListPost for application/json ContentType.
type MetricDefinitionsListPostJSONRequestBody = MetricDefinitionsListRequest

// MetricDefinitionsUpdateJSONRequestBody defines body for MetricDefinitionsUpdate for application/json ContentType.
type MetricDefinitionsUpdateJSONRequestBody = MetricDefinitionsUpdateRequest

// MetricTrackersGetPostJSONRequestBody defines body for MetricTrackersGetPost for application/json ContentType.
type MetricTrackersGetPostJSONRequestBody = MetricTrackersGetRequest

// MetricsDevrevIngestJSONRequestBody defines body for MetricsDevrevIngest for application/json ContentType.
type MetricsDevrevIngestJSONRequestBody = MetricsDataIngestRequest

// NotificationsSendJSONRequestBody defines body for NotificationsSend for application/json ContentType.
type NotificationsSendJSONRequestBody = NotificationsSendRequest

// OrgScheduleFragmentsCreateJSONRequestBody defines body for OrgScheduleFragmentsCreate for application/json ContentType.
type OrgScheduleFragmentsCreateJSONRequestBody = OrgScheduleFragmentsCreateRequest

// OrgScheduleFragmentsGetPostJSONRequestBody defines body for OrgScheduleFragmentsGetPost for application/json ContentType.
type OrgScheduleFragmentsGetPostJSONRequestBody = OrgScheduleFragmentsGetRequest

// OrgScheduleFragmentsTransitionJSONRequestBody defines body for OrgScheduleFragmentsTransition for application/json ContentType.
type OrgScheduleFragmentsTransitionJSONRequestBody = OrgScheduleFragmentsTransitionRequest

// OrgSchedulesCreateJSONRequestBody defines body for OrgSchedulesCreate for application/json ContentType.
type OrgSchedulesCreateJSONRequestBody = OrgSchedulesCreateRequest

// OrgSchedulesEvaluatePostJSONRequestBody defines body for OrgSchedulesEvaluatePost for application/json ContentType.
type OrgSchedulesEvaluatePostJSONRequestBody = OrgSchedulesEvaluateRequest

// OrgSchedulesGetPostJSONRequestBody defines body for OrgSchedulesGetPost for application/json ContentType.
type OrgSchedulesGetPostJSONRequestBody = OrgSchedulesGetRequest

// OrgSchedulesListPostJSONRequestBody defines body for OrgSchedulesListPost for application/json ContentType.
type OrgSchedulesListPostJSONRequestBody = OrgSchedulesListRequest

// OrgSchedulesSetFutureJSONRequestBody defines body for OrgSchedulesSetFuture for application/json ContentType.
type OrgSchedulesSetFutureJSONRequestBody = OrgSchedulesSetFutureRequest

// OrgSchedulesTransitionJSONRequestBody defines body for OrgSchedulesTransition for application/json ContentType.
type OrgSchedulesTransitionJSONRequestBody = OrgSchedulesTransitionRequest

// OrgSchedulesUpdateJSONRequestBody defines body for OrgSchedulesUpdate for application/json ContentType.
type OrgSchedulesUpdateJSONRequestBody = OrgSchedulesUpdateRequest

// PartsCreateJSONRequestBody defines body for PartsCreate for application/json ContentType.
type PartsCreateJSONRequestBody = PartsCreateRequest

// PartsDeleteJSONRequestBody defines body for PartsDelete for application/json ContentType.
type PartsDeleteJSONRequestBody = PartsDeleteRequest

// PartsGetPostJSONRequestBody defines body for PartsGetPost for application/json ContentType.
type PartsGetPostJSONRequestBody = PartsGetRequest

// PartsListPostJSONRequestBody defines body for PartsListPost for application/json ContentType.
type PartsListPostJSONRequestBody = PartsListRequest

// PartsUpdateJSONRequestBody defines body for PartsUpdate for application/json ContentType.
type PartsUpdateJSONRequestBody = PartsUpdateRequest

// PreferencesGetPostJSONRequestBody defines body for PreferencesGetPost for application/json ContentType.
type PreferencesGetPostJSONRequestBody = PreferencesGetRequest

// PreferencesUpdateJSONRequestBody defines body for PreferencesUpdate for application/json ContentType.
type PreferencesUpdateJSONRequestBody = PreferencesUpdateRequest

// CreateQuestionAnswerJSONRequestBody defines body for CreateQuestionAnswer for application/json ContentType.
type CreateQuestionAnswerJSONRequestBody = QuestionAnswersCreateRequest

// DeleteQuestionAnswerJSONRequestBody defines body for DeleteQuestionAnswer for application/json ContentType.
type DeleteQuestionAnswerJSONRequestBody = QuestionAnswersDeleteRequest

// GetQuestionAnswerPostJSONRequestBody defines body for GetQuestionAnswerPost for application/json ContentType.
type GetQuestionAnswerPostJSONRequestBody = QuestionAnswersGetRequest

// ListQuestionAnswersPostJSONRequestBody defines body for ListQuestionAnswersPost for application/json ContentType.
type ListQuestionAnswersPostJSONRequestBody = QuestionAnswersListRequest

// UpdateQuestionAnswerJSONRequestBody defines body for UpdateQuestionAnswer for application/json ContentType.
type UpdateQuestionAnswerJSONRequestBody = QuestionAnswersUpdateRequest

// ReactionsListPostJSONRequestBody defines body for ReactionsListPost for application/json ContentType.
type ReactionsListPostJSONRequestBody = ReactionsListRequest

// ReactionsUpdateJSONRequestBody defines body for ReactionsUpdate for application/json ContentType.
type ReactionsUpdateJSONRequestBody = ReactionsUpdateRequest

// ChatCompletionsJSONRequestBody defines body for ChatCompletions for application/json ContentType.
type ChatCompletionsJSONRequestBody = ChatCompletionsRequest

// GetReplyJSONRequestBody defines body for GetReply for application/json ContentType.
type GetReplyJSONRequestBody = GetReplyRequest

// RecordTemplateGetPostJSONRequestBody defines body for RecordTemplateGetPost for application/json ContentType.
type RecordTemplateGetPostJSONRequestBody = RecordTemplateGetRequest

// RevOrgsCreateJSONRequestBody defines body for RevOrgsCreate for application/json ContentType.
type RevOrgsCreateJSONRequestBody = RevOrgsCreateRequest

// RevOrgsDeleteJSONRequestBody defines body for RevOrgsDelete for application/json ContentType.
type RevOrgsDeleteJSONRequestBody = RevOrgsDeleteRequest

// RevOrgsGetPostJSONRequestBody defines body for RevOrgsGetPost for application/json ContentType.
type RevOrgsGetPostJSONRequestBody = RevOrgsGetRequest

// RevOrgsListPostJSONRequestBody defines body for RevOrgsListPost for application/json ContentType.
type RevOrgsListPostJSONRequestBody = RevOrgsListRequest

// RevOrgsUpdateJSONRequestBody defines body for RevOrgsUpdate for application/json ContentType.
type RevOrgsUpdateJSONRequestBody = RevOrgsUpdateRequest

// RevUsersAssociationsAddJSONRequestBody defines body for RevUsersAssociationsAdd for application/json ContentType.
type RevUsersAssociationsAddJSONRequestBody = RevUsersAssociationsAddRequest

// RevUsersAssociationsListPostJSONRequestBody defines body for RevUsersAssociationsListPost for application/json ContentType.
type RevUsersAssociationsListPostJSONRequestBody = RevUsersAssociationsListRequest

// RevUsersAssociationsRemoveJSONRequestBody defines body for RevUsersAssociationsRemove for application/json ContentType.
type RevUsersAssociationsRemoveJSONRequestBody = RevUsersAssociationsRemoveRequest

// RevUsersCreateJSONRequestBody defines body for RevUsersCreate for application/json ContentType.
type RevUsersCreateJSONRequestBody = RevUsersCreateRequest

// RevUsersDeleteJSONRequestBody defines body for RevUsersDelete for application/json ContentType.
type RevUsersDeleteJSONRequestBody = RevUsersDeleteRequest

// DeleteRevUsersPersonalDataJSONRequestBody defines body for DeleteRevUsersPersonalData for application/json ContentType.
type DeleteRevUsersPersonalDataJSONRequestBody = DeleteRevUsersPersonalDataRequest

// RevUsersGetPostJSONRequestBody defines body for RevUsersGetPost for application/json ContentType.
type RevUsersGetPostJSONRequestBody = RevUsersGetRequest

// LinkRevUserToRevOrgJSONRequestBody defines body for LinkRevUserToRevOrg for application/json ContentType.
type LinkRevUserToRevOrgJSONRequestBody = LinkRevUserToRevOrgRequest

// RevUsersListPostJSONRequestBody defines body for RevUsersListPost for application/json ContentType.
type RevUsersListPostJSONRequestBody = RevUsersListRequest

// RevUsersMergeJSONRequestBody defines body for RevUsersMerge for application/json ContentType.
type RevUsersMergeJSONRequestBody = RevUsersMergeRequest

// GetRevUsersPersonalDataJSONRequestBody defines body for GetRevUsersPersonalData for application/json ContentType.
type GetRevUsersPersonalDataJSONRequestBody = GetRevUsersPersonalDataRequest

// RevUsersScanPostJSONRequestBody defines body for RevUsersScanPost for application/json ContentType.
type RevUsersScanPostJSONRequestBody = RevUsersScanRequest

// UnlinkRevUserFromRevOrgJSONRequestBody defines body for UnlinkRevUserFromRevOrg for application/json ContentType.
type UnlinkRevUserFromRevOrgJSONRequestBody = UnlinkRevUserFromRevOrgRequest

// RevUsersUpdateJSONRequestBody defines body for RevUsersUpdate for application/json ContentType.
type RevUsersUpdateJSONRequestBody = RevUsersUpdateRequest

// RolesApplyJSONRequestBody defines body for RolesApply for application/json ContentType.
type RolesApplyJSONRequestBody = RolesApplyRequest

// RolesCreateJSONRequestBody defines body for RolesCreate for application/json ContentType.
type RolesCreateJSONRequestBody = RolesCreateRequest

// AggregatedSchemaGetPostJSONRequestBody defines body for AggregatedSchemaGetPost for application/json ContentType.
type AggregatedSchemaGetPostJSONRequestBody = AggregatedSchemaGetRequest

// CustomSchemaFragmentsGetPostJSONRequestBody defines body for CustomSchemaFragmentsGetPost for application/json ContentType.
type CustomSchemaFragmentsGetPostJSONRequestBody = CustomSchemaFragmentsGetRequest

// CustomSchemaFragmentsListPostJSONRequestBody defines body for CustomSchemaFragmentsListPost for application/json ContentType.
type CustomSchemaFragmentsListPostJSONRequestBody = CustomSchemaFragmentsListRequest

// CustomSchemaFragmentsSetJSONRequestBody defines body for CustomSchemaFragmentsSet for application/json ContentType.
type CustomSchemaFragmentsSetJSONRequestBody = CustomSchemaFragmentsSetRequest

// StockSchemaFragmentsGetPostJSONRequestBody defines body for StockSchemaFragmentsGetPost for application/json ContentType.
type StockSchemaFragmentsGetPostJSONRequestBody = StockSchemaFragmentsGetRequest

// StockSchemaFragmentsListPostJSONRequestBody defines body for StockSchemaFragmentsListPost for application/json ContentType.
type StockSchemaFragmentsListPostJSONRequestBody = StockSchemaFragmentsListRequest

// SubtypesListPostJSONRequestBody defines body for SubtypesListPost for application/json ContentType.
type SubtypesListPostJSONRequestBody = SubtypesListRequest

// SchemasSubtypePrepareUpdateGetJSONRequestBody defines body for SchemasSubtypePrepareUpdateGet for application/json ContentType.
type SchemasSubtypePrepareUpdateGetJSONRequestBody = SchemasSubtypePrepareUpdateGetRequest

// SearchCorePostJSONRequestBody defines body for SearchCorePost for application/json ContentType.
type SearchCorePostJSONRequestBody = SearchCoreRequest

// SearchHybridPostJSONRequestBody defines body for SearchHybridPost for application/json ContentType.
type SearchHybridPostJSONRequestBody = SearchHybridRequest

// ServiceAccountsCreateJSONRequestBody defines body for ServiceAccountsCreate for application/json ContentType.
type ServiceAccountsCreateJSONRequestBody = ServiceAccountsCreateRequest

// ServiceAccountsGetPostJSONRequestBody defines body for ServiceAccountsGetPost for application/json ContentType.
type ServiceAccountsGetPostJSONRequestBody = ServiceAccountsGetRequest

// ServiceAccountsUpdateJSONRequestBody defines body for ServiceAccountsUpdate for application/json ContentType.
type ServiceAccountsUpdateJSONRequestBody = ServiceAccountsUpdateRequest

// SlaTrackersGetPostJSONRequestBody defines body for SlaTrackersGetPost for application/json ContentType.
type SlaTrackersGetPostJSONRequestBody = SlaTrackersGetRequest

// SlaTrackersListPostJSONRequestBody defines body for SlaTrackersListPost for application/json ContentType.
type SlaTrackersListPostJSONRequestBody = SlaTrackersListRequest

// SlaTrackersRemoveMetricJSONRequestBody defines body for SlaTrackersRemoveMetric for application/json ContentType.
type SlaTrackersRemoveMetricJSONRequestBody = SlaTrackersRemoveMetricRequest

// SlasAssignJSONRequestBody defines body for SlasAssign for application/json ContentType.
type SlasAssignJSONRequestBody = SlasAssignRequest

// SlasCreateJSONRequestBody defines body for SlasCreate for application/json ContentType.
type SlasCreateJSONRequestBody = SlasCreateRequest

// SlasGetPostJSONRequestBody defines body for SlasGetPost for application/json ContentType.
type SlasGetPostJSONRequestBody = SlasGetRequest

// SlasListPostJSONRequestBody defines body for SlasListPost for application/json ContentType.
type SlasListPostJSONRequestBody = SlasListRequest

// SlasTransitionJSONRequestBody defines body for SlasTransition for application/json ContentType.
type SlasTransitionJSONRequestBody = SlasTransitionRequest

// SlasUpdateJSONRequestBody defines body for SlasUpdate for application/json ContentType.
type SlasUpdateJSONRequestBody = SlasUpdateRequest

// SnapInsResourcesPostJSONRequestBody defines body for SnapInsResourcesPost for application/json ContentType.
type SnapInsResourcesPostJSONRequestBody = SnapInsResourcesRequest

// SnapInsUpdateJSONRequestBody defines body for SnapInsUpdate for application/json ContentType.
type SnapInsUpdateJSONRequestBody = SnapInsUpdateRequest

// SnapKitActionExecuteDeferredJSONRequestBody defines body for SnapKitActionExecuteDeferred for application/json ContentType.
type SnapKitActionExecuteDeferredJSONRequestBody = SnapKitActionExecuteDeferredRequest

// SnapWidgetsCreateJSONRequestBody defines body for SnapWidgetsCreate for application/json ContentType.
type SnapWidgetsCreateJSONRequestBody = SnapWidgetsCreateRequest

// StageDiagramsCreateJSONRequestBody defines body for StageDiagramsCreate for application/json ContentType.
type StageDiagramsCreateJSONRequestBody = StageDiagramsCreateRequest

// StageDiagramsGetPostJSONRequestBody defines body for StageDiagramsGetPost for application/json ContentType.
type StageDiagramsGetPostJSONRequestBody = StageDiagramsGetRequest

// StageDiagramsListPostJSONRequestBody defines body for StageDiagramsListPost for application/json ContentType.
type StageDiagramsListPostJSONRequestBody = StageDiagramsListRequest

// StageDiagramsUpdateJSONRequestBody defines body for StageDiagramsUpdate for application/json ContentType.
type StageDiagramsUpdateJSONRequestBody = StageDiagramsUpdateRequest

// CustomStagesCreateJSONRequestBody defines body for CustomStagesCreate for application/json ContentType.
type CustomStagesCreateJSONRequestBody = CustomStagesCreateRequest

// CustomStagesGetPostJSONRequestBody defines body for CustomStagesGetPost for application/json ContentType.
type CustomStagesGetPostJSONRequestBody = CustomStagesGetRequest

// CustomStagesListPostJSONRequestBody defines body for CustomStagesListPost for application/json ContentType.
type CustomStagesListPostJSONRequestBody = CustomStagesListRequest

// CustomStagesUpdateJSONRequestBody defines body for CustomStagesUpdate for application/json ContentType.
type CustomStagesUpdateJSONRequestBody = CustomStagesUpdateRequest

// CustomStatesCreateJSONRequestBody defines body for CustomStatesCreate for application/json ContentType.
type CustomStatesCreateJSONRequestBody = CustomStatesCreateRequest

// CustomStatesGetPostJSONRequestBody defines body for CustomStatesGetPost for application/json ContentType.
type CustomStatesGetPostJSONRequestBody = CustomStatesGetRequest

// CustomStatesListPostJSONRequestBody defines body for CustomStatesListPost for application/json ContentType.
type CustomStatesListPostJSONRequestBody = CustomStatesListRequest

// CustomStatesUpdateJSONRequestBody defines body for CustomStatesUpdate for application/json ContentType.
type CustomStatesUpdateJSONRequestBody = CustomStatesUpdateRequest

// SubscribersListPostJSONRequestBody defines body for SubscribersListPost for application/json ContentType.
type SubscribersListPostJSONRequestBody = SubscribersListRequest

// SubscribersUpdateJSONRequestBody defines body for SubscribersUpdate for application/json ContentType.
type SubscribersUpdateJSONRequestBody = SubscribersUpdateRequest

// SurveysCreateJSONRequestBody defines body for SurveysCreate for application/json ContentType.
type SurveysCreateJSONRequestBody = SurveysCreateRequest

// SurveysDeleteJSONRequestBody defines body for SurveysDelete for application/json ContentType.
type SurveysDeleteJSONRequestBody = SurveysDeleteRequest

// SurveysGetPostJSONRequestBody defines body for SurveysGetPost for application/json ContentType.
type SurveysGetPostJSONRequestBody = SurveysGetRequest

// SurveysListPostJSONRequestBody defines body for SurveysListPost for application/json ContentType.
type SurveysListPostJSONRequestBody = SurveysListRequest

// SurveysResponsesListPostJSONRequestBody defines body for SurveysResponsesListPost for application/json ContentType.
type SurveysResponsesListPostJSONRequestBody = SurveysResponsesListRequest

// SurveysResponsesUpdateJSONRequestBody defines body for SurveysResponsesUpdate for application/json ContentType.
type SurveysResponsesUpdateJSONRequestBody = SurveysResponsesUpdateRequest

// SurveysSendJSONRequestBody defines body for SurveysSend for application/json ContentType.
type SurveysSendJSONRequestBody = SurveysSendRequest

// SurveysSubmitJSONRequestBody defines body for SurveysSubmit for application/json ContentType.
type SurveysSubmitJSONRequestBody = SurveysSubmitRequest

// SurveysUpdateJSONRequestBody defines body for SurveysUpdate for application/json ContentType.
type SurveysUpdateJSONRequestBody = SurveysUpdateRequest

// SysUsersListPostJSONRequestBody defines body for SysUsersListPost for application/json ContentType.
type SysUsersListPostJSONRequestBody = SysUsersListRequest

// SysUsersUpdateJSONRequestBody defines body for SysUsersUpdate for application/json ContentType.
type SysUsersUpdateJSONRequestBody = SysUsersUpdateRequest

// TagsCreateJSONRequestBody defines body for TagsCreate for application/json ContentType.
type TagsCreateJSONRequestBody = TagsCreateRequest

// TagsDeleteJSONRequestBody defines body for TagsDelete for application/json ContentType.
type TagsDeleteJSONRequestBody = TagsDeleteRequest

// TagsGetPostJSONRequestBody defines body for TagsGetPost for application/json ContentType.
type TagsGetPostJSONRequestBody = TagsGetRequest

// TagsListPostJSONRequestBody defines body for TagsListPost for application/json ContentType.
type TagsListPostJSONRequestBody = TagsListRequest

// TagsUpdateJSONRequestBody defines body for TagsUpdate for application/json ContentType.
type TagsUpdateJSONRequestBody = TagsUpdateRequest

// TimelineEntriesCreateJSONRequestBody defines body for TimelineEntriesCreate for application/json ContentType.
type TimelineEntriesCreateJSONRequestBody = TimelineEntriesCreateRequest

// TimelineEntriesDeleteJSONRequestBody defines body for TimelineEntriesDelete for application/json ContentType.
type TimelineEntriesDeleteJSONRequestBody = TimelineEntriesDeleteRequest

// TimelineEntriesGetPostJSONRequestBody defines body for TimelineEntriesGetPost for application/json ContentType.
type TimelineEntriesGetPostJSONRequestBody = TimelineEntriesGetRequest

// TimelineEntriesListPostJSONRequestBody defines body for TimelineEntriesListPost for application/json ContentType.
type TimelineEntriesListPostJSONRequestBody = TimelineEntriesListRequest

// TimelineEntriesUpdateJSONRequestBody defines body for TimelineEntriesUpdate for application/json ContentType.
type TimelineEntriesUpdateJSONRequestBody = TimelineEntriesUpdateRequest

// TrackEventsPublishJSONRequestBody defines body for TrackEventsPublish for application/json ContentType.
type TrackEventsPublishJSONRequestBody = TrackEventsPublishRequest

// UomsCountPostJSONRequestBody defines body for UomsCountPost for application/json ContentType.
type UomsCountPostJSONRequestBody = UomsCountRequest

// UomsCreateJSONRequestBody defines body for UomsCreate for application/json ContentType.
type UomsCreateJSONRequestBody = UomsCreateRequest

// UomsDeleteJSONRequestBody defines body for UomsDelete for application/json ContentType.
type UomsDeleteJSONRequestBody = UomsDeleteRequest

// UomsGetPostJSONRequestBody defines body for UomsGetPost for application/json ContentType.
type UomsGetPostJSONRequestBody = UomsGetRequest

// UomsListPostJSONRequestBody defines body for UomsListPost for application/json ContentType.
type UomsListPostJSONRequestBody = UomsListRequest

// UomsUpdateJSONRequestBody defines body for UomsUpdate for application/json ContentType.
type UomsUpdateJSONRequestBody = UomsUpdateRequest

// WebCrawlerJobsControlJSONRequestBody defines body for WebCrawlerJobsControl for application/json ContentType.
type WebCrawlerJobsControlJSONRequestBody = WebCrawlerJobsControlRequest

// CreateWebCrawlerJobJSONRequestBody defines body for CreateWebCrawlerJob for application/json ContentType.
type CreateWebCrawlerJobJSONRequestBody = WebCrawlerJobsCreateRequest

// GetWebCrawlerJobPostJSONRequestBody defines body for GetWebCrawlerJobPost for application/json ContentType.
type GetWebCrawlerJobPostJSONRequestBody = WebCrawlerJobsGetRequest

// ListWebCrawlerJobsPostJSONRequestBody defines body for ListWebCrawlerJobsPost for application/json ContentType.
type ListWebCrawlerJobsPostJSONRequestBody = WebCrawlerJobsListRequest

// WebhooksCreateJSONRequestBody defines body for WebhooksCreate for application/json ContentType.
type WebhooksCreateJSONRequestBody = WebhooksCreateRequest

// WebhooksDeleteJSONRequestBody defines body for WebhooksDelete for application/json ContentType.
type WebhooksDeleteJSONRequestBody = WebhooksDeleteRequest

// WebhooksEventJSONRequestBody defines body for WebhooksEvent for application/json ContentType.
type WebhooksEventJSONRequestBody = WebhookEventRequest

// WebhooksFetchJSONRequestBody defines body for WebhooksFetch for application/json ContentType.
type WebhooksFetchJSONRequestBody = WebhooksFetchRequest

// WebhooksGetPostJSONRequestBody defines body for WebhooksGetPost for application/json ContentType.
type WebhooksGetPostJSONRequestBody = WebhooksGetRequest

// WebhooksListPostJSONRequestBody defines body for WebhooksListPost for application/json ContentType.
type WebhooksListPostJSONRequestBody = WebhooksListRequest

// WebhooksUpdateJSONRequestBody defines body for WebhooksUpdate for application/json ContentType.
type WebhooksUpdateJSONRequestBody = WebhooksUpdateRequest

// WidgetsGetPostJSONRequestBody defines body for WidgetsGetPost for application/json ContentType.
type WidgetsGetPostJSONRequestBody = WidgetsGetRequest

// WorksCreateJSONRequestBody defines body for WorksCreate for application/json ContentType.
type WorksCreateJSONRequestBody = WorksCreateRequest

// WorksDeleteJSONRequestBody defines body for WorksDelete for application/json ContentType.
type WorksDeleteJSONRequestBody = WorksDeleteRequest

// WorksExportPostJSONRequestBody defines body for WorksExportPost for application/json ContentType.
type WorksExportPostJSONRequestBody = WorksExportRequest

// WorksGetPostJSONRequestBody defines body for WorksGetPost for application/json ContentType.
type WorksGetPostJSONRequestBody = WorksGetRequest

// WorksListPostJSONRequestBody defines body for WorksListPost for application/json ContentType.
type WorksListPostJSONRequestBody = WorksListRequest

// WorksUpdateJSONRequestBody defines body for WorksUpdate for application/json ContentType.
type WorksUpdateJSONRequestBody = WorksUpdateRequest

// AsAccountSummary returns the union data inside the AssociatedToSummary as a AccountSummary
func (t AssociatedToSummary) AsAccountSummary() (AccountSummary, error) {
	var body AccountSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccountSummary overwrites any union data inside the AssociatedToSummary as the provided AccountSummary
func (t *AssociatedToSummary) FromAccountSummary(v AccountSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccountSummary performs a merge with any union data inside the AssociatedToSummary, using the provided AccountSummary
func (t *AssociatedToSummary) MergeAccountSummary(v AccountSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevOrgSummary returns the union data inside the AssociatedToSummary as a RevOrgSummary
func (t AssociatedToSummary) AsRevOrgSummary() (RevOrgSummary, error) {
	var body RevOrgSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevOrgSummary overwrites any union data inside the AssociatedToSummary as the provided RevOrgSummary
func (t *AssociatedToSummary) FromRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevOrgSummary performs a merge with any union data inside the AssociatedToSummary, using the provided RevOrgSummary
func (t *AssociatedToSummary) MergeRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssociatedToSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AssociatedToSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "account":
		return t.AsAccountSummary()
	case "rev_org":
		return t.AsRevOrgSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AssociatedToSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AssociatedToSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAccount returns the union data inside the Atom as a Account
func (t Atom) AsAccount() (Account, error) {
	var body Account
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccount overwrites any union data inside the Atom as the provided Account
func (t *Atom) FromAccount(v Account) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccount performs a merge with any union data inside the Atom, using the provided Account
func (t *Atom) MergeAccount(v Account) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppFragment returns the union data inside the Atom as a AppFragment
func (t Atom) AsAppFragment() (AppFragment, error) {
	var body AppFragment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppFragment overwrites any union data inside the Atom as the provided AppFragment
func (t *Atom) FromAppFragment(v AppFragment) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppFragment performs a merge with any union data inside the Atom, using the provided AppFragment
func (t *Atom) MergeAppFragment(v AppFragment) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthToken returns the union data inside the Atom as a AuthToken
func (t Atom) AsAuthToken() (AuthToken, error) {
	var body AuthToken
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthToken overwrites any union data inside the Atom as the provided AuthToken
func (t *Atom) FromAuthToken(v AuthToken) error {
	t.Type = "auth_token"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthToken performs a merge with any union data inside the Atom, using the provided AuthToken
func (t *Atom) MergeAuthToken(v AuthToken) error {
	t.Type = "auth_token"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapability returns the union data inside the Atom as a Capability
func (t Atom) AsCapability() (Capability, error) {
	var body Capability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapability overwrites any union data inside the Atom as the provided Capability
func (t *Atom) FromCapability(v Capability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapability performs a merge with any union data inside the Atom, using the provided Capability
func (t *Atom) MergeCapability(v Capability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCodeChange returns the union data inside the Atom as a CodeChange
func (t Atom) AsCodeChange() (CodeChange, error) {
	var body CodeChange
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCodeChange overwrites any union data inside the Atom as the provided CodeChange
func (t *Atom) FromCodeChange(v CodeChange) error {
	t.Type = "code_change"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCodeChange performs a merge with any union data inside the Atom, using the provided CodeChange
func (t *Atom) MergeCodeChange(v CodeChange) error {
	t.Type = "code_change"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommand returns the union data inside the Atom as a Command
func (t Atom) AsCommand() (Command, error) {
	var body Command
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand overwrites any union data inside the Atom as the provided Command
func (t *Atom) FromCommand(v Command) error {
	t.Type = "command"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand performs a merge with any union data inside the Atom, using the provided Command
func (t *Atom) MergeCommand(v Command) error {
	t.Type = "command"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConversation returns the union data inside the Atom as a Conversation
func (t Atom) AsConversation() (Conversation, error) {
	var body Conversation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConversation overwrites any union data inside the Atom as the provided Conversation
func (t *Atom) FromConversation(v Conversation) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConversation performs a merge with any union data inside the Atom, using the provided Conversation
func (t *Atom) MergeConversation(v Conversation) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomObject returns the union data inside the Atom as a CustomObject
func (t Atom) AsCustomObject() (CustomObject, error) {
	var body CustomObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomObject overwrites any union data inside the Atom as the provided CustomObject
func (t *Atom) FromCustomObject(v CustomObject) error {
	t.Type = "custom_object"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomObject performs a merge with any union data inside the Atom, using the provided CustomObject
func (t *Atom) MergeCustomObject(v CustomObject) error {
	t.Type = "custom_object"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomTypeFragment returns the union data inside the Atom as a CustomTypeFragment
func (t Atom) AsCustomTypeFragment() (CustomTypeFragment, error) {
	var body CustomTypeFragment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomTypeFragment overwrites any union data inside the Atom as the provided CustomTypeFragment
func (t *Atom) FromCustomTypeFragment(v CustomTypeFragment) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomTypeFragment performs a merge with any union data inside the Atom, using the provided CustomTypeFragment
func (t *Atom) MergeCustomTypeFragment(v CustomTypeFragment) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrg returns the union data inside the Atom as a DevOrg
func (t Atom) AsDevOrg() (DevOrg, error) {
	var body DevOrg
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrg overwrites any union data inside the Atom as the provided DevOrg
func (t *Atom) FromDevOrg(v DevOrg) error {
	t.Type = "dev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrg performs a merge with any union data inside the Atom, using the provided DevOrg
func (t *Atom) MergeDevOrg(v DevOrg) error {
	t.Type = "dev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevUser returns the union data inside the Atom as a DevUser
func (t Atom) AsDevUser() (DevUser, error) {
	var body DevUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUser overwrites any union data inside the Atom as the provided DevUser
func (t *Atom) FromDevUser(v DevUser) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUser performs a merge with any union data inside the Atom, using the provided DevUser
func (t *Atom) MergeDevUser(v DevUser) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDm returns the union data inside the Atom as a Dm
func (t Atom) AsDm() (Dm, error) {
	var body Dm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDm overwrites any union data inside the Atom as the provided Dm
func (t *Atom) FromDm(v Dm) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDm performs a merge with any union data inside the Atom, using the provided Dm
func (t *Atom) MergeDm(v Dm) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEngagement returns the union data inside the Atom as a Engagement
func (t Atom) AsEngagement() (Engagement, error) {
	var body Engagement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEngagement overwrites any union data inside the Atom as the provided Engagement
func (t *Atom) FromEngagement(v Engagement) error {
	t.Type = "engagement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEngagement performs a merge with any union data inside the Atom, using the provided Engagement
func (t *Atom) MergeEngagement(v Engagement) error {
	t.Type = "engagement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancement returns the union data inside the Atom as a Enhancement
func (t Atom) AsEnhancement() (Enhancement, error) {
	var body Enhancement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancement overwrites any union data inside the Atom as the provided Enhancement
func (t *Atom) FromEnhancement(v Enhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancement performs a merge with any union data inside the Atom, using the provided Enhancement
func (t *Atom) MergeEnhancement(v Enhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeature returns the union data inside the Atom as a Feature
func (t Atom) AsFeature() (Feature, error) {
	var body Feature
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeature overwrites any union data inside the Atom as the provided Feature
func (t *Atom) FromFeature(v Feature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeature performs a merge with any union data inside the Atom, using the provided Feature
func (t *Atom) MergeFeature(v Feature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroup returns the union data inside the Atom as a Group
func (t Atom) AsGroup() (Group, error) {
	var body Group
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroup overwrites any union data inside the Atom as the provided Group
func (t *Atom) FromGroup(v Group) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroup performs a merge with any union data inside the Atom, using the provided Group
func (t *Atom) MergeGroup(v Group) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIncident returns the union data inside the Atom as a Incident
func (t Atom) AsIncident() (Incident, error) {
	var body Incident
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIncident overwrites any union data inside the Atom as the provided Incident
func (t *Atom) FromIncident(v Incident) error {
	t.Type = "incident"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIncident performs a merge with any union data inside the Atom, using the provided Incident
func (t *Atom) MergeIncident(v Incident) error {
	t.Type = "incident"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssue returns the union data inside the Atom as a Issue
func (t Atom) AsIssue() (Issue, error) {
	var body Issue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssue overwrites any union data inside the Atom as the provided Issue
func (t *Atom) FromIssue(v Issue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssue performs a merge with any union data inside the Atom, using the provided Issue
func (t *Atom) MergeIssue(v Issue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLink returns the union data inside the Atom as a Link
func (t Atom) AsLink() (Link, error) {
	var body Link
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLink overwrites any union data inside the Atom as the provided Link
func (t *Atom) FromLink(v Link) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLink performs a merge with any union data inside the Atom, using the provided Link
func (t *Atom) MergeLink(v Link) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkable returns the union data inside the Atom as a Linkable
func (t Atom) AsLinkable() (Linkable, error) {
	var body Linkable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkable overwrites any union data inside the Atom as the provided Linkable
func (t *Atom) FromLinkable(v Linkable) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkable performs a merge with any union data inside the Atom, using the provided Linkable
func (t *Atom) MergeLinkable(v Linkable) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeeting returns the union data inside the Atom as a Meeting
func (t Atom) AsMeeting() (Meeting, error) {
	var body Meeting
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeeting overwrites any union data inside the Atom as the provided Meeting
func (t *Atom) FromMeeting(v Meeting) error {
	t.Type = "meeting"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeeting performs a merge with any union data inside the Atom, using the provided Meeting
func (t *Atom) MergeMeeting(v Meeting) error {
	t.Type = "meeting"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsObjectMember returns the union data inside the Atom as a ObjectMember
func (t Atom) AsObjectMember() (ObjectMember, error) {
	var body ObjectMember
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObjectMember overwrites any union data inside the Atom as the provided ObjectMember
func (t *Atom) FromObjectMember(v ObjectMember) error {
	t.Type = "object_member"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObjectMember performs a merge with any union data inside the Atom, using the provided ObjectMember
func (t *Atom) MergeObjectMember(v ObjectMember) error {
	t.Type = "object_member"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpportunity returns the union data inside the Atom as a Opportunity
func (t Atom) AsOpportunity() (Opportunity, error) {
	var body Opportunity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpportunity overwrites any union data inside the Atom as the provided Opportunity
func (t *Atom) FromOpportunity(v Opportunity) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpportunity performs a merge with any union data inside the Atom, using the provided Opportunity
func (t *Atom) MergeOpportunity(v Opportunity) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProduct returns the union data inside the Atom as a Product
func (t Atom) AsProduct() (Product, error) {
	var body Product
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProduct overwrites any union data inside the Atom as the provided Product
func (t *Atom) FromProduct(v Product) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProduct performs a merge with any union data inside the Atom, using the provided Product
func (t *Atom) MergeProduct(v Product) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionAnswer returns the union data inside the Atom as a QuestionAnswer
func (t Atom) AsQuestionAnswer() (QuestionAnswer, error) {
	var body QuestionAnswer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionAnswer overwrites any union data inside the Atom as the provided QuestionAnswer
func (t *Atom) FromQuestionAnswer(v QuestionAnswer) error {
	t.Type = "question_answer"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionAnswer performs a merge with any union data inside the Atom, using the provided QuestionAnswer
func (t *Atom) MergeQuestionAnswer(v QuestionAnswer) error {
	t.Type = "question_answer"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevOrg returns the union data inside the Atom as a RevOrg
func (t Atom) AsRevOrg() (RevOrg, error) {
	var body RevOrg
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevOrg overwrites any union data inside the Atom as the provided RevOrg
func (t *Atom) FromRevOrg(v RevOrg) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevOrg performs a merge with any union data inside the Atom, using the provided RevOrg
func (t *Atom) MergeRevOrg(v RevOrg) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUser returns the union data inside the Atom as a RevUser
func (t Atom) AsRevUser() (RevUser, error) {
	var body RevUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUser overwrites any union data inside the Atom as the provided RevUser
func (t *Atom) FromRevUser(v RevUser) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUser performs a merge with any union data inside the Atom, using the provided RevUser
func (t *Atom) MergeRevUser(v RevUser) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunnable returns the union data inside the Atom as a Runnable
func (t Atom) AsRunnable() (Runnable, error) {
	var body Runnable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunnable overwrites any union data inside the Atom as the provided Runnable
func (t *Atom) FromRunnable(v Runnable) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunnable performs a merge with any union data inside the Atom, using the provided Runnable
func (t *Atom) MergeRunnable(v Runnable) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServiceAccount returns the union data inside the Atom as a ServiceAccount
func (t Atom) AsServiceAccount() (ServiceAccount, error) {
	var body ServiceAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServiceAccount overwrites any union data inside the Atom as the provided ServiceAccount
func (t *Atom) FromServiceAccount(v ServiceAccount) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServiceAccount performs a merge with any union data inside the Atom, using the provided ServiceAccount
func (t *Atom) MergeServiceAccount(v ServiceAccount) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSla returns the union data inside the Atom as a Sla
func (t Atom) AsSla() (Sla, error) {
	var body Sla
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSla overwrites any union data inside the Atom as the provided Sla
func (t *Atom) FromSla(v Sla) error {
	t.Type = "sla"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSla performs a merge with any union data inside the Atom, using the provided Sla
func (t *Atom) MergeSla(v Sla) error {
	t.Type = "sla"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlaTracker returns the union data inside the Atom as a SlaTracker
func (t Atom) AsSlaTracker() (SlaTracker, error) {
	var body SlaTracker
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlaTracker overwrites any union data inside the Atom as the provided SlaTracker
func (t *Atom) FromSlaTracker(v SlaTracker) error {
	t.Type = "sla_tracker"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlaTracker performs a merge with any union data inside the Atom, using the provided SlaTracker
func (t *Atom) MergeSlaTracker(v SlaTracker) error {
	t.Type = "sla_tracker"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapIn returns the union data inside the Atom as a SnapIn
func (t Atom) AsSnapIn() (SnapIn, error) {
	var body SnapIn
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapIn overwrites any union data inside the Atom as the provided SnapIn
func (t *Atom) FromSnapIn(v SnapIn) error {
	t.Type = "snap_in"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapIn performs a merge with any union data inside the Atom, using the provided SnapIn
func (t *Atom) MergeSnapIn(v SnapIn) error {
	t.Type = "snap_in"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapInVersion returns the union data inside the Atom as a SnapInVersion
func (t Atom) AsSnapInVersion() (SnapInVersion, error) {
	var body SnapInVersion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapInVersion overwrites any union data inside the Atom as the provided SnapInVersion
func (t *Atom) FromSnapInVersion(v SnapInVersion) error {
	t.Type = "snap_in_version"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapInVersion performs a merge with any union data inside the Atom, using the provided SnapInVersion
func (t *Atom) MergeSnapInVersion(v SnapInVersion) error {
	t.Type = "snap_in_version"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSysUser returns the union data inside the Atom as a SysUser
func (t Atom) AsSysUser() (SysUser, error) {
	var body SysUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSysUser overwrites any union data inside the Atom as the provided SysUser
func (t *Atom) FromSysUser(v SysUser) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSysUser performs a merge with any union data inside the Atom, using the provided SysUser
func (t *Atom) MergeSysUser(v SysUser) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTag returns the union data inside the Atom as a Tag
func (t Atom) AsTag() (Tag, error) {
	var body Tag
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTag overwrites any union data inside the Atom as the provided Tag
func (t *Atom) FromTag(v Tag) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTag performs a merge with any union data inside the Atom, using the provided Tag
func (t *Atom) MergeTag(v Tag) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTask returns the union data inside the Atom as a Task
func (t Atom) AsTask() (Task, error) {
	var body Task
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTask overwrites any union data inside the Atom as the provided Task
func (t *Atom) FromTask(v Task) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTask performs a merge with any union data inside the Atom, using the provided Task
func (t *Atom) MergeTask(v Task) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTenantFragment returns the union data inside the Atom as a TenantFragment
func (t Atom) AsTenantFragment() (TenantFragment, error) {
	var body TenantFragment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTenantFragment overwrites any union data inside the Atom as the provided TenantFragment
func (t *Atom) FromTenantFragment(v TenantFragment) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTenantFragment performs a merge with any union data inside the Atom, using the provided TenantFragment
func (t *Atom) MergeTenantFragment(v TenantFragment) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTicket returns the union data inside the Atom as a Ticket
func (t Atom) AsTicket() (Ticket, error) {
	var body Ticket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTicket overwrites any union data inside the Atom as the provided Ticket
func (t *Atom) FromTicket(v Ticket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTicket performs a merge with any union data inside the Atom, using the provided Ticket
func (t *Atom) MergeTicket(v Ticket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimelineChangeEvent returns the union data inside the Atom as a TimelineChangeEvent
func (t Atom) AsTimelineChangeEvent() (TimelineChangeEvent, error) {
	var body TimelineChangeEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineChangeEvent overwrites any union data inside the Atom as the provided TimelineChangeEvent
func (t *Atom) FromTimelineChangeEvent(v TimelineChangeEvent) error {
	t.Type = "timeline_change_event"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineChangeEvent performs a merge with any union data inside the Atom, using the provided TimelineChangeEvent
func (t *Atom) MergeTimelineChangeEvent(v TimelineChangeEvent) error {
	t.Type = "timeline_change_event"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimelineComment returns the union data inside the Atom as a TimelineComment
func (t Atom) AsTimelineComment() (TimelineComment, error) {
	var body TimelineComment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineComment overwrites any union data inside the Atom as the provided TimelineComment
func (t *Atom) FromTimelineComment(v TimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineComment performs a merge with any union data inside the Atom, using the provided TimelineComment
func (t *Atom) MergeTimelineComment(v TimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUom returns the union data inside the Atom as a Uom
func (t Atom) AsUom() (Uom, error) {
	var body Uom
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUom overwrites any union data inside the Atom as the provided Uom
func (t *Atom) FromUom(v Uom) error {
	t.Type = "uom"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUom performs a merge with any union data inside the Atom, using the provided Uom
func (t *Atom) MergeUom(v Uom) error {
	t.Type = "uom"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserPreferences returns the union data inside the Atom as a UserPreferences
func (t Atom) AsUserPreferences() (UserPreferences, error) {
	var body UserPreferences
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserPreferences overwrites any union data inside the Atom as the provided UserPreferences
func (t *Atom) FromUserPreferences(v UserPreferences) error {
	t.Type = "user_preferences"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserPreferences performs a merge with any union data inside the Atom, using the provided UserPreferences
func (t *Atom) MergeUserPreferences(v UserPreferences) error {
	t.Type = "user_preferences"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhook returns the union data inside the Atom as a Webhook
func (t Atom) AsWebhook() (Webhook, error) {
	var body Webhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhook overwrites any union data inside the Atom as the provided Webhook
func (t *Atom) FromWebhook(v Webhook) error {
	t.Type = "webhook"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhook performs a merge with any union data inside the Atom, using the provided Webhook
func (t *Atom) MergeWebhook(v Webhook) error {
	t.Type = "webhook"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWidget returns the union data inside the Atom as a Widget
func (t Atom) AsWidget() (Widget, error) {
	var body Widget
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWidget overwrites any union data inside the Atom as the provided Widget
func (t *Atom) FromWidget(v Widget) error {
	t.Type = "widget"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWidget performs a merge with any union data inside the Atom, using the provided Widget
func (t *Atom) MergeWidget(v Widget) error {
	t.Type = "widget"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Atom) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Atom) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "account":
		return t.AsAccount()
	case "app_fragment":
		return t.AsAppFragment()
	case "auth_token":
		return t.AsAuthToken()
	case "capability":
		return t.AsCapability()
	case "code_change":
		return t.AsCodeChange()
	case "command":
		return t.AsCommand()
	case "conversation":
		return t.AsConversation()
	case "custom_object":
		return t.AsCustomObject()
	case "custom_type_fragment":
		return t.AsCustomTypeFragment()
	case "dev_org":
		return t.AsDevOrg()
	case "dev_user":
		return t.AsDevUser()
	case "dm":
		return t.AsDm()
	case "engagement":
		return t.AsEngagement()
	case "enhancement":
		return t.AsEnhancement()
	case "feature":
		return t.AsFeature()
	case "group":
		return t.AsGroup()
	case "incident":
		return t.AsIncident()
	case "issue":
		return t.AsIssue()
	case "link":
		return t.AsLink()
	case "linkable":
		return t.AsLinkable()
	case "meeting":
		return t.AsMeeting()
	case "object_member":
		return t.AsObjectMember()
	case "opportunity":
		return t.AsOpportunity()
	case "product":
		return t.AsProduct()
	case "question_answer":
		return t.AsQuestionAnswer()
	case "rev_org":
		return t.AsRevOrg()
	case "rev_user":
		return t.AsRevUser()
	case "runnable":
		return t.AsRunnable()
	case "service_account":
		return t.AsServiceAccount()
	case "sla":
		return t.AsSla()
	case "sla_tracker":
		return t.AsSlaTracker()
	case "snap_in":
		return t.AsSnapIn()
	case "snap_in_version":
		return t.AsSnapInVersion()
	case "sys_user":
		return t.AsSysUser()
	case "tag":
		return t.AsTag()
	case "task":
		return t.AsTask()
	case "tenant_fragment":
		return t.AsTenantFragment()
	case "ticket":
		return t.AsTicket()
	case "timeline_change_event":
		return t.AsTimelineChangeEvent()
	case "timeline_comment":
		return t.AsTimelineComment()
	case "uom":
		return t.AsUom()
	case "user_preferences":
		return t.AsUserPreferences()
	case "webhook":
		return t.AsWebhook()
	case "widget":
		return t.AsWidget()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Atom) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Atom) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAccountSummary returns the union data inside the AtomSummary as a AccountSummary
func (t AtomSummary) AsAccountSummary() (AccountSummary, error) {
	var body AccountSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccountSummary overwrites any union data inside the AtomSummary as the provided AccountSummary
func (t *AtomSummary) FromAccountSummary(v AccountSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccountSummary performs a merge with any union data inside the AtomSummary, using the provided AccountSummary
func (t *AtomSummary) MergeAccountSummary(v AccountSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppFragmentSummary returns the union data inside the AtomSummary as a AppFragmentSummary
func (t AtomSummary) AsAppFragmentSummary() (AppFragmentSummary, error) {
	var body AppFragmentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppFragmentSummary overwrites any union data inside the AtomSummary as the provided AppFragmentSummary
func (t *AtomSummary) FromAppFragmentSummary(v AppFragmentSummary) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppFragmentSummary performs a merge with any union data inside the AtomSummary, using the provided AppFragmentSummary
func (t *AtomSummary) MergeAppFragmentSummary(v AppFragmentSummary) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthTokenSummary returns the union data inside the AtomSummary as a AuthTokenSummary
func (t AtomSummary) AsAuthTokenSummary() (AuthTokenSummary, error) {
	var body AuthTokenSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthTokenSummary overwrites any union data inside the AtomSummary as the provided AuthTokenSummary
func (t *AtomSummary) FromAuthTokenSummary(v AuthTokenSummary) error {
	t.Type = "auth_token"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthTokenSummary performs a merge with any union data inside the AtomSummary, using the provided AuthTokenSummary
func (t *AtomSummary) MergeAuthTokenSummary(v AuthTokenSummary) error {
	t.Type = "auth_token"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapabilitySummary returns the union data inside the AtomSummary as a CapabilitySummary
func (t AtomSummary) AsCapabilitySummary() (CapabilitySummary, error) {
	var body CapabilitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapabilitySummary overwrites any union data inside the AtomSummary as the provided CapabilitySummary
func (t *AtomSummary) FromCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapabilitySummary performs a merge with any union data inside the AtomSummary, using the provided CapabilitySummary
func (t *AtomSummary) MergeCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCodeChangeSummary returns the union data inside the AtomSummary as a CodeChangeSummary
func (t AtomSummary) AsCodeChangeSummary() (CodeChangeSummary, error) {
	var body CodeChangeSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCodeChangeSummary overwrites any union data inside the AtomSummary as the provided CodeChangeSummary
func (t *AtomSummary) FromCodeChangeSummary(v CodeChangeSummary) error {
	t.Type = "code_change"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCodeChangeSummary performs a merge with any union data inside the AtomSummary, using the provided CodeChangeSummary
func (t *AtomSummary) MergeCodeChangeSummary(v CodeChangeSummary) error {
	t.Type = "code_change"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommandSummary returns the union data inside the AtomSummary as a CommandSummary
func (t AtomSummary) AsCommandSummary() (CommandSummary, error) {
	var body CommandSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommandSummary overwrites any union data inside the AtomSummary as the provided CommandSummary
func (t *AtomSummary) FromCommandSummary(v CommandSummary) error {
	t.Type = "command"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommandSummary performs a merge with any union data inside the AtomSummary, using the provided CommandSummary
func (t *AtomSummary) MergeCommandSummary(v CommandSummary) error {
	t.Type = "command"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConversationSummary returns the union data inside the AtomSummary as a ConversationSummary
func (t AtomSummary) AsConversationSummary() (ConversationSummary, error) {
	var body ConversationSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConversationSummary overwrites any union data inside the AtomSummary as the provided ConversationSummary
func (t *AtomSummary) FromConversationSummary(v ConversationSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConversationSummary performs a merge with any union data inside the AtomSummary, using the provided ConversationSummary
func (t *AtomSummary) MergeConversationSummary(v ConversationSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomObjectSummary returns the union data inside the AtomSummary as a CustomObjectSummary
func (t AtomSummary) AsCustomObjectSummary() (CustomObjectSummary, error) {
	var body CustomObjectSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomObjectSummary overwrites any union data inside the AtomSummary as the provided CustomObjectSummary
func (t *AtomSummary) FromCustomObjectSummary(v CustomObjectSummary) error {
	t.Type = "custom_object"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomObjectSummary performs a merge with any union data inside the AtomSummary, using the provided CustomObjectSummary
func (t *AtomSummary) MergeCustomObjectSummary(v CustomObjectSummary) error {
	t.Type = "custom_object"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomTypeFragmentSummary returns the union data inside the AtomSummary as a CustomTypeFragmentSummary
func (t AtomSummary) AsCustomTypeFragmentSummary() (CustomTypeFragmentSummary, error) {
	var body CustomTypeFragmentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomTypeFragmentSummary overwrites any union data inside the AtomSummary as the provided CustomTypeFragmentSummary
func (t *AtomSummary) FromCustomTypeFragmentSummary(v CustomTypeFragmentSummary) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomTypeFragmentSummary performs a merge with any union data inside the AtomSummary, using the provided CustomTypeFragmentSummary
func (t *AtomSummary) MergeCustomTypeFragmentSummary(v CustomTypeFragmentSummary) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgSummary returns the union data inside the AtomSummary as a DevOrgSummary
func (t AtomSummary) AsDevOrgSummary() (DevOrgSummary, error) {
	var body DevOrgSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgSummary overwrites any union data inside the AtomSummary as the provided DevOrgSummary
func (t *AtomSummary) FromDevOrgSummary(v DevOrgSummary) error {
	t.Type = "dev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgSummary performs a merge with any union data inside the AtomSummary, using the provided DevOrgSummary
func (t *AtomSummary) MergeDevOrgSummary(v DevOrgSummary) error {
	t.Type = "dev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevUserSummary returns the union data inside the AtomSummary as a DevUserSummary
func (t AtomSummary) AsDevUserSummary() (DevUserSummary, error) {
	var body DevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUserSummary overwrites any union data inside the AtomSummary as the provided DevUserSummary
func (t *AtomSummary) FromDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUserSummary performs a merge with any union data inside the AtomSummary, using the provided DevUserSummary
func (t *AtomSummary) MergeDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDmSummary returns the union data inside the AtomSummary as a DmSummary
func (t AtomSummary) AsDmSummary() (DmSummary, error) {
	var body DmSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDmSummary overwrites any union data inside the AtomSummary as the provided DmSummary
func (t *AtomSummary) FromDmSummary(v DmSummary) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDmSummary performs a merge with any union data inside the AtomSummary, using the provided DmSummary
func (t *AtomSummary) MergeDmSummary(v DmSummary) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEngagementSummary returns the union data inside the AtomSummary as a EngagementSummary
func (t AtomSummary) AsEngagementSummary() (EngagementSummary, error) {
	var body EngagementSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEngagementSummary overwrites any union data inside the AtomSummary as the provided EngagementSummary
func (t *AtomSummary) FromEngagementSummary(v EngagementSummary) error {
	t.Type = "engagement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEngagementSummary performs a merge with any union data inside the AtomSummary, using the provided EngagementSummary
func (t *AtomSummary) MergeEngagementSummary(v EngagementSummary) error {
	t.Type = "engagement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancementSummary returns the union data inside the AtomSummary as a EnhancementSummary
func (t AtomSummary) AsEnhancementSummary() (EnhancementSummary, error) {
	var body EnhancementSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancementSummary overwrites any union data inside the AtomSummary as the provided EnhancementSummary
func (t *AtomSummary) FromEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancementSummary performs a merge with any union data inside the AtomSummary, using the provided EnhancementSummary
func (t *AtomSummary) MergeEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeatureSummary returns the union data inside the AtomSummary as a FeatureSummary
func (t AtomSummary) AsFeatureSummary() (FeatureSummary, error) {
	var body FeatureSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeatureSummary overwrites any union data inside the AtomSummary as the provided FeatureSummary
func (t *AtomSummary) FromFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeatureSummary performs a merge with any union data inside the AtomSummary, using the provided FeatureSummary
func (t *AtomSummary) MergeFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroupSummary returns the union data inside the AtomSummary as a GroupSummary
func (t AtomSummary) AsGroupSummary() (GroupSummary, error) {
	var body GroupSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroupSummary overwrites any union data inside the AtomSummary as the provided GroupSummary
func (t *AtomSummary) FromGroupSummary(v GroupSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroupSummary performs a merge with any union data inside the AtomSummary, using the provided GroupSummary
func (t *AtomSummary) MergeGroupSummary(v GroupSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIncidentSummary returns the union data inside the AtomSummary as a IncidentSummary
func (t AtomSummary) AsIncidentSummary() (IncidentSummary, error) {
	var body IncidentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIncidentSummary overwrites any union data inside the AtomSummary as the provided IncidentSummary
func (t *AtomSummary) FromIncidentSummary(v IncidentSummary) error {
	t.Type = "incident"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIncidentSummary performs a merge with any union data inside the AtomSummary, using the provided IncidentSummary
func (t *AtomSummary) MergeIncidentSummary(v IncidentSummary) error {
	t.Type = "incident"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueSummary returns the union data inside the AtomSummary as a IssueSummary
func (t AtomSummary) AsIssueSummary() (IssueSummary, error) {
	var body IssueSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueSummary overwrites any union data inside the AtomSummary as the provided IssueSummary
func (t *AtomSummary) FromIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueSummary performs a merge with any union data inside the AtomSummary, using the provided IssueSummary
func (t *AtomSummary) MergeIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkSummary returns the union data inside the AtomSummary as a LinkSummary
func (t AtomSummary) AsLinkSummary() (LinkSummary, error) {
	var body LinkSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkSummary overwrites any union data inside the AtomSummary as the provided LinkSummary
func (t *AtomSummary) FromLinkSummary(v LinkSummary) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkSummary performs a merge with any union data inside the AtomSummary, using the provided LinkSummary
func (t *AtomSummary) MergeLinkSummary(v LinkSummary) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkableSummary returns the union data inside the AtomSummary as a LinkableSummary
func (t AtomSummary) AsLinkableSummary() (LinkableSummary, error) {
	var body LinkableSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkableSummary overwrites any union data inside the AtomSummary as the provided LinkableSummary
func (t *AtomSummary) FromLinkableSummary(v LinkableSummary) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkableSummary performs a merge with any union data inside the AtomSummary, using the provided LinkableSummary
func (t *AtomSummary) MergeLinkableSummary(v LinkableSummary) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeetingSummary returns the union data inside the AtomSummary as a MeetingSummary
func (t AtomSummary) AsMeetingSummary() (MeetingSummary, error) {
	var body MeetingSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeetingSummary overwrites any union data inside the AtomSummary as the provided MeetingSummary
func (t *AtomSummary) FromMeetingSummary(v MeetingSummary) error {
	t.Type = "meeting"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeetingSummary performs a merge with any union data inside the AtomSummary, using the provided MeetingSummary
func (t *AtomSummary) MergeMeetingSummary(v MeetingSummary) error {
	t.Type = "meeting"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsObjectMemberSummary returns the union data inside the AtomSummary as a ObjectMemberSummary
func (t AtomSummary) AsObjectMemberSummary() (ObjectMemberSummary, error) {
	var body ObjectMemberSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObjectMemberSummary overwrites any union data inside the AtomSummary as the provided ObjectMemberSummary
func (t *AtomSummary) FromObjectMemberSummary(v ObjectMemberSummary) error {
	t.Type = "object_member"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObjectMemberSummary performs a merge with any union data inside the AtomSummary, using the provided ObjectMemberSummary
func (t *AtomSummary) MergeObjectMemberSummary(v ObjectMemberSummary) error {
	t.Type = "object_member"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpportunitySummary returns the union data inside the AtomSummary as a OpportunitySummary
func (t AtomSummary) AsOpportunitySummary() (OpportunitySummary, error) {
	var body OpportunitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpportunitySummary overwrites any union data inside the AtomSummary as the provided OpportunitySummary
func (t *AtomSummary) FromOpportunitySummary(v OpportunitySummary) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpportunitySummary performs a merge with any union data inside the AtomSummary, using the provided OpportunitySummary
func (t *AtomSummary) MergeOpportunitySummary(v OpportunitySummary) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProductSummary returns the union data inside the AtomSummary as a ProductSummary
func (t AtomSummary) AsProductSummary() (ProductSummary, error) {
	var body ProductSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProductSummary overwrites any union data inside the AtomSummary as the provided ProductSummary
func (t *AtomSummary) FromProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProductSummary performs a merge with any union data inside the AtomSummary, using the provided ProductSummary
func (t *AtomSummary) MergeProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionAnswerSummary returns the union data inside the AtomSummary as a QuestionAnswerSummary
func (t AtomSummary) AsQuestionAnswerSummary() (QuestionAnswerSummary, error) {
	var body QuestionAnswerSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionAnswerSummary overwrites any union data inside the AtomSummary as the provided QuestionAnswerSummary
func (t *AtomSummary) FromQuestionAnswerSummary(v QuestionAnswerSummary) error {
	t.Type = "question_answer"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionAnswerSummary performs a merge with any union data inside the AtomSummary, using the provided QuestionAnswerSummary
func (t *AtomSummary) MergeQuestionAnswerSummary(v QuestionAnswerSummary) error {
	t.Type = "question_answer"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevOrgSummary returns the union data inside the AtomSummary as a RevOrgSummary
func (t AtomSummary) AsRevOrgSummary() (RevOrgSummary, error) {
	var body RevOrgSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevOrgSummary overwrites any union data inside the AtomSummary as the provided RevOrgSummary
func (t *AtomSummary) FromRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevOrgSummary performs a merge with any union data inside the AtomSummary, using the provided RevOrgSummary
func (t *AtomSummary) MergeRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUserSummary returns the union data inside the AtomSummary as a RevUserSummary
func (t AtomSummary) AsRevUserSummary() (RevUserSummary, error) {
	var body RevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUserSummary overwrites any union data inside the AtomSummary as the provided RevUserSummary
func (t *AtomSummary) FromRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUserSummary performs a merge with any union data inside the AtomSummary, using the provided RevUserSummary
func (t *AtomSummary) MergeRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunnableSummary returns the union data inside the AtomSummary as a RunnableSummary
func (t AtomSummary) AsRunnableSummary() (RunnableSummary, error) {
	var body RunnableSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunnableSummary overwrites any union data inside the AtomSummary as the provided RunnableSummary
func (t *AtomSummary) FromRunnableSummary(v RunnableSummary) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunnableSummary performs a merge with any union data inside the AtomSummary, using the provided RunnableSummary
func (t *AtomSummary) MergeRunnableSummary(v RunnableSummary) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServiceAccountSummary returns the union data inside the AtomSummary as a ServiceAccountSummary
func (t AtomSummary) AsServiceAccountSummary() (ServiceAccountSummary, error) {
	var body ServiceAccountSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServiceAccountSummary overwrites any union data inside the AtomSummary as the provided ServiceAccountSummary
func (t *AtomSummary) FromServiceAccountSummary(v ServiceAccountSummary) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServiceAccountSummary performs a merge with any union data inside the AtomSummary, using the provided ServiceAccountSummary
func (t *AtomSummary) MergeServiceAccountSummary(v ServiceAccountSummary) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlaSummary returns the union data inside the AtomSummary as a SlaSummary
func (t AtomSummary) AsSlaSummary() (SlaSummary, error) {
	var body SlaSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlaSummary overwrites any union data inside the AtomSummary as the provided SlaSummary
func (t *AtomSummary) FromSlaSummary(v SlaSummary) error {
	t.Type = "sla"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlaSummary performs a merge with any union data inside the AtomSummary, using the provided SlaSummary
func (t *AtomSummary) MergeSlaSummary(v SlaSummary) error {
	t.Type = "sla"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlaTrackerSummary returns the union data inside the AtomSummary as a SlaTrackerSummary
func (t AtomSummary) AsSlaTrackerSummary() (SlaTrackerSummary, error) {
	var body SlaTrackerSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlaTrackerSummary overwrites any union data inside the AtomSummary as the provided SlaTrackerSummary
func (t *AtomSummary) FromSlaTrackerSummary(v SlaTrackerSummary) error {
	t.Type = "sla_tracker"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlaTrackerSummary performs a merge with any union data inside the AtomSummary, using the provided SlaTrackerSummary
func (t *AtomSummary) MergeSlaTrackerSummary(v SlaTrackerSummary) error {
	t.Type = "sla_tracker"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapInSummary returns the union data inside the AtomSummary as a SnapInSummary
func (t AtomSummary) AsSnapInSummary() (SnapInSummary, error) {
	var body SnapInSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapInSummary overwrites any union data inside the AtomSummary as the provided SnapInSummary
func (t *AtomSummary) FromSnapInSummary(v SnapInSummary) error {
	t.Type = "snap_in"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapInSummary performs a merge with any union data inside the AtomSummary, using the provided SnapInSummary
func (t *AtomSummary) MergeSnapInSummary(v SnapInSummary) error {
	t.Type = "snap_in"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapInVersionSummary returns the union data inside the AtomSummary as a SnapInVersionSummary
func (t AtomSummary) AsSnapInVersionSummary() (SnapInVersionSummary, error) {
	var body SnapInVersionSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapInVersionSummary overwrites any union data inside the AtomSummary as the provided SnapInVersionSummary
func (t *AtomSummary) FromSnapInVersionSummary(v SnapInVersionSummary) error {
	t.Type = "snap_in_version"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapInVersionSummary performs a merge with any union data inside the AtomSummary, using the provided SnapInVersionSummary
func (t *AtomSummary) MergeSnapInVersionSummary(v SnapInVersionSummary) error {
	t.Type = "snap_in_version"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSysUserSummary returns the union data inside the AtomSummary as a SysUserSummary
func (t AtomSummary) AsSysUserSummary() (SysUserSummary, error) {
	var body SysUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSysUserSummary overwrites any union data inside the AtomSummary as the provided SysUserSummary
func (t *AtomSummary) FromSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSysUserSummary performs a merge with any union data inside the AtomSummary, using the provided SysUserSummary
func (t *AtomSummary) MergeSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTagSummary returns the union data inside the AtomSummary as a TagSummary
func (t AtomSummary) AsTagSummary() (TagSummary, error) {
	var body TagSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTagSummary overwrites any union data inside the AtomSummary as the provided TagSummary
func (t *AtomSummary) FromTagSummary(v TagSummary) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTagSummary performs a merge with any union data inside the AtomSummary, using the provided TagSummary
func (t *AtomSummary) MergeTagSummary(v TagSummary) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTaskSummary returns the union data inside the AtomSummary as a TaskSummary
func (t AtomSummary) AsTaskSummary() (TaskSummary, error) {
	var body TaskSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTaskSummary overwrites any union data inside the AtomSummary as the provided TaskSummary
func (t *AtomSummary) FromTaskSummary(v TaskSummary) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTaskSummary performs a merge with any union data inside the AtomSummary, using the provided TaskSummary
func (t *AtomSummary) MergeTaskSummary(v TaskSummary) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTenantFragmentSummary returns the union data inside the AtomSummary as a TenantFragmentSummary
func (t AtomSummary) AsTenantFragmentSummary() (TenantFragmentSummary, error) {
	var body TenantFragmentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTenantFragmentSummary overwrites any union data inside the AtomSummary as the provided TenantFragmentSummary
func (t *AtomSummary) FromTenantFragmentSummary(v TenantFragmentSummary) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTenantFragmentSummary performs a merge with any union data inside the AtomSummary, using the provided TenantFragmentSummary
func (t *AtomSummary) MergeTenantFragmentSummary(v TenantFragmentSummary) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTicketSummary returns the union data inside the AtomSummary as a TicketSummary
func (t AtomSummary) AsTicketSummary() (TicketSummary, error) {
	var body TicketSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTicketSummary overwrites any union data inside the AtomSummary as the provided TicketSummary
func (t *AtomSummary) FromTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTicketSummary performs a merge with any union data inside the AtomSummary, using the provided TicketSummary
func (t *AtomSummary) MergeTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimelineChangeEventSummary returns the union data inside the AtomSummary as a TimelineChangeEventSummary
func (t AtomSummary) AsTimelineChangeEventSummary() (TimelineChangeEventSummary, error) {
	var body TimelineChangeEventSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineChangeEventSummary overwrites any union data inside the AtomSummary as the provided TimelineChangeEventSummary
func (t *AtomSummary) FromTimelineChangeEventSummary(v TimelineChangeEventSummary) error {
	t.Type = "timeline_change_event"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineChangeEventSummary performs a merge with any union data inside the AtomSummary, using the provided TimelineChangeEventSummary
func (t *AtomSummary) MergeTimelineChangeEventSummary(v TimelineChangeEventSummary) error {
	t.Type = "timeline_change_event"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimelineCommentSummary returns the union data inside the AtomSummary as a TimelineCommentSummary
func (t AtomSummary) AsTimelineCommentSummary() (TimelineCommentSummary, error) {
	var body TimelineCommentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineCommentSummary overwrites any union data inside the AtomSummary as the provided TimelineCommentSummary
func (t *AtomSummary) FromTimelineCommentSummary(v TimelineCommentSummary) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineCommentSummary performs a merge with any union data inside the AtomSummary, using the provided TimelineCommentSummary
func (t *AtomSummary) MergeTimelineCommentSummary(v TimelineCommentSummary) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUomSummary returns the union data inside the AtomSummary as a UomSummary
func (t AtomSummary) AsUomSummary() (UomSummary, error) {
	var body UomSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUomSummary overwrites any union data inside the AtomSummary as the provided UomSummary
func (t *AtomSummary) FromUomSummary(v UomSummary) error {
	t.Type = "uom"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUomSummary performs a merge with any union data inside the AtomSummary, using the provided UomSummary
func (t *AtomSummary) MergeUomSummary(v UomSummary) error {
	t.Type = "uom"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserPreferencesSummary returns the union data inside the AtomSummary as a UserPreferencesSummary
func (t AtomSummary) AsUserPreferencesSummary() (UserPreferencesSummary, error) {
	var body UserPreferencesSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserPreferencesSummary overwrites any union data inside the AtomSummary as the provided UserPreferencesSummary
func (t *AtomSummary) FromUserPreferencesSummary(v UserPreferencesSummary) error {
	t.Type = "user_preferences"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserPreferencesSummary performs a merge with any union data inside the AtomSummary, using the provided UserPreferencesSummary
func (t *AtomSummary) MergeUserPreferencesSummary(v UserPreferencesSummary) error {
	t.Type = "user_preferences"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookSummary returns the union data inside the AtomSummary as a WebhookSummary
func (t AtomSummary) AsWebhookSummary() (WebhookSummary, error) {
	var body WebhookSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookSummary overwrites any union data inside the AtomSummary as the provided WebhookSummary
func (t *AtomSummary) FromWebhookSummary(v WebhookSummary) error {
	t.Type = "webhook"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookSummary performs a merge with any union data inside the AtomSummary, using the provided WebhookSummary
func (t *AtomSummary) MergeWebhookSummary(v WebhookSummary) error {
	t.Type = "webhook"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWidgetSummary returns the union data inside the AtomSummary as a WidgetSummary
func (t AtomSummary) AsWidgetSummary() (WidgetSummary, error) {
	var body WidgetSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWidgetSummary overwrites any union data inside the AtomSummary as the provided WidgetSummary
func (t *AtomSummary) FromWidgetSummary(v WidgetSummary) error {
	t.Type = "widget"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWidgetSummary performs a merge with any union data inside the AtomSummary, using the provided WidgetSummary
func (t *AtomSummary) MergeWidgetSummary(v WidgetSummary) error {
	t.Type = "widget"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AtomSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AtomSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "account":
		return t.AsAccountSummary()
	case "app_fragment":
		return t.AsAppFragmentSummary()
	case "auth_token":
		return t.AsAuthTokenSummary()
	case "capability":
		return t.AsCapabilitySummary()
	case "code_change":
		return t.AsCodeChangeSummary()
	case "command":
		return t.AsCommandSummary()
	case "conversation":
		return t.AsConversationSummary()
	case "custom_object":
		return t.AsCustomObjectSummary()
	case "custom_type_fragment":
		return t.AsCustomTypeFragmentSummary()
	case "dev_org":
		return t.AsDevOrgSummary()
	case "dev_user":
		return t.AsDevUserSummary()
	case "dm":
		return t.AsDmSummary()
	case "engagement":
		return t.AsEngagementSummary()
	case "enhancement":
		return t.AsEnhancementSummary()
	case "feature":
		return t.AsFeatureSummary()
	case "group":
		return t.AsGroupSummary()
	case "incident":
		return t.AsIncidentSummary()
	case "issue":
		return t.AsIssueSummary()
	case "link":
		return t.AsLinkSummary()
	case "linkable":
		return t.AsLinkableSummary()
	case "meeting":
		return t.AsMeetingSummary()
	case "object_member":
		return t.AsObjectMemberSummary()
	case "opportunity":
		return t.AsOpportunitySummary()
	case "product":
		return t.AsProductSummary()
	case "question_answer":
		return t.AsQuestionAnswerSummary()
	case "rev_org":
		return t.AsRevOrgSummary()
	case "rev_user":
		return t.AsRevUserSummary()
	case "runnable":
		return t.AsRunnableSummary()
	case "service_account":
		return t.AsServiceAccountSummary()
	case "sla":
		return t.AsSlaSummary()
	case "sla_tracker":
		return t.AsSlaTrackerSummary()
	case "snap_in":
		return t.AsSnapInSummary()
	case "snap_in_version":
		return t.AsSnapInVersionSummary()
	case "sys_user":
		return t.AsSysUserSummary()
	case "tag":
		return t.AsTagSummary()
	case "task":
		return t.AsTaskSummary()
	case "tenant_fragment":
		return t.AsTenantFragmentSummary()
	case "ticket":
		return t.AsTicketSummary()
	case "timeline_change_event":
		return t.AsTimelineChangeEventSummary()
	case "timeline_comment":
		return t.AsTimelineCommentSummary()
	case "uom":
		return t.AsUomSummary()
	case "user_preferences":
		return t.AsUserPreferencesSummary()
	case "webhook":
		return t.AsWebhookSummary()
	case "widget":
		return t.AsWidgetSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AtomSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AtomSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAuthConnectionOptionsAzureAd returns the union data inside the AuthConnection as a AuthConnectionOptionsAzureAd
func (t AuthConnection) AsAuthConnectionOptionsAzureAd() (AuthConnectionOptionsAzureAd, error) {
	var body AuthConnectionOptionsAzureAd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsAzureAd overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsAzureAd
func (t *AuthConnection) FromAuthConnectionOptionsAzureAd(v AuthConnectionOptionsAzureAd) error {
	t.Type = "waad"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsAzureAd performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsAzureAd
func (t *AuthConnection) MergeAuthConnectionOptionsAzureAd(v AuthConnectionOptionsAzureAd) error {
	t.Type = "waad"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsGoogleApps returns the union data inside the AuthConnection as a AuthConnectionOptionsGoogleApps
func (t AuthConnection) AsAuthConnectionOptionsGoogleApps() (AuthConnectionOptionsGoogleApps, error) {
	var body AuthConnectionOptionsGoogleApps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsGoogleApps overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsGoogleApps
func (t *AuthConnection) FromAuthConnectionOptionsGoogleApps(v AuthConnectionOptionsGoogleApps) error {
	t.Type = "google_apps"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsGoogleApps performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsGoogleApps
func (t *AuthConnection) MergeAuthConnectionOptionsGoogleApps(v AuthConnectionOptionsGoogleApps) error {
	t.Type = "google_apps"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsOidc returns the union data inside the AuthConnection as a AuthConnectionOptionsOidc
func (t AuthConnection) AsAuthConnectionOptionsOidc() (AuthConnectionOptionsOidc, error) {
	var body AuthConnectionOptionsOidc
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsOidc overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsOidc
func (t *AuthConnection) FromAuthConnectionOptionsOidc(v AuthConnectionOptionsOidc) error {
	t.Type = "oidc"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsOidc performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsOidc
func (t *AuthConnection) MergeAuthConnectionOptionsOidc(v AuthConnectionOptionsOidc) error {
	t.Type = "oidc"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsOkta returns the union data inside the AuthConnection as a AuthConnectionOptionsOkta
func (t AuthConnection) AsAuthConnectionOptionsOkta() (AuthConnectionOptionsOkta, error) {
	var body AuthConnectionOptionsOkta
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsOkta overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsOkta
func (t *AuthConnection) FromAuthConnectionOptionsOkta(v AuthConnectionOptionsOkta) error {
	t.Type = "okta"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsOkta performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsOkta
func (t *AuthConnection) MergeAuthConnectionOptionsOkta(v AuthConnectionOptionsOkta) error {
	t.Type = "okta"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsSaml returns the union data inside the AuthConnection as a AuthConnectionOptionsSaml
func (t AuthConnection) AsAuthConnectionOptionsSaml() (AuthConnectionOptionsSaml, error) {
	var body AuthConnectionOptionsSaml
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsSaml overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsSaml
func (t *AuthConnection) FromAuthConnectionOptionsSaml(v AuthConnectionOptionsSaml) error {
	t.Type = "samlp"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsSaml performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsSaml
func (t *AuthConnection) MergeAuthConnectionOptionsSaml(v AuthConnectionOptionsSaml) error {
	t.Type = "samlp"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthConnectionOptionsSocial returns the union data inside the AuthConnection as a AuthConnectionOptionsSocial
func (t AuthConnection) AsAuthConnectionOptionsSocial() (AuthConnectionOptionsSocial, error) {
	var body AuthConnectionOptionsSocial
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthConnectionOptionsSocial overwrites any union data inside the AuthConnection as the provided AuthConnectionOptionsSocial
func (t *AuthConnection) FromAuthConnectionOptionsSocial(v AuthConnectionOptionsSocial) error {
	t.Type = "social"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthConnectionOptionsSocial performs a merge with any union data inside the AuthConnection, using the provided AuthConnectionOptionsSocial
func (t *AuthConnection) MergeAuthConnectionOptionsSocial(v AuthConnectionOptionsSocial) error {
	t.Type = "social"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AuthConnection) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AuthConnection) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "google_apps":
		return t.AsAuthConnectionOptionsGoogleApps()
	case "oidc":
		return t.AsAuthConnectionOptionsOidc()
	case "okta":
		return t.AsAuthConnectionOptionsOkta()
	case "samlp":
		return t.AsAuthConnectionOptionsSaml()
	case "social":
		return t.AsAuthConnectionOptionsSocial()
	case "waad":
		return t.AsAuthConnectionOptionsAzureAd()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AuthConnection) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["display_name"], err = json.Marshal(t.DisplayName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'display_name': %w", err)
	}

	object["enabled"], err = json.Marshal(t.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AuthConnection) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["display_name"]; found {
		err = json.Unmarshal(raw, &t.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display_name': %w", err)
		}
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &t.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsBooleanExpressionAndExpression returns the union data inside the BooleanExpression as a BooleanExpressionAndExpression
func (t BooleanExpression) AsBooleanExpressionAndExpression() (BooleanExpressionAndExpression, error) {
	var body BooleanExpressionAndExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanExpressionAndExpression overwrites any union data inside the BooleanExpression as the provided BooleanExpressionAndExpression
func (t *BooleanExpression) FromBooleanExpressionAndExpression(v BooleanExpressionAndExpression) error {
	t.Type = "and"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanExpressionAndExpression performs a merge with any union data inside the BooleanExpression, using the provided BooleanExpressionAndExpression
func (t *BooleanExpression) MergeBooleanExpressionAndExpression(v BooleanExpressionAndExpression) error {
	t.Type = "and"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBooleanExpressionNotExpression returns the union data inside the BooleanExpression as a BooleanExpressionNotExpression
func (t BooleanExpression) AsBooleanExpressionNotExpression() (BooleanExpressionNotExpression, error) {
	var body BooleanExpressionNotExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanExpressionNotExpression overwrites any union data inside the BooleanExpression as the provided BooleanExpressionNotExpression
func (t *BooleanExpression) FromBooleanExpressionNotExpression(v BooleanExpressionNotExpression) error {
	t.Type = "not"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanExpressionNotExpression performs a merge with any union data inside the BooleanExpression, using the provided BooleanExpressionNotExpression
func (t *BooleanExpression) MergeBooleanExpressionNotExpression(v BooleanExpressionNotExpression) error {
	t.Type = "not"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBooleanExpressionOrExpression returns the union data inside the BooleanExpression as a BooleanExpressionOrExpression
func (t BooleanExpression) AsBooleanExpressionOrExpression() (BooleanExpressionOrExpression, error) {
	var body BooleanExpressionOrExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanExpressionOrExpression overwrites any union data inside the BooleanExpression as the provided BooleanExpressionOrExpression
func (t *BooleanExpression) FromBooleanExpressionOrExpression(v BooleanExpressionOrExpression) error {
	t.Type = "or"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanExpressionOrExpression performs a merge with any union data inside the BooleanExpression, using the provided BooleanExpressionOrExpression
func (t *BooleanExpression) MergeBooleanExpressionOrExpression(v BooleanExpressionOrExpression) error {
	t.Type = "or"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBooleanExpressionPrimitiveExpression returns the union data inside the BooleanExpression as a BooleanExpressionPrimitiveExpression
func (t BooleanExpression) AsBooleanExpressionPrimitiveExpression() (BooleanExpressionPrimitiveExpression, error) {
	var body BooleanExpressionPrimitiveExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanExpressionPrimitiveExpression overwrites any union data inside the BooleanExpression as the provided BooleanExpressionPrimitiveExpression
func (t *BooleanExpression) FromBooleanExpressionPrimitiveExpression(v BooleanExpressionPrimitiveExpression) error {
	t.Type = "primitive"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanExpressionPrimitiveExpression performs a merge with any union data inside the BooleanExpression, using the provided BooleanExpressionPrimitiveExpression
func (t *BooleanExpression) MergeBooleanExpressionPrimitiveExpression(v BooleanExpressionPrimitiveExpression) error {
	t.Type = "primitive"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BooleanExpression) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BooleanExpression) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "and":
		return t.AsBooleanExpressionAndExpression()
	case "not":
		return t.AsBooleanExpressionNotExpression()
	case "or":
		return t.AsBooleanExpressionOrExpression()
	case "primitive":
		return t.AsBooleanExpressionPrimitiveExpression()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BooleanExpression) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *BooleanExpression) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDm returns the union data inside the Chat as a Dm
func (t Chat) AsDm() (Dm, error) {
	var body Dm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDm overwrites any union data inside the Chat as the provided Dm
func (t *Chat) FromDm(v Dm) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDm performs a merge with any union data inside the Chat, using the provided Dm
func (t *Chat) MergeDm(v Dm) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Chat) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Chat) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dm":
		return t.AsDm()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Chat) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Chat) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsChatsCreateRequestDm returns the union data inside the ChatsCreateRequest as a ChatsCreateRequestDm
func (t ChatsCreateRequest) AsChatsCreateRequestDm() (ChatsCreateRequestDm, error) {
	var body ChatsCreateRequestDm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatsCreateRequestDm overwrites any union data inside the ChatsCreateRequest as the provided ChatsCreateRequestDm
func (t *ChatsCreateRequest) FromChatsCreateRequestDm(v ChatsCreateRequestDm) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatsCreateRequestDm performs a merge with any union data inside the ChatsCreateRequest, using the provided ChatsCreateRequestDm
func (t *ChatsCreateRequest) MergeChatsCreateRequestDm(v ChatsCreateRequestDm) error {
	t.Type = "dm"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatsCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ChatsCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dm":
		return t.AsChatsCreateRequestDm()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ChatsCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.CustomFields != nil {
		object["custom_fields"], err = json.Marshal(t.CustomFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_fields': %w", err)
		}
	}

	if t.CustomSchemaSpec != nil {
		object["custom_schema_spec"], err = json.Marshal(t.CustomSchemaSpec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_spec': %w", err)
		}
	}

	if t.GetIfConflict != nil {
		object["get_if_conflict"], err = json.Marshal(t.GetIfConflict)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'get_if_conflict': %w", err)
		}
	}

	if t.Title != nil {
		object["title"], err = json.Marshal(t.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ChatsCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["custom_fields"]; found {
		err = json.Unmarshal(raw, &t.CustomFields)
		if err != nil {
			return fmt.Errorf("error reading 'custom_fields': %w", err)
		}
	}

	if raw, found := object["custom_schema_spec"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaSpec)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_spec': %w", err)
		}
	}

	if raw, found := object["get_if_conflict"]; found {
		err = json.Unmarshal(raw, &t.GetIfConflict)
		if err != nil {
			return fmt.Errorf("error reading 'get_if_conflict': %w", err)
		}
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &t.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsChatsGetRequestDm returns the union data inside the ChatsGetRequest as a ChatsGetRequestDm
func (t ChatsGetRequest) AsChatsGetRequestDm() (ChatsGetRequestDm, error) {
	var body ChatsGetRequestDm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatsGetRequestDm overwrites any union data inside the ChatsGetRequest as the provided ChatsGetRequestDm
func (t *ChatsGetRequest) FromChatsGetRequestDm(v ChatsGetRequestDm) error {
	t.Type = func() *ChatType { v := ChatType("dm"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatsGetRequestDm performs a merge with any union data inside the ChatsGetRequest, using the provided ChatsGetRequestDm
func (t *ChatsGetRequest) MergeChatsGetRequestDm(v ChatsGetRequestDm) error {
	t.Type = func() *ChatType { v := ChatType("dm"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmpty returns the union data inside the ChatsGetRequest as a Empty
func (t ChatsGetRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the ChatsGetRequest as the provided Empty
func (t *ChatsGetRequest) FromEmpty(v Empty) error {
	t.Type = func() *ChatType { v := ChatType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the ChatsGetRequest, using the provided Empty
func (t *ChatsGetRequest) MergeEmpty(v Empty) error {
	t.Type = func() *ChatType { v := ChatType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatsGetRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ChatsGetRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dm":
		return t.AsChatsGetRequestDm()
	case "none":
		return t.AsEmpty()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ChatsGetRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *ChatsGetRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsChatsUpdateRequestDm returns the union data inside the ChatsUpdateRequest as a ChatsUpdateRequestDm
func (t ChatsUpdateRequest) AsChatsUpdateRequestDm() (ChatsUpdateRequestDm, error) {
	var body ChatsUpdateRequestDm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatsUpdateRequestDm overwrites any union data inside the ChatsUpdateRequest as the provided ChatsUpdateRequestDm
func (t *ChatsUpdateRequest) FromChatsUpdateRequestDm(v ChatsUpdateRequestDm) error {
	t.Type = func() *ChatType { v := ChatType("dm"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatsUpdateRequestDm performs a merge with any union data inside the ChatsUpdateRequest, using the provided ChatsUpdateRequestDm
func (t *ChatsUpdateRequest) MergeChatsUpdateRequestDm(v ChatsUpdateRequestDm) error {
	t.Type = func() *ChatType { v := ChatType("dm"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmpty returns the union data inside the ChatsUpdateRequest as a Empty
func (t ChatsUpdateRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the ChatsUpdateRequest as the provided Empty
func (t *ChatsUpdateRequest) FromEmpty(v Empty) error {
	t.Type = func() *ChatType { v := ChatType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the ChatsUpdateRequest, using the provided Empty
func (t *ChatsUpdateRequest) MergeEmpty(v Empty) error {
	t.Type = func() *ChatType { v := ChatType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatsUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ChatsUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dm":
		return t.AsChatsUpdateRequestDm()
	case "none":
		return t.AsEmpty()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ChatsUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.CustomFields != nil {
		object["custom_fields"], err = json.Marshal(t.CustomFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_fields': %w", err)
		}
	}

	if t.CustomSchemaSpec != nil {
		object["custom_schema_spec"], err = json.Marshal(t.CustomSchemaSpec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_spec': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Title != nil {
		object["title"], err = json.Marshal(t.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *ChatsUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["custom_fields"]; found {
		err = json.Unmarshal(raw, &t.CustomFields)
		if err != nil {
			return fmt.Errorf("error reading 'custom_fields': %w", err)
		}
	}

	if raw, found := object["custom_schema_spec"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaSpec)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_spec': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &t.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsContentTemplateCreateRequestNotificationContentTemplate returns the union data inside the ContentTemplateCreateRequest as a ContentTemplateCreateRequestNotificationContentTemplate
func (t ContentTemplateCreateRequest) AsContentTemplateCreateRequestNotificationContentTemplate() (ContentTemplateCreateRequestNotificationContentTemplate, error) {
	var body ContentTemplateCreateRequestNotificationContentTemplate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContentTemplateCreateRequestNotificationContentTemplate overwrites any union data inside the ContentTemplateCreateRequest as the provided ContentTemplateCreateRequestNotificationContentTemplate
func (t *ContentTemplateCreateRequest) FromContentTemplateCreateRequestNotificationContentTemplate(v ContentTemplateCreateRequestNotificationContentTemplate) error {
	t.Type = "notification_content_template"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContentTemplateCreateRequestNotificationContentTemplate performs a merge with any union data inside the ContentTemplateCreateRequest, using the provided ContentTemplateCreateRequestNotificationContentTemplate
func (t *ContentTemplateCreateRequest) MergeContentTemplateCreateRequestNotificationContentTemplate(v ContentTemplateCreateRequestNotificationContentTemplate) error {
	t.Type = "notification_content_template"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContentTemplateCreateRequestNotificationContentTemplateTranslation returns the union data inside the ContentTemplateCreateRequest as a ContentTemplateCreateRequestNotificationContentTemplateTranslation
func (t ContentTemplateCreateRequest) AsContentTemplateCreateRequestNotificationContentTemplateTranslation() (ContentTemplateCreateRequestNotificationContentTemplateTranslation, error) {
	var body ContentTemplateCreateRequestNotificationContentTemplateTranslation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContentTemplateCreateRequestNotificationContentTemplateTranslation overwrites any union data inside the ContentTemplateCreateRequest as the provided ContentTemplateCreateRequestNotificationContentTemplateTranslation
func (t *ContentTemplateCreateRequest) FromContentTemplateCreateRequestNotificationContentTemplateTranslation(v ContentTemplateCreateRequestNotificationContentTemplateTranslation) error {
	t.Type = "notification_content_template_translation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContentTemplateCreateRequestNotificationContentTemplateTranslation performs a merge with any union data inside the ContentTemplateCreateRequest, using the provided ContentTemplateCreateRequestNotificationContentTemplateTranslation
func (t *ContentTemplateCreateRequest) MergeContentTemplateCreateRequestNotificationContentTemplateTranslation(v ContentTemplateCreateRequestNotificationContentTemplateTranslation) error {
	t.Type = "notification_content_template_translation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentTemplateCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ContentTemplateCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "notification_content_template":
		return t.AsContentTemplateCreateRequestNotificationContentTemplate()
	case "notification_content_template_translation":
		return t.AsContentTemplateCreateRequestNotificationContentTemplateTranslation()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ContentTemplateCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.InputFieldsSchema != nil {
		object["input_fields_schema"], err = json.Marshal(t.InputFieldsSchema)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'input_fields_schema': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ContentTemplateCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["input_fields_schema"]; found {
		err = json.Unmarshal(raw, &t.InputFieldsSchema)
		if err != nil {
			return fmt.Errorf("error reading 'input_fields_schema': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAppFragment returns the union data inside the CustomSchemaFragment as a AppFragment
func (t CustomSchemaFragment) AsAppFragment() (AppFragment, error) {
	var body AppFragment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppFragment overwrites any union data inside the CustomSchemaFragment as the provided AppFragment
func (t *CustomSchemaFragment) FromAppFragment(v AppFragment) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppFragment performs a merge with any union data inside the CustomSchemaFragment, using the provided AppFragment
func (t *CustomSchemaFragment) MergeAppFragment(v AppFragment) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomTypeFragment returns the union data inside the CustomSchemaFragment as a CustomTypeFragment
func (t CustomSchemaFragment) AsCustomTypeFragment() (CustomTypeFragment, error) {
	var body CustomTypeFragment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomTypeFragment overwrites any union data inside the CustomSchemaFragment as the provided CustomTypeFragment
func (t *CustomSchemaFragment) FromCustomTypeFragment(v CustomTypeFragment) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomTypeFragment performs a merge with any union data inside the CustomSchemaFragment, using the provided CustomTypeFragment
func (t *CustomSchemaFragment) MergeCustomTypeFragment(v CustomTypeFragment) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTenantFragment returns the union data inside the CustomSchemaFragment as a TenantFragment
func (t CustomSchemaFragment) AsTenantFragment() (TenantFragment, error) {
	var body TenantFragment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTenantFragment overwrites any union data inside the CustomSchemaFragment as the provided TenantFragment
func (t *CustomSchemaFragment) FromTenantFragment(v TenantFragment) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTenantFragment performs a merge with any union data inside the CustomSchemaFragment, using the provided TenantFragment
func (t *CustomSchemaFragment) MergeTenantFragment(v TenantFragment) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomSchemaFragment) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CustomSchemaFragment) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "app_fragment":
		return t.AsAppFragment()
	case "custom_type_fragment":
		return t.AsCustomTypeFragment()
	case "tenant_fragment":
		return t.AsTenantFragment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CustomSchemaFragment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *CustomSchemaFragment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAppFragmentSummary returns the union data inside the CustomSchemaFragmentSummary as a AppFragmentSummary
func (t CustomSchemaFragmentSummary) AsAppFragmentSummary() (AppFragmentSummary, error) {
	var body AppFragmentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppFragmentSummary overwrites any union data inside the CustomSchemaFragmentSummary as the provided AppFragmentSummary
func (t *CustomSchemaFragmentSummary) FromAppFragmentSummary(v AppFragmentSummary) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppFragmentSummary performs a merge with any union data inside the CustomSchemaFragmentSummary, using the provided AppFragmentSummary
func (t *CustomSchemaFragmentSummary) MergeAppFragmentSummary(v AppFragmentSummary) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomTypeFragmentSummary returns the union data inside the CustomSchemaFragmentSummary as a CustomTypeFragmentSummary
func (t CustomSchemaFragmentSummary) AsCustomTypeFragmentSummary() (CustomTypeFragmentSummary, error) {
	var body CustomTypeFragmentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomTypeFragmentSummary overwrites any union data inside the CustomSchemaFragmentSummary as the provided CustomTypeFragmentSummary
func (t *CustomSchemaFragmentSummary) FromCustomTypeFragmentSummary(v CustomTypeFragmentSummary) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomTypeFragmentSummary performs a merge with any union data inside the CustomSchemaFragmentSummary, using the provided CustomTypeFragmentSummary
func (t *CustomSchemaFragmentSummary) MergeCustomTypeFragmentSummary(v CustomTypeFragmentSummary) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTenantFragmentSummary returns the union data inside the CustomSchemaFragmentSummary as a TenantFragmentSummary
func (t CustomSchemaFragmentSummary) AsTenantFragmentSummary() (TenantFragmentSummary, error) {
	var body TenantFragmentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTenantFragmentSummary overwrites any union data inside the CustomSchemaFragmentSummary as the provided TenantFragmentSummary
func (t *CustomSchemaFragmentSummary) FromTenantFragmentSummary(v TenantFragmentSummary) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTenantFragmentSummary performs a merge with any union data inside the CustomSchemaFragmentSummary, using the provided TenantFragmentSummary
func (t *CustomSchemaFragmentSummary) MergeTenantFragmentSummary(v TenantFragmentSummary) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomSchemaFragmentSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CustomSchemaFragmentSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "app_fragment":
		return t.AsAppFragmentSummary()
	case "custom_type_fragment":
		return t.AsCustomTypeFragmentSummary()
	case "tenant_fragment":
		return t.AsTenantFragmentSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CustomSchemaFragmentSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *CustomSchemaFragmentSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsCustomSchemaFragmentsSetRequestAppFragment returns the union data inside the CustomSchemaFragmentsSetRequest as a CustomSchemaFragmentsSetRequestAppFragment
func (t CustomSchemaFragmentsSetRequest) AsCustomSchemaFragmentsSetRequestAppFragment() (CustomSchemaFragmentsSetRequestAppFragment, error) {
	var body CustomSchemaFragmentsSetRequestAppFragment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomSchemaFragmentsSetRequestAppFragment overwrites any union data inside the CustomSchemaFragmentsSetRequest as the provided CustomSchemaFragmentsSetRequestAppFragment
func (t *CustomSchemaFragmentsSetRequest) FromCustomSchemaFragmentsSetRequestAppFragment(v CustomSchemaFragmentsSetRequestAppFragment) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomSchemaFragmentsSetRequestAppFragment performs a merge with any union data inside the CustomSchemaFragmentsSetRequest, using the provided CustomSchemaFragmentsSetRequestAppFragment
func (t *CustomSchemaFragmentsSetRequest) MergeCustomSchemaFragmentsSetRequestAppFragment(v CustomSchemaFragmentsSetRequestAppFragment) error {
	t.Type = "app_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomSchemaFragmentsSetRequestCustomTypeFragment returns the union data inside the CustomSchemaFragmentsSetRequest as a CustomSchemaFragmentsSetRequestCustomTypeFragment
func (t CustomSchemaFragmentsSetRequest) AsCustomSchemaFragmentsSetRequestCustomTypeFragment() (CustomSchemaFragmentsSetRequestCustomTypeFragment, error) {
	var body CustomSchemaFragmentsSetRequestCustomTypeFragment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomSchemaFragmentsSetRequestCustomTypeFragment overwrites any union data inside the CustomSchemaFragmentsSetRequest as the provided CustomSchemaFragmentsSetRequestCustomTypeFragment
func (t *CustomSchemaFragmentsSetRequest) FromCustomSchemaFragmentsSetRequestCustomTypeFragment(v CustomSchemaFragmentsSetRequestCustomTypeFragment) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomSchemaFragmentsSetRequestCustomTypeFragment performs a merge with any union data inside the CustomSchemaFragmentsSetRequest, using the provided CustomSchemaFragmentsSetRequestCustomTypeFragment
func (t *CustomSchemaFragmentsSetRequest) MergeCustomSchemaFragmentsSetRequestCustomTypeFragment(v CustomSchemaFragmentsSetRequestCustomTypeFragment) error {
	t.Type = "custom_type_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomSchemaFragmentsSetRequestTenantFragment returns the union data inside the CustomSchemaFragmentsSetRequest as a CustomSchemaFragmentsSetRequestTenantFragment
func (t CustomSchemaFragmentsSetRequest) AsCustomSchemaFragmentsSetRequestTenantFragment() (CustomSchemaFragmentsSetRequestTenantFragment, error) {
	var body CustomSchemaFragmentsSetRequestTenantFragment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomSchemaFragmentsSetRequestTenantFragment overwrites any union data inside the CustomSchemaFragmentsSetRequest as the provided CustomSchemaFragmentsSetRequestTenantFragment
func (t *CustomSchemaFragmentsSetRequest) FromCustomSchemaFragmentsSetRequestTenantFragment(v CustomSchemaFragmentsSetRequestTenantFragment) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomSchemaFragmentsSetRequestTenantFragment performs a merge with any union data inside the CustomSchemaFragmentsSetRequest, using the provided CustomSchemaFragmentsSetRequestTenantFragment
func (t *CustomSchemaFragmentsSetRequest) MergeCustomSchemaFragmentsSetRequestTenantFragment(v CustomSchemaFragmentsSetRequestTenantFragment) error {
	t.Type = "tenant_fragment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomSchemaFragmentsSetRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CustomSchemaFragmentsSetRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "app_fragment":
		return t.AsCustomSchemaFragmentsSetRequestAppFragment()
	case "custom_type_fragment":
		return t.AsCustomSchemaFragmentsSetRequestCustomTypeFragment()
	case "tenant_fragment":
		return t.AsCustomSchemaFragmentsSetRequestTenantFragment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CustomSchemaFragmentsSetRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.CompositeSchemas != nil {
		object["composite_schemas"], err = json.Marshal(t.CompositeSchemas)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'composite_schemas': %w", err)
		}
	}

	if t.Conditions != nil {
		object["conditions"], err = json.Marshal(t.Conditions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'conditions': %w", err)
		}
	}

	if t.DeletedFields != nil {
		object["deleted_fields"], err = json.Marshal(t.DeletedFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deleted_fields': %w", err)
		}
	}

	if t.Deprecated != nil {
		object["deprecated"], err = json.Marshal(t.Deprecated)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deprecated': %w", err)
		}
	}

	object["description"], err = json.Marshal(t.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	if t.Fields != nil {
		object["fields"], err = json.Marshal(t.Fields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fields': %w", err)
		}
	}

	if t.IsCustomLeafType != nil {
		object["is_custom_leaf_type"], err = json.Marshal(t.IsCustomLeafType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_custom_leaf_type': %w", err)
		}
	}

	if t.IsDeprecated != nil {
		object["is_deprecated"], err = json.Marshal(t.IsDeprecated)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_deprecated': %w", err)
		}
	}

	object["leaf_type"], err = json.Marshal(t.LeafType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'leaf_type': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *CustomSchemaFragmentsSetRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["composite_schemas"]; found {
		err = json.Unmarshal(raw, &t.CompositeSchemas)
		if err != nil {
			return fmt.Errorf("error reading 'composite_schemas': %w", err)
		}
	}

	if raw, found := object["conditions"]; found {
		err = json.Unmarshal(raw, &t.Conditions)
		if err != nil {
			return fmt.Errorf("error reading 'conditions': %w", err)
		}
	}

	if raw, found := object["deleted_fields"]; found {
		err = json.Unmarshal(raw, &t.DeletedFields)
		if err != nil {
			return fmt.Errorf("error reading 'deleted_fields': %w", err)
		}
	}

	if raw, found := object["deprecated"]; found {
		err = json.Unmarshal(raw, &t.Deprecated)
		if err != nil {
			return fmt.Errorf("error reading 'deprecated': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["fields"]; found {
		err = json.Unmarshal(raw, &t.Fields)
		if err != nil {
			return fmt.Errorf("error reading 'fields': %w", err)
		}
	}

	if raw, found := object["is_custom_leaf_type"]; found {
		err = json.Unmarshal(raw, &t.IsCustomLeafType)
		if err != nil {
			return fmt.Errorf("error reading 'is_custom_leaf_type': %w", err)
		}
	}

	if raw, found := object["is_deprecated"]; found {
		err = json.Unmarshal(raw, &t.IsDeprecated)
		if err != nil {
			return fmt.Errorf("error reading 'is_deprecated': %w", err)
		}
	}

	if raw, found := object["leaf_type"]; found {
		err = json.Unmarshal(raw, &t.LeafType)
		if err != nil {
			return fmt.Errorf("error reading 'leaf_type': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDateTimeFilter returns the union data inside the DateFilter as a DateTimeFilter
func (t DateFilter) AsDateTimeFilter() (DateTimeFilter, error) {
	var body DateTimeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFilter overwrites any union data inside the DateFilter as the provided DateTimeFilter
func (t *DateFilter) FromDateTimeFilter(v DateTimeFilter) error {
	t.Type = "range"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFilter performs a merge with any union data inside the DateFilter, using the provided DateTimeFilter
func (t *DateFilter) MergeDateTimeFilter(v DateTimeFilter) error {
	t.Type = "range"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTimePreset returns the union data inside the DateFilter as a DateTimePreset
func (t DateFilter) AsDateTimePreset() (DateTimePreset, error) {
	var body DateTimePreset
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimePreset overwrites any union data inside the DateFilter as the provided DateTimePreset
func (t *DateFilter) FromDateTimePreset(v DateTimePreset) error {
	t.Type = "preset"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimePreset performs a merge with any union data inside the DateFilter, using the provided DateTimePreset
func (t *DateFilter) MergeDateTimePreset(v DateTimePreset) error {
	t.Type = "preset"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DateFilter) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DateFilter) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "preset":
		return t.AsDateTimePreset()
	case "range":
		return t.AsDateTimeFilter()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DateFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *DateFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDateTimePresetLastNDays returns the union data inside the DateTimePreset as a DateTimePresetLastNDays
func (t DateTimePreset) AsDateTimePresetLastNDays() (DateTimePresetLastNDays, error) {
	var body DateTimePresetLastNDays
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimePresetLastNDays overwrites any union data inside the DateTimePreset as the provided DateTimePresetLastNDays
func (t *DateTimePreset) FromDateTimePresetLastNDays(v DateTimePresetLastNDays) error {
	t.PresetType = "last_n_days"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimePresetLastNDays performs a merge with any union data inside the DateTimePreset, using the provided DateTimePresetLastNDays
func (t *DateTimePreset) MergeDateTimePresetLastNDays(v DateTimePresetLastNDays) error {
	t.PresetType = "last_n_days"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTimePresetNextNDays returns the union data inside the DateTimePreset as a DateTimePresetNextNDays
func (t DateTimePreset) AsDateTimePresetNextNDays() (DateTimePresetNextNDays, error) {
	var body DateTimePresetNextNDays
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimePresetNextNDays overwrites any union data inside the DateTimePreset as the provided DateTimePresetNextNDays
func (t *DateTimePreset) FromDateTimePresetNextNDays(v DateTimePresetNextNDays) error {
	t.PresetType = "next_n_days"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimePresetNextNDays performs a merge with any union data inside the DateTimePreset, using the provided DateTimePresetNextNDays
func (t *DateTimePreset) MergeDateTimePresetNextNDays(v DateTimePresetNextNDays) error {
	t.PresetType = "next_n_days"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DateTimePreset) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"preset_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DateTimePreset) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "last_n_days":
		return t.AsDateTimePresetLastNDays()
	case "next_n_days":
		return t.AsDateTimePresetNextNDays()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DateTimePreset) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["preset_type"], err = json.Marshal(t.PresetType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'preset_type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *DateTimePreset) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["preset_type"]; found {
		err = json.Unmarshal(raw, &t.PresetType)
		if err != nil {
			return fmt.Errorf("error reading 'preset_type': %w", err)
		}
	}

	return err
}

// AsDevOrgAuthConnectionsCreateRequestAzureAdOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestAzureAdOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestAzureAdOptions() (DevOrgAuthConnectionsCreateRequestAzureAdOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestAzureAdOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestAzureAdOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestAzureAdOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestAzureAdOptions(v DevOrgAuthConnectionsCreateRequestAzureAdOptions) error {
	t.Type = "waad"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestAzureAdOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestAzureAdOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestAzureAdOptions(v DevOrgAuthConnectionsCreateRequestAzureAdOptions) error {
	t.Type = "waad"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsCreateRequestGoogleAppsOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestGoogleAppsOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestGoogleAppsOptions() (DevOrgAuthConnectionsCreateRequestGoogleAppsOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestGoogleAppsOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestGoogleAppsOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestGoogleAppsOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestGoogleAppsOptions(v DevOrgAuthConnectionsCreateRequestGoogleAppsOptions) error {
	t.Type = "google_apps"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestGoogleAppsOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestGoogleAppsOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestGoogleAppsOptions(v DevOrgAuthConnectionsCreateRequestGoogleAppsOptions) error {
	t.Type = "google_apps"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsCreateRequestOidcOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestOidcOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestOidcOptions() (DevOrgAuthConnectionsCreateRequestOidcOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestOidcOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestOidcOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestOidcOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestOidcOptions(v DevOrgAuthConnectionsCreateRequestOidcOptions) error {
	t.Type = "oidc"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestOidcOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestOidcOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestOidcOptions(v DevOrgAuthConnectionsCreateRequestOidcOptions) error {
	t.Type = "oidc"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsCreateRequestOktaOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestOktaOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestOktaOptions() (DevOrgAuthConnectionsCreateRequestOktaOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestOktaOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestOktaOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestOktaOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestOktaOptions(v DevOrgAuthConnectionsCreateRequestOktaOptions) error {
	t.Type = "okta"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestOktaOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestOktaOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestOktaOptions(v DevOrgAuthConnectionsCreateRequestOktaOptions) error {
	t.Type = "okta"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsCreateRequestSamlOptions returns the union data inside the DevOrgAuthConnectionsCreateRequest as a DevOrgAuthConnectionsCreateRequestSamlOptions
func (t DevOrgAuthConnectionsCreateRequest) AsDevOrgAuthConnectionsCreateRequestSamlOptions() (DevOrgAuthConnectionsCreateRequestSamlOptions, error) {
	var body DevOrgAuthConnectionsCreateRequestSamlOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsCreateRequestSamlOptions overwrites any union data inside the DevOrgAuthConnectionsCreateRequest as the provided DevOrgAuthConnectionsCreateRequestSamlOptions
func (t *DevOrgAuthConnectionsCreateRequest) FromDevOrgAuthConnectionsCreateRequestSamlOptions(v DevOrgAuthConnectionsCreateRequestSamlOptions) error {
	t.Type = "samlp"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsCreateRequestSamlOptions performs a merge with any union data inside the DevOrgAuthConnectionsCreateRequest, using the provided DevOrgAuthConnectionsCreateRequestSamlOptions
func (t *DevOrgAuthConnectionsCreateRequest) MergeDevOrgAuthConnectionsCreateRequestSamlOptions(v DevOrgAuthConnectionsCreateRequestSamlOptions) error {
	t.Type = "samlp"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevOrgAuthConnectionsCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DevOrgAuthConnectionsCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "google_apps":
		return t.AsDevOrgAuthConnectionsCreateRequestGoogleAppsOptions()
	case "oidc":
		return t.AsDevOrgAuthConnectionsCreateRequestOidcOptions()
	case "okta":
		return t.AsDevOrgAuthConnectionsCreateRequestOktaOptions()
	case "samlp":
		return t.AsDevOrgAuthConnectionsCreateRequestSamlOptions()
	case "waad":
		return t.AsDevOrgAuthConnectionsCreateRequestAzureAdOptions()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DevOrgAuthConnectionsCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.DisplayName != nil {
		object["display_name"], err = json.Marshal(t.DisplayName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'display_name': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *DevOrgAuthConnectionsCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["display_name"]; found {
		err = json.Unmarshal(raw, &t.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display_name': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDevOrgAuthConnectionsUpdateRequestAzureAdOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestAzureAdOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestAzureAdOptions() (DevOrgAuthConnectionsUpdateRequestAzureAdOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestAzureAdOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestAzureAdOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestAzureAdOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestAzureAdOptions(v DevOrgAuthConnectionsUpdateRequestAzureAdOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("waad"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestAzureAdOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestAzureAdOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestAzureAdOptions(v DevOrgAuthConnectionsUpdateRequestAzureAdOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("waad"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions() (DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions(v DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("google_apps"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions(v DevOrgAuthConnectionsUpdateRequestGoogleAppsOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("google_apps"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsUpdateRequestOidcOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestOidcOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestOidcOptions() (DevOrgAuthConnectionsUpdateRequestOidcOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestOidcOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestOidcOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestOidcOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestOidcOptions(v DevOrgAuthConnectionsUpdateRequestOidcOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("oidc"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestOidcOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestOidcOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestOidcOptions(v DevOrgAuthConnectionsUpdateRequestOidcOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("oidc"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsUpdateRequestOktaOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestOktaOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestOktaOptions() (DevOrgAuthConnectionsUpdateRequestOktaOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestOktaOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestOktaOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestOktaOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestOktaOptions(v DevOrgAuthConnectionsUpdateRequestOktaOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("okta"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestOktaOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestOktaOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestOktaOptions(v DevOrgAuthConnectionsUpdateRequestOktaOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("okta"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgAuthConnectionsUpdateRequestSamlOptions returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a DevOrgAuthConnectionsUpdateRequestSamlOptions
func (t DevOrgAuthConnectionsUpdateRequest) AsDevOrgAuthConnectionsUpdateRequestSamlOptions() (DevOrgAuthConnectionsUpdateRequestSamlOptions, error) {
	var body DevOrgAuthConnectionsUpdateRequestSamlOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgAuthConnectionsUpdateRequestSamlOptions overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided DevOrgAuthConnectionsUpdateRequestSamlOptions
func (t *DevOrgAuthConnectionsUpdateRequest) FromDevOrgAuthConnectionsUpdateRequestSamlOptions(v DevOrgAuthConnectionsUpdateRequestSamlOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("samlp"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgAuthConnectionsUpdateRequestSamlOptions performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided DevOrgAuthConnectionsUpdateRequestSamlOptions
func (t *DevOrgAuthConnectionsUpdateRequest) MergeDevOrgAuthConnectionsUpdateRequestSamlOptions(v DevOrgAuthConnectionsUpdateRequestSamlOptions) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("samlp"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmpty returns the union data inside the DevOrgAuthConnectionsUpdateRequest as a Empty
func (t DevOrgAuthConnectionsUpdateRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the DevOrgAuthConnectionsUpdateRequest as the provided Empty
func (t *DevOrgAuthConnectionsUpdateRequest) FromEmpty(v Empty) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the DevOrgAuthConnectionsUpdateRequest, using the provided Empty
func (t *DevOrgAuthConnectionsUpdateRequest) MergeEmpty(v Empty) error {
	t.Type = func() *DevOrgAuthConnectionsUpdateRequestType { v := DevOrgAuthConnectionsUpdateRequestType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevOrgAuthConnectionsUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DevOrgAuthConnectionsUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "google_apps":
		return t.AsDevOrgAuthConnectionsUpdateRequestGoogleAppsOptions()
	case "none":
		return t.AsEmpty()
	case "oidc":
		return t.AsDevOrgAuthConnectionsUpdateRequestOidcOptions()
	case "okta":
		return t.AsDevOrgAuthConnectionsUpdateRequestOktaOptions()
	case "samlp":
		return t.AsDevOrgAuthConnectionsUpdateRequestSamlOptions()
	case "waad":
		return t.AsDevOrgAuthConnectionsUpdateRequestAzureAdOptions()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DevOrgAuthConnectionsUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.DisplayName != nil {
		object["display_name"], err = json.Marshal(t.DisplayName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'display_name': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *DevOrgAuthConnectionsUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["display_name"]; found {
		err = json.Unmarshal(raw, &t.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display_name': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorBadRequestArtifactAlreadyAttachedToAParent returns the union data inside the ErrorBadRequest as a ErrorBadRequestArtifactAlreadyAttachedToAParent
func (t ErrorBadRequest) AsErrorBadRequestArtifactAlreadyAttachedToAParent() (ErrorBadRequestArtifactAlreadyAttachedToAParent, error) {
	var body ErrorBadRequestArtifactAlreadyAttachedToAParent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestArtifactAlreadyAttachedToAParent overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestArtifactAlreadyAttachedToAParent
func (t *ErrorBadRequest) FromErrorBadRequestArtifactAlreadyAttachedToAParent(v ErrorBadRequestArtifactAlreadyAttachedToAParent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestArtifactAlreadyAttachedToAParent performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestArtifactAlreadyAttachedToAParent
func (t *ErrorBadRequest) MergeErrorBadRequestArtifactAlreadyAttachedToAParent(v ErrorBadRequestArtifactAlreadyAttachedToAParent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestBadRequest returns the union data inside the ErrorBadRequest as a ErrorBadRequestBadRequest
func (t ErrorBadRequest) AsErrorBadRequestBadRequest() (ErrorBadRequestBadRequest, error) {
	var body ErrorBadRequestBadRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestBadRequest overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestBadRequest
func (t *ErrorBadRequest) FromErrorBadRequestBadRequest(v ErrorBadRequestBadRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestBadRequest performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestBadRequest
func (t *ErrorBadRequest) MergeErrorBadRequestBadRequest(v ErrorBadRequestBadRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationError returns the union data inside the ErrorBadRequest as a ErrorBadRequestCustomizationValidationError
func (t ErrorBadRequest) AsErrorBadRequestCustomizationValidationError() (ErrorBadRequestCustomizationValidationError, error) {
	var body ErrorBadRequestCustomizationValidationError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationError overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestCustomizationValidationError
func (t *ErrorBadRequest) FromErrorBadRequestCustomizationValidationError(v ErrorBadRequestCustomizationValidationError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationError performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestCustomizationValidationError
func (t *ErrorBadRequest) MergeErrorBadRequestCustomizationValidationError(v ErrorBadRequestCustomizationValidationError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestInvalidApiVersion returns the union data inside the ErrorBadRequest as a ErrorBadRequestInvalidApiVersion
func (t ErrorBadRequest) AsErrorBadRequestInvalidApiVersion() (ErrorBadRequestInvalidApiVersion, error) {
	var body ErrorBadRequestInvalidApiVersion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestInvalidApiVersion overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestInvalidApiVersion
func (t *ErrorBadRequest) FromErrorBadRequestInvalidApiVersion(v ErrorBadRequestInvalidApiVersion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestInvalidApiVersion performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestInvalidApiVersion
func (t *ErrorBadRequest) MergeErrorBadRequestInvalidApiVersion(v ErrorBadRequestInvalidApiVersion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestInvalidEnumValue returns the union data inside the ErrorBadRequest as a ErrorBadRequestInvalidEnumValue
func (t ErrorBadRequest) AsErrorBadRequestInvalidEnumValue() (ErrorBadRequestInvalidEnumValue, error) {
	var body ErrorBadRequestInvalidEnumValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestInvalidEnumValue overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestInvalidEnumValue
func (t *ErrorBadRequest) FromErrorBadRequestInvalidEnumValue(v ErrorBadRequestInvalidEnumValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestInvalidEnumValue performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestInvalidEnumValue
func (t *ErrorBadRequest) MergeErrorBadRequestInvalidEnumValue(v ErrorBadRequestInvalidEnumValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestInvalidField returns the union data inside the ErrorBadRequest as a ErrorBadRequestInvalidField
func (t ErrorBadRequest) AsErrorBadRequestInvalidField() (ErrorBadRequestInvalidField, error) {
	var body ErrorBadRequestInvalidField
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestInvalidField overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestInvalidField
func (t *ErrorBadRequest) FromErrorBadRequestInvalidField(v ErrorBadRequestInvalidField) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestInvalidField performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestInvalidField
func (t *ErrorBadRequest) MergeErrorBadRequestInvalidField(v ErrorBadRequestInvalidField) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestInvalidId returns the union data inside the ErrorBadRequest as a ErrorBadRequestInvalidId
func (t ErrorBadRequest) AsErrorBadRequestInvalidId() (ErrorBadRequestInvalidId, error) {
	var body ErrorBadRequestInvalidId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestInvalidId overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestInvalidId
func (t *ErrorBadRequest) FromErrorBadRequestInvalidId(v ErrorBadRequestInvalidId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestInvalidId performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestInvalidId
func (t *ErrorBadRequest) MergeErrorBadRequestInvalidId(v ErrorBadRequestInvalidId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestMergeWorksError returns the union data inside the ErrorBadRequest as a ErrorBadRequestMergeWorksError
func (t ErrorBadRequest) AsErrorBadRequestMergeWorksError() (ErrorBadRequestMergeWorksError, error) {
	var body ErrorBadRequestMergeWorksError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestMergeWorksError overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestMergeWorksError
func (t *ErrorBadRequest) FromErrorBadRequestMergeWorksError(v ErrorBadRequestMergeWorksError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestMergeWorksError performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestMergeWorksError
func (t *ErrorBadRequest) MergeErrorBadRequestMergeWorksError(v ErrorBadRequestMergeWorksError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestMissingDependency returns the union data inside the ErrorBadRequest as a ErrorBadRequestMissingDependency
func (t ErrorBadRequest) AsErrorBadRequestMissingDependency() (ErrorBadRequestMissingDependency, error) {
	var body ErrorBadRequestMissingDependency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestMissingDependency overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestMissingDependency
func (t *ErrorBadRequest) FromErrorBadRequestMissingDependency(v ErrorBadRequestMissingDependency) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestMissingDependency performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestMissingDependency
func (t *ErrorBadRequest) MergeErrorBadRequestMissingDependency(v ErrorBadRequestMissingDependency) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestMissingRequiredField returns the union data inside the ErrorBadRequest as a ErrorBadRequestMissingRequiredField
func (t ErrorBadRequest) AsErrorBadRequestMissingRequiredField() (ErrorBadRequestMissingRequiredField, error) {
	var body ErrorBadRequestMissingRequiredField
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestMissingRequiredField overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestMissingRequiredField
func (t *ErrorBadRequest) FromErrorBadRequestMissingRequiredField(v ErrorBadRequestMissingRequiredField) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestMissingRequiredField performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestMissingRequiredField
func (t *ErrorBadRequest) MergeErrorBadRequestMissingRequiredField(v ErrorBadRequestMissingRequiredField) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestParseError returns the union data inside the ErrorBadRequest as a ErrorBadRequestParseError
func (t ErrorBadRequest) AsErrorBadRequestParseError() (ErrorBadRequestParseError, error) {
	var body ErrorBadRequestParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestParseError overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestParseError
func (t *ErrorBadRequest) FromErrorBadRequestParseError(v ErrorBadRequestParseError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestParseError performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestParseError
func (t *ErrorBadRequest) MergeErrorBadRequestParseError(v ErrorBadRequestParseError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestStaleSchemaFragments returns the union data inside the ErrorBadRequest as a ErrorBadRequestStaleSchemaFragments
func (t ErrorBadRequest) AsErrorBadRequestStaleSchemaFragments() (ErrorBadRequestStaleSchemaFragments, error) {
	var body ErrorBadRequestStaleSchemaFragments
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestStaleSchemaFragments overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestStaleSchemaFragments
func (t *ErrorBadRequest) FromErrorBadRequestStaleSchemaFragments(v ErrorBadRequestStaleSchemaFragments) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestStaleSchemaFragments performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestStaleSchemaFragments
func (t *ErrorBadRequest) MergeErrorBadRequestStaleSchemaFragments(v ErrorBadRequestStaleSchemaFragments) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestUnexpectedIdType returns the union data inside the ErrorBadRequest as a ErrorBadRequestUnexpectedIdType
func (t ErrorBadRequest) AsErrorBadRequestUnexpectedIdType() (ErrorBadRequestUnexpectedIdType, error) {
	var body ErrorBadRequestUnexpectedIdType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestUnexpectedIdType overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestUnexpectedIdType
func (t *ErrorBadRequest) FromErrorBadRequestUnexpectedIdType(v ErrorBadRequestUnexpectedIdType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestUnexpectedIdType performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestUnexpectedIdType
func (t *ErrorBadRequest) MergeErrorBadRequestUnexpectedIdType(v ErrorBadRequestUnexpectedIdType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestUnexpectedJsonType returns the union data inside the ErrorBadRequest as a ErrorBadRequestUnexpectedJsonType
func (t ErrorBadRequest) AsErrorBadRequestUnexpectedJsonType() (ErrorBadRequestUnexpectedJsonType, error) {
	var body ErrorBadRequestUnexpectedJsonType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestUnexpectedJsonType overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestUnexpectedJsonType
func (t *ErrorBadRequest) FromErrorBadRequestUnexpectedJsonType(v ErrorBadRequestUnexpectedJsonType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestUnexpectedJsonType performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestUnexpectedJsonType
func (t *ErrorBadRequest) MergeErrorBadRequestUnexpectedJsonType(v ErrorBadRequestUnexpectedJsonType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestValueNotPermitted returns the union data inside the ErrorBadRequest as a ErrorBadRequestValueNotPermitted
func (t ErrorBadRequest) AsErrorBadRequestValueNotPermitted() (ErrorBadRequestValueNotPermitted, error) {
	var body ErrorBadRequestValueNotPermitted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestValueNotPermitted overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestValueNotPermitted
func (t *ErrorBadRequest) FromErrorBadRequestValueNotPermitted(v ErrorBadRequestValueNotPermitted) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestValueNotPermitted performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestValueNotPermitted
func (t *ErrorBadRequest) MergeErrorBadRequestValueNotPermitted(v ErrorBadRequestValueNotPermitted) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestWorkflowComponentValidationErrors returns the union data inside the ErrorBadRequest as a ErrorBadRequestWorkflowComponentValidationErrors
func (t ErrorBadRequest) AsErrorBadRequestWorkflowComponentValidationErrors() (ErrorBadRequestWorkflowComponentValidationErrors, error) {
	var body ErrorBadRequestWorkflowComponentValidationErrors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestWorkflowComponentValidationErrors overwrites any union data inside the ErrorBadRequest as the provided ErrorBadRequestWorkflowComponentValidationErrors
func (t *ErrorBadRequest) FromErrorBadRequestWorkflowComponentValidationErrors(v ErrorBadRequestWorkflowComponentValidationErrors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestWorkflowComponentValidationErrors performs a merge with any union data inside the ErrorBadRequest, using the provided ErrorBadRequestWorkflowComponentValidationErrors
func (t *ErrorBadRequest) MergeErrorBadRequestWorkflowComponentValidationErrors(v ErrorBadRequestWorkflowComponentValidationErrors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorBadRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorBadRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorBadRequestCustomizationValidationErrorBadIdType returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorBadIdType
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorBadIdType() (ErrorBadRequestCustomizationValidationErrorBadIdType, error) {
	var body ErrorBadRequestCustomizationValidationErrorBadIdType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorBadIdType overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorBadIdType
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorBadIdType(v ErrorBadRequestCustomizationValidationErrorBadIdType) error {
	t.Subtype = "bad_id_type"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorBadIdType performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorBadIdType
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorBadIdType(v ErrorBadRequestCustomizationValidationErrorBadIdType) error {
	t.Subtype = "bad_id_type"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorDateParseError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorDateParseError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorDateParseError() (ErrorBadRequestCustomizationValidationErrorDateParseError, error) {
	var body ErrorBadRequestCustomizationValidationErrorDateParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorDateParseError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorDateParseError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorDateParseError(v ErrorBadRequestCustomizationValidationErrorDateParseError) error {
	t.Subtype = "date_parse_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorDateParseError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorDateParseError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorDateParseError(v ErrorBadRequestCustomizationValidationErrorDateParseError) error {
	t.Subtype = "date_parse_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorEnumOutOfRange returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorEnumOutOfRange
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorEnumOutOfRange() (ErrorBadRequestCustomizationValidationErrorEnumOutOfRange, error) {
	var body ErrorBadRequestCustomizationValidationErrorEnumOutOfRange
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorEnumOutOfRange overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorEnumOutOfRange
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorEnumOutOfRange(v ErrorBadRequestCustomizationValidationErrorEnumOutOfRange) error {
	t.Subtype = "enum_out_of_range"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorEnumOutOfRange performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorEnumOutOfRange
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorEnumOutOfRange(v ErrorBadRequestCustomizationValidationErrorEnumOutOfRange) error {
	t.Subtype = "enum_out_of_range"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorExpressionParseError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorExpressionParseError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorExpressionParseError() (ErrorBadRequestCustomizationValidationErrorExpressionParseError, error) {
	var body ErrorBadRequestCustomizationValidationErrorExpressionParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorExpressionParseError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorExpressionParseError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorExpressionParseError(v ErrorBadRequestCustomizationValidationErrorExpressionParseError) error {
	t.Subtype = "expression_parse_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorExpressionParseError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorExpressionParseError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorExpressionParseError(v ErrorBadRequestCustomizationValidationErrorExpressionParseError) error {
	t.Subtype = "expression_parse_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFieldDropped returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFieldDropped
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFieldDropped() (ErrorBadRequestCustomizationValidationErrorFieldDropped, error) {
	var body ErrorBadRequestCustomizationValidationErrorFieldDropped
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFieldDropped overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFieldDropped
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFieldDropped(v ErrorBadRequestCustomizationValidationErrorFieldDropped) error {
	t.Subtype = "field_dropped"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFieldDropped performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFieldDropped
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFieldDropped(v ErrorBadRequestCustomizationValidationErrorFieldDropped) error {
	t.Subtype = "field_dropped"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFieldImmutable returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFieldImmutable
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFieldImmutable() (ErrorBadRequestCustomizationValidationErrorFieldImmutable, error) {
	var body ErrorBadRequestCustomizationValidationErrorFieldImmutable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFieldImmutable overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFieldImmutable
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFieldImmutable(v ErrorBadRequestCustomizationValidationErrorFieldImmutable) error {
	t.Subtype = "field_immutable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFieldImmutable performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFieldImmutable
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFieldImmutable(v ErrorBadRequestCustomizationValidationErrorFieldImmutable) error {
	t.Subtype = "field_immutable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFieldNotInSchema returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFieldNotInSchema
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFieldNotInSchema() (ErrorBadRequestCustomizationValidationErrorFieldNotInSchema, error) {
	var body ErrorBadRequestCustomizationValidationErrorFieldNotInSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFieldNotInSchema overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFieldNotInSchema
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFieldNotInSchema(v ErrorBadRequestCustomizationValidationErrorFieldNotInSchema) error {
	t.Subtype = "field_not_in_schema"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFieldNotInSchema performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFieldNotInSchema
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFieldNotInSchema(v ErrorBadRequestCustomizationValidationErrorFieldNotInSchema) error {
	t.Subtype = "field_not_in_schema"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFieldRequired returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFieldRequired
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFieldRequired() (ErrorBadRequestCustomizationValidationErrorFieldRequired, error) {
	var body ErrorBadRequestCustomizationValidationErrorFieldRequired
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFieldRequired overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFieldRequired
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFieldRequired(v ErrorBadRequestCustomizationValidationErrorFieldRequired) error {
	t.Subtype = "field_required"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFieldRequired performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFieldRequired
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFieldRequired(v ErrorBadRequestCustomizationValidationErrorFieldRequired) error {
	t.Subtype = "field_required"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorFragmentNotFound returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorFragmentNotFound
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorFragmentNotFound() (ErrorBadRequestCustomizationValidationErrorFragmentNotFound, error) {
	var body ErrorBadRequestCustomizationValidationErrorFragmentNotFound
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorFragmentNotFound overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorFragmentNotFound
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorFragmentNotFound(v ErrorBadRequestCustomizationValidationErrorFragmentNotFound) error {
	t.Subtype = "fragment_not_found"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorFragmentNotFound performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorFragmentNotFound
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorFragmentNotFound(v ErrorBadRequestCustomizationValidationErrorFragmentNotFound) error {
	t.Subtype = "fragment_not_found"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorIdParseError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorIdParseError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorIdParseError() (ErrorBadRequestCustomizationValidationErrorIdParseError, error) {
	var body ErrorBadRequestCustomizationValidationErrorIdParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorIdParseError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorIdParseError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorIdParseError(v ErrorBadRequestCustomizationValidationErrorIdParseError) error {
	t.Subtype = "id_parse_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorIdParseError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorIdParseError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorIdParseError(v ErrorBadRequestCustomizationValidationErrorIdParseError) error {
	t.Subtype = "id_parse_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed() (ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed, error) {
	var body ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed(v ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed) error {
	t.Subtype = "id_type_not_allowed"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed(v ErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed) error {
	t.Subtype = "id_type_not_allowed"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorInvalidArgument returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorInvalidArgument
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorInvalidArgument() (ErrorBadRequestCustomizationValidationErrorInvalidArgument, error) {
	var body ErrorBadRequestCustomizationValidationErrorInvalidArgument
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorInvalidArgument overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorInvalidArgument
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorInvalidArgument(v ErrorBadRequestCustomizationValidationErrorInvalidArgument) error {
	t.Subtype = "invalid_argument"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorInvalidArgument performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorInvalidArgument
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorInvalidArgument(v ErrorBadRequestCustomizationValidationErrorInvalidArgument) error {
	t.Subtype = "invalid_argument"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorTimestampParseError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorTimestampParseError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorTimestampParseError() (ErrorBadRequestCustomizationValidationErrorTimestampParseError, error) {
	var body ErrorBadRequestCustomizationValidationErrorTimestampParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorTimestampParseError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorTimestampParseError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorTimestampParseError(v ErrorBadRequestCustomizationValidationErrorTimestampParseError) error {
	t.Subtype = "timestamp_parse_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorTimestampParseError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorTimestampParseError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorTimestampParseError(v ErrorBadRequestCustomizationValidationErrorTimestampParseError) error {
	t.Subtype = "timestamp_parse_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorUnknownError returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorUnknownError
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorUnknownError() (ErrorBadRequestCustomizationValidationErrorUnknownError, error) {
	var body ErrorBadRequestCustomizationValidationErrorUnknownError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorUnknownError overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorUnknownError
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorUnknownError(v ErrorBadRequestCustomizationValidationErrorUnknownError) error {
	t.Subtype = "unknown_error"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorUnknownError performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorUnknownError
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorUnknownError(v ErrorBadRequestCustomizationValidationErrorUnknownError) error {
	t.Subtype = "unknown_error"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorUnsupportedType returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorUnsupportedType
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorUnsupportedType() (ErrorBadRequestCustomizationValidationErrorUnsupportedType, error) {
	var body ErrorBadRequestCustomizationValidationErrorUnsupportedType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorUnsupportedType overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorUnsupportedType
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorUnsupportedType(v ErrorBadRequestCustomizationValidationErrorUnsupportedType) error {
	t.Subtype = "unsupported_type"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorUnsupportedType performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorUnsupportedType
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorUnsupportedType(v ErrorBadRequestCustomizationValidationErrorUnsupportedType) error {
	t.Subtype = "unsupported_type"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorBadRequestCustomizationValidationErrorWrongType returns the union data inside the ErrorBadRequestCustomizationValidationError as a ErrorBadRequestCustomizationValidationErrorWrongType
func (t ErrorBadRequestCustomizationValidationError) AsErrorBadRequestCustomizationValidationErrorWrongType() (ErrorBadRequestCustomizationValidationErrorWrongType, error) {
	var body ErrorBadRequestCustomizationValidationErrorWrongType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorBadRequestCustomizationValidationErrorWrongType overwrites any union data inside the ErrorBadRequestCustomizationValidationError as the provided ErrorBadRequestCustomizationValidationErrorWrongType
func (t *ErrorBadRequestCustomizationValidationError) FromErrorBadRequestCustomizationValidationErrorWrongType(v ErrorBadRequestCustomizationValidationErrorWrongType) error {
	t.Subtype = "wrong_type"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorBadRequestCustomizationValidationErrorWrongType performs a merge with any union data inside the ErrorBadRequestCustomizationValidationError, using the provided ErrorBadRequestCustomizationValidationErrorWrongType
func (t *ErrorBadRequestCustomizationValidationError) MergeErrorBadRequestCustomizationValidationErrorWrongType(v ErrorBadRequestCustomizationValidationErrorWrongType) error {
	t.Subtype = "wrong_type"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorBadRequestCustomizationValidationError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"subtype"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ErrorBadRequestCustomizationValidationError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "bad_id_type":
		return t.AsErrorBadRequestCustomizationValidationErrorBadIdType()
	case "date_parse_error":
		return t.AsErrorBadRequestCustomizationValidationErrorDateParseError()
	case "enum_out_of_range":
		return t.AsErrorBadRequestCustomizationValidationErrorEnumOutOfRange()
	case "expression_parse_error":
		return t.AsErrorBadRequestCustomizationValidationErrorExpressionParseError()
	case "field_dropped":
		return t.AsErrorBadRequestCustomizationValidationErrorFieldDropped()
	case "field_immutable":
		return t.AsErrorBadRequestCustomizationValidationErrorFieldImmutable()
	case "field_not_in_schema":
		return t.AsErrorBadRequestCustomizationValidationErrorFieldNotInSchema()
	case "field_required":
		return t.AsErrorBadRequestCustomizationValidationErrorFieldRequired()
	case "fragment_not_found":
		return t.AsErrorBadRequestCustomizationValidationErrorFragmentNotFound()
	case "id_parse_error":
		return t.AsErrorBadRequestCustomizationValidationErrorIdParseError()
	case "id_type_not_allowed":
		return t.AsErrorBadRequestCustomizationValidationErrorIdTypeNotAllowed()
	case "invalid_argument":
		return t.AsErrorBadRequestCustomizationValidationErrorInvalidArgument()
	case "timestamp_parse_error":
		return t.AsErrorBadRequestCustomizationValidationErrorTimestampParseError()
	case "unknown_error":
		return t.AsErrorBadRequestCustomizationValidationErrorUnknownError()
	case "unsupported_type":
		return t.AsErrorBadRequestCustomizationValidationErrorUnsupportedType()
	case "wrong_type":
		return t.AsErrorBadRequestCustomizationValidationErrorWrongType()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ErrorBadRequestCustomizationValidationError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.FieldName != nil {
		object["field_name"], err = json.Marshal(t.FieldName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'field_name': %w", err)
		}
	}

	if t.Reason != nil {
		object["reason"], err = json.Marshal(t.Reason)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reason': %w", err)
		}
	}

	object["subtype"], err = json.Marshal(t.Subtype)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'subtype': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorBadRequestCustomizationValidationError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["field_name"]; found {
		err = json.Unmarshal(raw, &t.FieldName)
		if err != nil {
			return fmt.Errorf("error reading 'field_name': %w", err)
		}
	}

	if raw, found := object["reason"]; found {
		err = json.Unmarshal(raw, &t.Reason)
		if err != nil {
			return fmt.Errorf("error reading 'reason': %w", err)
		}
	}

	if raw, found := object["subtype"]; found {
		err = json.Unmarshal(raw, &t.Subtype)
		if err != nil {
			return fmt.Errorf("error reading 'subtype': %w", err)
		}
	}

	return err
}

// AsErrorConflictConflict returns the union data inside the ErrorConflict as a ErrorConflictConflict
func (t ErrorConflict) AsErrorConflictConflict() (ErrorConflictConflict, error) {
	var body ErrorConflictConflict
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorConflictConflict overwrites any union data inside the ErrorConflict as the provided ErrorConflictConflict
func (t *ErrorConflict) FromErrorConflictConflict(v ErrorConflictConflict) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorConflictConflict performs a merge with any union data inside the ErrorConflict, using the provided ErrorConflictConflict
func (t *ErrorConflict) MergeErrorConflictConflict(v ErrorConflictConflict) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorConflict) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorConflict) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorForbiddenForbidden returns the union data inside the ErrorForbidden as a ErrorForbiddenForbidden
func (t ErrorForbidden) AsErrorForbiddenForbidden() (ErrorForbiddenForbidden, error) {
	var body ErrorForbiddenForbidden
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorForbiddenForbidden overwrites any union data inside the ErrorForbidden as the provided ErrorForbiddenForbidden
func (t *ErrorForbidden) FromErrorForbiddenForbidden(v ErrorForbiddenForbidden) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorForbiddenForbidden performs a merge with any union data inside the ErrorForbidden, using the provided ErrorForbiddenForbidden
func (t *ErrorForbidden) MergeErrorForbiddenForbidden(v ErrorForbiddenForbidden) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorForbidden) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorForbidden) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorInternalServerErrorInternalError returns the union data inside the ErrorInternalServerError as a ErrorInternalServerErrorInternalError
func (t ErrorInternalServerError) AsErrorInternalServerErrorInternalError() (ErrorInternalServerErrorInternalError, error) {
	var body ErrorInternalServerErrorInternalError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorInternalServerErrorInternalError overwrites any union data inside the ErrorInternalServerError as the provided ErrorInternalServerErrorInternalError
func (t *ErrorInternalServerError) FromErrorInternalServerErrorInternalError(v ErrorInternalServerErrorInternalError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorInternalServerErrorInternalError performs a merge with any union data inside the ErrorInternalServerError, using the provided ErrorInternalServerErrorInternalError
func (t *ErrorInternalServerError) MergeErrorInternalServerErrorInternalError(v ErrorInternalServerErrorInternalError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorInternalServerError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	if t.ReferenceId != nil {
		object["reference_id"], err = json.Marshal(t.ReferenceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reference_id': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorInternalServerError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["reference_id"]; found {
		err = json.Unmarshal(raw, &t.ReferenceId)
		if err != nil {
			return fmt.Errorf("error reading 'reference_id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorNotFoundNotFound returns the union data inside the ErrorNotFound as a ErrorNotFoundNotFound
func (t ErrorNotFound) AsErrorNotFoundNotFound() (ErrorNotFoundNotFound, error) {
	var body ErrorNotFoundNotFound
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorNotFoundNotFound overwrites any union data inside the ErrorNotFound as the provided ErrorNotFoundNotFound
func (t *ErrorNotFound) FromErrorNotFoundNotFound(v ErrorNotFoundNotFound) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorNotFoundNotFound performs a merge with any union data inside the ErrorNotFound, using the provided ErrorNotFoundNotFound
func (t *ErrorNotFound) MergeErrorNotFoundNotFound(v ErrorNotFoundNotFound) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorNotFound) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorNotFound) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorServiceUnavailableServiceUnavailable returns the union data inside the ErrorServiceUnavailable as a ErrorServiceUnavailableServiceUnavailable
func (t ErrorServiceUnavailable) AsErrorServiceUnavailableServiceUnavailable() (ErrorServiceUnavailableServiceUnavailable, error) {
	var body ErrorServiceUnavailableServiceUnavailable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorServiceUnavailableServiceUnavailable overwrites any union data inside the ErrorServiceUnavailable as the provided ErrorServiceUnavailableServiceUnavailable
func (t *ErrorServiceUnavailable) FromErrorServiceUnavailableServiceUnavailable(v ErrorServiceUnavailableServiceUnavailable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorServiceUnavailableServiceUnavailable performs a merge with any union data inside the ErrorServiceUnavailable, using the provided ErrorServiceUnavailableServiceUnavailable
func (t *ErrorServiceUnavailable) MergeErrorServiceUnavailableServiceUnavailable(v ErrorServiceUnavailableServiceUnavailable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorServiceUnavailable) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorServiceUnavailable) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorTooManyRequestsTooManyRequests returns the union data inside the ErrorTooManyRequests as a ErrorTooManyRequestsTooManyRequests
func (t ErrorTooManyRequests) AsErrorTooManyRequestsTooManyRequests() (ErrorTooManyRequestsTooManyRequests, error) {
	var body ErrorTooManyRequestsTooManyRequests
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorTooManyRequestsTooManyRequests overwrites any union data inside the ErrorTooManyRequests as the provided ErrorTooManyRequestsTooManyRequests
func (t *ErrorTooManyRequests) FromErrorTooManyRequestsTooManyRequests(v ErrorTooManyRequestsTooManyRequests) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorTooManyRequestsTooManyRequests performs a merge with any union data inside the ErrorTooManyRequests, using the provided ErrorTooManyRequestsTooManyRequests
func (t *ErrorTooManyRequests) MergeErrorTooManyRequestsTooManyRequests(v ErrorTooManyRequestsTooManyRequests) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorTooManyRequests) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	if t.RetryAfter != nil {
		object["retry_after"], err = json.Marshal(t.RetryAfter)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'retry_after': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorTooManyRequests) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["retry_after"]; found {
		err = json.Unmarshal(raw, &t.RetryAfter)
		if err != nil {
			return fmt.Errorf("error reading 'retry_after': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsErrorUnauthorizedUnauthenticated returns the union data inside the ErrorUnauthorized as a ErrorUnauthorizedUnauthenticated
func (t ErrorUnauthorized) AsErrorUnauthorizedUnauthenticated() (ErrorUnauthorizedUnauthenticated, error) {
	var body ErrorUnauthorizedUnauthenticated
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorUnauthorizedUnauthenticated overwrites any union data inside the ErrorUnauthorized as the provided ErrorUnauthorizedUnauthenticated
func (t *ErrorUnauthorized) FromErrorUnauthorizedUnauthenticated(v ErrorUnauthorizedUnauthenticated) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorUnauthorizedUnauthenticated performs a merge with any union data inside the ErrorUnauthorized, using the provided ErrorUnauthorizedUnauthenticated
func (t *ErrorUnauthorized) MergeErrorUnauthorizedUnauthenticated(v ErrorUnauthorizedUnauthenticated) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ErrorUnauthorized) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Detail != nil {
		object["detail"], err = json.Marshal(t.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ErrorUnauthorized) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &t.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsEmpty returns the union data inside the EventSlaTrackerFetched as a Empty
func (t EventSlaTrackerFetched) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the EventSlaTrackerFetched as the provided Empty
func (t *EventSlaTrackerFetched) FromEmpty(v Empty) error {
	t.Result = "forbidden"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the EventSlaTrackerFetched, using the provided Empty
func (t *EventSlaTrackerFetched) MergeEmpty(v Empty) error {
	t.Result = "forbidden"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEventSlaTrackerFetchedOk returns the union data inside the EventSlaTrackerFetched as a EventSlaTrackerFetchedOk
func (t EventSlaTrackerFetched) AsEventSlaTrackerFetchedOk() (EventSlaTrackerFetchedOk, error) {
	var body EventSlaTrackerFetchedOk
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEventSlaTrackerFetchedOk overwrites any union data inside the EventSlaTrackerFetched as the provided EventSlaTrackerFetchedOk
func (t *EventSlaTrackerFetched) FromEventSlaTrackerFetchedOk(v EventSlaTrackerFetchedOk) error {
	t.Result = "ok"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEventSlaTrackerFetchedOk performs a merge with any union data inside the EventSlaTrackerFetched, using the provided EventSlaTrackerFetchedOk
func (t *EventSlaTrackerFetched) MergeEventSlaTrackerFetchedOk(v EventSlaTrackerFetchedOk) error {
	t.Result = "ok"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EventSlaTrackerFetched) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"result"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EventSlaTrackerFetched) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "forbidden":
		return t.AsEmpty()
	case "ok":
		return t.AsEventSlaTrackerFetchedOk()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EventSlaTrackerFetched) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["result"], err = json.Marshal(t.Result)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'result': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *EventSlaTrackerFetched) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["result"]; found {
		err = json.Unmarshal(raw, &t.Result)
		if err != nil {
			return fmt.Errorf("error reading 'result': %w", err)
		}
	}

	return err
}

// AsEmpty returns the union data inside the EventWorkFetched as a Empty
func (t EventWorkFetched) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the EventWorkFetched as the provided Empty
func (t *EventWorkFetched) FromEmpty(v Empty) error {
	t.Result = "forbidden"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the EventWorkFetched, using the provided Empty
func (t *EventWorkFetched) MergeEmpty(v Empty) error {
	t.Result = "forbidden"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEventWorkFetchedOk returns the union data inside the EventWorkFetched as a EventWorkFetchedOk
func (t EventWorkFetched) AsEventWorkFetchedOk() (EventWorkFetchedOk, error) {
	var body EventWorkFetchedOk
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEventWorkFetchedOk overwrites any union data inside the EventWorkFetched as the provided EventWorkFetchedOk
func (t *EventWorkFetched) FromEventWorkFetchedOk(v EventWorkFetchedOk) error {
	t.Result = "ok"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEventWorkFetchedOk performs a merge with any union data inside the EventWorkFetched, using the provided EventWorkFetchedOk
func (t *EventWorkFetched) MergeEventWorkFetchedOk(v EventWorkFetchedOk) error {
	t.Result = "ok"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EventWorkFetched) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"result"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EventWorkFetched) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "forbidden":
		return t.AsEmpty()
	case "ok":
		return t.AsEventWorkFetchedOk()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EventWorkFetched) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["result"], err = json.Marshal(t.Result)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'result': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *EventWorkFetched) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["result"]; found {
		err = json.Unmarshal(raw, &t.Result)
		if err != nil {
			return fmt.Errorf("error reading 'result': %w", err)
		}
	}

	return err
}

// AsFieldValueBool returns the union data inside the FieldValue as a FieldValueBool
func (t FieldValue) AsFieldValueBool() (FieldValueBool, error) {
	var body FieldValueBool
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueBool overwrites any union data inside the FieldValue as the provided FieldValueBool
func (t *FieldValue) FromFieldValueBool(v FieldValueBool) error {
	t.Type = "bool"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueBool performs a merge with any union data inside the FieldValue, using the provided FieldValueBool
func (t *FieldValue) MergeFieldValueBool(v FieldValueBool) error {
	t.Type = "bool"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueBoolList returns the union data inside the FieldValue as a FieldValueBoolList
func (t FieldValue) AsFieldValueBoolList() (FieldValueBoolList, error) {
	var body FieldValueBoolList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueBoolList overwrites any union data inside the FieldValue as the provided FieldValueBoolList
func (t *FieldValue) FromFieldValueBoolList(v FieldValueBoolList) error {
	t.Type = "bool_list"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueBoolList performs a merge with any union data inside the FieldValue, using the provided FieldValueBoolList
func (t *FieldValue) MergeFieldValueBoolList(v FieldValueBoolList) error {
	t.Type = "bool_list"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueComposite returns the union data inside the FieldValue as a FieldValueComposite
func (t FieldValue) AsFieldValueComposite() (FieldValueComposite, error) {
	var body FieldValueComposite
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueComposite overwrites any union data inside the FieldValue as the provided FieldValueComposite
func (t *FieldValue) FromFieldValueComposite(v FieldValueComposite) error {
	t.Type = "composite"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueComposite performs a merge with any union data inside the FieldValue, using the provided FieldValueComposite
func (t *FieldValue) MergeFieldValueComposite(v FieldValueComposite) error {
	t.Type = "composite"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueCompositeList returns the union data inside the FieldValue as a FieldValueCompositeList
func (t FieldValue) AsFieldValueCompositeList() (FieldValueCompositeList, error) {
	var body FieldValueCompositeList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueCompositeList overwrites any union data inside the FieldValue as the provided FieldValueCompositeList
func (t *FieldValue) FromFieldValueCompositeList(v FieldValueCompositeList) error {
	t.Type = "composite_list"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueCompositeList performs a merge with any union data inside the FieldValue, using the provided FieldValueCompositeList
func (t *FieldValue) MergeFieldValueCompositeList(v FieldValueCompositeList) error {
	t.Type = "composite_list"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueDateList returns the union data inside the FieldValue as a FieldValueDateList
func (t FieldValue) AsFieldValueDateList() (FieldValueDateList, error) {
	var body FieldValueDateList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueDateList overwrites any union data inside the FieldValue as the provided FieldValueDateList
func (t *FieldValue) FromFieldValueDateList(v FieldValueDateList) error {
	t.Type = "date_list"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueDateList performs a merge with any union data inside the FieldValue, using the provided FieldValueDateList
func (t *FieldValue) MergeFieldValueDateList(v FieldValueDateList) error {
	t.Type = "date_list"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueDateTimeList returns the union data inside the FieldValue as a FieldValueDateTimeList
func (t FieldValue) AsFieldValueDateTimeList() (FieldValueDateTimeList, error) {
	var body FieldValueDateTimeList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueDateTimeList overwrites any union data inside the FieldValue as the provided FieldValueDateTimeList
func (t *FieldValue) FromFieldValueDateTimeList(v FieldValueDateTimeList) error {
	t.Type = "date_time_list"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueDateTimeList performs a merge with any union data inside the FieldValue, using the provided FieldValueDateTimeList
func (t *FieldValue) MergeFieldValueDateTimeList(v FieldValueDateTimeList) error {
	t.Type = "date_time_list"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueDateTimeValue returns the union data inside the FieldValue as a FieldValueDateTimeValue
func (t FieldValue) AsFieldValueDateTimeValue() (FieldValueDateTimeValue, error) {
	var body FieldValueDateTimeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueDateTimeValue overwrites any union data inside the FieldValue as the provided FieldValueDateTimeValue
func (t *FieldValue) FromFieldValueDateTimeValue(v FieldValueDateTimeValue) error {
	t.Type = "date_time"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueDateTimeValue performs a merge with any union data inside the FieldValue, using the provided FieldValueDateTimeValue
func (t *FieldValue) MergeFieldValueDateTimeValue(v FieldValueDateTimeValue) error {
	t.Type = "date_time"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueDateValue returns the union data inside the FieldValue as a FieldValueDateValue
func (t FieldValue) AsFieldValueDateValue() (FieldValueDateValue, error) {
	var body FieldValueDateValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueDateValue overwrites any union data inside the FieldValue as the provided FieldValueDateValue
func (t *FieldValue) FromFieldValueDateValue(v FieldValueDateValue) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueDateValue performs a merge with any union data inside the FieldValue, using the provided FieldValueDateValue
func (t *FieldValue) MergeFieldValueDateValue(v FieldValueDateValue) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueDouble returns the union data inside the FieldValue as a FieldValueDouble
func (t FieldValue) AsFieldValueDouble() (FieldValueDouble, error) {
	var body FieldValueDouble
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueDouble overwrites any union data inside the FieldValue as the provided FieldValueDouble
func (t *FieldValue) FromFieldValueDouble(v FieldValueDouble) error {
	t.Type = "double"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueDouble performs a merge with any union data inside the FieldValue, using the provided FieldValueDouble
func (t *FieldValue) MergeFieldValueDouble(v FieldValueDouble) error {
	t.Type = "double"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueDoubleList returns the union data inside the FieldValue as a FieldValueDoubleList
func (t FieldValue) AsFieldValueDoubleList() (FieldValueDoubleList, error) {
	var body FieldValueDoubleList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueDoubleList overwrites any union data inside the FieldValue as the provided FieldValueDoubleList
func (t *FieldValue) FromFieldValueDoubleList(v FieldValueDoubleList) error {
	t.Type = "double_list"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueDoubleList performs a merge with any union data inside the FieldValue, using the provided FieldValueDoubleList
func (t *FieldValue) MergeFieldValueDoubleList(v FieldValueDoubleList) error {
	t.Type = "double_list"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueId returns the union data inside the FieldValue as a FieldValueId
func (t FieldValue) AsFieldValueId() (FieldValueId, error) {
	var body FieldValueId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueId overwrites any union data inside the FieldValue as the provided FieldValueId
func (t *FieldValue) FromFieldValueId(v FieldValueId) error {
	t.Type = "id"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueId performs a merge with any union data inside the FieldValue, using the provided FieldValueId
func (t *FieldValue) MergeFieldValueId(v FieldValueId) error {
	t.Type = "id"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueIdList returns the union data inside the FieldValue as a FieldValueIdList
func (t FieldValue) AsFieldValueIdList() (FieldValueIdList, error) {
	var body FieldValueIdList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueIdList overwrites any union data inside the FieldValue as the provided FieldValueIdList
func (t *FieldValue) FromFieldValueIdList(v FieldValueIdList) error {
	t.Type = "id_list"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueIdList performs a merge with any union data inside the FieldValue, using the provided FieldValueIdList
func (t *FieldValue) MergeFieldValueIdList(v FieldValueIdList) error {
	t.Type = "id_list"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueInt64 returns the union data inside the FieldValue as a FieldValueInt64
func (t FieldValue) AsFieldValueInt64() (FieldValueInt64, error) {
	var body FieldValueInt64
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueInt64 overwrites any union data inside the FieldValue as the provided FieldValueInt64
func (t *FieldValue) FromFieldValueInt64(v FieldValueInt64) error {
	t.Type = "int"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueInt64 performs a merge with any union data inside the FieldValue, using the provided FieldValueInt64
func (t *FieldValue) MergeFieldValueInt64(v FieldValueInt64) error {
	t.Type = "int"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueInt64List returns the union data inside the FieldValue as a FieldValueInt64List
func (t FieldValue) AsFieldValueInt64List() (FieldValueInt64List, error) {
	var body FieldValueInt64List
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueInt64List overwrites any union data inside the FieldValue as the provided FieldValueInt64List
func (t *FieldValue) FromFieldValueInt64List(v FieldValueInt64List) error {
	t.Type = "int_list"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueInt64List performs a merge with any union data inside the FieldValue, using the provided FieldValueInt64List
func (t *FieldValue) MergeFieldValueInt64List(v FieldValueInt64List) error {
	t.Type = "int_list"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueStage returns the union data inside the FieldValue as a FieldValueStage
func (t FieldValue) AsFieldValueStage() (FieldValueStage, error) {
	var body FieldValueStage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueStage overwrites any union data inside the FieldValue as the provided FieldValueStage
func (t *FieldValue) FromFieldValueStage(v FieldValueStage) error {
	t.Type = "stage"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueStage performs a merge with any union data inside the FieldValue, using the provided FieldValueStage
func (t *FieldValue) MergeFieldValueStage(v FieldValueStage) error {
	t.Type = "stage"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueString returns the union data inside the FieldValue as a FieldValueString
func (t FieldValue) AsFieldValueString() (FieldValueString, error) {
	var body FieldValueString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueString overwrites any union data inside the FieldValue as the provided FieldValueString
func (t *FieldValue) FromFieldValueString(v FieldValueString) error {
	t.Type = "string"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueString performs a merge with any union data inside the FieldValue, using the provided FieldValueString
func (t *FieldValue) MergeFieldValueString(v FieldValueString) error {
	t.Type = "string"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueStringList returns the union data inside the FieldValue as a FieldValueStringList
func (t FieldValue) AsFieldValueStringList() (FieldValueStringList, error) {
	var body FieldValueStringList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueStringList overwrites any union data inside the FieldValue as the provided FieldValueStringList
func (t *FieldValue) FromFieldValueStringList(v FieldValueStringList) error {
	t.Type = "string_list"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueStringList performs a merge with any union data inside the FieldValue, using the provided FieldValueStringList
func (t *FieldValue) MergeFieldValueStringList(v FieldValueStringList) error {
	t.Type = "string_list"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueTagSummary returns the union data inside the FieldValue as a FieldValueTagSummary
func (t FieldValue) AsFieldValueTagSummary() (FieldValueTagSummary, error) {
	var body FieldValueTagSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueTagSummary overwrites any union data inside the FieldValue as the provided FieldValueTagSummary
func (t *FieldValue) FromFieldValueTagSummary(v FieldValueTagSummary) error {
	t.Type = "tag_summary"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueTagSummary performs a merge with any union data inside the FieldValue, using the provided FieldValueTagSummary
func (t *FieldValue) MergeFieldValueTagSummary(v FieldValueTagSummary) error {
	t.Type = "tag_summary"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueTagSummaryList returns the union data inside the FieldValue as a FieldValueTagSummaryList
func (t FieldValue) AsFieldValueTagSummaryList() (FieldValueTagSummaryList, error) {
	var body FieldValueTagSummaryList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueTagSummaryList overwrites any union data inside the FieldValue as the provided FieldValueTagSummaryList
func (t *FieldValue) FromFieldValueTagSummaryList(v FieldValueTagSummaryList) error {
	t.Type = "tag_summary_list"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueTagSummaryList performs a merge with any union data inside the FieldValue, using the provided FieldValueTagSummaryList
func (t *FieldValue) MergeFieldValueTagSummaryList(v FieldValueTagSummaryList) error {
	t.Type = "tag_summary_list"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FieldValue) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FieldValue) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "bool":
		return t.AsFieldValueBool()
	case "bool_list":
		return t.AsFieldValueBoolList()
	case "composite":
		return t.AsFieldValueComposite()
	case "composite_list":
		return t.AsFieldValueCompositeList()
	case "date":
		return t.AsFieldValueDateValue()
	case "date_list":
		return t.AsFieldValueDateList()
	case "date_time":
		return t.AsFieldValueDateTimeValue()
	case "date_time_list":
		return t.AsFieldValueDateTimeList()
	case "double":
		return t.AsFieldValueDouble()
	case "double_list":
		return t.AsFieldValueDoubleList()
	case "id":
		return t.AsFieldValueId()
	case "id_list":
		return t.AsFieldValueIdList()
	case "int":
		return t.AsFieldValueInt64()
	case "int_list":
		return t.AsFieldValueInt64List()
	case "stage":
		return t.AsFieldValueStage()
	case "string":
		return t.AsFieldValueString()
	case "string_list":
		return t.AsFieldValueStringList()
	case "tag_summary":
		return t.AsFieldValueTagSummary()
	case "tag_summary_list":
		return t.AsFieldValueTagSummaryList()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FieldValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *FieldValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAccountSummary returns the union data inside the LinkEndpointSummary as a AccountSummary
func (t LinkEndpointSummary) AsAccountSummary() (AccountSummary, error) {
	var body AccountSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccountSummary overwrites any union data inside the LinkEndpointSummary as the provided AccountSummary
func (t *LinkEndpointSummary) FromAccountSummary(v AccountSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccountSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided AccountSummary
func (t *LinkEndpointSummary) MergeAccountSummary(v AccountSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapabilitySummary returns the union data inside the LinkEndpointSummary as a CapabilitySummary
func (t LinkEndpointSummary) AsCapabilitySummary() (CapabilitySummary, error) {
	var body CapabilitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapabilitySummary overwrites any union data inside the LinkEndpointSummary as the provided CapabilitySummary
func (t *LinkEndpointSummary) FromCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapabilitySummary performs a merge with any union data inside the LinkEndpointSummary, using the provided CapabilitySummary
func (t *LinkEndpointSummary) MergeCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCodeChangeSummary returns the union data inside the LinkEndpointSummary as a CodeChangeSummary
func (t LinkEndpointSummary) AsCodeChangeSummary() (CodeChangeSummary, error) {
	var body CodeChangeSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCodeChangeSummary overwrites any union data inside the LinkEndpointSummary as the provided CodeChangeSummary
func (t *LinkEndpointSummary) FromCodeChangeSummary(v CodeChangeSummary) error {
	t.Type = "code_change"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCodeChangeSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided CodeChangeSummary
func (t *LinkEndpointSummary) MergeCodeChangeSummary(v CodeChangeSummary) error {
	t.Type = "code_change"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConversationSummary returns the union data inside the LinkEndpointSummary as a ConversationSummary
func (t LinkEndpointSummary) AsConversationSummary() (ConversationSummary, error) {
	var body ConversationSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConversationSummary overwrites any union data inside the LinkEndpointSummary as the provided ConversationSummary
func (t *LinkEndpointSummary) FromConversationSummary(v ConversationSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConversationSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided ConversationSummary
func (t *LinkEndpointSummary) MergeConversationSummary(v ConversationSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomObjectSummary returns the union data inside the LinkEndpointSummary as a CustomObjectSummary
func (t LinkEndpointSummary) AsCustomObjectSummary() (CustomObjectSummary, error) {
	var body CustomObjectSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomObjectSummary overwrites any union data inside the LinkEndpointSummary as the provided CustomObjectSummary
func (t *LinkEndpointSummary) FromCustomObjectSummary(v CustomObjectSummary) error {
	t.Type = "custom_object"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomObjectSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided CustomObjectSummary
func (t *LinkEndpointSummary) MergeCustomObjectSummary(v CustomObjectSummary) error {
	t.Type = "custom_object"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevUserSummary returns the union data inside the LinkEndpointSummary as a DevUserSummary
func (t LinkEndpointSummary) AsDevUserSummary() (DevUserSummary, error) {
	var body DevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUserSummary overwrites any union data inside the LinkEndpointSummary as the provided DevUserSummary
func (t *LinkEndpointSummary) FromDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUserSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided DevUserSummary
func (t *LinkEndpointSummary) MergeDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancementSummary returns the union data inside the LinkEndpointSummary as a EnhancementSummary
func (t LinkEndpointSummary) AsEnhancementSummary() (EnhancementSummary, error) {
	var body EnhancementSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancementSummary overwrites any union data inside the LinkEndpointSummary as the provided EnhancementSummary
func (t *LinkEndpointSummary) FromEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancementSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided EnhancementSummary
func (t *LinkEndpointSummary) MergeEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeatureSummary returns the union data inside the LinkEndpointSummary as a FeatureSummary
func (t LinkEndpointSummary) AsFeatureSummary() (FeatureSummary, error) {
	var body FeatureSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeatureSummary overwrites any union data inside the LinkEndpointSummary as the provided FeatureSummary
func (t *LinkEndpointSummary) FromFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeatureSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided FeatureSummary
func (t *LinkEndpointSummary) MergeFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIncidentSummary returns the union data inside the LinkEndpointSummary as a IncidentSummary
func (t LinkEndpointSummary) AsIncidentSummary() (IncidentSummary, error) {
	var body IncidentSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIncidentSummary overwrites any union data inside the LinkEndpointSummary as the provided IncidentSummary
func (t *LinkEndpointSummary) FromIncidentSummary(v IncidentSummary) error {
	t.Type = "incident"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIncidentSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided IncidentSummary
func (t *LinkEndpointSummary) MergeIncidentSummary(v IncidentSummary) error {
	t.Type = "incident"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueSummary returns the union data inside the LinkEndpointSummary as a IssueSummary
func (t LinkEndpointSummary) AsIssueSummary() (IssueSummary, error) {
	var body IssueSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueSummary overwrites any union data inside the LinkEndpointSummary as the provided IssueSummary
func (t *LinkEndpointSummary) FromIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided IssueSummary
func (t *LinkEndpointSummary) MergeIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkableSummary returns the union data inside the LinkEndpointSummary as a LinkableSummary
func (t LinkEndpointSummary) AsLinkableSummary() (LinkableSummary, error) {
	var body LinkableSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkableSummary overwrites any union data inside the LinkEndpointSummary as the provided LinkableSummary
func (t *LinkEndpointSummary) FromLinkableSummary(v LinkableSummary) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkableSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided LinkableSummary
func (t *LinkEndpointSummary) MergeLinkableSummary(v LinkableSummary) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeetingSummary returns the union data inside the LinkEndpointSummary as a MeetingSummary
func (t LinkEndpointSummary) AsMeetingSummary() (MeetingSummary, error) {
	var body MeetingSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeetingSummary overwrites any union data inside the LinkEndpointSummary as the provided MeetingSummary
func (t *LinkEndpointSummary) FromMeetingSummary(v MeetingSummary) error {
	t.Type = "meeting"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeetingSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided MeetingSummary
func (t *LinkEndpointSummary) MergeMeetingSummary(v MeetingSummary) error {
	t.Type = "meeting"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpportunitySummary returns the union data inside the LinkEndpointSummary as a OpportunitySummary
func (t LinkEndpointSummary) AsOpportunitySummary() (OpportunitySummary, error) {
	var body OpportunitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpportunitySummary overwrites any union data inside the LinkEndpointSummary as the provided OpportunitySummary
func (t *LinkEndpointSummary) FromOpportunitySummary(v OpportunitySummary) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpportunitySummary performs a merge with any union data inside the LinkEndpointSummary, using the provided OpportunitySummary
func (t *LinkEndpointSummary) MergeOpportunitySummary(v OpportunitySummary) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProductSummary returns the union data inside the LinkEndpointSummary as a ProductSummary
func (t LinkEndpointSummary) AsProductSummary() (ProductSummary, error) {
	var body ProductSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProductSummary overwrites any union data inside the LinkEndpointSummary as the provided ProductSummary
func (t *LinkEndpointSummary) FromProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProductSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided ProductSummary
func (t *LinkEndpointSummary) MergeProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevOrgSummary returns the union data inside the LinkEndpointSummary as a RevOrgSummary
func (t LinkEndpointSummary) AsRevOrgSummary() (RevOrgSummary, error) {
	var body RevOrgSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevOrgSummary overwrites any union data inside the LinkEndpointSummary as the provided RevOrgSummary
func (t *LinkEndpointSummary) FromRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevOrgSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided RevOrgSummary
func (t *LinkEndpointSummary) MergeRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUserSummary returns the union data inside the LinkEndpointSummary as a RevUserSummary
func (t LinkEndpointSummary) AsRevUserSummary() (RevUserSummary, error) {
	var body RevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUserSummary overwrites any union data inside the LinkEndpointSummary as the provided RevUserSummary
func (t *LinkEndpointSummary) FromRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUserSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided RevUserSummary
func (t *LinkEndpointSummary) MergeRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunnableSummary returns the union data inside the LinkEndpointSummary as a RunnableSummary
func (t LinkEndpointSummary) AsRunnableSummary() (RunnableSummary, error) {
	var body RunnableSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunnableSummary overwrites any union data inside the LinkEndpointSummary as the provided RunnableSummary
func (t *LinkEndpointSummary) FromRunnableSummary(v RunnableSummary) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunnableSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided RunnableSummary
func (t *LinkEndpointSummary) MergeRunnableSummary(v RunnableSummary) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTaskSummary returns the union data inside the LinkEndpointSummary as a TaskSummary
func (t LinkEndpointSummary) AsTaskSummary() (TaskSummary, error) {
	var body TaskSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTaskSummary overwrites any union data inside the LinkEndpointSummary as the provided TaskSummary
func (t *LinkEndpointSummary) FromTaskSummary(v TaskSummary) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTaskSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided TaskSummary
func (t *LinkEndpointSummary) MergeTaskSummary(v TaskSummary) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTicketSummary returns the union data inside the LinkEndpointSummary as a TicketSummary
func (t LinkEndpointSummary) AsTicketSummary() (TicketSummary, error) {
	var body TicketSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTicketSummary overwrites any union data inside the LinkEndpointSummary as the provided TicketSummary
func (t *LinkEndpointSummary) FromTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTicketSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided TicketSummary
func (t *LinkEndpointSummary) MergeTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWidgetSummary returns the union data inside the LinkEndpointSummary as a WidgetSummary
func (t LinkEndpointSummary) AsWidgetSummary() (WidgetSummary, error) {
	var body WidgetSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWidgetSummary overwrites any union data inside the LinkEndpointSummary as the provided WidgetSummary
func (t *LinkEndpointSummary) FromWidgetSummary(v WidgetSummary) error {
	t.Type = "widget"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWidgetSummary performs a merge with any union data inside the LinkEndpointSummary, using the provided WidgetSummary
func (t *LinkEndpointSummary) MergeWidgetSummary(v WidgetSummary) error {
	t.Type = "widget"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LinkEndpointSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t LinkEndpointSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "account":
		return t.AsAccountSummary()
	case "capability":
		return t.AsCapabilitySummary()
	case "code_change":
		return t.AsCodeChangeSummary()
	case "conversation":
		return t.AsConversationSummary()
	case "custom_object":
		return t.AsCustomObjectSummary()
	case "dev_user":
		return t.AsDevUserSummary()
	case "enhancement":
		return t.AsEnhancementSummary()
	case "feature":
		return t.AsFeatureSummary()
	case "incident":
		return t.AsIncidentSummary()
	case "issue":
		return t.AsIssueSummary()
	case "linkable":
		return t.AsLinkableSummary()
	case "meeting":
		return t.AsMeetingSummary()
	case "opportunity":
		return t.AsOpportunitySummary()
	case "product":
		return t.AsProductSummary()
	case "rev_org":
		return t.AsRevOrgSummary()
	case "rev_user":
		return t.AsRevUserSummary()
	case "runnable":
		return t.AsRunnableSummary()
	case "task":
		return t.AsTaskSummary()
	case "ticket":
		return t.AsTicketSummary()
	case "widget":
		return t.AsWidgetSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t LinkEndpointSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *LinkEndpointSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDevUserSummary returns the union data inside the MemberSummary as a DevUserSummary
func (t MemberSummary) AsDevUserSummary() (DevUserSummary, error) {
	var body DevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUserSummary overwrites any union data inside the MemberSummary as the provided DevUserSummary
func (t *MemberSummary) FromDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUserSummary performs a merge with any union data inside the MemberSummary, using the provided DevUserSummary
func (t *MemberSummary) MergeDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroupSummary returns the union data inside the MemberSummary as a GroupSummary
func (t MemberSummary) AsGroupSummary() (GroupSummary, error) {
	var body GroupSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroupSummary overwrites any union data inside the MemberSummary as the provided GroupSummary
func (t *MemberSummary) FromGroupSummary(v GroupSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroupSummary performs a merge with any union data inside the MemberSummary, using the provided GroupSummary
func (t *MemberSummary) MergeGroupSummary(v GroupSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUserSummary returns the union data inside the MemberSummary as a RevUserSummary
func (t MemberSummary) AsRevUserSummary() (RevUserSummary, error) {
	var body RevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUserSummary overwrites any union data inside the MemberSummary as the provided RevUserSummary
func (t *MemberSummary) FromRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUserSummary performs a merge with any union data inside the MemberSummary, using the provided RevUserSummary
func (t *MemberSummary) MergeRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSysUserSummary returns the union data inside the MemberSummary as a SysUserSummary
func (t MemberSummary) AsSysUserSummary() (SysUserSummary, error) {
	var body SysUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSysUserSummary overwrites any union data inside the MemberSummary as the provided SysUserSummary
func (t *MemberSummary) FromSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSysUserSummary performs a merge with any union data inside the MemberSummary, using the provided SysUserSummary
func (t *MemberSummary) MergeSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MemberSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MemberSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dev_user":
		return t.AsDevUserSummary()
	case "group":
		return t.AsGroupSummary()
	case "rev_user":
		return t.AsRevUserSummary()
	case "sys_user":
		return t.AsSysUserSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MemberSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *MemberSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAccountSummary returns the union data inside the OrgSummary as a AccountSummary
func (t OrgSummary) AsAccountSummary() (AccountSummary, error) {
	var body AccountSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccountSummary overwrites any union data inside the OrgSummary as the provided AccountSummary
func (t *OrgSummary) FromAccountSummary(v AccountSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccountSummary performs a merge with any union data inside the OrgSummary, using the provided AccountSummary
func (t *OrgSummary) MergeAccountSummary(v AccountSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevOrgSummary returns the union data inside the OrgSummary as a DevOrgSummary
func (t OrgSummary) AsDevOrgSummary() (DevOrgSummary, error) {
	var body DevOrgSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevOrgSummary overwrites any union data inside the OrgSummary as the provided DevOrgSummary
func (t *OrgSummary) FromDevOrgSummary(v DevOrgSummary) error {
	t.Type = "dev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevOrgSummary performs a merge with any union data inside the OrgSummary, using the provided DevOrgSummary
func (t *OrgSummary) MergeDevOrgSummary(v DevOrgSummary) error {
	t.Type = "dev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevOrgSummary returns the union data inside the OrgSummary as a RevOrgSummary
func (t OrgSummary) AsRevOrgSummary() (RevOrgSummary, error) {
	var body RevOrgSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevOrgSummary overwrites any union data inside the OrgSummary as the provided RevOrgSummary
func (t *OrgSummary) FromRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevOrgSummary performs a merge with any union data inside the OrgSummary, using the provided RevOrgSummary
func (t *OrgSummary) MergeRevOrgSummary(v RevOrgSummary) error {
	t.Type = "rev_org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrgSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OrgSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "account":
		return t.AsAccountSummary()
	case "dev_org":
		return t.AsDevOrgSummary()
	case "rev_org":
		return t.AsRevOrgSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OrgSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *OrgSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsCapability returns the union data inside the Part as a Capability
func (t Part) AsCapability() (Capability, error) {
	var body Capability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapability overwrites any union data inside the Part as the provided Capability
func (t *Part) FromCapability(v Capability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapability performs a merge with any union data inside the Part, using the provided Capability
func (t *Part) MergeCapability(v Capability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancement returns the union data inside the Part as a Enhancement
func (t Part) AsEnhancement() (Enhancement, error) {
	var body Enhancement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancement overwrites any union data inside the Part as the provided Enhancement
func (t *Part) FromEnhancement(v Enhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancement performs a merge with any union data inside the Part, using the provided Enhancement
func (t *Part) MergeEnhancement(v Enhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeature returns the union data inside the Part as a Feature
func (t Part) AsFeature() (Feature, error) {
	var body Feature
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeature overwrites any union data inside the Part as the provided Feature
func (t *Part) FromFeature(v Feature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeature performs a merge with any union data inside the Part, using the provided Feature
func (t *Part) MergeFeature(v Feature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkable returns the union data inside the Part as a Linkable
func (t Part) AsLinkable() (Linkable, error) {
	var body Linkable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkable overwrites any union data inside the Part as the provided Linkable
func (t *Part) FromLinkable(v Linkable) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkable performs a merge with any union data inside the Part, using the provided Linkable
func (t *Part) MergeLinkable(v Linkable) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProduct returns the union data inside the Part as a Product
func (t Part) AsProduct() (Product, error) {
	var body Product
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProduct overwrites any union data inside the Part as the provided Product
func (t *Part) FromProduct(v Product) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProduct performs a merge with any union data inside the Part, using the provided Product
func (t *Part) MergeProduct(v Product) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunnable returns the union data inside the Part as a Runnable
func (t Part) AsRunnable() (Runnable, error) {
	var body Runnable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunnable overwrites any union data inside the Part as the provided Runnable
func (t *Part) FromRunnable(v Runnable) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunnable performs a merge with any union data inside the Part, using the provided Runnable
func (t *Part) MergeRunnable(v Runnable) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Part) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Part) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capability":
		return t.AsCapability()
	case "enhancement":
		return t.AsEnhancement()
	case "feature":
		return t.AsFeature()
	case "linkable":
		return t.AsLinkable()
	case "product":
		return t.AsProduct()
	case "runnable":
		return t.AsRunnable()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Part) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Part) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsCapabilitySummary returns the union data inside the PartSummary as a CapabilitySummary
func (t PartSummary) AsCapabilitySummary() (CapabilitySummary, error) {
	var body CapabilitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapabilitySummary overwrites any union data inside the PartSummary as the provided CapabilitySummary
func (t *PartSummary) FromCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapabilitySummary performs a merge with any union data inside the PartSummary, using the provided CapabilitySummary
func (t *PartSummary) MergeCapabilitySummary(v CapabilitySummary) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnhancementSummary returns the union data inside the PartSummary as a EnhancementSummary
func (t PartSummary) AsEnhancementSummary() (EnhancementSummary, error) {
	var body EnhancementSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnhancementSummary overwrites any union data inside the PartSummary as the provided EnhancementSummary
func (t *PartSummary) FromEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnhancementSummary performs a merge with any union data inside the PartSummary, using the provided EnhancementSummary
func (t *PartSummary) MergeEnhancementSummary(v EnhancementSummary) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeatureSummary returns the union data inside the PartSummary as a FeatureSummary
func (t PartSummary) AsFeatureSummary() (FeatureSummary, error) {
	var body FeatureSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeatureSummary overwrites any union data inside the PartSummary as the provided FeatureSummary
func (t *PartSummary) FromFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeatureSummary performs a merge with any union data inside the PartSummary, using the provided FeatureSummary
func (t *PartSummary) MergeFeatureSummary(v FeatureSummary) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkableSummary returns the union data inside the PartSummary as a LinkableSummary
func (t PartSummary) AsLinkableSummary() (LinkableSummary, error) {
	var body LinkableSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkableSummary overwrites any union data inside the PartSummary as the provided LinkableSummary
func (t *PartSummary) FromLinkableSummary(v LinkableSummary) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkableSummary performs a merge with any union data inside the PartSummary, using the provided LinkableSummary
func (t *PartSummary) MergeLinkableSummary(v LinkableSummary) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProductSummary returns the union data inside the PartSummary as a ProductSummary
func (t PartSummary) AsProductSummary() (ProductSummary, error) {
	var body ProductSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProductSummary overwrites any union data inside the PartSummary as the provided ProductSummary
func (t *PartSummary) FromProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProductSummary performs a merge with any union data inside the PartSummary, using the provided ProductSummary
func (t *PartSummary) MergeProductSummary(v ProductSummary) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunnableSummary returns the union data inside the PartSummary as a RunnableSummary
func (t PartSummary) AsRunnableSummary() (RunnableSummary, error) {
	var body RunnableSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunnableSummary overwrites any union data inside the PartSummary as the provided RunnableSummary
func (t *PartSummary) FromRunnableSummary(v RunnableSummary) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunnableSummary performs a merge with any union data inside the PartSummary, using the provided RunnableSummary
func (t *PartSummary) MergeRunnableSummary(v RunnableSummary) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PartSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PartSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capability":
		return t.AsCapabilitySummary()
	case "enhancement":
		return t.AsEnhancementSummary()
	case "feature":
		return t.AsFeatureSummary()
	case "linkable":
		return t.AsLinkableSummary()
	case "product":
		return t.AsProductSummary()
	case "runnable":
		return t.AsRunnableSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PartSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *PartSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsPartsCreateRequestCapability returns the union data inside the PartsCreateRequest as a PartsCreateRequestCapability
func (t PartsCreateRequest) AsPartsCreateRequestCapability() (PartsCreateRequestCapability, error) {
	var body PartsCreateRequestCapability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestCapability overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestCapability
func (t *PartsCreateRequest) FromPartsCreateRequestCapability(v PartsCreateRequestCapability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestCapability performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestCapability
func (t *PartsCreateRequest) MergePartsCreateRequestCapability(v PartsCreateRequestCapability) error {
	t.Type = "capability"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsCreateRequestEnhancement returns the union data inside the PartsCreateRequest as a PartsCreateRequestEnhancement
func (t PartsCreateRequest) AsPartsCreateRequestEnhancement() (PartsCreateRequestEnhancement, error) {
	var body PartsCreateRequestEnhancement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestEnhancement overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestEnhancement
func (t *PartsCreateRequest) FromPartsCreateRequestEnhancement(v PartsCreateRequestEnhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestEnhancement performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestEnhancement
func (t *PartsCreateRequest) MergePartsCreateRequestEnhancement(v PartsCreateRequestEnhancement) error {
	t.Type = "enhancement"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsCreateRequestFeature returns the union data inside the PartsCreateRequest as a PartsCreateRequestFeature
func (t PartsCreateRequest) AsPartsCreateRequestFeature() (PartsCreateRequestFeature, error) {
	var body PartsCreateRequestFeature
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestFeature overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestFeature
func (t *PartsCreateRequest) FromPartsCreateRequestFeature(v PartsCreateRequestFeature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestFeature performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestFeature
func (t *PartsCreateRequest) MergePartsCreateRequestFeature(v PartsCreateRequestFeature) error {
	t.Type = "feature"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsCreateRequestLinkable returns the union data inside the PartsCreateRequest as a PartsCreateRequestLinkable
func (t PartsCreateRequest) AsPartsCreateRequestLinkable() (PartsCreateRequestLinkable, error) {
	var body PartsCreateRequestLinkable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestLinkable overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestLinkable
func (t *PartsCreateRequest) FromPartsCreateRequestLinkable(v PartsCreateRequestLinkable) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestLinkable performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestLinkable
func (t *PartsCreateRequest) MergePartsCreateRequestLinkable(v PartsCreateRequestLinkable) error {
	t.Type = "linkable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsCreateRequestProduct returns the union data inside the PartsCreateRequest as a PartsCreateRequestProduct
func (t PartsCreateRequest) AsPartsCreateRequestProduct() (PartsCreateRequestProduct, error) {
	var body PartsCreateRequestProduct
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestProduct overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestProduct
func (t *PartsCreateRequest) FromPartsCreateRequestProduct(v PartsCreateRequestProduct) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestProduct performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestProduct
func (t *PartsCreateRequest) MergePartsCreateRequestProduct(v PartsCreateRequestProduct) error {
	t.Type = "product"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsCreateRequestRunnable returns the union data inside the PartsCreateRequest as a PartsCreateRequestRunnable
func (t PartsCreateRequest) AsPartsCreateRequestRunnable() (PartsCreateRequestRunnable, error) {
	var body PartsCreateRequestRunnable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsCreateRequestRunnable overwrites any union data inside the PartsCreateRequest as the provided PartsCreateRequestRunnable
func (t *PartsCreateRequest) FromPartsCreateRequestRunnable(v PartsCreateRequestRunnable) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsCreateRequestRunnable performs a merge with any union data inside the PartsCreateRequest, using the provided PartsCreateRequestRunnable
func (t *PartsCreateRequest) MergePartsCreateRequestRunnable(v PartsCreateRequestRunnable) error {
	t.Type = "runnable"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PartsCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PartsCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capability":
		return t.AsPartsCreateRequestCapability()
	case "enhancement":
		return t.AsPartsCreateRequestEnhancement()
	case "feature":
		return t.AsPartsCreateRequestFeature()
	case "linkable":
		return t.AsPartsCreateRequestLinkable()
	case "product":
		return t.AsPartsCreateRequestProduct()
	case "runnable":
		return t.AsPartsCreateRequestRunnable()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PartsCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Artifacts != nil {
		object["artifacts"], err = json.Marshal(t.Artifacts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artifacts': %w", err)
		}
	}

	if t.CustomFields != nil {
		object["custom_fields"], err = json.Marshal(t.CustomFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_fields': %w", err)
		}
	}

	if t.CustomSchemaFragments != nil {
		object["custom_schema_fragments"], err = json.Marshal(t.CustomSchemaFragments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_fragments': %w", err)
		}
	}

	if t.CustomSchemaSpec != nil {
		object["custom_schema_spec"], err = json.Marshal(t.CustomSchemaSpec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_spec': %w", err)
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if t.Links != nil {
		object["links"], err = json.Marshal(t.Links)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'links': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["owned_by"], err = json.Marshal(t.OwnedBy)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'owned_by': %w", err)
	}

	if t.StageValidationOptions != nil {
		object["stage_validation_options"], err = json.Marshal(t.StageValidationOptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_validation_options': %w", err)
		}
	}

	if t.Tags != nil {
		object["tags"], err = json.Marshal(t.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *PartsCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["artifacts"]; found {
		err = json.Unmarshal(raw, &t.Artifacts)
		if err != nil {
			return fmt.Errorf("error reading 'artifacts': %w", err)
		}
	}

	if raw, found := object["custom_fields"]; found {
		err = json.Unmarshal(raw, &t.CustomFields)
		if err != nil {
			return fmt.Errorf("error reading 'custom_fields': %w", err)
		}
	}

	if raw, found := object["custom_schema_fragments"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaFragments)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_fragments': %w", err)
		}
	}

	if raw, found := object["custom_schema_spec"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaSpec)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_spec': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["links"]; found {
		err = json.Unmarshal(raw, &t.Links)
		if err != nil {
			return fmt.Errorf("error reading 'links': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["owned_by"]; found {
		err = json.Unmarshal(raw, &t.OwnedBy)
		if err != nil {
			return fmt.Errorf("error reading 'owned_by': %w", err)
		}
	}

	if raw, found := object["stage_validation_options"]; found {
		err = json.Unmarshal(raw, &t.StageValidationOptions)
		if err != nil {
			return fmt.Errorf("error reading 'stage_validation_options': %w", err)
		}
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &t.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsEmpty returns the union data inside the PartsUpdateRequest as a Empty
func (t PartsUpdateRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the PartsUpdateRequest as the provided Empty
func (t *PartsUpdateRequest) FromEmpty(v Empty) error {
	t.Type = func() *PartType { v := PartType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the PartsUpdateRequest, using the provided Empty
func (t *PartsUpdateRequest) MergeEmpty(v Empty) error {
	t.Type = func() *PartType { v := PartType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestCapability returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestCapability
func (t PartsUpdateRequest) AsPartsUpdateRequestCapability() (PartsUpdateRequestCapability, error) {
	var body PartsUpdateRequestCapability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestCapability overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestCapability
func (t *PartsUpdateRequest) FromPartsUpdateRequestCapability(v PartsUpdateRequestCapability) error {
	t.Type = func() *PartType { v := PartType("capability"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestCapability performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestCapability
func (t *PartsUpdateRequest) MergePartsUpdateRequestCapability(v PartsUpdateRequestCapability) error {
	t.Type = func() *PartType { v := PartType("capability"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestEnhancement returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestEnhancement
func (t PartsUpdateRequest) AsPartsUpdateRequestEnhancement() (PartsUpdateRequestEnhancement, error) {
	var body PartsUpdateRequestEnhancement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestEnhancement overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestEnhancement
func (t *PartsUpdateRequest) FromPartsUpdateRequestEnhancement(v PartsUpdateRequestEnhancement) error {
	t.Type = func() *PartType { v := PartType("enhancement"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestEnhancement performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestEnhancement
func (t *PartsUpdateRequest) MergePartsUpdateRequestEnhancement(v PartsUpdateRequestEnhancement) error {
	t.Type = func() *PartType { v := PartType("enhancement"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestFeature returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestFeature
func (t PartsUpdateRequest) AsPartsUpdateRequestFeature() (PartsUpdateRequestFeature, error) {
	var body PartsUpdateRequestFeature
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestFeature overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestFeature
func (t *PartsUpdateRequest) FromPartsUpdateRequestFeature(v PartsUpdateRequestFeature) error {
	t.Type = func() *PartType { v := PartType("feature"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestFeature performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestFeature
func (t *PartsUpdateRequest) MergePartsUpdateRequestFeature(v PartsUpdateRequestFeature) error {
	t.Type = func() *PartType { v := PartType("feature"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestLinkable returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestLinkable
func (t PartsUpdateRequest) AsPartsUpdateRequestLinkable() (PartsUpdateRequestLinkable, error) {
	var body PartsUpdateRequestLinkable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestLinkable overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestLinkable
func (t *PartsUpdateRequest) FromPartsUpdateRequestLinkable(v PartsUpdateRequestLinkable) error {
	t.Type = func() *PartType { v := PartType("linkable"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestLinkable performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestLinkable
func (t *PartsUpdateRequest) MergePartsUpdateRequestLinkable(v PartsUpdateRequestLinkable) error {
	t.Type = func() *PartType { v := PartType("linkable"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestProduct returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestProduct
func (t PartsUpdateRequest) AsPartsUpdateRequestProduct() (PartsUpdateRequestProduct, error) {
	var body PartsUpdateRequestProduct
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestProduct overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestProduct
func (t *PartsUpdateRequest) FromPartsUpdateRequestProduct(v PartsUpdateRequestProduct) error {
	t.Type = func() *PartType { v := PartType("product"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestProduct performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestProduct
func (t *PartsUpdateRequest) MergePartsUpdateRequestProduct(v PartsUpdateRequestProduct) error {
	t.Type = func() *PartType { v := PartType("product"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartsUpdateRequestRunnable returns the union data inside the PartsUpdateRequest as a PartsUpdateRequestRunnable
func (t PartsUpdateRequest) AsPartsUpdateRequestRunnable() (PartsUpdateRequestRunnable, error) {
	var body PartsUpdateRequestRunnable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartsUpdateRequestRunnable overwrites any union data inside the PartsUpdateRequest as the provided PartsUpdateRequestRunnable
func (t *PartsUpdateRequest) FromPartsUpdateRequestRunnable(v PartsUpdateRequestRunnable) error {
	t.Type = func() *PartType { v := PartType("runnable"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartsUpdateRequestRunnable performs a merge with any union data inside the PartsUpdateRequest, using the provided PartsUpdateRequestRunnable
func (t *PartsUpdateRequest) MergePartsUpdateRequestRunnable(v PartsUpdateRequestRunnable) error {
	t.Type = func() *PartType { v := PartType("runnable"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PartsUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PartsUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capability":
		return t.AsPartsUpdateRequestCapability()
	case "enhancement":
		return t.AsPartsUpdateRequestEnhancement()
	case "feature":
		return t.AsPartsUpdateRequestFeature()
	case "linkable":
		return t.AsPartsUpdateRequestLinkable()
	case "none":
		return t.AsEmpty()
	case "product":
		return t.AsPartsUpdateRequestProduct()
	case "runnable":
		return t.AsPartsUpdateRequestRunnable()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PartsUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Artifacts != nil {
		object["artifacts"], err = json.Marshal(t.Artifacts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artifacts': %w", err)
		}
	}

	if t.CustomFields != nil {
		object["custom_fields"], err = json.Marshal(t.CustomFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_fields': %w", err)
		}
	}

	if t.CustomSchemaFragments != nil {
		object["custom_schema_fragments"], err = json.Marshal(t.CustomSchemaFragments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_fragments': %w", err)
		}
	}

	if t.CustomSchemaSpec != nil {
		object["custom_schema_spec"], err = json.Marshal(t.CustomSchemaSpec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_spec': %w", err)
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Name != nil {
		object["name"], err = json.Marshal(t.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if t.OwnedBy != nil {
		object["owned_by"], err = json.Marshal(t.OwnedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owned_by': %w", err)
		}
	}

	if t.StageValidationOptions != nil {
		object["stage_validation_options"], err = json.Marshal(t.StageValidationOptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_validation_options': %w", err)
		}
	}

	if t.Tags != nil {
		object["tags"], err = json.Marshal(t.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *PartsUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["artifacts"]; found {
		err = json.Unmarshal(raw, &t.Artifacts)
		if err != nil {
			return fmt.Errorf("error reading 'artifacts': %w", err)
		}
	}

	if raw, found := object["custom_fields"]; found {
		err = json.Unmarshal(raw, &t.CustomFields)
		if err != nil {
			return fmt.Errorf("error reading 'custom_fields': %w", err)
		}
	}

	if raw, found := object["custom_schema_fragments"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaFragments)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_fragments': %w", err)
		}
	}

	if raw, found := object["custom_schema_spec"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaSpec)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_spec': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["owned_by"]; found {
		err = json.Unmarshal(raw, &t.OwnedBy)
		if err != nil {
			return fmt.Errorf("error reading 'owned_by': %w", err)
		}
	}

	if raw, found := object["stage_validation_options"]; found {
		err = json.Unmarshal(raw, &t.StageValidationOptions)
		if err != nil {
			return fmt.Errorf("error reading 'stage_validation_options': %w", err)
		}
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &t.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsUserPreferences returns the union data inside the Preferences as a UserPreferences
func (t Preferences) AsUserPreferences() (UserPreferences, error) {
	var body UserPreferences
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserPreferences overwrites any union data inside the Preferences as the provided UserPreferences
func (t *Preferences) FromUserPreferences(v UserPreferences) error {
	t.Type = "user_preferences"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserPreferences performs a merge with any union data inside the Preferences, using the provided UserPreferences
func (t *Preferences) MergeUserPreferences(v UserPreferences) error {
	t.Type = "user_preferences"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Preferences) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Preferences) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "user_preferences":
		return t.AsUserPreferences()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Preferences) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Preferences) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsUpdateUserPreferences returns the union data inside the PreferencesUpdateRequest as a UpdateUserPreferences
func (t PreferencesUpdateRequest) AsUpdateUserPreferences() (UpdateUserPreferences, error) {
	var body UpdateUserPreferences
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateUserPreferences overwrites any union data inside the PreferencesUpdateRequest as the provided UpdateUserPreferences
func (t *PreferencesUpdateRequest) FromUpdateUserPreferences(v UpdateUserPreferences) error {
	t.Type = "user_preferences"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateUserPreferences performs a merge with any union data inside the PreferencesUpdateRequest, using the provided UpdateUserPreferences
func (t *PreferencesUpdateRequest) MergeUpdateUserPreferences(v UpdateUserPreferences) error {
	t.Type = "user_preferences"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PreferencesUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PreferencesUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "user_preferences":
		return t.AsUpdateUserPreferences()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PreferencesUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.LanguageCode != nil {
		object["language_code"], err = json.Marshal(t.LanguageCode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'language_code': %w", err)
		}
	}

	object["object"], err = json.Marshal(t.Object)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'object': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *PreferencesUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["language_code"]; found {
		err = json.Unmarshal(raw, &t.LanguageCode)
		if err != nil {
			return fmt.Errorf("error reading 'language_code': %w", err)
		}
	}

	if raw, found := object["object"]; found {
		err = json.Unmarshal(raw, &t.Object)
		if err != nil {
			return fmt.Errorf("error reading 'object': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsSchemaBoolFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaBoolFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaBoolFieldDescriptor() (SchemaBoolFieldDescriptor, error) {
	var body SchemaBoolFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaBoolFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaBoolFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaBoolFieldDescriptor(v SchemaBoolFieldDescriptor) error {
	t.FieldType = "bool"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaBoolFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaBoolFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaBoolFieldDescriptor(v SchemaBoolFieldDescriptor) error {
	t.FieldType = "bool"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaCompositeFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaCompositeFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaCompositeFieldDescriptor() (SchemaCompositeFieldDescriptor, error) {
	var body SchemaCompositeFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaCompositeFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaCompositeFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaCompositeFieldDescriptor(v SchemaCompositeFieldDescriptor) error {
	t.FieldType = "composite"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaCompositeFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaCompositeFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaCompositeFieldDescriptor(v SchemaCompositeFieldDescriptor) error {
	t.FieldType = "composite"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaDateFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaDateFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaDateFieldDescriptor() (SchemaDateFieldDescriptor, error) {
	var body SchemaDateFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaDateFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaDateFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaDateFieldDescriptor(v SchemaDateFieldDescriptor) error {
	t.FieldType = "date"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaDateFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaDateFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaDateFieldDescriptor(v SchemaDateFieldDescriptor) error {
	t.FieldType = "date"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaDoubleFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaDoubleFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaDoubleFieldDescriptor() (SchemaDoubleFieldDescriptor, error) {
	var body SchemaDoubleFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaDoubleFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaDoubleFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaDoubleFieldDescriptor(v SchemaDoubleFieldDescriptor) error {
	t.FieldType = "double"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaDoubleFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaDoubleFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaDoubleFieldDescriptor(v SchemaDoubleFieldDescriptor) error {
	t.FieldType = "double"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaEnumFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaEnumFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaEnumFieldDescriptor() (SchemaEnumFieldDescriptor, error) {
	var body SchemaEnumFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaEnumFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaEnumFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaEnumFieldDescriptor(v SchemaEnumFieldDescriptor) error {
	t.FieldType = "enum"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaEnumFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaEnumFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaEnumFieldDescriptor(v SchemaEnumFieldDescriptor) error {
	t.FieldType = "enum"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaFieldDescriptorArrayType returns the union data inside the SchemaFieldDescriptor as a SchemaFieldDescriptorArrayType
func (t SchemaFieldDescriptor) AsSchemaFieldDescriptorArrayType() (SchemaFieldDescriptorArrayType, error) {
	var body SchemaFieldDescriptorArrayType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaFieldDescriptorArrayType overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaFieldDescriptorArrayType
func (t *SchemaFieldDescriptor) FromSchemaFieldDescriptorArrayType(v SchemaFieldDescriptorArrayType) error {
	t.FieldType = "array"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaFieldDescriptorArrayType performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaFieldDescriptorArrayType
func (t *SchemaFieldDescriptor) MergeSchemaFieldDescriptorArrayType(v SchemaFieldDescriptorArrayType) error {
	t.FieldType = "array"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaIdFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaIdFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaIdFieldDescriptor() (SchemaIdFieldDescriptor, error) {
	var body SchemaIdFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaIdFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaIdFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaIdFieldDescriptor(v SchemaIdFieldDescriptor) error {
	t.FieldType = "id"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaIdFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaIdFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaIdFieldDescriptor(v SchemaIdFieldDescriptor) error {
	t.FieldType = "id"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaIntFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaIntFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaIntFieldDescriptor() (SchemaIntFieldDescriptor, error) {
	var body SchemaIntFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaIntFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaIntFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaIntFieldDescriptor(v SchemaIntFieldDescriptor) error {
	t.FieldType = "int"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaIntFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaIntFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaIntFieldDescriptor(v SchemaIntFieldDescriptor) error {
	t.FieldType = "int"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaJsonValueFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaJsonValueFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaJsonValueFieldDescriptor() (SchemaJsonValueFieldDescriptor, error) {
	var body SchemaJsonValueFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaJsonValueFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaJsonValueFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaJsonValueFieldDescriptor(v SchemaJsonValueFieldDescriptor) error {
	t.FieldType = "json_value"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaJsonValueFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaJsonValueFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaJsonValueFieldDescriptor(v SchemaJsonValueFieldDescriptor) error {
	t.FieldType = "json_value"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaRichTextFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaRichTextFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaRichTextFieldDescriptor() (SchemaRichTextFieldDescriptor, error) {
	var body SchemaRichTextFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaRichTextFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaRichTextFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaRichTextFieldDescriptor(v SchemaRichTextFieldDescriptor) error {
	t.FieldType = "rich_text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaRichTextFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaRichTextFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaRichTextFieldDescriptor(v SchemaRichTextFieldDescriptor) error {
	t.FieldType = "rich_text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaStructFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaStructFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaStructFieldDescriptor() (SchemaStructFieldDescriptor, error) {
	var body SchemaStructFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaStructFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaStructFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaStructFieldDescriptor(v SchemaStructFieldDescriptor) error {
	t.FieldType = "struct"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaStructFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaStructFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaStructFieldDescriptor(v SchemaStructFieldDescriptor) error {
	t.FieldType = "struct"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTextFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaTextFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaTextFieldDescriptor() (SchemaTextFieldDescriptor, error) {
	var body SchemaTextFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTextFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaTextFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaTextFieldDescriptor(v SchemaTextFieldDescriptor) error {
	t.FieldType = "text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTextFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaTextFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaTextFieldDescriptor(v SchemaTextFieldDescriptor) error {
	t.FieldType = "text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTimestampFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaTimestampFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaTimestampFieldDescriptor() (SchemaTimestampFieldDescriptor, error) {
	var body SchemaTimestampFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTimestampFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaTimestampFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaTimestampFieldDescriptor(v SchemaTimestampFieldDescriptor) error {
	t.FieldType = "timestamp"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTimestampFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaTimestampFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaTimestampFieldDescriptor(v SchemaTimestampFieldDescriptor) error {
	t.FieldType = "timestamp"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTokensFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaTokensFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaTokensFieldDescriptor() (SchemaTokensFieldDescriptor, error) {
	var body SchemaTokensFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTokensFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaTokensFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaTokensFieldDescriptor(v SchemaTokensFieldDescriptor) error {
	t.FieldType = "tokens"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTokensFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaTokensFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaTokensFieldDescriptor(v SchemaTokensFieldDescriptor) error {
	t.FieldType = "tokens"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaUenumFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaUenumFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaUenumFieldDescriptor() (SchemaUenumFieldDescriptor, error) {
	var body SchemaUenumFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaUenumFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaUenumFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaUenumFieldDescriptor(v SchemaUenumFieldDescriptor) error {
	t.FieldType = "uenum"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaUenumFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaUenumFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaUenumFieldDescriptor(v SchemaUenumFieldDescriptor) error {
	t.FieldType = "uenum"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaUnknownFieldDescriptor returns the union data inside the SchemaFieldDescriptor as a SchemaUnknownFieldDescriptor
func (t SchemaFieldDescriptor) AsSchemaUnknownFieldDescriptor() (SchemaUnknownFieldDescriptor, error) {
	var body SchemaUnknownFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaUnknownFieldDescriptor overwrites any union data inside the SchemaFieldDescriptor as the provided SchemaUnknownFieldDescriptor
func (t *SchemaFieldDescriptor) FromSchemaUnknownFieldDescriptor(v SchemaUnknownFieldDescriptor) error {
	t.FieldType = "unknown"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaUnknownFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptor, using the provided SchemaUnknownFieldDescriptor
func (t *SchemaFieldDescriptor) MergeSchemaUnknownFieldDescriptor(v SchemaUnknownFieldDescriptor) error {
	t.FieldType = "unknown"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchemaFieldDescriptor) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"field_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SchemaFieldDescriptor) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "array":
		return t.AsSchemaFieldDescriptorArrayType()
	case "bool":
		return t.AsSchemaBoolFieldDescriptor()
	case "composite":
		return t.AsSchemaCompositeFieldDescriptor()
	case "date":
		return t.AsSchemaDateFieldDescriptor()
	case "double":
		return t.AsSchemaDoubleFieldDescriptor()
	case "enum":
		return t.AsSchemaEnumFieldDescriptor()
	case "id":
		return t.AsSchemaIdFieldDescriptor()
	case "int":
		return t.AsSchemaIntFieldDescriptor()
	case "json_value":
		return t.AsSchemaJsonValueFieldDescriptor()
	case "rich_text":
		return t.AsSchemaRichTextFieldDescriptor()
	case "struct":
		return t.AsSchemaStructFieldDescriptor()
	case "text":
		return t.AsSchemaTextFieldDescriptor()
	case "timestamp":
		return t.AsSchemaTimestampFieldDescriptor()
	case "tokens":
		return t.AsSchemaTokensFieldDescriptor()
	case "uenum":
		return t.AsSchemaUenumFieldDescriptor()
	case "unknown":
		return t.AsSchemaUnknownFieldDescriptor()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SchemaFieldDescriptor) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["field_type"], err = json.Marshal(t.FieldType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'field_type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SchemaFieldDescriptor) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["field_type"]; found {
		err = json.Unmarshal(raw, &t.FieldType)
		if err != nil {
			return fmt.Errorf("error reading 'field_type': %w", err)
		}
	}

	return err
}

// AsSchemaBoolListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaBoolListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaBoolListFieldDescriptor() (SchemaBoolListFieldDescriptor, error) {
	var body SchemaBoolListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaBoolListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaBoolListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaBoolListFieldDescriptor(v SchemaBoolListFieldDescriptor) error {
	t.BaseType = "bool"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaBoolListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaBoolListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaBoolListFieldDescriptor(v SchemaBoolListFieldDescriptor) error {
	t.BaseType = "bool"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaCompositeListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaCompositeListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaCompositeListFieldDescriptor() (SchemaCompositeListFieldDescriptor, error) {
	var body SchemaCompositeListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaCompositeListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaCompositeListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaCompositeListFieldDescriptor(v SchemaCompositeListFieldDescriptor) error {
	t.BaseType = "composite"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaCompositeListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaCompositeListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaCompositeListFieldDescriptor(v SchemaCompositeListFieldDescriptor) error {
	t.BaseType = "composite"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaDateListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaDateListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaDateListFieldDescriptor() (SchemaDateListFieldDescriptor, error) {
	var body SchemaDateListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaDateListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaDateListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaDateListFieldDescriptor(v SchemaDateListFieldDescriptor) error {
	t.BaseType = "date"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaDateListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaDateListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaDateListFieldDescriptor(v SchemaDateListFieldDescriptor) error {
	t.BaseType = "date"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaDoubleListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaDoubleListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaDoubleListFieldDescriptor() (SchemaDoubleListFieldDescriptor, error) {
	var body SchemaDoubleListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaDoubleListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaDoubleListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaDoubleListFieldDescriptor(v SchemaDoubleListFieldDescriptor) error {
	t.BaseType = "double"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaDoubleListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaDoubleListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaDoubleListFieldDescriptor(v SchemaDoubleListFieldDescriptor) error {
	t.BaseType = "double"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaEnumListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaEnumListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaEnumListFieldDescriptor() (SchemaEnumListFieldDescriptor, error) {
	var body SchemaEnumListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaEnumListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaEnumListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaEnumListFieldDescriptor(v SchemaEnumListFieldDescriptor) error {
	t.BaseType = "enum"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaEnumListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaEnumListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaEnumListFieldDescriptor(v SchemaEnumListFieldDescriptor) error {
	t.BaseType = "enum"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaIdListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaIdListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaIdListFieldDescriptor() (SchemaIdListFieldDescriptor, error) {
	var body SchemaIdListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaIdListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaIdListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaIdListFieldDescriptor(v SchemaIdListFieldDescriptor) error {
	t.BaseType = "id"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaIdListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaIdListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaIdListFieldDescriptor(v SchemaIdListFieldDescriptor) error {
	t.BaseType = "id"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaIntListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaIntListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaIntListFieldDescriptor() (SchemaIntListFieldDescriptor, error) {
	var body SchemaIntListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaIntListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaIntListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaIntListFieldDescriptor(v SchemaIntListFieldDescriptor) error {
	t.BaseType = "int"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaIntListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaIntListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaIntListFieldDescriptor(v SchemaIntListFieldDescriptor) error {
	t.BaseType = "int"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaJsonValueListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaJsonValueListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaJsonValueListFieldDescriptor() (SchemaJsonValueListFieldDescriptor, error) {
	var body SchemaJsonValueListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaJsonValueListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaJsonValueListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaJsonValueListFieldDescriptor(v SchemaJsonValueListFieldDescriptor) error {
	t.BaseType = "json_value"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaJsonValueListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaJsonValueListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaJsonValueListFieldDescriptor(v SchemaJsonValueListFieldDescriptor) error {
	t.BaseType = "json_value"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaRichTextListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaRichTextListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaRichTextListFieldDescriptor() (SchemaRichTextListFieldDescriptor, error) {
	var body SchemaRichTextListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaRichTextListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaRichTextListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaRichTextListFieldDescriptor(v SchemaRichTextListFieldDescriptor) error {
	t.BaseType = "rich_text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaRichTextListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaRichTextListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaRichTextListFieldDescriptor(v SchemaRichTextListFieldDescriptor) error {
	t.BaseType = "rich_text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaStructListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaStructListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaStructListFieldDescriptor() (SchemaStructListFieldDescriptor, error) {
	var body SchemaStructListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaStructListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaStructListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaStructListFieldDescriptor(v SchemaStructListFieldDescriptor) error {
	t.BaseType = "struct"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaStructListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaStructListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaStructListFieldDescriptor(v SchemaStructListFieldDescriptor) error {
	t.BaseType = "struct"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTextListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaTextListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaTextListFieldDescriptor() (SchemaTextListFieldDescriptor, error) {
	var body SchemaTextListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTextListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaTextListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaTextListFieldDescriptor(v SchemaTextListFieldDescriptor) error {
	t.BaseType = "text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTextListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaTextListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaTextListFieldDescriptor(v SchemaTextListFieldDescriptor) error {
	t.BaseType = "text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTimestampListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaTimestampListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaTimestampListFieldDescriptor() (SchemaTimestampListFieldDescriptor, error) {
	var body SchemaTimestampListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTimestampListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaTimestampListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaTimestampListFieldDescriptor(v SchemaTimestampListFieldDescriptor) error {
	t.BaseType = "timestamp"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTimestampListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaTimestampListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaTimestampListFieldDescriptor(v SchemaTimestampListFieldDescriptor) error {
	t.BaseType = "timestamp"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaTokensListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaTokensListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaTokensListFieldDescriptor() (SchemaTokensListFieldDescriptor, error) {
	var body SchemaTokensListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaTokensListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaTokensListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaTokensListFieldDescriptor(v SchemaTokensListFieldDescriptor) error {
	t.BaseType = "tokens"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaTokensListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaTokensListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaTokensListFieldDescriptor(v SchemaTokensListFieldDescriptor) error {
	t.BaseType = "tokens"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaUenumListFieldDescriptor returns the union data inside the SchemaFieldDescriptorArrayType as a SchemaUenumListFieldDescriptor
func (t SchemaFieldDescriptorArrayType) AsSchemaUenumListFieldDescriptor() (SchemaUenumListFieldDescriptor, error) {
	var body SchemaUenumListFieldDescriptor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaUenumListFieldDescriptor overwrites any union data inside the SchemaFieldDescriptorArrayType as the provided SchemaUenumListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) FromSchemaUenumListFieldDescriptor(v SchemaUenumListFieldDescriptor) error {
	t.BaseType = "uenum"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaUenumListFieldDescriptor performs a merge with any union data inside the SchemaFieldDescriptorArrayType, using the provided SchemaUenumListFieldDescriptor
func (t *SchemaFieldDescriptorArrayType) MergeSchemaUenumListFieldDescriptor(v SchemaUenumListFieldDescriptor) error {
	t.BaseType = "uenum"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchemaFieldDescriptorArrayType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"base_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SchemaFieldDescriptorArrayType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "bool":
		return t.AsSchemaBoolListFieldDescriptor()
	case "composite":
		return t.AsSchemaCompositeListFieldDescriptor()
	case "date":
		return t.AsSchemaDateListFieldDescriptor()
	case "double":
		return t.AsSchemaDoubleListFieldDescriptor()
	case "enum":
		return t.AsSchemaEnumListFieldDescriptor()
	case "id":
		return t.AsSchemaIdListFieldDescriptor()
	case "int":
		return t.AsSchemaIntListFieldDescriptor()
	case "json_value":
		return t.AsSchemaJsonValueListFieldDescriptor()
	case "rich_text":
		return t.AsSchemaRichTextListFieldDescriptor()
	case "struct":
		return t.AsSchemaStructListFieldDescriptor()
	case "text":
		return t.AsSchemaTextListFieldDescriptor()
	case "timestamp":
		return t.AsSchemaTimestampListFieldDescriptor()
	case "tokens":
		return t.AsSchemaTokensListFieldDescriptor()
	case "uenum":
		return t.AsSchemaUenumListFieldDescriptor()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SchemaFieldDescriptorArrayType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["base_type"], err = json.Marshal(t.BaseType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'base_type': %w", err)
	}

	if t.EqItems != nil {
		object["eq_items"], err = json.Marshal(t.EqItems)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'eq_items': %w", err)
		}
	}

	if t.MaxItems != nil {
		object["max_items"], err = json.Marshal(t.MaxItems)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_items': %w", err)
		}
	}

	if t.MinItems != nil {
		object["min_items"], err = json.Marshal(t.MinItems)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'min_items': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *SchemaFieldDescriptorArrayType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["base_type"]; found {
		err = json.Unmarshal(raw, &t.BaseType)
		if err != nil {
			return fmt.Errorf("error reading 'base_type': %w", err)
		}
	}

	if raw, found := object["eq_items"]; found {
		err = json.Unmarshal(raw, &t.EqItems)
		if err != nil {
			return fmt.Errorf("error reading 'eq_items': %w", err)
		}
	}

	if raw, found := object["max_items"]; found {
		err = json.Unmarshal(raw, &t.MaxItems)
		if err != nil {
			return fmt.Errorf("error reading 'max_items': %w", err)
		}
	}

	if raw, found := object["min_items"]; found {
		err = json.Unmarshal(raw, &t.MinItems)
		if err != nil {
			return fmt.Errorf("error reading 'min_items': %w", err)
		}
	}

	return err
}

// AsAccountSearchSummary returns the union data inside the SearchResult as a AccountSearchSummary
func (t SearchResult) AsAccountSearchSummary() (AccountSearchSummary, error) {
	var body AccountSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccountSearchSummary overwrites any union data inside the SearchResult as the provided AccountSearchSummary
func (t *SearchResult) FromAccountSearchSummary(v AccountSearchSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccountSearchSummary performs a merge with any union data inside the SearchResult, using the provided AccountSearchSummary
func (t *SearchResult) MergeAccountSearchSummary(v AccountSearchSummary) error {
	t.Type = "account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArticleSearchSummary returns the union data inside the SearchResult as a ArticleSearchSummary
func (t SearchResult) AsArticleSearchSummary() (ArticleSearchSummary, error) {
	var body ArticleSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArticleSearchSummary overwrites any union data inside the SearchResult as the provided ArticleSearchSummary
func (t *SearchResult) FromArticleSearchSummary(v ArticleSearchSummary) error {
	t.Type = "article"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArticleSearchSummary performs a merge with any union data inside the SearchResult, using the provided ArticleSearchSummary
func (t *SearchResult) MergeArticleSearchSummary(v ArticleSearchSummary) error {
	t.Type = "article"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArtifactSearchSummary returns the union data inside the SearchResult as a ArtifactSearchSummary
func (t SearchResult) AsArtifactSearchSummary() (ArtifactSearchSummary, error) {
	var body ArtifactSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArtifactSearchSummary overwrites any union data inside the SearchResult as the provided ArtifactSearchSummary
func (t *SearchResult) FromArtifactSearchSummary(v ArtifactSearchSummary) error {
	t.Type = "artifact"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArtifactSearchSummary performs a merge with any union data inside the SearchResult, using the provided ArtifactSearchSummary
func (t *SearchResult) MergeArtifactSearchSummary(v ArtifactSearchSummary) error {
	t.Type = "artifact"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConversationSearchSummary returns the union data inside the SearchResult as a ConversationSearchSummary
func (t SearchResult) AsConversationSearchSummary() (ConversationSearchSummary, error) {
	var body ConversationSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConversationSearchSummary overwrites any union data inside the SearchResult as the provided ConversationSearchSummary
func (t *SearchResult) FromConversationSearchSummary(v ConversationSearchSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConversationSearchSummary performs a merge with any union data inside the SearchResult, using the provided ConversationSearchSummary
func (t *SearchResult) MergeConversationSearchSummary(v ConversationSearchSummary) error {
	t.Type = "conversation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomObjectSearchSummary returns the union data inside the SearchResult as a CustomObjectSearchSummary
func (t SearchResult) AsCustomObjectSearchSummary() (CustomObjectSearchSummary, error) {
	var body CustomObjectSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomObjectSearchSummary overwrites any union data inside the SearchResult as the provided CustomObjectSearchSummary
func (t *SearchResult) FromCustomObjectSearchSummary(v CustomObjectSearchSummary) error {
	t.Type = "custom_object"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomObjectSearchSummary performs a merge with any union data inside the SearchResult, using the provided CustomObjectSearchSummary
func (t *SearchResult) MergeCustomObjectSearchSummary(v CustomObjectSearchSummary) error {
	t.Type = "custom_object"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDashboardSearchSummary returns the union data inside the SearchResult as a DashboardSearchSummary
func (t SearchResult) AsDashboardSearchSummary() (DashboardSearchSummary, error) {
	var body DashboardSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDashboardSearchSummary overwrites any union data inside the SearchResult as the provided DashboardSearchSummary
func (t *SearchResult) FromDashboardSearchSummary(v DashboardSearchSummary) error {
	t.Type = "dashboard"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDashboardSearchSummary performs a merge with any union data inside the SearchResult, using the provided DashboardSearchSummary
func (t *SearchResult) MergeDashboardSearchSummary(v DashboardSearchSummary) error {
	t.Type = "dashboard"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroupSearchSummary returns the union data inside the SearchResult as a GroupSearchSummary
func (t SearchResult) AsGroupSearchSummary() (GroupSearchSummary, error) {
	var body GroupSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroupSearchSummary overwrites any union data inside the SearchResult as the provided GroupSearchSummary
func (t *SearchResult) FromGroupSearchSummary(v GroupSearchSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroupSearchSummary performs a merge with any union data inside the SearchResult, using the provided GroupSearchSummary
func (t *SearchResult) MergeGroupSearchSummary(v GroupSearchSummary) error {
	t.Type = "group"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkSearchSummary returns the union data inside the SearchResult as a LinkSearchSummary
func (t SearchResult) AsLinkSearchSummary() (LinkSearchSummary, error) {
	var body LinkSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkSearchSummary overwrites any union data inside the SearchResult as the provided LinkSearchSummary
func (t *SearchResult) FromLinkSearchSummary(v LinkSearchSummary) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkSearchSummary performs a merge with any union data inside the SearchResult, using the provided LinkSearchSummary
func (t *SearchResult) MergeLinkSearchSummary(v LinkSearchSummary) error {
	t.Type = "link"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsObjectMemberSearchSummary returns the union data inside the SearchResult as a ObjectMemberSearchSummary
func (t SearchResult) AsObjectMemberSearchSummary() (ObjectMemberSearchSummary, error) {
	var body ObjectMemberSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObjectMemberSearchSummary overwrites any union data inside the SearchResult as the provided ObjectMemberSearchSummary
func (t *SearchResult) FromObjectMemberSearchSummary(v ObjectMemberSearchSummary) error {
	t.Type = "object_member"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObjectMemberSearchSummary performs a merge with any union data inside the SearchResult, using the provided ObjectMemberSearchSummary
func (t *SearchResult) MergeObjectMemberSearchSummary(v ObjectMemberSearchSummary) error {
	t.Type = "object_member"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOperationSearchSummary returns the union data inside the SearchResult as a OperationSearchSummary
func (t SearchResult) AsOperationSearchSummary() (OperationSearchSummary, error) {
	var body OperationSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationSearchSummary overwrites any union data inside the SearchResult as the provided OperationSearchSummary
func (t *SearchResult) FromOperationSearchSummary(v OperationSearchSummary) error {
	t.Type = "operation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationSearchSummary performs a merge with any union data inside the SearchResult, using the provided OperationSearchSummary
func (t *SearchResult) MergeOperationSearchSummary(v OperationSearchSummary) error {
	t.Type = "operation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgSearchSummary returns the union data inside the SearchResult as a OrgSearchSummary
func (t SearchResult) AsOrgSearchSummary() (OrgSearchSummary, error) {
	var body OrgSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgSearchSummary overwrites any union data inside the SearchResult as the provided OrgSearchSummary
func (t *SearchResult) FromOrgSearchSummary(v OrgSearchSummary) error {
	t.Type = "org"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgSearchSummary performs a merge with any union data inside the SearchResult, using the provided OrgSearchSummary
func (t *SearchResult) MergeOrgSearchSummary(v OrgSearchSummary) error {
	t.Type = "org"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartSearchSummary returns the union data inside the SearchResult as a PartSearchSummary
func (t SearchResult) AsPartSearchSummary() (PartSearchSummary, error) {
	var body PartSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartSearchSummary overwrites any union data inside the SearchResult as the provided PartSearchSummary
func (t *SearchResult) FromPartSearchSummary(v PartSearchSummary) error {
	t.Type = "part"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartSearchSummary performs a merge with any union data inside the SearchResult, using the provided PartSearchSummary
func (t *SearchResult) MergePartSearchSummary(v PartSearchSummary) error {
	t.Type = "part"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionAnswerSearchSummary returns the union data inside the SearchResult as a QuestionAnswerSearchSummary
func (t SearchResult) AsQuestionAnswerSearchSummary() (QuestionAnswerSearchSummary, error) {
	var body QuestionAnswerSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionAnswerSearchSummary overwrites any union data inside the SearchResult as the provided QuestionAnswerSearchSummary
func (t *SearchResult) FromQuestionAnswerSearchSummary(v QuestionAnswerSearchSummary) error {
	t.Type = "question_answer"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionAnswerSearchSummary performs a merge with any union data inside the SearchResult, using the provided QuestionAnswerSearchSummary
func (t *SearchResult) MergeQuestionAnswerSearchSummary(v QuestionAnswerSearchSummary) error {
	t.Type = "question_answer"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTagSearchSummary returns the union data inside the SearchResult as a TagSearchSummary
func (t SearchResult) AsTagSearchSummary() (TagSearchSummary, error) {
	var body TagSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTagSearchSummary overwrites any union data inside the SearchResult as the provided TagSearchSummary
func (t *SearchResult) FromTagSearchSummary(v TagSearchSummary) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTagSearchSummary performs a merge with any union data inside the SearchResult, using the provided TagSearchSummary
func (t *SearchResult) MergeTagSearchSummary(v TagSearchSummary) error {
	t.Type = "tag"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserSearchSummary returns the union data inside the SearchResult as a UserSearchSummary
func (t SearchResult) AsUserSearchSummary() (UserSearchSummary, error) {
	var body UserSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSearchSummary overwrites any union data inside the SearchResult as the provided UserSearchSummary
func (t *SearchResult) FromUserSearchSummary(v UserSearchSummary) error {
	t.Type = "user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSearchSummary performs a merge with any union data inside the SearchResult, using the provided UserSearchSummary
func (t *SearchResult) MergeUserSearchSummary(v UserSearchSummary) error {
	t.Type = "user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVistaSearchSummary returns the union data inside the SearchResult as a VistaSearchSummary
func (t SearchResult) AsVistaSearchSummary() (VistaSearchSummary, error) {
	var body VistaSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVistaSearchSummary overwrites any union data inside the SearchResult as the provided VistaSearchSummary
func (t *SearchResult) FromVistaSearchSummary(v VistaSearchSummary) error {
	t.Type = "vista"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVistaSearchSummary performs a merge with any union data inside the SearchResult, using the provided VistaSearchSummary
func (t *SearchResult) MergeVistaSearchSummary(v VistaSearchSummary) error {
	t.Type = "vista"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkSearchSummary returns the union data inside the SearchResult as a WorkSearchSummary
func (t SearchResult) AsWorkSearchSummary() (WorkSearchSummary, error) {
	var body WorkSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkSearchSummary overwrites any union data inside the SearchResult as the provided WorkSearchSummary
func (t *SearchResult) FromWorkSearchSummary(v WorkSearchSummary) error {
	t.Type = "work"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkSearchSummary performs a merge with any union data inside the SearchResult, using the provided WorkSearchSummary
func (t *SearchResult) MergeWorkSearchSummary(v WorkSearchSummary) error {
	t.Type = "work"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowSearchSummary returns the union data inside the SearchResult as a WorkflowSearchSummary
func (t SearchResult) AsWorkflowSearchSummary() (WorkflowSearchSummary, error) {
	var body WorkflowSearchSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowSearchSummary overwrites any union data inside the SearchResult as the provided WorkflowSearchSummary
func (t *SearchResult) FromWorkflowSearchSummary(v WorkflowSearchSummary) error {
	t.Type = "workflow"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowSearchSummary performs a merge with any union data inside the SearchResult, using the provided WorkflowSearchSummary
func (t *SearchResult) MergeWorkflowSearchSummary(v WorkflowSearchSummary) error {
	t.Type = "workflow"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SearchResult) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SearchResult) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "account":
		return t.AsAccountSearchSummary()
	case "article":
		return t.AsArticleSearchSummary()
	case "artifact":
		return t.AsArtifactSearchSummary()
	case "conversation":
		return t.AsConversationSearchSummary()
	case "custom_object":
		return t.AsCustomObjectSearchSummary()
	case "dashboard":
		return t.AsDashboardSearchSummary()
	case "group":
		return t.AsGroupSearchSummary()
	case "link":
		return t.AsLinkSearchSummary()
	case "object_member":
		return t.AsObjectMemberSearchSummary()
	case "operation":
		return t.AsOperationSearchSummary()
	case "org":
		return t.AsOrgSearchSummary()
	case "part":
		return t.AsPartSearchSummary()
	case "question_answer":
		return t.AsQuestionAnswerSearchSummary()
	case "tag":
		return t.AsTagSearchSummary()
	case "user":
		return t.AsUserSearchSummary()
	case "vista":
		return t.AsVistaSearchSummary()
	case "work":
		return t.AsWorkSearchSummary()
	case "workflow":
		return t.AsWorkflowSearchSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SearchResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SearchResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsSendNotificationGenericNotificationEntry returns the union data inside the SendNotification as a SendNotificationGenericNotificationEntry
func (t SendNotification) AsSendNotificationGenericNotificationEntry() (SendNotificationGenericNotificationEntry, error) {
	var body SendNotificationGenericNotificationEntry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendNotificationGenericNotificationEntry overwrites any union data inside the SendNotification as the provided SendNotificationGenericNotificationEntry
func (t *SendNotification) FromSendNotificationGenericNotificationEntry(v SendNotificationGenericNotificationEntry) error {
	t.Type = "generic_notification"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendNotificationGenericNotificationEntry performs a merge with any union data inside the SendNotification, using the provided SendNotificationGenericNotificationEntry
func (t *SendNotification) MergeSendNotificationGenericNotificationEntry(v SendNotificationGenericNotificationEntry) error {
	t.Type = "generic_notification"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendNotification) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SendNotification) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "generic_notification":
		return t.AsSendNotificationGenericNotificationEntry()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SendNotification) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Parent != nil {
		object["parent"], err = json.Marshal(t.Parent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parent': %w", err)
		}
	}

	object["receiver"], err = json.Marshal(t.Receiver)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'receiver': %w", err)
	}

	if t.Timestamp != nil {
		object["timestamp"], err = json.Marshal(t.Timestamp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timestamp': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SendNotification) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["parent"]; found {
		err = json.Unmarshal(raw, &t.Parent)
		if err != nil {
			return fmt.Errorf("error reading 'parent': %w", err)
		}
	}

	if raw, found := object["receiver"]; found {
		err = json.Unmarshal(raw, &t.Receiver)
		if err != nil {
			return fmt.Errorf("error reading 'receiver': %w", err)
		}
	}

	if raw, found := object["timestamp"]; found {
		err = json.Unmarshal(raw, &t.Timestamp)
		if err != nil {
			return fmt.Errorf("error reading 'timestamp': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsSnapKitActionRequestButton returns the union data inside the SnapKitActionRequest as a SnapKitActionRequestButton
func (t SnapKitActionRequest) AsSnapKitActionRequestButton() (SnapKitActionRequestButton, error) {
	var body SnapKitActionRequestButton
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapKitActionRequestButton overwrites any union data inside the SnapKitActionRequest as the provided SnapKitActionRequestButton
func (t *SnapKitActionRequest) FromSnapKitActionRequestButton(v SnapKitActionRequestButton) error {
	t.Type = "button"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapKitActionRequestButton performs a merge with any union data inside the SnapKitActionRequest, using the provided SnapKitActionRequestButton
func (t *SnapKitActionRequest) MergeSnapKitActionRequestButton(v SnapKitActionRequestButton) error {
	t.Type = "button"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapKitActionRequestForm returns the union data inside the SnapKitActionRequest as a SnapKitActionRequestForm
func (t SnapKitActionRequest) AsSnapKitActionRequestForm() (SnapKitActionRequestForm, error) {
	var body SnapKitActionRequestForm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapKitActionRequestForm overwrites any union data inside the SnapKitActionRequest as the provided SnapKitActionRequestForm
func (t *SnapKitActionRequest) FromSnapKitActionRequestForm(v SnapKitActionRequestForm) error {
	t.Type = "form"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapKitActionRequestForm performs a merge with any union data inside the SnapKitActionRequest, using the provided SnapKitActionRequestForm
func (t *SnapKitActionRequest) MergeSnapKitActionRequestForm(v SnapKitActionRequestForm) error {
	t.Type = "form"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SnapKitActionRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SnapKitActionRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "button":
		return t.AsSnapKitActionRequestButton()
	case "form":
		return t.AsSnapKitActionRequestForm()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SnapKitActionRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["action_id"], err = json.Marshal(t.ActionId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'action_id': %w", err)
	}

	if t.ActionType != nil {
		object["action_type"], err = json.Marshal(t.ActionType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'action_type': %w", err)
		}
	}

	if t.BlockId != nil {
		object["block_id"], err = json.Marshal(t.BlockId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'block_id': %w", err)
		}
	}

	object["timestamp"], err = json.Marshal(t.Timestamp)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'timestamp': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SnapKitActionRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["action_id"]; found {
		err = json.Unmarshal(raw, &t.ActionId)
		if err != nil {
			return fmt.Errorf("error reading 'action_id': %w", err)
		}
	}

	if raw, found := object["action_type"]; found {
		err = json.Unmarshal(raw, &t.ActionType)
		if err != nil {
			return fmt.Errorf("error reading 'action_type': %w", err)
		}
	}

	if raw, found := object["block_id"]; found {
		err = json.Unmarshal(raw, &t.BlockId)
		if err != nil {
			return fmt.Errorf("error reading 'block_id': %w", err)
		}
	}

	if raw, found := object["timestamp"]; found {
		err = json.Unmarshal(raw, &t.Timestamp)
		if err != nil {
			return fmt.Errorf("error reading 'timestamp': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsEmailPreviewWidget returns the union data inside the SnapWidget as a EmailPreviewWidget
func (t SnapWidget) AsEmailPreviewWidget() (EmailPreviewWidget, error) {
	var body EmailPreviewWidget
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailPreviewWidget overwrites any union data inside the SnapWidget as the provided EmailPreviewWidget
func (t *SnapWidget) FromEmailPreviewWidget(v EmailPreviewWidget) error {
	t.Type = "email_preview"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailPreviewWidget performs a merge with any union data inside the SnapWidget, using the provided EmailPreviewWidget
func (t *SnapWidget) MergeEmailPreviewWidget(v EmailPreviewWidget) error {
	t.Type = "email_preview"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStarterMessageNudgeWidget returns the union data inside the SnapWidget as a StarterMessageNudgeWidget
func (t SnapWidget) AsStarterMessageNudgeWidget() (StarterMessageNudgeWidget, error) {
	var body StarterMessageNudgeWidget
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStarterMessageNudgeWidget overwrites any union data inside the SnapWidget as the provided StarterMessageNudgeWidget
func (t *SnapWidget) FromStarterMessageNudgeWidget(v StarterMessageNudgeWidget) error {
	t.Type = "starter_message_nudge"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStarterMessageNudgeWidget performs a merge with any union data inside the SnapWidget, using the provided StarterMessageNudgeWidget
func (t *SnapWidget) MergeStarterMessageNudgeWidget(v StarterMessageNudgeWidget) error {
	t.Type = "starter_message_nudge"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SnapWidget) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SnapWidget) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "email_preview":
		return t.AsEmailPreviewWidget()
	case "starter_message_nudge":
		return t.AsStarterMessageNudgeWidget()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SnapWidget) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SnapWidget) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsSnapWidgetOpenPlugWidgetAction returns the union data inside the SnapWidgetClickInteraction as a SnapWidgetOpenPlugWidgetAction
func (t SnapWidgetClickInteraction) AsSnapWidgetOpenPlugWidgetAction() (SnapWidgetOpenPlugWidgetAction, error) {
	var body SnapWidgetOpenPlugWidgetAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapWidgetOpenPlugWidgetAction overwrites any union data inside the SnapWidgetClickInteraction as the provided SnapWidgetOpenPlugWidgetAction
func (t *SnapWidgetClickInteraction) FromSnapWidgetOpenPlugWidgetAction(v SnapWidgetOpenPlugWidgetAction) error {
	t.ClickAction = "open_plug_widget"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapWidgetOpenPlugWidgetAction performs a merge with any union data inside the SnapWidgetClickInteraction, using the provided SnapWidgetOpenPlugWidgetAction
func (t *SnapWidgetClickInteraction) MergeSnapWidgetOpenPlugWidgetAction(v SnapWidgetOpenPlugWidgetAction) error {
	t.ClickAction = "open_plug_widget"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapWidgetOpenUrlAction returns the union data inside the SnapWidgetClickInteraction as a SnapWidgetOpenUrlAction
func (t SnapWidgetClickInteraction) AsSnapWidgetOpenUrlAction() (SnapWidgetOpenUrlAction, error) {
	var body SnapWidgetOpenUrlAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapWidgetOpenUrlAction overwrites any union data inside the SnapWidgetClickInteraction as the provided SnapWidgetOpenUrlAction
func (t *SnapWidgetClickInteraction) FromSnapWidgetOpenUrlAction(v SnapWidgetOpenUrlAction) error {
	t.ClickAction = "open_url"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapWidgetOpenUrlAction performs a merge with any union data inside the SnapWidgetClickInteraction, using the provided SnapWidgetOpenUrlAction
func (t *SnapWidgetClickInteraction) MergeSnapWidgetOpenUrlAction(v SnapWidgetOpenUrlAction) error {
	t.ClickAction = "open_url"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapWidgetStartConversationAction returns the union data inside the SnapWidgetClickInteraction as a SnapWidgetStartConversationAction
func (t SnapWidgetClickInteraction) AsSnapWidgetStartConversationAction() (SnapWidgetStartConversationAction, error) {
	var body SnapWidgetStartConversationAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapWidgetStartConversationAction overwrites any union data inside the SnapWidgetClickInteraction as the provided SnapWidgetStartConversationAction
func (t *SnapWidgetClickInteraction) FromSnapWidgetStartConversationAction(v SnapWidgetStartConversationAction) error {
	t.ClickAction = "start_conversation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapWidgetStartConversationAction performs a merge with any union data inside the SnapWidgetClickInteraction, using the provided SnapWidgetStartConversationAction
func (t *SnapWidgetClickInteraction) MergeSnapWidgetStartConversationAction(v SnapWidgetStartConversationAction) error {
	t.ClickAction = "start_conversation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SnapWidgetClickInteraction) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"click_action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SnapWidgetClickInteraction) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "open_plug_widget":
		return t.AsSnapWidgetOpenPlugWidgetAction()
	case "open_url":
		return t.AsSnapWidgetOpenUrlAction()
	case "start_conversation":
		return t.AsSnapWidgetStartConversationAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SnapWidgetClickInteraction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["click_action"], err = json.Marshal(t.ClickAction)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'click_action': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SnapWidgetClickInteraction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["click_action"]; found {
		err = json.Unmarshal(raw, &t.ClickAction)
		if err != nil {
			return fmt.Errorf("error reading 'click_action': %w", err)
		}
	}

	return err
}

// AsSnapWidgetClickInteraction returns the union data inside the SnapWidgetInteraction as a SnapWidgetClickInteraction
func (t SnapWidgetInteraction) AsSnapWidgetClickInteraction() (SnapWidgetClickInteraction, error) {
	var body SnapWidgetClickInteraction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapWidgetClickInteraction overwrites any union data inside the SnapWidgetInteraction as the provided SnapWidgetClickInteraction
func (t *SnapWidgetInteraction) FromSnapWidgetClickInteraction(v SnapWidgetClickInteraction) error {
	t.Type = "click"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapWidgetClickInteraction performs a merge with any union data inside the SnapWidgetInteraction, using the provided SnapWidgetClickInteraction
func (t *SnapWidgetInteraction) MergeSnapWidgetClickInteraction(v SnapWidgetClickInteraction) error {
	t.Type = "click"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapWidgetEmailInputInteraction returns the union data inside the SnapWidgetInteraction as a SnapWidgetEmailInputInteraction
func (t SnapWidgetInteraction) AsSnapWidgetEmailInputInteraction() (SnapWidgetEmailInputInteraction, error) {
	var body SnapWidgetEmailInputInteraction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapWidgetEmailInputInteraction overwrites any union data inside the SnapWidgetInteraction as the provided SnapWidgetEmailInputInteraction
func (t *SnapWidgetInteraction) FromSnapWidgetEmailInputInteraction(v SnapWidgetEmailInputInteraction) error {
	t.Type = "email_input"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapWidgetEmailInputInteraction performs a merge with any union data inside the SnapWidgetInteraction, using the provided SnapWidgetEmailInputInteraction
func (t *SnapWidgetInteraction) MergeSnapWidgetEmailInputInteraction(v SnapWidgetEmailInputInteraction) error {
	t.Type = "email_input"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SnapWidgetInteraction) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SnapWidgetInteraction) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "click":
		return t.AsSnapWidgetClickInteraction()
	case "email_input":
		return t.AsSnapWidgetEmailInputInteraction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SnapWidgetInteraction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SnapWidgetInteraction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsCreateEmailPreviewWidget returns the union data inside the SnapWidgetsCreateRequest as a CreateEmailPreviewWidget
func (t SnapWidgetsCreateRequest) AsCreateEmailPreviewWidget() (CreateEmailPreviewWidget, error) {
	var body CreateEmailPreviewWidget
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmailPreviewWidget overwrites any union data inside the SnapWidgetsCreateRequest as the provided CreateEmailPreviewWidget
func (t *SnapWidgetsCreateRequest) FromCreateEmailPreviewWidget(v CreateEmailPreviewWidget) error {
	t.Type = "email_preview"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmailPreviewWidget performs a merge with any union data inside the SnapWidgetsCreateRequest, using the provided CreateEmailPreviewWidget
func (t *SnapWidgetsCreateRequest) MergeCreateEmailPreviewWidget(v CreateEmailPreviewWidget) error {
	t.Type = "email_preview"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateStarterMessageNudgeWidget returns the union data inside the SnapWidgetsCreateRequest as a CreateStarterMessageNudgeWidget
func (t SnapWidgetsCreateRequest) AsCreateStarterMessageNudgeWidget() (CreateStarterMessageNudgeWidget, error) {
	var body CreateStarterMessageNudgeWidget
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateStarterMessageNudgeWidget overwrites any union data inside the SnapWidgetsCreateRequest as the provided CreateStarterMessageNudgeWidget
func (t *SnapWidgetsCreateRequest) FromCreateStarterMessageNudgeWidget(v CreateStarterMessageNudgeWidget) error {
	t.Type = "starter_message_nudge"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateStarterMessageNudgeWidget performs a merge with any union data inside the SnapWidgetsCreateRequest, using the provided CreateStarterMessageNudgeWidget
func (t *SnapWidgetsCreateRequest) MergeCreateStarterMessageNudgeWidget(v CreateStarterMessageNudgeWidget) error {
	t.Type = "starter_message_nudge"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SnapWidgetsCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SnapWidgetsCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "email_preview":
		return t.AsCreateEmailPreviewWidget()
	case "starter_message_nudge":
		return t.AsCreateStarterMessageNudgeWidget()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SnapWidgetsCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Interactions != nil {
		object["interactions"], err = json.Marshal(t.Interactions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'interactions': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Namespace != nil {
		object["namespace"], err = json.Marshal(t.Namespace)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'namespace': %w", err)
		}
	}

	if t.SharedWith != nil {
		object["shared_with"], err = json.Marshal(t.SharedWith)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shared_with': %w", err)
		}
	}

	if t.Status != nil {
		object["status"], err = json.Marshal(t.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SnapWidgetsCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["interactions"]; found {
		err = json.Unmarshal(raw, &t.Interactions)
		if err != nil {
			return fmt.Errorf("error reading 'interactions': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["namespace"]; found {
		err = json.Unmarshal(raw, &t.Namespace)
		if err != nil {
			return fmt.Errorf("error reading 'namespace': %w", err)
		}
	}

	if raw, found := object["shared_with"]; found {
		err = json.Unmarshal(raw, &t.SharedWith)
		if err != nil {
			return fmt.Errorf("error reading 'shared_with': %w", err)
		}
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &t.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsTimelineEntriesCreateRequestTimelineComment returns the union data inside the TimelineEntriesCreateRequest as a TimelineEntriesCreateRequestTimelineComment
func (t TimelineEntriesCreateRequest) AsTimelineEntriesCreateRequestTimelineComment() (TimelineEntriesCreateRequestTimelineComment, error) {
	var body TimelineEntriesCreateRequestTimelineComment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineEntriesCreateRequestTimelineComment overwrites any union data inside the TimelineEntriesCreateRequest as the provided TimelineEntriesCreateRequestTimelineComment
func (t *TimelineEntriesCreateRequest) FromTimelineEntriesCreateRequestTimelineComment(v TimelineEntriesCreateRequestTimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineEntriesCreateRequestTimelineComment performs a merge with any union data inside the TimelineEntriesCreateRequest, using the provided TimelineEntriesCreateRequestTimelineComment
func (t *TimelineEntriesCreateRequest) MergeTimelineEntriesCreateRequestTimelineComment(v TimelineEntriesCreateRequestTimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TimelineEntriesCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TimelineEntriesCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "timeline_comment":
		return t.AsTimelineEntriesCreateRequestTimelineComment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TimelineEntriesCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Collections != nil {
		object["collections"], err = json.Marshal(t.Collections)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'collections': %w", err)
		}
	}

	if t.ExpiresAt != nil {
		object["expires_at"], err = json.Marshal(t.ExpiresAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'expires_at': %w", err)
		}
	}

	if t.Labels != nil {
		object["labels"], err = json.Marshal(t.Labels)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'labels': %w", err)
		}
	}

	object["object"], err = json.Marshal(t.Object)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'object': %w", err)
	}

	if t.PrivateTo != nil {
		object["private_to"], err = json.Marshal(t.PrivateTo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'private_to': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if t.Visibility != nil {
		object["visibility"], err = json.Marshal(t.Visibility)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'visibility': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *TimelineEntriesCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["collections"]; found {
		err = json.Unmarshal(raw, &t.Collections)
		if err != nil {
			return fmt.Errorf("error reading 'collections': %w", err)
		}
	}

	if raw, found := object["expires_at"]; found {
		err = json.Unmarshal(raw, &t.ExpiresAt)
		if err != nil {
			return fmt.Errorf("error reading 'expires_at': %w", err)
		}
	}

	if raw, found := object["labels"]; found {
		err = json.Unmarshal(raw, &t.Labels)
		if err != nil {
			return fmt.Errorf("error reading 'labels': %w", err)
		}
	}

	if raw, found := object["object"]; found {
		err = json.Unmarshal(raw, &t.Object)
		if err != nil {
			return fmt.Errorf("error reading 'object': %w", err)
		}
	}

	if raw, found := object["private_to"]; found {
		err = json.Unmarshal(raw, &t.PrivateTo)
		if err != nil {
			return fmt.Errorf("error reading 'private_to': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	if raw, found := object["visibility"]; found {
		err = json.Unmarshal(raw, &t.Visibility)
		if err != nil {
			return fmt.Errorf("error reading 'visibility': %w", err)
		}
	}

	return err
}

// AsTimelineEntriesUpdateRequestTimelineComment returns the union data inside the TimelineEntriesUpdateRequest as a TimelineEntriesUpdateRequestTimelineComment
func (t TimelineEntriesUpdateRequest) AsTimelineEntriesUpdateRequestTimelineComment() (TimelineEntriesUpdateRequestTimelineComment, error) {
	var body TimelineEntriesUpdateRequestTimelineComment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineEntriesUpdateRequestTimelineComment overwrites any union data inside the TimelineEntriesUpdateRequest as the provided TimelineEntriesUpdateRequestTimelineComment
func (t *TimelineEntriesUpdateRequest) FromTimelineEntriesUpdateRequestTimelineComment(v TimelineEntriesUpdateRequestTimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineEntriesUpdateRequestTimelineComment performs a merge with any union data inside the TimelineEntriesUpdateRequest, using the provided TimelineEntriesUpdateRequestTimelineComment
func (t *TimelineEntriesUpdateRequest) MergeTimelineEntriesUpdateRequestTimelineComment(v TimelineEntriesUpdateRequestTimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TimelineEntriesUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TimelineEntriesUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "timeline_comment":
		return t.AsTimelineEntriesUpdateRequestTimelineComment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TimelineEntriesUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *TimelineEntriesUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsTimelineChangeEvent returns the union data inside the TimelineEntry as a TimelineChangeEvent
func (t TimelineEntry) AsTimelineChangeEvent() (TimelineChangeEvent, error) {
	var body TimelineChangeEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineChangeEvent overwrites any union data inside the TimelineEntry as the provided TimelineChangeEvent
func (t *TimelineEntry) FromTimelineChangeEvent(v TimelineChangeEvent) error {
	t.Type = "timeline_change_event"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineChangeEvent performs a merge with any union data inside the TimelineEntry, using the provided TimelineChangeEvent
func (t *TimelineEntry) MergeTimelineChangeEvent(v TimelineChangeEvent) error {
	t.Type = "timeline_change_event"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimelineComment returns the union data inside the TimelineEntry as a TimelineComment
func (t TimelineEntry) AsTimelineComment() (TimelineComment, error) {
	var body TimelineComment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimelineComment overwrites any union data inside the TimelineEntry as the provided TimelineComment
func (t *TimelineEntry) FromTimelineComment(v TimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimelineComment performs a merge with any union data inside the TimelineEntry, using the provided TimelineComment
func (t *TimelineEntry) MergeTimelineComment(v TimelineComment) error {
	t.Type = "timeline_comment"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TimelineEntry) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TimelineEntry) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "timeline_change_event":
		return t.AsTimelineChangeEvent()
	case "timeline_comment":
		return t.AsTimelineComment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TimelineEntry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *TimelineEntry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsArticleSummary returns the union data inside the TuringSources as a ArticleSummary
func (t TuringSources) AsArticleSummary() (ArticleSummary, error) {
	var body ArticleSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArticleSummary overwrites any union data inside the TuringSources as the provided ArticleSummary
func (t *TuringSources) FromArticleSummary(v ArticleSummary) error {
	t.Type = "article"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArticleSummary performs a merge with any union data inside the TuringSources, using the provided ArticleSummary
func (t *TuringSources) MergeArticleSummary(v ArticleSummary) error {
	t.Type = "article"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionAnswerSummary returns the union data inside the TuringSources as a QuestionAnswerSummary
func (t TuringSources) AsQuestionAnswerSummary() (QuestionAnswerSummary, error) {
	var body QuestionAnswerSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionAnswerSummary overwrites any union data inside the TuringSources as the provided QuestionAnswerSummary
func (t *TuringSources) FromQuestionAnswerSummary(v QuestionAnswerSummary) error {
	t.Type = "question_answer"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionAnswerSummary performs a merge with any union data inside the TuringSources, using the provided QuestionAnswerSummary
func (t *TuringSources) MergeQuestionAnswerSummary(v QuestionAnswerSummary) error {
	t.Type = "question_answer"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TuringSources) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TuringSources) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "article":
		return t.AsArticleSummary()
	case "question_answer":
		return t.AsQuestionAnswerSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TuringSources) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *TuringSources) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsDevUserSummary returns the union data inside the UserSummary as a DevUserSummary
func (t UserSummary) AsDevUserSummary() (DevUserSummary, error) {
	var body DevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevUserSummary overwrites any union data inside the UserSummary as the provided DevUserSummary
func (t *UserSummary) FromDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevUserSummary performs a merge with any union data inside the UserSummary, using the provided DevUserSummary
func (t *UserSummary) MergeDevUserSummary(v DevUserSummary) error {
	t.Type = "dev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevUserSummary returns the union data inside the UserSummary as a RevUserSummary
func (t UserSummary) AsRevUserSummary() (RevUserSummary, error) {
	var body RevUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevUserSummary overwrites any union data inside the UserSummary as the provided RevUserSummary
func (t *UserSummary) FromRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevUserSummary performs a merge with any union data inside the UserSummary, using the provided RevUserSummary
func (t *UserSummary) MergeRevUserSummary(v RevUserSummary) error {
	t.Type = "rev_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServiceAccountSummary returns the union data inside the UserSummary as a ServiceAccountSummary
func (t UserSummary) AsServiceAccountSummary() (ServiceAccountSummary, error) {
	var body ServiceAccountSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServiceAccountSummary overwrites any union data inside the UserSummary as the provided ServiceAccountSummary
func (t *UserSummary) FromServiceAccountSummary(v ServiceAccountSummary) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServiceAccountSummary performs a merge with any union data inside the UserSummary, using the provided ServiceAccountSummary
func (t *UserSummary) MergeServiceAccountSummary(v ServiceAccountSummary) error {
	t.Type = "service_account"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSysUserSummary returns the union data inside the UserSummary as a SysUserSummary
func (t UserSummary) AsSysUserSummary() (SysUserSummary, error) {
	var body SysUserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSysUserSummary overwrites any union data inside the UserSummary as the provided SysUserSummary
func (t *UserSummary) FromSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSysUserSummary performs a merge with any union data inside the UserSummary, using the provided SysUserSummary
func (t *UserSummary) MergeSysUserSummary(v SysUserSummary) error {
	t.Type = "sys_user"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UserSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UserSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dev_user":
		return t.AsDevUserSummary()
	case "rev_user":
		return t.AsRevUserSummary()
	case "service_account":
		return t.AsServiceAccountSummary()
	case "sys_user":
		return t.AsSysUserSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UserSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *UserSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsCuratedVistaSummary returns the union data inside the VistaSummary as a CuratedVistaSummary
func (t VistaSummary) AsCuratedVistaSummary() (CuratedVistaSummary, error) {
	var body CuratedVistaSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCuratedVistaSummary overwrites any union data inside the VistaSummary as the provided CuratedVistaSummary
func (t *VistaSummary) FromCuratedVistaSummary(v CuratedVistaSummary) error {
	t.Type = "curated"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCuratedVistaSummary performs a merge with any union data inside the VistaSummary, using the provided CuratedVistaSummary
func (t *VistaSummary) MergeCuratedVistaSummary(v CuratedVistaSummary) error {
	t.Type = "curated"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDynamicVistaSummary returns the union data inside the VistaSummary as a DynamicVistaSummary
func (t VistaSummary) AsDynamicVistaSummary() (DynamicVistaSummary, error) {
	var body DynamicVistaSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDynamicVistaSummary overwrites any union data inside the VistaSummary as the provided DynamicVistaSummary
func (t *VistaSummary) FromDynamicVistaSummary(v DynamicVistaSummary) error {
	t.Type = "dynamic"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDynamicVistaSummary performs a merge with any union data inside the VistaSummary, using the provided DynamicVistaSummary
func (t *VistaSummary) MergeDynamicVistaSummary(v DynamicVistaSummary) error {
	t.Type = "dynamic"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroupedVistaSummary returns the union data inside the VistaSummary as a GroupedVistaSummary
func (t VistaSummary) AsGroupedVistaSummary() (GroupedVistaSummary, error) {
	var body GroupedVistaSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroupedVistaSummary overwrites any union data inside the VistaSummary as the provided GroupedVistaSummary
func (t *VistaSummary) FromGroupedVistaSummary(v GroupedVistaSummary) error {
	t.Type = "grouped"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroupedVistaSummary performs a merge with any union data inside the VistaSummary, using the provided GroupedVistaSummary
func (t *VistaSummary) MergeGroupedVistaSummary(v GroupedVistaSummary) error {
	t.Type = "grouped"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VistaSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t VistaSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "curated":
		return t.AsCuratedVistaSummary()
	case "dynamic":
		return t.AsDynamicVistaSummary()
	case "grouped":
		return t.AsGroupedVistaSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t VistaSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *VistaSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsIssue returns the union data inside the Work as a Issue
func (t Work) AsIssue() (Issue, error) {
	var body Issue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssue overwrites any union data inside the Work as the provided Issue
func (t *Work) FromIssue(v Issue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssue performs a merge with any union data inside the Work, using the provided Issue
func (t *Work) MergeIssue(v Issue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpportunity returns the union data inside the Work as a Opportunity
func (t Work) AsOpportunity() (Opportunity, error) {
	var body Opportunity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpportunity overwrites any union data inside the Work as the provided Opportunity
func (t *Work) FromOpportunity(v Opportunity) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpportunity performs a merge with any union data inside the Work, using the provided Opportunity
func (t *Work) MergeOpportunity(v Opportunity) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTask returns the union data inside the Work as a Task
func (t Work) AsTask() (Task, error) {
	var body Task
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTask overwrites any union data inside the Work as the provided Task
func (t *Work) FromTask(v Task) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTask performs a merge with any union data inside the Work, using the provided Task
func (t *Work) MergeTask(v Task) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTicket returns the union data inside the Work as a Ticket
func (t Work) AsTicket() (Ticket, error) {
	var body Ticket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTicket overwrites any union data inside the Work as the provided Ticket
func (t *Work) FromTicket(v Ticket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTicket performs a merge with any union data inside the Work, using the provided Ticket
func (t *Work) MergeTicket(v Ticket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Work) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Work) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "issue":
		return t.AsIssue()
	case "opportunity":
		return t.AsOpportunity()
	case "task":
		return t.AsTask()
	case "ticket":
		return t.AsTicket()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Work) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Work) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsIssueSummary returns the union data inside the WorkSummary as a IssueSummary
func (t WorkSummary) AsIssueSummary() (IssueSummary, error) {
	var body IssueSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueSummary overwrites any union data inside the WorkSummary as the provided IssueSummary
func (t *WorkSummary) FromIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueSummary performs a merge with any union data inside the WorkSummary, using the provided IssueSummary
func (t *WorkSummary) MergeIssueSummary(v IssueSummary) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpportunitySummary returns the union data inside the WorkSummary as a OpportunitySummary
func (t WorkSummary) AsOpportunitySummary() (OpportunitySummary, error) {
	var body OpportunitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpportunitySummary overwrites any union data inside the WorkSummary as the provided OpportunitySummary
func (t *WorkSummary) FromOpportunitySummary(v OpportunitySummary) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpportunitySummary performs a merge with any union data inside the WorkSummary, using the provided OpportunitySummary
func (t *WorkSummary) MergeOpportunitySummary(v OpportunitySummary) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTaskSummary returns the union data inside the WorkSummary as a TaskSummary
func (t WorkSummary) AsTaskSummary() (TaskSummary, error) {
	var body TaskSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTaskSummary overwrites any union data inside the WorkSummary as the provided TaskSummary
func (t *WorkSummary) FromTaskSummary(v TaskSummary) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTaskSummary performs a merge with any union data inside the WorkSummary, using the provided TaskSummary
func (t *WorkSummary) MergeTaskSummary(v TaskSummary) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTicketSummary returns the union data inside the WorkSummary as a TicketSummary
func (t WorkSummary) AsTicketSummary() (TicketSummary, error) {
	var body TicketSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTicketSummary overwrites any union data inside the WorkSummary as the provided TicketSummary
func (t *WorkSummary) FromTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTicketSummary performs a merge with any union data inside the WorkSummary, using the provided TicketSummary
func (t *WorkSummary) MergeTicketSummary(v TicketSummary) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorkSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t WorkSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "issue":
		return t.AsIssueSummary()
	case "opportunity":
		return t.AsOpportunitySummary()
	case "task":
		return t.AsTaskSummary()
	case "ticket":
		return t.AsTicketSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t WorkSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *WorkSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsWorksCreateRequestIssue returns the union data inside the WorksCreateRequest as a WorksCreateRequestIssue
func (t WorksCreateRequest) AsWorksCreateRequestIssue() (WorksCreateRequestIssue, error) {
	var body WorksCreateRequestIssue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksCreateRequestIssue overwrites any union data inside the WorksCreateRequest as the provided WorksCreateRequestIssue
func (t *WorksCreateRequest) FromWorksCreateRequestIssue(v WorksCreateRequestIssue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksCreateRequestIssue performs a merge with any union data inside the WorksCreateRequest, using the provided WorksCreateRequestIssue
func (t *WorksCreateRequest) MergeWorksCreateRequestIssue(v WorksCreateRequestIssue) error {
	t.Type = "issue"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksCreateRequestOpportunity returns the union data inside the WorksCreateRequest as a WorksCreateRequestOpportunity
func (t WorksCreateRequest) AsWorksCreateRequestOpportunity() (WorksCreateRequestOpportunity, error) {
	var body WorksCreateRequestOpportunity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksCreateRequestOpportunity overwrites any union data inside the WorksCreateRequest as the provided WorksCreateRequestOpportunity
func (t *WorksCreateRequest) FromWorksCreateRequestOpportunity(v WorksCreateRequestOpportunity) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksCreateRequestOpportunity performs a merge with any union data inside the WorksCreateRequest, using the provided WorksCreateRequestOpportunity
func (t *WorksCreateRequest) MergeWorksCreateRequestOpportunity(v WorksCreateRequestOpportunity) error {
	t.Type = "opportunity"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksCreateRequestTask returns the union data inside the WorksCreateRequest as a WorksCreateRequestTask
func (t WorksCreateRequest) AsWorksCreateRequestTask() (WorksCreateRequestTask, error) {
	var body WorksCreateRequestTask
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksCreateRequestTask overwrites any union data inside the WorksCreateRequest as the provided WorksCreateRequestTask
func (t *WorksCreateRequest) FromWorksCreateRequestTask(v WorksCreateRequestTask) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksCreateRequestTask performs a merge with any union data inside the WorksCreateRequest, using the provided WorksCreateRequestTask
func (t *WorksCreateRequest) MergeWorksCreateRequestTask(v WorksCreateRequestTask) error {
	t.Type = "task"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksCreateRequestTicket returns the union data inside the WorksCreateRequest as a WorksCreateRequestTicket
func (t WorksCreateRequest) AsWorksCreateRequestTicket() (WorksCreateRequestTicket, error) {
	var body WorksCreateRequestTicket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksCreateRequestTicket overwrites any union data inside the WorksCreateRequest as the provided WorksCreateRequestTicket
func (t *WorksCreateRequest) FromWorksCreateRequestTicket(v WorksCreateRequestTicket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksCreateRequestTicket performs a merge with any union data inside the WorksCreateRequest, using the provided WorksCreateRequestTicket
func (t *WorksCreateRequest) MergeWorksCreateRequestTicket(v WorksCreateRequestTicket) error {
	t.Type = "ticket"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorksCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t WorksCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "issue":
		return t.AsWorksCreateRequestIssue()
	case "opportunity":
		return t.AsWorksCreateRequestOpportunity()
	case "task":
		return t.AsWorksCreateRequestTask()
	case "ticket":
		return t.AsWorksCreateRequestTicket()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t WorksCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["applies_to_part"], err = json.Marshal(t.AppliesToPart)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'applies_to_part': %w", err)
	}

	if t.Artifacts != nil {
		object["artifacts"], err = json.Marshal(t.Artifacts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artifacts': %w", err)
		}
	}

	if t.Body != nil {
		object["body"], err = json.Marshal(t.Body)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body': %w", err)
		}
	}

	if t.CustomFields != nil {
		object["custom_fields"], err = json.Marshal(t.CustomFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_fields': %w", err)
		}
	}

	if t.CustomSchemaFragments != nil {
		object["custom_schema_fragments"], err = json.Marshal(t.CustomSchemaFragments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_fragments': %w", err)
		}
	}

	if t.CustomSchemaSpec != nil {
		object["custom_schema_spec"], err = json.Marshal(t.CustomSchemaSpec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_spec': %w", err)
		}
	}

	object["owned_by"], err = json.Marshal(t.OwnedBy)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'owned_by': %w", err)
	}

	if t.ReportedBy != nil {
		object["reported_by"], err = json.Marshal(t.ReportedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reported_by': %w", err)
		}
	}

	if t.Stage != nil {
		object["stage"], err = json.Marshal(t.Stage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage': %w", err)
		}
	}

	if t.StageValidationOptions != nil {
		object["stage_validation_options"], err = json.Marshal(t.StageValidationOptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_validation_options': %w", err)
		}
	}

	if t.Tags != nil {
		object["tags"], err = json.Marshal(t.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if t.TargetCloseDate != nil {
		object["target_close_date"], err = json.Marshal(t.TargetCloseDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target_close_date': %w", err)
		}
	}

	object["title"], err = json.Marshal(t.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *WorksCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["applies_to_part"]; found {
		err = json.Unmarshal(raw, &t.AppliesToPart)
		if err != nil {
			return fmt.Errorf("error reading 'applies_to_part': %w", err)
		}
	}

	if raw, found := object["artifacts"]; found {
		err = json.Unmarshal(raw, &t.Artifacts)
		if err != nil {
			return fmt.Errorf("error reading 'artifacts': %w", err)
		}
	}

	if raw, found := object["body"]; found {
		err = json.Unmarshal(raw, &t.Body)
		if err != nil {
			return fmt.Errorf("error reading 'body': %w", err)
		}
	}

	if raw, found := object["custom_fields"]; found {
		err = json.Unmarshal(raw, &t.CustomFields)
		if err != nil {
			return fmt.Errorf("error reading 'custom_fields': %w", err)
		}
	}

	if raw, found := object["custom_schema_fragments"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaFragments)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_fragments': %w", err)
		}
	}

	if raw, found := object["custom_schema_spec"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaSpec)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_spec': %w", err)
		}
	}

	if raw, found := object["owned_by"]; found {
		err = json.Unmarshal(raw, &t.OwnedBy)
		if err != nil {
			return fmt.Errorf("error reading 'owned_by': %w", err)
		}
	}

	if raw, found := object["reported_by"]; found {
		err = json.Unmarshal(raw, &t.ReportedBy)
		if err != nil {
			return fmt.Errorf("error reading 'reported_by': %w", err)
		}
	}

	if raw, found := object["stage"]; found {
		err = json.Unmarshal(raw, &t.Stage)
		if err != nil {
			return fmt.Errorf("error reading 'stage': %w", err)
		}
	}

	if raw, found := object["stage_validation_options"]; found {
		err = json.Unmarshal(raw, &t.StageValidationOptions)
		if err != nil {
			return fmt.Errorf("error reading 'stage_validation_options': %w", err)
		}
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &t.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
	}

	if raw, found := object["target_close_date"]; found {
		err = json.Unmarshal(raw, &t.TargetCloseDate)
		if err != nil {
			return fmt.Errorf("error reading 'target_close_date': %w", err)
		}
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &t.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsEmpty returns the union data inside the WorksUpdateRequest as a Empty
func (t WorksUpdateRequest) AsEmpty() (Empty, error) {
	var body Empty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmpty overwrites any union data inside the WorksUpdateRequest as the provided Empty
func (t *WorksUpdateRequest) FromEmpty(v Empty) error {
	t.Type = func() *WorkType { v := WorkType("none"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmpty performs a merge with any union data inside the WorksUpdateRequest, using the provided Empty
func (t *WorksUpdateRequest) MergeEmpty(v Empty) error {
	t.Type = func() *WorkType { v := WorkType("none"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksUpdateRequestIssue returns the union data inside the WorksUpdateRequest as a WorksUpdateRequestIssue
func (t WorksUpdateRequest) AsWorksUpdateRequestIssue() (WorksUpdateRequestIssue, error) {
	var body WorksUpdateRequestIssue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksUpdateRequestIssue overwrites any union data inside the WorksUpdateRequest as the provided WorksUpdateRequestIssue
func (t *WorksUpdateRequest) FromWorksUpdateRequestIssue(v WorksUpdateRequestIssue) error {
	t.Type = func() *WorkType { v := WorkType("issue"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksUpdateRequestIssue performs a merge with any union data inside the WorksUpdateRequest, using the provided WorksUpdateRequestIssue
func (t *WorksUpdateRequest) MergeWorksUpdateRequestIssue(v WorksUpdateRequestIssue) error {
	t.Type = func() *WorkType { v := WorkType("issue"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksUpdateRequestOpportunity returns the union data inside the WorksUpdateRequest as a WorksUpdateRequestOpportunity
func (t WorksUpdateRequest) AsWorksUpdateRequestOpportunity() (WorksUpdateRequestOpportunity, error) {
	var body WorksUpdateRequestOpportunity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksUpdateRequestOpportunity overwrites any union data inside the WorksUpdateRequest as the provided WorksUpdateRequestOpportunity
func (t *WorksUpdateRequest) FromWorksUpdateRequestOpportunity(v WorksUpdateRequestOpportunity) error {
	t.Type = func() *WorkType { v := WorkType("opportunity"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksUpdateRequestOpportunity performs a merge with any union data inside the WorksUpdateRequest, using the provided WorksUpdateRequestOpportunity
func (t *WorksUpdateRequest) MergeWorksUpdateRequestOpportunity(v WorksUpdateRequestOpportunity) error {
	t.Type = func() *WorkType { v := WorkType("opportunity"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksUpdateRequestTask returns the union data inside the WorksUpdateRequest as a WorksUpdateRequestTask
func (t WorksUpdateRequest) AsWorksUpdateRequestTask() (WorksUpdateRequestTask, error) {
	var body WorksUpdateRequestTask
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksUpdateRequestTask overwrites any union data inside the WorksUpdateRequest as the provided WorksUpdateRequestTask
func (t *WorksUpdateRequest) FromWorksUpdateRequestTask(v WorksUpdateRequestTask) error {
	t.Type = func() *WorkType { v := WorkType("task"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksUpdateRequestTask performs a merge with any union data inside the WorksUpdateRequest, using the provided WorksUpdateRequestTask
func (t *WorksUpdateRequest) MergeWorksUpdateRequestTask(v WorksUpdateRequestTask) error {
	t.Type = func() *WorkType { v := WorkType("task"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorksUpdateRequestTicket returns the union data inside the WorksUpdateRequest as a WorksUpdateRequestTicket
func (t WorksUpdateRequest) AsWorksUpdateRequestTicket() (WorksUpdateRequestTicket, error) {
	var body WorksUpdateRequestTicket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorksUpdateRequestTicket overwrites any union data inside the WorksUpdateRequest as the provided WorksUpdateRequestTicket
func (t *WorksUpdateRequest) FromWorksUpdateRequestTicket(v WorksUpdateRequestTicket) error {
	t.Type = func() *WorkType { v := WorkType("ticket"); return &v }()

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorksUpdateRequestTicket performs a merge with any union data inside the WorksUpdateRequest, using the provided WorksUpdateRequestTicket
func (t *WorksUpdateRequest) MergeWorksUpdateRequestTicket(v WorksUpdateRequestTicket) error {
	t.Type = func() *WorkType { v := WorkType("ticket"); return &v }()

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorksUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t WorksUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "issue":
		return t.AsWorksUpdateRequestIssue()
	case "none":
		return t.AsEmpty()
	case "opportunity":
		return t.AsWorksUpdateRequestOpportunity()
	case "task":
		return t.AsWorksUpdateRequestTask()
	case "ticket":
		return t.AsWorksUpdateRequestTicket()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t WorksUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.AppliesToPart != nil {
		object["applies_to_part"], err = json.Marshal(t.AppliesToPart)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'applies_to_part': %w", err)
		}
	}

	if t.Artifacts != nil {
		object["artifacts"], err = json.Marshal(t.Artifacts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artifacts': %w", err)
		}
	}

	if t.Body != nil {
		object["body"], err = json.Marshal(t.Body)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'body': %w", err)
		}
	}

	if t.CustomFields != nil {
		object["custom_fields"], err = json.Marshal(t.CustomFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_fields': %w", err)
		}
	}

	if t.CustomSchemaFragments != nil {
		object["custom_schema_fragments"], err = json.Marshal(t.CustomSchemaFragments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_fragments': %w", err)
		}
	}

	if t.CustomSchemaSpec != nil {
		object["custom_schema_spec"], err = json.Marshal(t.CustomSchemaSpec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'custom_schema_spec': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.OwnedBy != nil {
		object["owned_by"], err = json.Marshal(t.OwnedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owned_by': %w", err)
		}
	}

	if t.ReportedBy != nil {
		object["reported_by"], err = json.Marshal(t.ReportedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reported_by': %w", err)
		}
	}

	if t.Stage != nil {
		object["stage"], err = json.Marshal(t.Stage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage': %w", err)
		}
	}

	if t.StageValidationOptions != nil {
		object["stage_validation_options"], err = json.Marshal(t.StageValidationOptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stage_validation_options': %w", err)
		}
	}

	if t.StagedInfo != nil {
		object["staged_info"], err = json.Marshal(t.StagedInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'staged_info': %w", err)
		}
	}

	if t.Tags != nil {
		object["tags"], err = json.Marshal(t.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if t.TargetCloseDate != nil {
		object["target_close_date"], err = json.Marshal(t.TargetCloseDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target_close_date': %w", err)
		}
	}

	if t.Title != nil {
		object["title"], err = json.Marshal(t.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *WorksUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["applies_to_part"]; found {
		err = json.Unmarshal(raw, &t.AppliesToPart)
		if err != nil {
			return fmt.Errorf("error reading 'applies_to_part': %w", err)
		}
	}

	if raw, found := object["artifacts"]; found {
		err = json.Unmarshal(raw, &t.Artifacts)
		if err != nil {
			return fmt.Errorf("error reading 'artifacts': %w", err)
		}
	}

	if raw, found := object["body"]; found {
		err = json.Unmarshal(raw, &t.Body)
		if err != nil {
			return fmt.Errorf("error reading 'body': %w", err)
		}
	}

	if raw, found := object["custom_fields"]; found {
		err = json.Unmarshal(raw, &t.CustomFields)
		if err != nil {
			return fmt.Errorf("error reading 'custom_fields': %w", err)
		}
	}

	if raw, found := object["custom_schema_fragments"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaFragments)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_fragments': %w", err)
		}
	}

	if raw, found := object["custom_schema_spec"]; found {
		err = json.Unmarshal(raw, &t.CustomSchemaSpec)
		if err != nil {
			return fmt.Errorf("error reading 'custom_schema_spec': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["owned_by"]; found {
		err = json.Unmarshal(raw, &t.OwnedBy)
		if err != nil {
			return fmt.Errorf("error reading 'owned_by': %w", err)
		}
	}

	if raw, found := object["reported_by"]; found {
		err = json.Unmarshal(raw, &t.ReportedBy)
		if err != nil {
			return fmt.Errorf("error reading 'reported_by': %w", err)
		}
	}

	if raw, found := object["stage"]; found {
		err = json.Unmarshal(raw, &t.Stage)
		if err != nil {
			return fmt.Errorf("error reading 'stage': %w", err)
		}
	}

	if raw, found := object["stage_validation_options"]; found {
		err = json.Unmarshal(raw, &t.StageValidationOptions)
		if err != nil {
			return fmt.Errorf("error reading 'stage_validation_options': %w", err)
		}
	}

	if raw, found := object["staged_info"]; found {
		err = json.Unmarshal(raw, &t.StagedInfo)
		if err != nil {
			return fmt.Errorf("error reading 'staged_info': %w", err)
		}
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &t.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
	}

	if raw, found := object["target_close_date"]; found {
		err = json.Unmarshal(raw, &t.TargetCloseDate)
		if err != nil {
			return fmt.Errorf("error reading 'target_close_date': %w", err)
		}
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &t.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AccountsCreateWithBody request with any body
	AccountsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsCreate(ctx context.Context, body AccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsDeleteWithBody request with any body
	AccountsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsDelete(ctx context.Context, body AccountsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsExport request
	AccountsExport(ctx context.Context, params *AccountsExportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsExportPostWithBody request with any body
	AccountsExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsExportPost(ctx context.Context, body AccountsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsGet request
	AccountsGet(ctx context.Context, params *AccountsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsGetPostWithBody request with any body
	AccountsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsGetPost(ctx context.Context, body AccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsList request
	AccountsList(ctx context.Context, params *AccountsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsListPostWithBody request with any body
	AccountsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsListPost(ctx context.Context, body AccountsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsMergeWithBody request with any body
	AccountsMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsMerge(ctx context.Context, body AccountsMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsUpdateWithBody request with any body
	AccountsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccountsUpdate(ctx context.Context, body AccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AiAgentEventsExecuteAsyncWithBody request with any body
	AiAgentEventsExecuteAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AiAgentEventsExecuteAsync(ctx context.Context, body AiAgentEventsExecuteAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AirdropSyncUnitsGet request
	AirdropSyncUnitsGet(ctx context.Context, params *AirdropSyncUnitsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AirdropSyncUnitsGetPostWithBody request with any body
	AirdropSyncUnitsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AirdropSyncUnitsGetPost(ctx context.Context, body AirdropSyncUnitsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AirdropSyncUnitsHistory request
	AirdropSyncUnitsHistory(ctx context.Context, params *AirdropSyncUnitsHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AirdropSyncUnitsHistoryPostWithBody request with any body
	AirdropSyncUnitsHistoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AirdropSyncUnitsHistoryPost(ctx context.Context, body AirdropSyncUnitsHistoryPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArticlesCount request
	ArticlesCount(ctx context.Context, params *ArticlesCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArticlesCountPostWithBody request with any body
	ArticlesCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArticlesCountPost(ctx context.Context, body ArticlesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateArticleWithBody request with any body
	CreateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateArticle(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteArticleWithBody request with any body
	DeleteArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteArticle(ctx context.Context, body DeleteArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArticle request
	GetArticle(ctx context.Context, params *GetArticleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArticlePostWithBody request with any body
	GetArticlePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetArticlePost(ctx context.Context, body GetArticlePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListArticles request
	ListArticles(ctx context.Context, params *ListArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListArticlesPostWithBody request with any body
	ListArticlesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListArticlesPost(ctx context.Context, body ListArticlesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateArticleWithBody request with any body
	UpdateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateArticle(ctx context.Context, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsGet request
	ArtifactsGet(ctx context.Context, params *ArtifactsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsGetPostWithBody request with any body
	ArtifactsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsGetPost(ctx context.Context, body ArtifactsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsList request
	ArtifactsList(ctx context.Context, params *ArtifactsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsListPostWithBody request with any body
	ArtifactsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsListPost(ctx context.Context, body ArtifactsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsLocate request
	ArtifactsLocate(ctx context.Context, params *ArtifactsLocateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsLocatePostWithBody request with any body
	ArtifactsLocatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsLocatePost(ctx context.Context, body ArtifactsLocatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsPrepareWithBody request with any body
	ArtifactsPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsPrepare(ctx context.Context, body ArtifactsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsHardDeleteVersionWithBody request with any body
	ArtifactsHardDeleteVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsHardDeleteVersion(ctx context.Context, body ArtifactsHardDeleteVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtifactsVersionsPrepareWithBody request with any body
	ArtifactsVersionsPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArtifactsVersionsPrepare(ctx context.Context, body ArtifactsVersionsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AtomsGet request
	AtomsGet(ctx context.Context, params *AtomsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AtomsGetPostWithBody request with any body
	AtomsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AtomsGetPost(ctx context.Context, body AtomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportAuditLogsWithBody request with any body
	ExportAuditLogsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportAuditLogs(ctx context.Context, body ExportAuditLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensCreateWithBody request with any body
	AuthTokensCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensCreate(ctx context.Context, body AuthTokensCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensDeleteWithBody request with any body
	AuthTokensDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensDelete(ctx context.Context, body AuthTokensDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensGet request
	AuthTokensGet(ctx context.Context, params *AuthTokensGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensGetPostWithBody request with any body
	AuthTokensGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensGetPost(ctx context.Context, body AuthTokensGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensInfo request
	AuthTokensInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensInfoPostWithBody request with any body
	AuthTokensInfoPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensInfoPost(ctx context.Context, body AuthTokensInfoPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensList request
	AuthTokensList(ctx context.Context, params *AuthTokensListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensListPostWithBody request with any body
	AuthTokensListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensListPost(ctx context.Context, body AuthTokensListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensSelfDeleteWithBody request with any body
	AuthTokensSelfDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensSelfDelete(ctx context.Context, body AuthTokensSelfDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthTokensUpdateWithBody request with any body
	AuthTokensUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthTokensUpdate(ctx context.Context, body AuthTokensUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrandsCreateWithBody request with any body
	BrandsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BrandsCreate(ctx context.Context, body BrandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrandsDeleteWithBody request with any body
	BrandsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BrandsDelete(ctx context.Context, body BrandsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrandsGet request
	BrandsGet(ctx context.Context, params *BrandsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrandsGetPostWithBody request with any body
	BrandsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BrandsGetPost(ctx context.Context, body BrandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrandsList request
	BrandsList(ctx context.Context, params *BrandsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrandsListPostWithBody request with any body
	BrandsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BrandsListPost(ctx context.Context, body BrandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrandsUpdateWithBody request with any body
	BrandsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BrandsUpdate(ctx context.Context, body BrandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatsCreateWithBody request with any body
	ChatsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatsCreate(ctx context.Context, body ChatsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatsGet request
	ChatsGet(ctx context.Context, params *ChatsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatsGetPostWithBody request with any body
	ChatsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatsGetPost(ctx context.Context, body ChatsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatsUpdateWithBody request with any body
	ChatsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatsUpdate(ctx context.Context, body ChatsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesCreateWithBody request with any body
	CodeChangesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesCreate(ctx context.Context, body CodeChangesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesDeleteWithBody request with any body
	CodeChangesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesDelete(ctx context.Context, body CodeChangesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesGet request
	CodeChangesGet(ctx context.Context, params *CodeChangesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesGetPostWithBody request with any body
	CodeChangesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesGetPost(ctx context.Context, body CodeChangesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesList request
	CodeChangesList(ctx context.Context, params *CodeChangesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesListPostWithBody request with any body
	CodeChangesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesListPost(ctx context.Context, body CodeChangesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeChangesUpdateWithBody request with any body
	CodeChangesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeChangesUpdate(ctx context.Context, body CodeChangesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsCreateWithBody request with any body
	CommandsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommandsCreate(ctx context.Context, body CommandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsGet request
	CommandsGet(ctx context.Context, params *CommandsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsGetPostWithBody request with any body
	CommandsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommandsGetPost(ctx context.Context, body CommandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsList request
	CommandsList(ctx context.Context, params *CommandsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsListPostWithBody request with any body
	CommandsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommandsListPost(ctx context.Context, body CommandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommandsUpdateWithBody request with any body
	CommandsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommandsUpdate(ctx context.Context, body CommandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContentTemplateCreateWithBody request with any body
	ContentTemplateCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ContentTemplateCreate(ctx context.Context, body ContentTemplateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContentTemplateGet request
	ContentTemplateGet(ctx context.Context, params *ContentTemplateGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContentTemplateGetPostWithBody request with any body
	ContentTemplateGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ContentTemplateGetPost(ctx context.Context, body ContentTemplateGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContentTemplateList request
	ContentTemplateList(ctx context.Context, params *ContentTemplateListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContentTemplateListPostWithBody request with any body
	ContentTemplateListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ContentTemplateListPost(ctx context.Context, body ContentTemplateListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsCreateWithBody request with any body
	ConversationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsCreate(ctx context.Context, body ConversationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsDeleteWithBody request with any body
	ConversationsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsDelete(ctx context.Context, body ConversationsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsExport request
	ConversationsExport(ctx context.Context, params *ConversationsExportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsExportPostWithBody request with any body
	ConversationsExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsExportPost(ctx context.Context, body ConversationsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsGet request
	ConversationsGet(ctx context.Context, params *ConversationsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsGetPostWithBody request with any body
	ConversationsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsGetPost(ctx context.Context, body ConversationsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsList request
	ConversationsList(ctx context.Context, params *ConversationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsListPostWithBody request with any body
	ConversationsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsListPost(ctx context.Context, body ConversationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConversationsUpdateWithBody request with any body
	ConversationsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConversationsUpdate(ctx context.Context, body ConversationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomObjectsCount request
	CustomObjectsCount(ctx context.Context, params *CustomObjectsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomObjectsCountPostWithBody request with any body
	CustomObjectsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomObjectsCountPost(ctx context.Context, body CustomObjectsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomObjectsCreateWithBody request with any body
	CustomObjectsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomObjectsCreate(ctx context.Context, body CustomObjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomObjectsDeleteWithBody request with any body
	CustomObjectsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomObjectsDelete(ctx context.Context, body CustomObjectsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomObjectsGet request
	CustomObjectsGet(ctx context.Context, params *CustomObjectsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomObjectsGetPostWithBody request with any body
	CustomObjectsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomObjectsGetPost(ctx context.Context, body CustomObjectsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomObjectsList request
	CustomObjectsList(ctx context.Context, params *CustomObjectsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomObjectsListPostWithBody request with any body
	CustomObjectsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomObjectsListPost(ctx context.Context, body CustomObjectsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomObjectsUpdateWithBody request with any body
	CustomObjectsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomObjectsUpdate(ctx context.Context, body CustomObjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsCreateWithBody request with any body
	DevOrgAuthConnectionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsCreate(ctx context.Context, body DevOrgAuthConnectionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsDeleteWithBody request with any body
	DevOrgAuthConnectionsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsDelete(ctx context.Context, body DevOrgAuthConnectionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsGet request
	DevOrgAuthConnectionsGet(ctx context.Context, params *DevOrgAuthConnectionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsGetPostWithBody request with any body
	DevOrgAuthConnectionsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsGetPost(ctx context.Context, body DevOrgAuthConnectionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsList request
	DevOrgAuthConnectionsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsListPostWithBody request with any body
	DevOrgAuthConnectionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsListPost(ctx context.Context, body DevOrgAuthConnectionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsToggleWithBody request with any body
	DevOrgAuthConnectionsToggleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsToggle(ctx context.Context, body DevOrgAuthConnectionsToggleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgAuthConnectionsUpdateWithBody request with any body
	DevOrgAuthConnectionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgAuthConnectionsUpdate(ctx context.Context, body DevOrgAuthConnectionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgsGet request
	DevOrgsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevOrgsGetPostWithBody request with any body
	DevOrgsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevOrgsGetPost(ctx context.Context, body DevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersActivateWithBody request with any body
	DevUsersActivateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersActivate(ctx context.Context, body DevUsersActivateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersCreateWithBody request with any body
	DevUsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersCreate(ctx context.Context, body DevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersDeactivateWithBody request with any body
	DevUsersDeactivateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersDeactivate(ctx context.Context, body DevUsersDeactivateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersGet request
	DevUsersGet(ctx context.Context, params *DevUsersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersGetPostWithBody request with any body
	DevUsersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersGetPost(ctx context.Context, body DevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersIdentitiesLinkWithBody request with any body
	DevUsersIdentitiesLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersIdentitiesLink(ctx context.Context, body DevUsersIdentitiesLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersIdentitiesUnlinkWithBody request with any body
	DevUsersIdentitiesUnlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersIdentitiesUnlink(ctx context.Context, body DevUsersIdentitiesUnlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersList request
	DevUsersList(ctx context.Context, params *DevUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersListPostWithBody request with any body
	DevUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersListPost(ctx context.Context, body DevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersMergeWithBody request with any body
	DevUsersMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersMerge(ctx context.Context, body DevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersSelf request
	DevUsersSelf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersSelfPostWithBody request with any body
	DevUsersSelfPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersSelfPost(ctx context.Context, body DevUsersSelfPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersSelfUpdateWithBody request with any body
	DevUsersSelfUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersSelfUpdate(ctx context.Context, body DevUsersSelfUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevUsersUpdateWithBody request with any body
	DevUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevUsersUpdate(ctx context.Context, body DevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesCount request
	DirectoriesCount(ctx context.Context, params *DirectoriesCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesCountPostWithBody request with any body
	DirectoriesCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesCountPost(ctx context.Context, body DirectoriesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesCreateWithBody request with any body
	DirectoriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesCreate(ctx context.Context, body DirectoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesDeleteWithBody request with any body
	DirectoriesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesDelete(ctx context.Context, body DirectoriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesGet request
	DirectoriesGet(ctx context.Context, params *DirectoriesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesGetPostWithBody request with any body
	DirectoriesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesGetPost(ctx context.Context, body DirectoriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesList request
	DirectoriesList(ctx context.Context, params *DirectoriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesListPostWithBody request with any body
	DirectoriesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesListPost(ctx context.Context, body DirectoriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectoriesUpdateWithBody request with any body
	DirectoriesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectoriesUpdate(ctx context.Context, body DirectoriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsCount request
	EngagementsCount(ctx context.Context, params *EngagementsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsCountPostWithBody request with any body
	EngagementsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsCountPost(ctx context.Context, body EngagementsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsCreateWithBody request with any body
	EngagementsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsCreate(ctx context.Context, body EngagementsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsDeleteWithBody request with any body
	EngagementsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsDelete(ctx context.Context, body EngagementsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsGet request
	EngagementsGet(ctx context.Context, params *EngagementsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsGetPostWithBody request with any body
	EngagementsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsGetPost(ctx context.Context, body EngagementsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsList request
	EngagementsList(ctx context.Context, params *EngagementsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsListPostWithBody request with any body
	EngagementsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsListPost(ctx context.Context, body EngagementsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsUpdateWithBody request with any body
	EngagementsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsUpdate(ctx context.Context, body EngagementsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventSourcesGet request
	EventSourcesGet(ctx context.Context, params *EventSourcesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventSourcesGetPostWithBody request with any body
	EventSourcesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventSourcesGetPost(ctx context.Context, body EventSourcesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventSourcesScheduleEventWithBody request with any body
	EventSourcesScheduleEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventSourcesScheduleEvent(ctx context.Context, body EventSourcesScheduleEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventSourcesDeleteScheduledEventWithBody request with any body
	EventSourcesDeleteScheduledEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventSourcesDeleteScheduledEvent(ctx context.Context, body EventSourcesDeleteScheduledEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsCreateWithBody request with any body
	GroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsCreate(ctx context.Context, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsGet request
	GroupsGet(ctx context.Context, params *GroupsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsGetPostWithBody request with any body
	GroupsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsGetPost(ctx context.Context, body GroupsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsList request
	GroupsList(ctx context.Context, params *GroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsListPostWithBody request with any body
	GroupsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsListPost(ctx context.Context, body GroupsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupMembersAddWithBody request with any body
	GroupMembersAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupMembersAdd(ctx context.Context, body GroupMembersAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupMembersList request
	GroupMembersList(ctx context.Context, params *GroupMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupMembersListPostWithBody request with any body
	GroupMembersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupMembersListPost(ctx context.Context, body GroupMembersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupMembersRemoveWithBody request with any body
	GroupMembersRemoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupMembersRemove(ctx context.Context, body GroupMembersRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsUpdateWithBody request with any body
	GroupsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsUpdate(ctx context.Context, body GroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncidentsCreateWithBody request with any body
	IncidentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IncidentsCreate(ctx context.Context, body IncidentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncidentsDeleteWithBody request with any body
	IncidentsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IncidentsDelete(ctx context.Context, body IncidentsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncidentsGet request
	IncidentsGet(ctx context.Context, params *IncidentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncidentsGetPostWithBody request with any body
	IncidentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IncidentsGetPost(ctx context.Context, body IncidentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncidentsGroup request
	IncidentsGroup(ctx context.Context, params *IncidentsGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncidentsGroupPostWithBody request with any body
	IncidentsGroupPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IncidentsGroupPost(ctx context.Context, body IncidentsGroupPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncidentsList request
	IncidentsList(ctx context.Context, params *IncidentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncidentsListPostWithBody request with any body
	IncidentsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IncidentsListPost(ctx context.Context, body IncidentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncidentsUpdateWithBody request with any body
	IncidentsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IncidentsUpdate(ctx context.Context, body IncidentsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// KeyringsCreateCallback request
	KeyringsCreateCallback(ctx context.Context, params *KeyringsCreateCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// KeyringsCreateCallbackPostWithBody request with any body
	KeyringsCreateCallbackPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	KeyringsCreateCallbackPost(ctx context.Context, body KeyringsCreateCallbackPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomLinkTypeCreateWithBody request with any body
	CustomLinkTypeCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomLinkTypeCreate(ctx context.Context, body CustomLinkTypeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomLinkTypeGet request
	CustomLinkTypeGet(ctx context.Context, params *CustomLinkTypeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomLinkTypeGetPostWithBody request with any body
	CustomLinkTypeGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomLinkTypeGetPost(ctx context.Context, body CustomLinkTypeGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomLinkTypeList request
	CustomLinkTypeList(ctx context.Context, params *CustomLinkTypeListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomLinkTypeListPostWithBody request with any body
	CustomLinkTypeListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomLinkTypeListPost(ctx context.Context, body CustomLinkTypeListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomLinkTypeUpdateWithBody request with any body
	CustomLinkTypeUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomLinkTypeUpdate(ctx context.Context, body CustomLinkTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksCreateWithBody request with any body
	LinksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksCreate(ctx context.Context, body LinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksDeleteWithBody request with any body
	LinksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksDelete(ctx context.Context, body LinksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksGet request
	LinksGet(ctx context.Context, params *LinksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksGetPostWithBody request with any body
	LinksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksGetPost(ctx context.Context, body LinksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksList request
	LinksList(ctx context.Context, params *LinksListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksListPostWithBody request with any body
	LinksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksListPost(ctx context.Context, body LinksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinksReplaceWithBody request with any body
	LinksReplaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinksReplace(ctx context.Context, body LinksReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsCount request
	MeetingsCount(ctx context.Context, params *MeetingsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsCountPostWithBody request with any body
	MeetingsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsCountPost(ctx context.Context, body MeetingsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsCreateWithBody request with any body
	MeetingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsCreate(ctx context.Context, body MeetingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsDeleteWithBody request with any body
	MeetingsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsDelete(ctx context.Context, body MeetingsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsGet request
	MeetingsGet(ctx context.Context, params *MeetingsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsGetPostWithBody request with any body
	MeetingsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsGetPost(ctx context.Context, body MeetingsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsList request
	MeetingsList(ctx context.Context, params *MeetingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsListPostWithBody request with any body
	MeetingsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsListPost(ctx context.Context, body MeetingsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingsUpdateWithBody request with any body
	MeetingsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingsUpdate(ctx context.Context, body MeetingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricActionExecuteWithBody request with any body
	MetricActionExecuteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricActionExecute(ctx context.Context, body MetricActionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsCreateWithBody request with any body
	MetricDefinitionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsCreate(ctx context.Context, body MetricDefinitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsDeleteWithBody request with any body
	MetricDefinitionsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsDelete(ctx context.Context, body MetricDefinitionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsGet request
	MetricDefinitionsGet(ctx context.Context, params *MetricDefinitionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsGetPostWithBody request with any body
	MetricDefinitionsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsGetPost(ctx context.Context, body MetricDefinitionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsList request
	MetricDefinitionsList(ctx context.Context, params *MetricDefinitionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsListPostWithBody request with any body
	MetricDefinitionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsListPost(ctx context.Context, body MetricDefinitionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricDefinitionsUpdateWithBody request with any body
	MetricDefinitionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricDefinitionsUpdate(ctx context.Context, body MetricDefinitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricTrackersGet request
	MetricTrackersGet(ctx context.Context, params *MetricTrackersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricTrackersGetPostWithBody request with any body
	MetricTrackersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricTrackersGetPost(ctx context.Context, body MetricTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricsDevrevIngestWithBody request with any body
	MetricsDevrevIngestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetricsDevrevIngest(ctx context.Context, body MetricsDevrevIngestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsSendWithBody request with any body
	NotificationsSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NotificationsSend(ctx context.Context, body NotificationsSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgScheduleFragmentsCreateWithBody request with any body
	OrgScheduleFragmentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgScheduleFragmentsCreate(ctx context.Context, body OrgScheduleFragmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgScheduleFragmentsGet request
	OrgScheduleFragmentsGet(ctx context.Context, params *OrgScheduleFragmentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgScheduleFragmentsGetPostWithBody request with any body
	OrgScheduleFragmentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgScheduleFragmentsGetPost(ctx context.Context, body OrgScheduleFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgScheduleFragmentsTransitionWithBody request with any body
	OrgScheduleFragmentsTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgScheduleFragmentsTransition(ctx context.Context, body OrgScheduleFragmentsTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesCreateWithBody request with any body
	OrgSchedulesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesCreate(ctx context.Context, body OrgSchedulesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesEvaluate request
	OrgSchedulesEvaluate(ctx context.Context, params *OrgSchedulesEvaluateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesEvaluatePostWithBody request with any body
	OrgSchedulesEvaluatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesEvaluatePost(ctx context.Context, body OrgSchedulesEvaluatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesGet request
	OrgSchedulesGet(ctx context.Context, params *OrgSchedulesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesGetPostWithBody request with any body
	OrgSchedulesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesGetPost(ctx context.Context, body OrgSchedulesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesList request
	OrgSchedulesList(ctx context.Context, params *OrgSchedulesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesListPostWithBody request with any body
	OrgSchedulesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesListPost(ctx context.Context, body OrgSchedulesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesSetFutureWithBody request with any body
	OrgSchedulesSetFutureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesSetFuture(ctx context.Context, body OrgSchedulesSetFutureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesTransitionWithBody request with any body
	OrgSchedulesTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesTransition(ctx context.Context, body OrgSchedulesTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgSchedulesUpdateWithBody request with any body
	OrgSchedulesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgSchedulesUpdate(ctx context.Context, body OrgSchedulesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsCreateWithBody request with any body
	PartsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsCreate(ctx context.Context, body PartsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsDeleteWithBody request with any body
	PartsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsDelete(ctx context.Context, body PartsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsGet request
	PartsGet(ctx context.Context, params *PartsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsGetPostWithBody request with any body
	PartsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsGetPost(ctx context.Context, body PartsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsList request
	PartsList(ctx context.Context, params *PartsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsListPostWithBody request with any body
	PartsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsListPost(ctx context.Context, body PartsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartsUpdateWithBody request with any body
	PartsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartsUpdate(ctx context.Context, body PartsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreferencesGet request
	PreferencesGet(ctx context.Context, params *PreferencesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreferencesGetPostWithBody request with any body
	PreferencesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreferencesGetPost(ctx context.Context, body PreferencesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreferencesUpdateWithBody request with any body
	PreferencesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreferencesUpdate(ctx context.Context, body PreferencesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateQuestionAnswerWithBody request with any body
	CreateQuestionAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateQuestionAnswer(ctx context.Context, body CreateQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteQuestionAnswerWithBody request with any body
	DeleteQuestionAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteQuestionAnswer(ctx context.Context, body DeleteQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQuestionAnswer request
	GetQuestionAnswer(ctx context.Context, params *GetQuestionAnswerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQuestionAnswerPostWithBody request with any body
	GetQuestionAnswerPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetQuestionAnswerPost(ctx context.Context, body GetQuestionAnswerPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQuestionAnswers request
	ListQuestionAnswers(ctx context.Context, params *ListQuestionAnswersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQuestionAnswersPostWithBody request with any body
	ListQuestionAnswersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListQuestionAnswersPost(ctx context.Context, body ListQuestionAnswersPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateQuestionAnswerWithBody request with any body
	UpdateQuestionAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateQuestionAnswer(ctx context.Context, body UpdateQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsList request
	ReactionsList(ctx context.Context, params *ReactionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsListPostWithBody request with any body
	ReactionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionsListPost(ctx context.Context, body ReactionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsUpdateWithBody request with any body
	ReactionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionsUpdate(ctx context.Context, body ReactionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatCompletionsWithBody request with any body
	ChatCompletionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatCompletions(ctx context.Context, body ChatCompletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplyWithBody request with any body
	GetReplyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetReply(ctx context.Context, body GetReplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecordTemplateGet request
	RecordTemplateGet(ctx context.Context, params *RecordTemplateGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecordTemplateGetPostWithBody request with any body
	RecordTemplateGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RecordTemplateGetPost(ctx context.Context, body RecordTemplateGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsCreateWithBody request with any body
	RevOrgsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsCreate(ctx context.Context, body RevOrgsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsDeleteWithBody request with any body
	RevOrgsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsDelete(ctx context.Context, body RevOrgsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsGet request
	RevOrgsGet(ctx context.Context, params *RevOrgsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsGetPostWithBody request with any body
	RevOrgsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsGetPost(ctx context.Context, body RevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsList request
	RevOrgsList(ctx context.Context, params *RevOrgsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsListPostWithBody request with any body
	RevOrgsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsListPost(ctx context.Context, body RevOrgsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevOrgsUpdateWithBody request with any body
	RevOrgsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevOrgsUpdate(ctx context.Context, body RevOrgsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersAssociationsAddWithBody request with any body
	RevUsersAssociationsAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersAssociationsAdd(ctx context.Context, body RevUsersAssociationsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersAssociationsList request
	RevUsersAssociationsList(ctx context.Context, params *RevUsersAssociationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersAssociationsListPostWithBody request with any body
	RevUsersAssociationsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersAssociationsListPost(ctx context.Context, body RevUsersAssociationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersAssociationsRemoveWithBody request with any body
	RevUsersAssociationsRemoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersAssociationsRemove(ctx context.Context, body RevUsersAssociationsRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersCreateWithBody request with any body
	RevUsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersCreate(ctx context.Context, body RevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersDeleteWithBody request with any body
	RevUsersDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersDelete(ctx context.Context, body RevUsersDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRevUsersPersonalDataWithBody request with any body
	DeleteRevUsersPersonalDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRevUsersPersonalData(ctx context.Context, body DeleteRevUsersPersonalDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersGet request
	RevUsersGet(ctx context.Context, params *RevUsersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersGetPostWithBody request with any body
	RevUsersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersGetPost(ctx context.Context, body RevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkRevUserToRevOrgWithBody request with any body
	LinkRevUserToRevOrgWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkRevUserToRevOrg(ctx context.Context, body LinkRevUserToRevOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersList request
	RevUsersList(ctx context.Context, params *RevUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersListPostWithBody request with any body
	RevUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersListPost(ctx context.Context, body RevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersMergeWithBody request with any body
	RevUsersMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersMerge(ctx context.Context, body RevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRevUsersPersonalDataWithBody request with any body
	GetRevUsersPersonalDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetRevUsersPersonalData(ctx context.Context, body GetRevUsersPersonalDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersScan request
	RevUsersScan(ctx context.Context, params *RevUsersScanParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersScanPostWithBody request with any body
	RevUsersScanPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersScanPost(ctx context.Context, body RevUsersScanPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkRevUserFromRevOrgWithBody request with any body
	UnlinkRevUserFromRevOrgWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkRevUserFromRevOrg(ctx context.Context, body UnlinkRevUserFromRevOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevUsersUpdateWithBody request with any body
	RevUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevUsersUpdate(ctx context.Context, body RevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RolesApplyWithBody request with any body
	RolesApplyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RolesApply(ctx context.Context, body RolesApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RolesCreateWithBody request with any body
	RolesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RolesCreate(ctx context.Context, body RolesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AggregatedSchemaGet request
	AggregatedSchemaGet(ctx context.Context, params *AggregatedSchemaGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AggregatedSchemaGetPostWithBody request with any body
	AggregatedSchemaGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AggregatedSchemaGetPost(ctx context.Context, body AggregatedSchemaGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomSchemaFragmentsGet request
	CustomSchemaFragmentsGet(ctx context.Context, params *CustomSchemaFragmentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomSchemaFragmentsGetPostWithBody request with any body
	CustomSchemaFragmentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomSchemaFragmentsGetPost(ctx context.Context, body CustomSchemaFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomSchemaFragmentsList request
	CustomSchemaFragmentsList(ctx context.Context, params *CustomSchemaFragmentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomSchemaFragmentsListPostWithBody request with any body
	CustomSchemaFragmentsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomSchemaFragmentsListPost(ctx context.Context, body CustomSchemaFragmentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomSchemaFragmentsSetWithBody request with any body
	CustomSchemaFragmentsSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomSchemaFragmentsSet(ctx context.Context, body CustomSchemaFragmentsSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StockSchemaFragmentsGet request
	StockSchemaFragmentsGet(ctx context.Context, params *StockSchemaFragmentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StockSchemaFragmentsGetPostWithBody request with any body
	StockSchemaFragmentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StockSchemaFragmentsGetPost(ctx context.Context, body StockSchemaFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StockSchemaFragmentsList request
	StockSchemaFragmentsList(ctx context.Context, params *StockSchemaFragmentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StockSchemaFragmentsListPostWithBody request with any body
	StockSchemaFragmentsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StockSchemaFragmentsListPost(ctx context.Context, body StockSchemaFragmentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubtypesList request
	SubtypesList(ctx context.Context, params *SubtypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubtypesListPostWithBody request with any body
	SubtypesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubtypesListPost(ctx context.Context, body SubtypesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasSubtypePrepareUpdateGetWithBody request with any body
	SchemasSubtypePrepareUpdateGetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SchemasSubtypePrepareUpdateGet(ctx context.Context, body SchemasSubtypePrepareUpdateGetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCore request
	SearchCore(ctx context.Context, params *SearchCoreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCorePostWithBody request with any body
	SearchCorePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchCorePost(ctx context.Context, body SearchCorePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchHybrid request
	SearchHybrid(ctx context.Context, params *SearchHybridParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchHybridPostWithBody request with any body
	SearchHybridPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchHybridPost(ctx context.Context, body SearchHybridPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServiceAccountsCreateWithBody request with any body
	ServiceAccountsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ServiceAccountsCreate(ctx context.Context, body ServiceAccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServiceAccountsGet request
	ServiceAccountsGet(ctx context.Context, params *ServiceAccountsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServiceAccountsGetPostWithBody request with any body
	ServiceAccountsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ServiceAccountsGetPost(ctx context.Context, body ServiceAccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServiceAccountsUpdateWithBody request with any body
	ServiceAccountsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ServiceAccountsUpdate(ctx context.Context, body ServiceAccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaTrackersGet request
	SlaTrackersGet(ctx context.Context, params *SlaTrackersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaTrackersGetPostWithBody request with any body
	SlaTrackersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlaTrackersGetPost(ctx context.Context, body SlaTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaTrackersList request
	SlaTrackersList(ctx context.Context, params *SlaTrackersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaTrackersListPostWithBody request with any body
	SlaTrackersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlaTrackersListPost(ctx context.Context, body SlaTrackersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaTrackersRemoveMetricWithBody request with any body
	SlaTrackersRemoveMetricWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlaTrackersRemoveMetric(ctx context.Context, body SlaTrackersRemoveMetricJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasAssignWithBody request with any body
	SlasAssignWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasAssign(ctx context.Context, body SlasAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasCreateWithBody request with any body
	SlasCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasCreate(ctx context.Context, body SlasCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasGet request
	SlasGet(ctx context.Context, params *SlasGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasGetPostWithBody request with any body
	SlasGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasGetPost(ctx context.Context, body SlasGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasList request
	SlasList(ctx context.Context, params *SlasListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasListPostWithBody request with any body
	SlasListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasListPost(ctx context.Context, body SlasListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasTransitionWithBody request with any body
	SlasTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasTransition(ctx context.Context, body SlasTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlasUpdateWithBody request with any body
	SlasUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlasUpdate(ctx context.Context, body SlasUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapInsResources request
	SnapInsResources(ctx context.Context, params *SnapInsResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapInsResourcesPostWithBody request with any body
	SnapInsResourcesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnapInsResourcesPost(ctx context.Context, body SnapInsResourcesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapInsUpdateWithBody request with any body
	SnapInsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnapInsUpdate(ctx context.Context, body SnapInsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapKitActionExecuteDeferredWithBody request with any body
	SnapKitActionExecuteDeferredWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnapKitActionExecuteDeferred(ctx context.Context, body SnapKitActionExecuteDeferredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapWidgetsCreateWithBody request with any body
	SnapWidgetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnapWidgetsCreate(ctx context.Context, body SnapWidgetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageDiagramsCreateWithBody request with any body
	StageDiagramsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StageDiagramsCreate(ctx context.Context, body StageDiagramsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageDiagramsGet request
	StageDiagramsGet(ctx context.Context, params *StageDiagramsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageDiagramsGetPostWithBody request with any body
	StageDiagramsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StageDiagramsGetPost(ctx context.Context, body StageDiagramsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageDiagramsList request
	StageDiagramsList(ctx context.Context, params *StageDiagramsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageDiagramsListPostWithBody request with any body
	StageDiagramsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StageDiagramsListPost(ctx context.Context, body StageDiagramsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageDiagramsUpdateWithBody request with any body
	StageDiagramsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StageDiagramsUpdate(ctx context.Context, body StageDiagramsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStagesCreateWithBody request with any body
	CustomStagesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomStagesCreate(ctx context.Context, body CustomStagesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStagesGet request
	CustomStagesGet(ctx context.Context, params *CustomStagesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStagesGetPostWithBody request with any body
	CustomStagesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomStagesGetPost(ctx context.Context, body CustomStagesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStagesList request
	CustomStagesList(ctx context.Context, params *CustomStagesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStagesListPostWithBody request with any body
	CustomStagesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomStagesListPost(ctx context.Context, body CustomStagesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStagesUpdateWithBody request with any body
	CustomStagesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomStagesUpdate(ctx context.Context, body CustomStagesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStatesCreateWithBody request with any body
	CustomStatesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomStatesCreate(ctx context.Context, body CustomStatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStatesGet request
	CustomStatesGet(ctx context.Context, params *CustomStatesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStatesGetPostWithBody request with any body
	CustomStatesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomStatesGetPost(ctx context.Context, body CustomStatesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStatesList request
	CustomStatesList(ctx context.Context, params *CustomStatesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStatesListPostWithBody request with any body
	CustomStatesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomStatesListPost(ctx context.Context, body CustomStatesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomStatesUpdateWithBody request with any body
	CustomStatesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomStatesUpdate(ctx context.Context, body CustomStatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribersList request
	SubscribersList(ctx context.Context, params *SubscribersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribersListPostWithBody request with any body
	SubscribersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubscribersListPost(ctx context.Context, body SubscribersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribersUpdateWithBody request with any body
	SubscribersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubscribersUpdate(ctx context.Context, body SubscribersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysCreateWithBody request with any body
	SurveysCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysCreate(ctx context.Context, body SurveysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysDeleteWithBody request with any body
	SurveysDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysDelete(ctx context.Context, body SurveysDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysGet request
	SurveysGet(ctx context.Context, params *SurveysGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysGetPostWithBody request with any body
	SurveysGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysGetPost(ctx context.Context, body SurveysGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysList request
	SurveysList(ctx context.Context, params *SurveysListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysListPostWithBody request with any body
	SurveysListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysListPost(ctx context.Context, body SurveysListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysResponsesList request
	SurveysResponsesList(ctx context.Context, params *SurveysResponsesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysResponsesListPostWithBody request with any body
	SurveysResponsesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysResponsesListPost(ctx context.Context, body SurveysResponsesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysResponsesUpdateWithBody request with any body
	SurveysResponsesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysResponsesUpdate(ctx context.Context, body SurveysResponsesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysSendWithBody request with any body
	SurveysSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysSend(ctx context.Context, body SurveysSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysSubmitWithBody request with any body
	SurveysSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysSubmit(ctx context.Context, body SurveysSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SurveysUpdateWithBody request with any body
	SurveysUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SurveysUpdate(ctx context.Context, body SurveysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SysUsersList request
	SysUsersList(ctx context.Context, params *SysUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SysUsersListPostWithBody request with any body
	SysUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SysUsersListPost(ctx context.Context, body SysUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SysUsersUpdateWithBody request with any body
	SysUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SysUsersUpdate(ctx context.Context, body SysUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsCreateWithBody request with any body
	TagsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsCreate(ctx context.Context, body TagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsDeleteWithBody request with any body
	TagsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsDelete(ctx context.Context, body TagsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsGet request
	TagsGet(ctx context.Context, params *TagsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsGetPostWithBody request with any body
	TagsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsGetPost(ctx context.Context, body TagsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsList request
	TagsList(ctx context.Context, params *TagsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsListPostWithBody request with any body
	TagsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsListPost(ctx context.Context, body TagsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsUpdateWithBody request with any body
	TagsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsUpdate(ctx context.Context, body TagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesCreateWithBody request with any body
	TimelineEntriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesCreate(ctx context.Context, body TimelineEntriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesDeleteWithBody request with any body
	TimelineEntriesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesDelete(ctx context.Context, body TimelineEntriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesGet request
	TimelineEntriesGet(ctx context.Context, params *TimelineEntriesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesGetPostWithBody request with any body
	TimelineEntriesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesGetPost(ctx context.Context, body TimelineEntriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesList request
	TimelineEntriesList(ctx context.Context, params *TimelineEntriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesListPostWithBody request with any body
	TimelineEntriesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesListPost(ctx context.Context, body TimelineEntriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelineEntriesUpdateWithBody request with any body
	TimelineEntriesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelineEntriesUpdate(ctx context.Context, body TimelineEntriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackEventsPublishWithBody request with any body
	TrackEventsPublishWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TrackEventsPublish(ctx context.Context, body TrackEventsPublishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UomsCount request
	UomsCount(ctx context.Context, params *UomsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UomsCountPostWithBody request with any body
	UomsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UomsCountPost(ctx context.Context, body UomsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UomsCreateWithBody request with any body
	UomsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UomsCreate(ctx context.Context, body UomsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UomsDeleteWithBody request with any body
	UomsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UomsDelete(ctx context.Context, body UomsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UomsGet request
	UomsGet(ctx context.Context, params *UomsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UomsGetPostWithBody request with any body
	UomsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UomsGetPost(ctx context.Context, body UomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UomsList request
	UomsList(ctx context.Context, params *UomsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UomsListPostWithBody request with any body
	UomsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UomsListPost(ctx context.Context, body UomsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UomsUpdateWithBody request with any body
	UomsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UomsUpdate(ctx context.Context, body UomsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebCrawlerJobsControlWithBody request with any body
	WebCrawlerJobsControlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebCrawlerJobsControl(ctx context.Context, body WebCrawlerJobsControlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebCrawlerJobWithBody request with any body
	CreateWebCrawlerJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebCrawlerJob(ctx context.Context, body CreateWebCrawlerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebCrawlerJob request
	GetWebCrawlerJob(ctx context.Context, params *GetWebCrawlerJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebCrawlerJobPostWithBody request with any body
	GetWebCrawlerJobPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetWebCrawlerJobPost(ctx context.Context, body GetWebCrawlerJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebCrawlerJobs request
	ListWebCrawlerJobs(ctx context.Context, params *ListWebCrawlerJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebCrawlerJobsPostWithBody request with any body
	ListWebCrawlerJobsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListWebCrawlerJobsPost(ctx context.Context, body ListWebCrawlerJobsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksCreateWithBody request with any body
	WebhooksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksCreate(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksDeleteWithBody request with any body
	WebhooksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksDelete(ctx context.Context, body WebhooksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksEventWithBody request with any body
	WebhooksEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksEvent(ctx context.Context, body WebhooksEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksFetchWithBody request with any body
	WebhooksFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksFetch(ctx context.Context, body WebhooksFetchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksGet request
	WebhooksGet(ctx context.Context, params *WebhooksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksGetPostWithBody request with any body
	WebhooksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksGetPost(ctx context.Context, body WebhooksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksList request
	WebhooksList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksListPostWithBody request with any body
	WebhooksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksListPost(ctx context.Context, body WebhooksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksUpdateWithBody request with any body
	WebhooksUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksUpdate(ctx context.Context, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WidgetsGet request
	WidgetsGet(ctx context.Context, params *WidgetsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WidgetsGetPostWithBody request with any body
	WidgetsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WidgetsGetPost(ctx context.Context, body WidgetsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksCreateWithBody request with any body
	WorksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksCreate(ctx context.Context, body WorksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksDeleteWithBody request with any body
	WorksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksDelete(ctx context.Context, body WorksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksExport request
	WorksExport(ctx context.Context, params *WorksExportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksExportPostWithBody request with any body
	WorksExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksExportPost(ctx context.Context, body WorksExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksGet request
	WorksGet(ctx context.Context, params *WorksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksGetPostWithBody request with any body
	WorksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksGetPost(ctx context.Context, body WorksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksList request
	WorksList(ctx context.Context, params *WorksListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksListPostWithBody request with any body
	WorksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksListPost(ctx context.Context, body WorksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorksUpdateWithBody request with any body
	WorksUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorksUpdate(ctx context.Context, body WorksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AccountsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsCreate(ctx context.Context, body AccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsDelete(ctx context.Context, body AccountsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsExport(ctx context.Context, params *AccountsExportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsExportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsExportPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsExportPost(ctx context.Context, body AccountsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsExportPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsGet(ctx context.Context, params *AccountsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsGetPost(ctx context.Context, body AccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsList(ctx context.Context, params *AccountsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsListPost(ctx context.Context, body AccountsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsMergeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsMerge(ctx context.Context, body AccountsMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsMergeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsUpdate(ctx context.Context, body AccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AiAgentEventsExecuteAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAiAgentEventsExecuteAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AiAgentEventsExecuteAsync(ctx context.Context, body AiAgentEventsExecuteAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAiAgentEventsExecuteAsyncRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AirdropSyncUnitsGet(ctx context.Context, params *AirdropSyncUnitsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAirdropSyncUnitsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AirdropSyncUnitsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAirdropSyncUnitsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AirdropSyncUnitsGetPost(ctx context.Context, body AirdropSyncUnitsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAirdropSyncUnitsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AirdropSyncUnitsHistory(ctx context.Context, params *AirdropSyncUnitsHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAirdropSyncUnitsHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AirdropSyncUnitsHistoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAirdropSyncUnitsHistoryPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AirdropSyncUnitsHistoryPost(ctx context.Context, body AirdropSyncUnitsHistoryPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAirdropSyncUnitsHistoryPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArticlesCount(ctx context.Context, params *ArticlesCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArticlesCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArticlesCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArticlesCountPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArticlesCountPost(ctx context.Context, body ArticlesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArticlesCountPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateArticleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateArticle(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateArticleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteArticleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteArticle(ctx context.Context, body DeleteArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteArticleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticle(ctx context.Context, params *GetArticleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticlePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticlePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArticlePost(ctx context.Context, body GetArticlePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArticlePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListArticles(ctx context.Context, params *ListArticlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListArticlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListArticlesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListArticlesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListArticlesPost(ctx context.Context, body ListArticlesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListArticlesPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateArticleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateArticleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateArticle(ctx context.Context, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateArticleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsGet(ctx context.Context, params *ArtifactsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsGetPost(ctx context.Context, body ArtifactsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsList(ctx context.Context, params *ArtifactsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsListPost(ctx context.Context, body ArtifactsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsLocate(ctx context.Context, params *ArtifactsLocateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsLocateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsLocatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsLocatePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsLocatePost(ctx context.Context, body ArtifactsLocatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsLocatePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsPrepareRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsPrepare(ctx context.Context, body ArtifactsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsPrepareRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsHardDeleteVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsHardDeleteVersionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsHardDeleteVersion(ctx context.Context, body ArtifactsHardDeleteVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsHardDeleteVersionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsVersionsPrepareWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsVersionsPrepareRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtifactsVersionsPrepare(ctx context.Context, body ArtifactsVersionsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtifactsVersionsPrepareRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AtomsGet(ctx context.Context, params *AtomsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAtomsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AtomsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAtomsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AtomsGetPost(ctx context.Context, body AtomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAtomsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportAuditLogsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportAuditLogsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportAuditLogs(ctx context.Context, body ExportAuditLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportAuditLogsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensCreate(ctx context.Context, body AuthTokensCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensDelete(ctx context.Context, body AuthTokensDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensGet(ctx context.Context, params *AuthTokensGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensGetPost(ctx context.Context, body AuthTokensGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensInfoPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensInfoPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensInfoPost(ctx context.Context, body AuthTokensInfoPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensInfoPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensList(ctx context.Context, params *AuthTokensListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensListPost(ctx context.Context, body AuthTokensListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensSelfDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensSelfDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensSelfDelete(ctx context.Context, body AuthTokensSelfDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensSelfDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthTokensUpdate(ctx context.Context, body AuthTokensUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthTokensUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsCreate(ctx context.Context, body BrandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsDelete(ctx context.Context, body BrandsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsGet(ctx context.Context, params *BrandsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsGetPost(ctx context.Context, body BrandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsList(ctx context.Context, params *BrandsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsListPost(ctx context.Context, body BrandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrandsUpdate(ctx context.Context, body BrandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrandsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsCreate(ctx context.Context, body ChatsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsGet(ctx context.Context, params *ChatsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsGetPost(ctx context.Context, body ChatsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatsUpdate(ctx context.Context, body ChatsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesCreate(ctx context.Context, body CodeChangesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesDelete(ctx context.Context, body CodeChangesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesGet(ctx context.Context, params *CodeChangesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesGetPost(ctx context.Context, body CodeChangesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesList(ctx context.Context, params *CodeChangesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesListPost(ctx context.Context, body CodeChangesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeChangesUpdate(ctx context.Context, body CodeChangesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeChangesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsCreate(ctx context.Context, body CommandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsGet(ctx context.Context, params *CommandsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsGetPost(ctx context.Context, body CommandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsList(ctx context.Context, params *CommandsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsListPost(ctx context.Context, body CommandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommandsUpdate(ctx context.Context, body CommandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommandsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContentTemplateCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContentTemplateCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContentTemplateCreate(ctx context.Context, body ContentTemplateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContentTemplateCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContentTemplateGet(ctx context.Context, params *ContentTemplateGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContentTemplateGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContentTemplateGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContentTemplateGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContentTemplateGetPost(ctx context.Context, body ContentTemplateGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContentTemplateGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContentTemplateList(ctx context.Context, params *ContentTemplateListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContentTemplateListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContentTemplateListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContentTemplateListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContentTemplateListPost(ctx context.Context, body ContentTemplateListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContentTemplateListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsCreate(ctx context.Context, body ConversationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsDelete(ctx context.Context, body ConversationsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsExport(ctx context.Context, params *ConversationsExportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsExportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsExportPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsExportPost(ctx context.Context, body ConversationsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsExportPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsGet(ctx context.Context, params *ConversationsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsGetPost(ctx context.Context, body ConversationsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsList(ctx context.Context, params *ConversationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsListPost(ctx context.Context, body ConversationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConversationsUpdate(ctx context.Context, body ConversationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConversationsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsCount(ctx context.Context, params *CustomObjectsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsCountPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsCountPost(ctx context.Context, body CustomObjectsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsCountPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsCreate(ctx context.Context, body CustomObjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsDelete(ctx context.Context, body CustomObjectsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsGet(ctx context.Context, params *CustomObjectsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsGetPost(ctx context.Context, body CustomObjectsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsList(ctx context.Context, params *CustomObjectsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsListPost(ctx context.Context, body CustomObjectsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomObjectsUpdate(ctx context.Context, body CustomObjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomObjectsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsCreate(ctx context.Context, body DevOrgAuthConnectionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsDelete(ctx context.Context, body DevOrgAuthConnectionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsGet(ctx context.Context, params *DevOrgAuthConnectionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsGetPost(ctx context.Context, body DevOrgAuthConnectionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsListPost(ctx context.Context, body DevOrgAuthConnectionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsToggleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsToggleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsToggle(ctx context.Context, body DevOrgAuthConnectionsToggleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsToggleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgAuthConnectionsUpdate(ctx context.Context, body DevOrgAuthConnectionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgAuthConnectionsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgsGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevOrgsGetPost(ctx context.Context, body DevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevOrgsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersActivateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersActivateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersActivate(ctx context.Context, body DevUsersActivateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersActivateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersCreate(ctx context.Context, body DevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersDeactivateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersDeactivateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersDeactivate(ctx context.Context, body DevUsersDeactivateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersDeactivateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersGet(ctx context.Context, params *DevUsersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersGetPost(ctx context.Context, body DevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersIdentitiesLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersIdentitiesLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersIdentitiesLink(ctx context.Context, body DevUsersIdentitiesLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersIdentitiesLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersIdentitiesUnlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersIdentitiesUnlinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersIdentitiesUnlink(ctx context.Context, body DevUsersIdentitiesUnlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersIdentitiesUnlinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersList(ctx context.Context, params *DevUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersListPost(ctx context.Context, body DevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersMergeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersMerge(ctx context.Context, body DevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersMergeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelfPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelfPost(ctx context.Context, body DevUsersSelfPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelfUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersSelfUpdate(ctx context.Context, body DevUsersSelfUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersSelfUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevUsersUpdate(ctx context.Context, body DevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevUsersUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCount(ctx context.Context, params *DirectoriesCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCountPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCountPost(ctx context.Context, body DirectoriesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCountPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesCreate(ctx context.Context, body DirectoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesDelete(ctx context.Context, body DirectoriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesGet(ctx context.Context, params *DirectoriesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesGetPost(ctx context.Context, body DirectoriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesList(ctx context.Context, params *DirectoriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesListPost(ctx context.Context, body DirectoriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectoriesUpdate(ctx context.Context, body DirectoriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectoriesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsCount(ctx context.Context, params *EngagementsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsCountPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsCountPost(ctx context.Context, body EngagementsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsCountPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsCreate(ctx context.Context, body EngagementsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsDelete(ctx context.Context, body EngagementsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsGet(ctx context.Context, params *EngagementsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsGetPost(ctx context.Context, body EngagementsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsList(ctx context.Context, params *EngagementsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsListPost(ctx context.Context, body EngagementsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsUpdate(ctx context.Context, body EngagementsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventSourcesGet(ctx context.Context, params *EventSourcesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventSourcesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventSourcesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventSourcesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventSourcesGetPost(ctx context.Context, body EventSourcesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventSourcesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventSourcesScheduleEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventSourcesScheduleEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventSourcesScheduleEvent(ctx context.Context, body EventSourcesScheduleEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventSourcesScheduleEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventSourcesDeleteScheduledEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventSourcesDeleteScheduledEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventSourcesDeleteScheduledEvent(ctx context.Context, body EventSourcesDeleteScheduledEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventSourcesDeleteScheduledEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsCreate(ctx context.Context, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsGet(ctx context.Context, params *GroupsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsGetPost(ctx context.Context, body GroupsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsList(ctx context.Context, params *GroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsListPost(ctx context.Context, body GroupsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersAddRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersAdd(ctx context.Context, body GroupMembersAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersAddRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersList(ctx context.Context, params *GroupMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersListPost(ctx context.Context, body GroupMembersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersRemoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersRemoveRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupMembersRemove(ctx context.Context, body GroupMembersRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupMembersRemoveRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsUpdate(ctx context.Context, body GroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsCreate(ctx context.Context, body IncidentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsDelete(ctx context.Context, body IncidentsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsGet(ctx context.Context, params *IncidentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsGetPost(ctx context.Context, body IncidentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsGroup(ctx context.Context, params *IncidentsGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsGroupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsGroupPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsGroupPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsGroupPost(ctx context.Context, body IncidentsGroupPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsGroupPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsList(ctx context.Context, params *IncidentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsListPost(ctx context.Context, body IncidentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncidentsUpdate(ctx context.Context, body IncidentsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncidentsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KeyringsCreateCallback(ctx context.Context, params *KeyringsCreateCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKeyringsCreateCallbackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KeyringsCreateCallbackPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKeyringsCreateCallbackPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KeyringsCreateCallbackPost(ctx context.Context, body KeyringsCreateCallbackPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKeyringsCreateCallbackPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeCreate(ctx context.Context, body CustomLinkTypeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeGet(ctx context.Context, params *CustomLinkTypeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeGetPost(ctx context.Context, body CustomLinkTypeGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeList(ctx context.Context, params *CustomLinkTypeListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeListPost(ctx context.Context, body CustomLinkTypeListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomLinkTypeUpdate(ctx context.Context, body CustomLinkTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomLinkTypeUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksCreate(ctx context.Context, body LinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksDelete(ctx context.Context, body LinksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksGet(ctx context.Context, params *LinksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksGetPost(ctx context.Context, body LinksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksList(ctx context.Context, params *LinksListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksListPost(ctx context.Context, body LinksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksReplaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksReplaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinksReplace(ctx context.Context, body LinksReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinksReplaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCount(ctx context.Context, params *MeetingsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCountPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCountPost(ctx context.Context, body MeetingsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCountPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsCreate(ctx context.Context, body MeetingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsDelete(ctx context.Context, body MeetingsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsGet(ctx context.Context, params *MeetingsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsGetPost(ctx context.Context, body MeetingsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsList(ctx context.Context, params *MeetingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsListPost(ctx context.Context, body MeetingsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingsUpdate(ctx context.Context, body MeetingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricActionExecuteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricActionExecuteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricActionExecute(ctx context.Context, body MetricActionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricActionExecuteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsCreate(ctx context.Context, body MetricDefinitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsDelete(ctx context.Context, body MetricDefinitionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsGet(ctx context.Context, params *MetricDefinitionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsGetPost(ctx context.Context, body MetricDefinitionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsList(ctx context.Context, params *MetricDefinitionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsListPost(ctx context.Context, body MetricDefinitionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricDefinitionsUpdate(ctx context.Context, body MetricDefinitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricDefinitionsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricTrackersGet(ctx context.Context, params *MetricTrackersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricTrackersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricTrackersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricTrackersGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricTrackersGetPost(ctx context.Context, body MetricTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricTrackersGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricsDevrevIngestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsDevrevIngestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricsDevrevIngest(ctx context.Context, body MetricsDevrevIngestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsDevrevIngestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsSendRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsSend(ctx context.Context, body NotificationsSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsSendRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsCreate(ctx context.Context, body OrgScheduleFragmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsGet(ctx context.Context, params *OrgScheduleFragmentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsGetPost(ctx context.Context, body OrgScheduleFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsTransitionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgScheduleFragmentsTransition(ctx context.Context, body OrgScheduleFragmentsTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgScheduleFragmentsTransitionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesCreate(ctx context.Context, body OrgSchedulesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesEvaluate(ctx context.Context, params *OrgSchedulesEvaluateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesEvaluateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesEvaluatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesEvaluatePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesEvaluatePost(ctx context.Context, body OrgSchedulesEvaluatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesEvaluatePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesGet(ctx context.Context, params *OrgSchedulesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesGetPost(ctx context.Context, body OrgSchedulesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesList(ctx context.Context, params *OrgSchedulesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesListPost(ctx context.Context, body OrgSchedulesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesSetFutureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesSetFutureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesSetFuture(ctx context.Context, body OrgSchedulesSetFutureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesSetFutureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesTransitionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesTransition(ctx context.Context, body OrgSchedulesTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesTransitionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgSchedulesUpdate(ctx context.Context, body OrgSchedulesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgSchedulesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsCreate(ctx context.Context, body PartsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsDelete(ctx context.Context, body PartsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsGet(ctx context.Context, params *PartsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsGetPost(ctx context.Context, body PartsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsList(ctx context.Context, params *PartsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsListPost(ctx context.Context, body PartsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartsUpdate(ctx context.Context, body PartsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreferencesGet(ctx context.Context, params *PreferencesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreferencesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreferencesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreferencesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreferencesGetPost(ctx context.Context, body PreferencesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreferencesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreferencesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreferencesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreferencesUpdate(ctx context.Context, body PreferencesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreferencesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQuestionAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQuestionAnswerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQuestionAnswer(ctx context.Context, body CreateQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQuestionAnswerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQuestionAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQuestionAnswerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQuestionAnswer(ctx context.Context, body DeleteQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQuestionAnswerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQuestionAnswer(ctx context.Context, params *GetQuestionAnswerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQuestionAnswerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQuestionAnswerPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQuestionAnswerPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQuestionAnswerPost(ctx context.Context, body GetQuestionAnswerPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQuestionAnswerPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQuestionAnswers(ctx context.Context, params *ListQuestionAnswersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQuestionAnswersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQuestionAnswersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQuestionAnswersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQuestionAnswersPost(ctx context.Context, body ListQuestionAnswersPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQuestionAnswersPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateQuestionAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateQuestionAnswerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateQuestionAnswer(ctx context.Context, body UpdateQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateQuestionAnswerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsList(ctx context.Context, params *ReactionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsListPost(ctx context.Context, body ReactionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsUpdate(ctx context.Context, body ReactionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatCompletionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatCompletionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatCompletions(ctx context.Context, body ChatCompletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatCompletionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReply(ctx context.Context, body GetReplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordTemplateGet(ctx context.Context, params *RecordTemplateGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordTemplateGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordTemplateGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordTemplateGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordTemplateGetPost(ctx context.Context, body RecordTemplateGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordTemplateGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsCreate(ctx context.Context, body RevOrgsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsDelete(ctx context.Context, body RevOrgsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsGet(ctx context.Context, params *RevOrgsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsGetPost(ctx context.Context, body RevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsList(ctx context.Context, params *RevOrgsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsListPost(ctx context.Context, body RevOrgsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevOrgsUpdate(ctx context.Context, body RevOrgsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevOrgsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersAssociationsAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersAssociationsAddRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersAssociationsAdd(ctx context.Context, body RevUsersAssociationsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersAssociationsAddRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersAssociationsList(ctx context.Context, params *RevUsersAssociationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersAssociationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersAssociationsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersAssociationsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersAssociationsListPost(ctx context.Context, body RevUsersAssociationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersAssociationsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersAssociationsRemoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersAssociationsRemoveRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersAssociationsRemove(ctx context.Context, body RevUsersAssociationsRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersAssociationsRemoveRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersCreate(ctx context.Context, body RevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersDelete(ctx context.Context, body RevUsersDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRevUsersPersonalDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRevUsersPersonalDataRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRevUsersPersonalData(ctx context.Context, body DeleteRevUsersPersonalDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRevUsersPersonalDataRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersGet(ctx context.Context, params *RevUsersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersGetPost(ctx context.Context, body RevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRevUserToRevOrgWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRevUserToRevOrgRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRevUserToRevOrg(ctx context.Context, body LinkRevUserToRevOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRevUserToRevOrgRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersList(ctx context.Context, params *RevUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersListPost(ctx context.Context, body RevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersMergeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersMergeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersMerge(ctx context.Context, body RevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersMergeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRevUsersPersonalDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRevUsersPersonalDataRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRevUsersPersonalData(ctx context.Context, body GetRevUsersPersonalDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRevUsersPersonalDataRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersScan(ctx context.Context, params *RevUsersScanParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersScanRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersScanPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersScanPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersScanPost(ctx context.Context, body RevUsersScanPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersScanPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkRevUserFromRevOrgWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkRevUserFromRevOrgRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkRevUserFromRevOrg(ctx context.Context, body UnlinkRevUserFromRevOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkRevUserFromRevOrgRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevUsersUpdate(ctx context.Context, body RevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevUsersUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RolesApplyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRolesApplyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RolesApply(ctx context.Context, body RolesApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRolesApplyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RolesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRolesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RolesCreate(ctx context.Context, body RolesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRolesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AggregatedSchemaGet(ctx context.Context, params *AggregatedSchemaGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAggregatedSchemaGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AggregatedSchemaGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAggregatedSchemaGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AggregatedSchemaGetPost(ctx context.Context, body AggregatedSchemaGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAggregatedSchemaGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomSchemaFragmentsGet(ctx context.Context, params *CustomSchemaFragmentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomSchemaFragmentsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomSchemaFragmentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomSchemaFragmentsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomSchemaFragmentsGetPost(ctx context.Context, body CustomSchemaFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomSchemaFragmentsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomSchemaFragmentsList(ctx context.Context, params *CustomSchemaFragmentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomSchemaFragmentsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomSchemaFragmentsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomSchemaFragmentsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomSchemaFragmentsListPost(ctx context.Context, body CustomSchemaFragmentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomSchemaFragmentsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomSchemaFragmentsSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomSchemaFragmentsSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomSchemaFragmentsSet(ctx context.Context, body CustomSchemaFragmentsSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomSchemaFragmentsSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StockSchemaFragmentsGet(ctx context.Context, params *StockSchemaFragmentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStockSchemaFragmentsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StockSchemaFragmentsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStockSchemaFragmentsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StockSchemaFragmentsGetPost(ctx context.Context, body StockSchemaFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStockSchemaFragmentsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StockSchemaFragmentsList(ctx context.Context, params *StockSchemaFragmentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStockSchemaFragmentsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StockSchemaFragmentsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStockSchemaFragmentsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StockSchemaFragmentsListPost(ctx context.Context, body StockSchemaFragmentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStockSchemaFragmentsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubtypesList(ctx context.Context, params *SubtypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubtypesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubtypesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubtypesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubtypesListPost(ctx context.Context, body SubtypesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubtypesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasSubtypePrepareUpdateGetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasSubtypePrepareUpdateGetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasSubtypePrepareUpdateGet(ctx context.Context, body SchemasSubtypePrepareUpdateGetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasSubtypePrepareUpdateGetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCore(ctx context.Context, params *SearchCoreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCoreRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCorePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCorePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCorePost(ctx context.Context, body SearchCorePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCorePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchHybrid(ctx context.Context, params *SearchHybridParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchHybridRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchHybridPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchHybridPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchHybridPost(ctx context.Context, body SearchHybridPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchHybridPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsCreate(ctx context.Context, body ServiceAccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsGet(ctx context.Context, params *ServiceAccountsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsGetPost(ctx context.Context, body ServiceAccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceAccountsUpdate(ctx context.Context, body ServiceAccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceAccountsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersGet(ctx context.Context, params *SlaTrackersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersGetPost(ctx context.Context, body SlaTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersList(ctx context.Context, params *SlaTrackersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersListPost(ctx context.Context, body SlaTrackersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersRemoveMetricWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersRemoveMetricRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaTrackersRemoveMetric(ctx context.Context, body SlaTrackersRemoveMetricJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaTrackersRemoveMetricRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasAssignWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasAssignRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasAssign(ctx context.Context, body SlasAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasAssignRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasCreate(ctx context.Context, body SlasCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasGet(ctx context.Context, params *SlasGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasGetPost(ctx context.Context, body SlasGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasList(ctx context.Context, params *SlasListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasListPost(ctx context.Context, body SlasListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasTransitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasTransitionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasTransition(ctx context.Context, body SlasTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasTransitionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlasUpdate(ctx context.Context, body SlasUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlasUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapInsResources(ctx context.Context, params *SnapInsResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapInsResourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapInsResourcesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapInsResourcesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapInsResourcesPost(ctx context.Context, body SnapInsResourcesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapInsResourcesPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapInsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapInsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapInsUpdate(ctx context.Context, body SnapInsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapInsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapKitActionExecuteDeferredWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapKitActionExecuteDeferredRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapKitActionExecuteDeferred(ctx context.Context, body SnapKitActionExecuteDeferredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapKitActionExecuteDeferredRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapWidgetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapWidgetsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapWidgetsCreate(ctx context.Context, body SnapWidgetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapWidgetsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsCreate(ctx context.Context, body StageDiagramsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsGet(ctx context.Context, params *StageDiagramsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsGetPost(ctx context.Context, body StageDiagramsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsList(ctx context.Context, params *StageDiagramsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsListPost(ctx context.Context, body StageDiagramsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageDiagramsUpdate(ctx context.Context, body StageDiagramsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageDiagramsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesCreate(ctx context.Context, body CustomStagesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesGet(ctx context.Context, params *CustomStagesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesGetPost(ctx context.Context, body CustomStagesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesList(ctx context.Context, params *CustomStagesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesListPost(ctx context.Context, body CustomStagesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStagesUpdate(ctx context.Context, body CustomStagesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStagesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesCreate(ctx context.Context, body CustomStatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesGet(ctx context.Context, params *CustomStatesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesGetPost(ctx context.Context, body CustomStatesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesList(ctx context.Context, params *CustomStatesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesListPost(ctx context.Context, body CustomStatesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomStatesUpdate(ctx context.Context, body CustomStatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomStatesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribersList(ctx context.Context, params *SubscribersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribersListPost(ctx context.Context, body SubscribersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribersUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribersUpdate(ctx context.Context, body SubscribersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribersUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysCreate(ctx context.Context, body SurveysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysDelete(ctx context.Context, body SurveysDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysGet(ctx context.Context, params *SurveysGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysGetPost(ctx context.Context, body SurveysGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysList(ctx context.Context, params *SurveysListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysListPost(ctx context.Context, body SurveysListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesList(ctx context.Context, params *SurveysResponsesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesListPost(ctx context.Context, body SurveysResponsesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysResponsesUpdate(ctx context.Context, body SurveysResponsesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysResponsesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysSendRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysSend(ctx context.Context, body SurveysSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysSendRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysSubmit(ctx context.Context, body SurveysSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SurveysUpdate(ctx context.Context, body SurveysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSurveysUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersList(ctx context.Context, params *SysUsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersListPost(ctx context.Context, body SysUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SysUsersUpdate(ctx context.Context, body SysUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSysUsersUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsCreate(ctx context.Context, body TagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsDelete(ctx context.Context, body TagsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsGet(ctx context.Context, params *TagsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsGetPost(ctx context.Context, body TagsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsList(ctx context.Context, params *TagsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsListPost(ctx context.Context, body TagsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TagsUpdate(ctx context.Context, body TagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesCreate(ctx context.Context, body TimelineEntriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesDelete(ctx context.Context, body TimelineEntriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesGet(ctx context.Context, params *TimelineEntriesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesGetPost(ctx context.Context, body TimelineEntriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesList(ctx context.Context, params *TimelineEntriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesListPost(ctx context.Context, body TimelineEntriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelineEntriesUpdate(ctx context.Context, body TimelineEntriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelineEntriesUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackEventsPublishWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackEventsPublishRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackEventsPublish(ctx context.Context, body TrackEventsPublishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackEventsPublishRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsCount(ctx context.Context, params *UomsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsCountPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsCountPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsCountPost(ctx context.Context, body UomsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsCountPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsCreate(ctx context.Context, body UomsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsDelete(ctx context.Context, body UomsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsGet(ctx context.Context, params *UomsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsGetPost(ctx context.Context, body UomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsList(ctx context.Context, params *UomsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsListPost(ctx context.Context, body UomsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UomsUpdate(ctx context.Context, body UomsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUomsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebCrawlerJobsControlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebCrawlerJobsControlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebCrawlerJobsControl(ctx context.Context, body WebCrawlerJobsControlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebCrawlerJobsControlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebCrawlerJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebCrawlerJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebCrawlerJob(ctx context.Context, body CreateWebCrawlerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebCrawlerJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebCrawlerJob(ctx context.Context, params *GetWebCrawlerJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebCrawlerJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebCrawlerJobPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebCrawlerJobPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebCrawlerJobPost(ctx context.Context, body GetWebCrawlerJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebCrawlerJobPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebCrawlerJobs(ctx context.Context, params *ListWebCrawlerJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebCrawlerJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebCrawlerJobsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebCrawlerJobsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebCrawlerJobsPost(ctx context.Context, body ListWebCrawlerJobsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebCrawlerJobsPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksCreate(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksDelete(ctx context.Context, body WebhooksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksEvent(ctx context.Context, body WebhooksEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksFetchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksFetch(ctx context.Context, body WebhooksFetchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksFetchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksGet(ctx context.Context, params *WebhooksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksGetPost(ctx context.Context, body WebhooksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksListPost(ctx context.Context, body WebhooksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksUpdate(ctx context.Context, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WidgetsGet(ctx context.Context, params *WidgetsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWidgetsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WidgetsGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWidgetsGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WidgetsGetPost(ctx context.Context, body WidgetsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWidgetsGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksCreate(ctx context.Context, body WorksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksDelete(ctx context.Context, body WorksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksExport(ctx context.Context, params *WorksExportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksExportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksExportPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksExportPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksExportPost(ctx context.Context, body WorksExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksExportPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksGet(ctx context.Context, params *WorksGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksGetPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksGetPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksGetPost(ctx context.Context, body WorksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksGetPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksList(ctx context.Context, params *WorksListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksListPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksListPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksListPost(ctx context.Context, body WorksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksListPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorksUpdate(ctx context.Context, body WorksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorksUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAccountsCreateRequest calls the generic AccountsCreate builder with application/json body
func NewAccountsCreateRequest(server string, body AccountsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsCreateRequestWithBody generates requests for AccountsCreate with any type of body
func NewAccountsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsDeleteRequest calls the generic AccountsDelete builder with application/json body
func NewAccountsDeleteRequest(server string, body AccountsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsDeleteRequestWithBody generates requests for AccountsDelete with any type of body
func NewAccountsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsExportRequest generates requests for AccountsExport
func NewAccountsExportRequest(server string, params *AccountsExportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "display_name", runtime.ParamLocationQuery, *params.DisplayName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "domains", runtime.ParamLocationQuery, *params.Domains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRefs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_refs", runtime.ParamLocationQuery, *params.ExternalRefs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage", runtime.ParamLocationQuery, *params.Stage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subtype", runtime.ParamLocationQuery, *params.Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tier", runtime.ParamLocationQuery, *params.Tier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Websites != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "websites", runtime.ParamLocationQuery, *params.Websites); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountsExportPostRequest calls the generic AccountsExportPost builder with application/json body
func NewAccountsExportPostRequest(server string, body AccountsExportPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsExportPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsExportPostRequestWithBody generates requests for AccountsExportPost with any type of body
func NewAccountsExportPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsGetRequest generates requests for AccountsGet
func NewAccountsGetRequest(server string, params *AccountsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountsGetPostRequest calls the generic AccountsGetPost builder with application/json body
func NewAccountsGetPostRequest(server string, body AccountsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsGetPostRequestWithBody generates requests for AccountsGetPost with any type of body
func NewAccountsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsListRequest generates requests for AccountsList
func NewAccountsListRequest(server string, params *AccountsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "display_name", runtime.ParamLocationQuery, *params.DisplayName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Domains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "domains", runtime.ParamLocationQuery, *params.Domains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRefs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_refs", runtime.ParamLocationQuery, *params.ExternalRefs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage", runtime.ParamLocationQuery, *params.Stage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subtype", runtime.ParamLocationQuery, *params.Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tier", runtime.ParamLocationQuery, *params.Tier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Websites != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "websites", runtime.ParamLocationQuery, *params.Websites); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountsListPostRequest calls the generic AccountsListPost builder with application/json body
func NewAccountsListPostRequest(server string, body AccountsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsListPostRequestWithBody generates requests for AccountsListPost with any type of body
func NewAccountsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsMergeRequest calls the generic AccountsMerge builder with application/json body
func NewAccountsMergeRequest(server string, body AccountsMergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsMergeRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsMergeRequestWithBody generates requests for AccountsMerge with any type of body
func NewAccountsMergeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAccountsUpdateRequest calls the generic AccountsUpdate builder with application/json body
func NewAccountsUpdateRequest(server string, body AccountsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccountsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewAccountsUpdateRequestWithBody generates requests for AccountsUpdate with any type of body
func NewAccountsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAiAgentEventsExecuteAsyncRequest calls the generic AiAgentEventsExecuteAsync builder with application/json body
func NewAiAgentEventsExecuteAsyncRequest(server string, body AiAgentEventsExecuteAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAiAgentEventsExecuteAsyncRequestWithBody(server, "application/json", bodyReader)
}

// NewAiAgentEventsExecuteAsyncRequestWithBody generates requests for AiAgentEventsExecuteAsync with any type of body
func NewAiAgentEventsExecuteAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ai-agents.events.execute-async")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAirdropSyncUnitsGetRequest generates requests for AirdropSyncUnitsGet
func NewAirdropSyncUnitsGetRequest(server string, params *AirdropSyncUnitsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/airdrop.sync-units.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAirdropSyncUnitsGetPostRequest calls the generic AirdropSyncUnitsGetPost builder with application/json body
func NewAirdropSyncUnitsGetPostRequest(server string, body AirdropSyncUnitsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAirdropSyncUnitsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAirdropSyncUnitsGetPostRequestWithBody generates requests for AirdropSyncUnitsGetPost with any type of body
func NewAirdropSyncUnitsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/airdrop.sync-units.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAirdropSyncUnitsHistoryRequest generates requests for AirdropSyncUnitsHistory
func NewAirdropSyncUnitsHistoryRequest(server string, params *AirdropSyncUnitsHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/airdrop.sync-units.history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterHasErrorsOrWarnings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "filter.has_errors_or_warnings", runtime.ParamLocationQuery, *params.FilterHasErrorsOrWarnings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "filter.mode", runtime.ParamLocationQuery, *params.FilterMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterStartedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "filter.started_by", runtime.ParamLocationQuery, *params.FilterStartedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "filter.state", runtime.ParamLocationQuery, *params.FilterState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAirdropSyncUnitsHistoryPostRequest calls the generic AirdropSyncUnitsHistoryPost builder with application/json body
func NewAirdropSyncUnitsHistoryPostRequest(server string, body AirdropSyncUnitsHistoryPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAirdropSyncUnitsHistoryPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAirdropSyncUnitsHistoryPostRequestWithBody generates requests for AirdropSyncUnitsHistoryPost with any type of body
func NewAirdropSyncUnitsHistoryPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/airdrop.sync-units.history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArticlesCountRequest generates requests for ArticlesCount
func NewArticlesCountRequest(server string, params *ArticlesCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ancestor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ancestor", runtime.ParamLocationQuery, *params.Ancestor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AppliesToParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_parts", runtime.ParamLocationQuery, *params.AppliesToParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArticleType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "article_type", runtime.ParamLocationQuery, *params.ArticleType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthoredBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "authored_by", runtime.ParamLocationQuery, *params.AuthoredBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Brands != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "brands", runtime.ParamLocationQuery, *params.Brands); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SharedWithMember != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "shared_with.member", runtime.ParamLocationQuery, *params.SharedWithMember); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SharedWithRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "shared_with.role", runtime.ParamLocationQuery, *params.SharedWithRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArticlesCountPostRequest calls the generic ArticlesCountPost builder with application/json body
func NewArticlesCountPostRequest(server string, body ArticlesCountPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArticlesCountPostRequestWithBody(server, "application/json", bodyReader)
}

// NewArticlesCountPostRequestWithBody generates requests for ArticlesCountPost with any type of body
func NewArticlesCountPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateArticleRequest calls the generic CreateArticle builder with application/json body
func NewCreateArticleRequest(server string, body CreateArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateArticleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateArticleRequestWithBody generates requests for CreateArticle with any type of body
func NewCreateArticleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteArticleRequest calls the generic DeleteArticle builder with application/json body
func NewDeleteArticleRequest(server string, body DeleteArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteArticleRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteArticleRequestWithBody generates requests for DeleteArticle with any type of body
func NewDeleteArticleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetArticleRequest generates requests for GetArticle
func NewGetArticleRequest(server string, params *GetArticleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dev_org", runtime.ParamLocationQuery, *params.DevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArticlePostRequest calls the generic GetArticlePost builder with application/json body
func NewGetArticlePostRequest(server string, body GetArticlePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetArticlePostRequestWithBody(server, "application/json", bodyReader)
}

// NewGetArticlePostRequestWithBody generates requests for GetArticlePost with any type of body
func NewGetArticlePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListArticlesRequest generates requests for ListArticles
func NewListArticlesRequest(server string, params *ListArticlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_parts", runtime.ParamLocationQuery, *params.AppliesToParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArticleType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "article_type", runtime.ParamLocationQuery, *params.ArticleType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthoredBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "authored_by", runtime.ParamLocationQuery, *params.AuthoredBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Brands != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "brands", runtime.ParamLocationQuery, *params.Brands); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dev_org", runtime.ParamLocationQuery, *params.DevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SharedWithMember != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "shared_with.member", runtime.ParamLocationQuery, *params.SharedWithMember); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SharedWithRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "shared_with.role", runtime.ParamLocationQuery, *params.SharedWithRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListArticlesPostRequest calls the generic ListArticlesPost builder with application/json body
func NewListArticlesPostRequest(server string, body ListArticlesPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListArticlesPostRequestWithBody(server, "application/json", bodyReader)
}

// NewListArticlesPostRequestWithBody generates requests for ListArticlesPost with any type of body
func NewListArticlesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateArticleRequest calls the generic UpdateArticle builder with application/json body
func NewUpdateArticleRequest(server string, body UpdateArticleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateArticleRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateArticleRequestWithBody generates requests for UpdateArticle with any type of body
func NewUpdateArticleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/articles.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsGetRequest generates requests for ArtifactsGet
func NewArtifactsGetRequest(server string, params *ArtifactsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtifactsGetPostRequest calls the generic ArtifactsGetPost builder with application/json body
func NewArtifactsGetPostRequest(server string, body ArtifactsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsGetPostRequestWithBody generates requests for ArtifactsGetPost with any type of body
func NewArtifactsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsListRequest generates requests for ArtifactsList
func NewArtifactsListRequest(server string, params *ArtifactsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_id", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtifactsListPostRequest calls the generic ArtifactsListPost builder with application/json body
func NewArtifactsListPostRequest(server string, body ArtifactsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsListPostRequestWithBody generates requests for ArtifactsListPost with any type of body
func NewArtifactsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsLocateRequest generates requests for ArtifactsLocate
func NewArtifactsLocateRequest(server string, params *ArtifactsLocateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.locate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtifactsLocatePostRequest calls the generic ArtifactsLocatePost builder with application/json body
func NewArtifactsLocatePostRequest(server string, body ArtifactsLocatePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsLocatePostRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsLocatePostRequestWithBody generates requests for ArtifactsLocatePost with any type of body
func NewArtifactsLocatePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.locate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsPrepareRequest calls the generic ArtifactsPrepare builder with application/json body
func NewArtifactsPrepareRequest(server string, body ArtifactsPrepareJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsPrepareRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsPrepareRequestWithBody generates requests for ArtifactsPrepare with any type of body
func NewArtifactsPrepareRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.prepare")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsHardDeleteVersionRequest calls the generic ArtifactsHardDeleteVersion builder with application/json body
func NewArtifactsHardDeleteVersionRequest(server string, body ArtifactsHardDeleteVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsHardDeleteVersionRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsHardDeleteVersionRequestWithBody generates requests for ArtifactsHardDeleteVersion with any type of body
func NewArtifactsHardDeleteVersionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.versions.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtifactsVersionsPrepareRequest calls the generic ArtifactsVersionsPrepare builder with application/json body
func NewArtifactsVersionsPrepareRequest(server string, body ArtifactsVersionsPrepareJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtifactsVersionsPrepareRequestWithBody(server, "application/json", bodyReader)
}

// NewArtifactsVersionsPrepareRequestWithBody generates requests for ArtifactsVersionsPrepare with any type of body
func NewArtifactsVersionsPrepareRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifacts.versions.prepare")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAtomsGetRequest generates requests for AtomsGet
func NewAtomsGetRequest(server string, params *AtomsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/atoms.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAtomsGetPostRequest calls the generic AtomsGetPost builder with application/json body
func NewAtomsGetPostRequest(server string, body AtomsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAtomsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAtomsGetPostRequestWithBody generates requests for AtomsGetPost with any type of body
func NewAtomsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/atoms.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportAuditLogsRequest calls the generic ExportAuditLogs builder with application/json body
func NewExportAuditLogsRequest(server string, body ExportAuditLogsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportAuditLogsRequestWithBody(server, "application/json", bodyReader)
}

// NewExportAuditLogsRequestWithBody generates requests for ExportAuditLogs with any type of body
func NewExportAuditLogsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audit-logs.fetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensCreateRequest calls the generic AuthTokensCreate builder with application/json body
func NewAuthTokensCreateRequest(server string, body AuthTokensCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensCreateRequestWithBody generates requests for AuthTokensCreate with any type of body
func NewAuthTokensCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensDeleteRequest calls the generic AuthTokensDelete builder with application/json body
func NewAuthTokensDeleteRequest(server string, body AuthTokensDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensDeleteRequestWithBody generates requests for AuthTokensDelete with any type of body
func NewAuthTokensDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensGetRequest generates requests for AuthTokensGet
func NewAuthTokensGetRequest(server string, params *AuthTokensGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "token_id", runtime.ParamLocationQuery, params.TokenId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthTokensGetPostRequest calls the generic AuthTokensGetPost builder with application/json body
func NewAuthTokensGetPostRequest(server string, body AuthTokensGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensGetPostRequestWithBody generates requests for AuthTokensGetPost with any type of body
func NewAuthTokensGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensInfoRequest generates requests for AuthTokensInfo
func NewAuthTokensInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthTokensInfoPostRequest calls the generic AuthTokensInfoPost builder with application/json body
func NewAuthTokensInfoPostRequest(server string, body AuthTokensInfoPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensInfoPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensInfoPostRequestWithBody generates requests for AuthTokensInfoPost with any type of body
func NewAuthTokensInfoPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensListRequest generates requests for AuthTokensList
func NewAuthTokensListRequest(server string, params *AuthTokensListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestedTokenType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "requested_token_type", runtime.ParamLocationQuery, *params.RequestedTokenType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthTokensListPostRequest calls the generic AuthTokensListPost builder with application/json body
func NewAuthTokensListPostRequest(server string, body AuthTokensListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensListPostRequestWithBody generates requests for AuthTokensListPost with any type of body
func NewAuthTokensListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensSelfDeleteRequest calls the generic AuthTokensSelfDelete builder with application/json body
func NewAuthTokensSelfDeleteRequest(server string, body AuthTokensSelfDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensSelfDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensSelfDeleteRequestWithBody generates requests for AuthTokensSelfDelete with any type of body
func NewAuthTokensSelfDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.self.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthTokensUpdateRequest calls the generic AuthTokensUpdate builder with application/json body
func NewAuthTokensUpdateRequest(server string, body AuthTokensUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthTokensUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthTokensUpdateRequestWithBody generates requests for AuthTokensUpdate with any type of body
func NewAuthTokensUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth-tokens.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBrandsCreateRequest calls the generic BrandsCreate builder with application/json body
func NewBrandsCreateRequest(server string, body BrandsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBrandsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewBrandsCreateRequestWithBody generates requests for BrandsCreate with any type of body
func NewBrandsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brands.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBrandsDeleteRequest calls the generic BrandsDelete builder with application/json body
func NewBrandsDeleteRequest(server string, body BrandsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBrandsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewBrandsDeleteRequestWithBody generates requests for BrandsDelete with any type of body
func NewBrandsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brands.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBrandsGetRequest generates requests for BrandsGet
func NewBrandsGetRequest(server string, params *BrandsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brands.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrandsGetPostRequest calls the generic BrandsGetPost builder with application/json body
func NewBrandsGetPostRequest(server string, body BrandsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBrandsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewBrandsGetPostRequestWithBody generates requests for BrandsGetPost with any type of body
func NewBrandsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brands.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBrandsListRequest generates requests for BrandsList
func NewBrandsListRequest(server string, params *BrandsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brands.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrandsListPostRequest calls the generic BrandsListPost builder with application/json body
func NewBrandsListPostRequest(server string, body BrandsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBrandsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewBrandsListPostRequestWithBody generates requests for BrandsListPost with any type of body
func NewBrandsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brands.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBrandsUpdateRequest calls the generic BrandsUpdate builder with application/json body
func NewBrandsUpdateRequest(server string, body BrandsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBrandsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewBrandsUpdateRequestWithBody generates requests for BrandsUpdate with any type of body
func NewBrandsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brands.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatsCreateRequest calls the generic ChatsCreate builder with application/json body
func NewChatsCreateRequest(server string, body ChatsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewChatsCreateRequestWithBody generates requests for ChatsCreate with any type of body
func NewChatsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatsGetRequest generates requests for ChatsGet
func NewChatsGetRequest(server string, params *ChatsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatsGetPostRequest calls the generic ChatsGetPost builder with application/json body
func NewChatsGetPostRequest(server string, body ChatsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewChatsGetPostRequestWithBody generates requests for ChatsGetPost with any type of body
func NewChatsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatsUpdateRequest calls the generic ChatsUpdate builder with application/json body
func NewChatsUpdateRequest(server string, body ChatsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewChatsUpdateRequestWithBody generates requests for ChatsUpdate with any type of body
func NewChatsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesCreateRequest calls the generic CodeChangesCreate builder with application/json body
func NewCodeChangesCreateRequest(server string, body CodeChangesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesCreateRequestWithBody generates requests for CodeChangesCreate with any type of body
func NewCodeChangesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesDeleteRequest calls the generic CodeChangesDelete builder with application/json body
func NewCodeChangesDeleteRequest(server string, body CodeChangesDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesDeleteRequestWithBody generates requests for CodeChangesDelete with any type of body
func NewCodeChangesDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesGetRequest generates requests for CodeChangesGet
func NewCodeChangesGetRequest(server string, params *CodeChangesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeChangesGetPostRequest calls the generic CodeChangesGetPost builder with application/json body
func NewCodeChangesGetPostRequest(server string, body CodeChangesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesGetPostRequestWithBody generates requests for CodeChangesGetPost with any type of body
func NewCodeChangesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesListRequest generates requests for CodeChangesList
func NewCodeChangesListRequest(server string, params *CodeChangesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeChangesListPostRequest calls the generic CodeChangesListPost builder with application/json body
func NewCodeChangesListPostRequest(server string, body CodeChangesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesListPostRequestWithBody generates requests for CodeChangesListPost with any type of body
func NewCodeChangesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeChangesUpdateRequest calls the generic CodeChangesUpdate builder with application/json body
func NewCodeChangesUpdateRequest(server string, body CodeChangesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeChangesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewCodeChangesUpdateRequestWithBody generates requests for CodeChangesUpdate with any type of body
func NewCodeChangesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/code-changes.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommandsCreateRequest calls the generic CommandsCreate builder with application/json body
func NewCommandsCreateRequest(server string, body CommandsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommandsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCommandsCreateRequestWithBody generates requests for CommandsCreate with any type of body
func NewCommandsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommandsGetRequest generates requests for CommandsGet
func NewCommandsGetRequest(server string, params *CommandsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommandsGetPostRequest calls the generic CommandsGetPost builder with application/json body
func NewCommandsGetPostRequest(server string, body CommandsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommandsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCommandsGetPostRequestWithBody generates requests for CommandsGetPost with any type of body
func NewCommandsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommandsListRequest generates requests for CommandsList
func NewCommandsListRequest(server string, params *CommandsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutorType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "executor_type", runtime.ParamLocationQuery, *params.ExecutorType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_object_id", runtime.ParamLocationQuery, *params.SourceObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommandsListPostRequest calls the generic CommandsListPost builder with application/json body
func NewCommandsListPostRequest(server string, body CommandsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommandsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCommandsListPostRequestWithBody generates requests for CommandsListPost with any type of body
func NewCommandsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommandsUpdateRequest calls the generic CommandsUpdate builder with application/json body
func NewCommandsUpdateRequest(server string, body CommandsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommandsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewCommandsUpdateRequestWithBody generates requests for CommandsUpdate with any type of body
func NewCommandsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/commands.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewContentTemplateCreateRequest calls the generic ContentTemplateCreate builder with application/json body
func NewContentTemplateCreateRequest(server string, body ContentTemplateCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewContentTemplateCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewContentTemplateCreateRequestWithBody generates requests for ContentTemplateCreate with any type of body
func NewContentTemplateCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/content-template.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewContentTemplateGetRequest generates requests for ContentTemplateGet
func NewContentTemplateGetRequest(server string, params *ContentTemplateGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/content-template.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContentTemplateGetPostRequest calls the generic ContentTemplateGetPost builder with application/json body
func NewContentTemplateGetPostRequest(server string, body ContentTemplateGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewContentTemplateGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewContentTemplateGetPostRequestWithBody generates requests for ContentTemplateGetPost with any type of body
func NewContentTemplateGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/content-template.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewContentTemplateListRequest generates requests for ContentTemplateList
func NewContentTemplateListRequest(server string, params *ContentTemplateListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/content-template.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContentTemplateListPostRequest calls the generic ContentTemplateListPost builder with application/json body
func NewContentTemplateListPostRequest(server string, body ContentTemplateListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewContentTemplateListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewContentTemplateListPostRequestWithBody generates requests for ContentTemplateListPost with any type of body
func NewContentTemplateListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/content-template.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsCreateRequest calls the generic ConversationsCreate builder with application/json body
func NewConversationsCreateRequest(server string, body ConversationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsCreateRequestWithBody generates requests for ConversationsCreate with any type of body
func NewConversationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsDeleteRequest calls the generic ConversationsDelete builder with application/json body
func NewConversationsDeleteRequest(server string, body ConversationsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsDeleteRequestWithBody generates requests for ConversationsDelete with any type of body
func NewConversationsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsExportRequest generates requests for ConversationsExport
func NewConversationsExportRequest(server string, params *ConversationsExportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_parts", runtime.ParamLocationQuery, *params.AppliesToParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Brand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "brand", runtime.ParamLocationQuery, *params.Brand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "channels", runtime.ParamLocationQuery, *params.Channels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsCreatorVerified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_creator_verified", runtime.ParamLocationQuery, *params.IsCreatorVerified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFrozen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_frozen", runtime.ParamLocationQuery, *params.IsFrozen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSpam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_spam", runtime.ParamLocationQuery, *params.IsSpam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Members != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "members", runtime.ParamLocationQuery, *params.Members); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_org", runtime.ParamLocationQuery, *params.RevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrgs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_orgs", runtime.ParamLocationQuery, *params.RevOrgs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sla_summary.stage", runtime.ParamLocationQuery, *params.SlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_channel", runtime.ParamLocationQuery, *params.SourceChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceChannelV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_channel_v2", runtime.ParamLocationQuery, *params.SourceChannelV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_channels", runtime.ParamLocationQuery, *params.SourceChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage.name", runtime.ParamLocationQuery, *params.StageName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subtype", runtime.ParamLocationQuery, *params.Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagsV2Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags_v2.id", runtime.ParamLocationQuery, *params.TagsV2Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagsV2Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags_v2.value", runtime.ParamLocationQuery, *params.TagsV2Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConversationsExportPostRequest calls the generic ConversationsExportPost builder with application/json body
func NewConversationsExportPostRequest(server string, body ConversationsExportPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsExportPostRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsExportPostRequestWithBody generates requests for ConversationsExportPost with any type of body
func NewConversationsExportPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsGetRequest generates requests for ConversationsGet
func NewConversationsGetRequest(server string, params *ConversationsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConversationsGetPostRequest calls the generic ConversationsGetPost builder with application/json body
func NewConversationsGetPostRequest(server string, body ConversationsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsGetPostRequestWithBody generates requests for ConversationsGetPost with any type of body
func NewConversationsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsListRequest generates requests for ConversationsList
func NewConversationsListRequest(server string, params *ConversationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_parts", runtime.ParamLocationQuery, *params.AppliesToParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Brand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "brand", runtime.ParamLocationQuery, *params.Brand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "channels", runtime.ParamLocationQuery, *params.Channels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsCreatorVerified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_creator_verified", runtime.ParamLocationQuery, *params.IsCreatorVerified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFrozen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_frozen", runtime.ParamLocationQuery, *params.IsFrozen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSpam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_spam", runtime.ParamLocationQuery, *params.IsSpam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Members != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "members", runtime.ParamLocationQuery, *params.Members); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_org", runtime.ParamLocationQuery, *params.RevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrgs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_orgs", runtime.ParamLocationQuery, *params.RevOrgs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sla_summary.stage", runtime.ParamLocationQuery, *params.SlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_channel", runtime.ParamLocationQuery, *params.SourceChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceChannelV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_channel_v2", runtime.ParamLocationQuery, *params.SourceChannelV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_channels", runtime.ParamLocationQuery, *params.SourceChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage.name", runtime.ParamLocationQuery, *params.StageName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subtype", runtime.ParamLocationQuery, *params.Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagsV2Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags_v2.id", runtime.ParamLocationQuery, *params.TagsV2Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagsV2Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags_v2.value", runtime.ParamLocationQuery, *params.TagsV2Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConversationsListPostRequest calls the generic ConversationsListPost builder with application/json body
func NewConversationsListPostRequest(server string, body ConversationsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsListPostRequestWithBody generates requests for ConversationsListPost with any type of body
func NewConversationsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConversationsUpdateRequest calls the generic ConversationsUpdate builder with application/json body
func NewConversationsUpdateRequest(server string, body ConversationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConversationsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewConversationsUpdateRequestWithBody generates requests for ConversationsUpdate with any type of body
func NewConversationsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomObjectsCountRequest generates requests for CustomObjectsCount
func NewCustomObjectsCountRequest(server string, params *CustomObjectsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-objects.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_type", runtime.ParamLocationQuery, params.LeafType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomObjectsCountPostRequest calls the generic CustomObjectsCountPost builder with application/json body
func NewCustomObjectsCountPostRequest(server string, body CustomObjectsCountPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomObjectsCountPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomObjectsCountPostRequestWithBody generates requests for CustomObjectsCountPost with any type of body
func NewCustomObjectsCountPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-objects.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomObjectsCreateRequest calls the generic CustomObjectsCreate builder with application/json body
func NewCustomObjectsCreateRequest(server string, body CustomObjectsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomObjectsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomObjectsCreateRequestWithBody generates requests for CustomObjectsCreate with any type of body
func NewCustomObjectsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-objects.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomObjectsDeleteRequest calls the generic CustomObjectsDelete builder with application/json body
func NewCustomObjectsDeleteRequest(server string, body CustomObjectsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomObjectsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomObjectsDeleteRequestWithBody generates requests for CustomObjectsDelete with any type of body
func NewCustomObjectsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-objects.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomObjectsGetRequest generates requests for CustomObjectsGet
func NewCustomObjectsGetRequest(server string, params *CustomObjectsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-objects.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomObjectsGetPostRequest calls the generic CustomObjectsGetPost builder with application/json body
func NewCustomObjectsGetPostRequest(server string, body CustomObjectsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomObjectsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomObjectsGetPostRequestWithBody generates requests for CustomObjectsGetPost with any type of body
func NewCustomObjectsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-objects.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomObjectsListRequest generates requests for CustomObjectsList
func NewCustomObjectsListRequest(server string, params *CustomObjectsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-objects.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_type", runtime.ParamLocationQuery, params.LeafType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomObjectsListPostRequest calls the generic CustomObjectsListPost builder with application/json body
func NewCustomObjectsListPostRequest(server string, body CustomObjectsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomObjectsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomObjectsListPostRequestWithBody generates requests for CustomObjectsListPost with any type of body
func NewCustomObjectsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-objects.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomObjectsUpdateRequest calls the generic CustomObjectsUpdate builder with application/json body
func NewCustomObjectsUpdateRequest(server string, body CustomObjectsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomObjectsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomObjectsUpdateRequestWithBody generates requests for CustomObjectsUpdate with any type of body
func NewCustomObjectsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-objects.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsCreateRequest calls the generic DevOrgAuthConnectionsCreate builder with application/json body
func NewDevOrgAuthConnectionsCreateRequest(server string, body DevOrgAuthConnectionsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsCreateRequestWithBody generates requests for DevOrgAuthConnectionsCreate with any type of body
func NewDevOrgAuthConnectionsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsDeleteRequest calls the generic DevOrgAuthConnectionsDelete builder with application/json body
func NewDevOrgAuthConnectionsDeleteRequest(server string, body DevOrgAuthConnectionsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsDeleteRequestWithBody generates requests for DevOrgAuthConnectionsDelete with any type of body
func NewDevOrgAuthConnectionsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsGetRequest generates requests for DevOrgAuthConnectionsGet
func NewDevOrgAuthConnectionsGetRequest(server string, params *DevOrgAuthConnectionsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevOrgAuthConnectionsGetPostRequest calls the generic DevOrgAuthConnectionsGetPost builder with application/json body
func NewDevOrgAuthConnectionsGetPostRequest(server string, body DevOrgAuthConnectionsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsGetPostRequestWithBody generates requests for DevOrgAuthConnectionsGetPost with any type of body
func NewDevOrgAuthConnectionsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsListRequest generates requests for DevOrgAuthConnectionsList
func NewDevOrgAuthConnectionsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevOrgAuthConnectionsListPostRequest calls the generic DevOrgAuthConnectionsListPost builder with application/json body
func NewDevOrgAuthConnectionsListPostRequest(server string, body DevOrgAuthConnectionsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsListPostRequestWithBody generates requests for DevOrgAuthConnectionsListPost with any type of body
func NewDevOrgAuthConnectionsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsToggleRequest calls the generic DevOrgAuthConnectionsToggle builder with application/json body
func NewDevOrgAuthConnectionsToggleRequest(server string, body DevOrgAuthConnectionsToggleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsToggleRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsToggleRequestWithBody generates requests for DevOrgAuthConnectionsToggle with any type of body
func NewDevOrgAuthConnectionsToggleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.toggle")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgAuthConnectionsUpdateRequest calls the generic DevOrgAuthConnectionsUpdate builder with application/json body
func NewDevOrgAuthConnectionsUpdateRequest(server string, body DevOrgAuthConnectionsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgAuthConnectionsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgAuthConnectionsUpdateRequestWithBody generates requests for DevOrgAuthConnectionsUpdate with any type of body
func NewDevOrgAuthConnectionsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.auth-connections.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevOrgsGetRequest generates requests for DevOrgsGet
func NewDevOrgsGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevOrgsGetPostRequest calls the generic DevOrgsGetPost builder with application/json body
func NewDevOrgsGetPostRequest(server string, body DevOrgsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevOrgsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevOrgsGetPostRequestWithBody generates requests for DevOrgsGetPost with any type of body
func NewDevOrgsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-orgs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersActivateRequest calls the generic DevUsersActivate builder with application/json body
func NewDevUsersActivateRequest(server string, body DevUsersActivateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersActivateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersActivateRequestWithBody generates requests for DevUsersActivate with any type of body
func NewDevUsersActivateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.activate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersCreateRequest calls the generic DevUsersCreate builder with application/json body
func NewDevUsersCreateRequest(server string, body DevUsersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersCreateRequestWithBody generates requests for DevUsersCreate with any type of body
func NewDevUsersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersDeactivateRequest calls the generic DevUsersDeactivate builder with application/json body
func NewDevUsersDeactivateRequest(server string, body DevUsersDeactivateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersDeactivateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersDeactivateRequestWithBody generates requests for DevUsersDeactivate with any type of body
func NewDevUsersDeactivateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.deactivate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersGetRequest generates requests for DevUsersGet
func NewDevUsersGetRequest(server string, params *DevUsersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevUsersGetPostRequest calls the generic DevUsersGetPost builder with application/json body
func NewDevUsersGetPostRequest(server string, body DevUsersGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersGetPostRequestWithBody generates requests for DevUsersGetPost with any type of body
func NewDevUsersGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersIdentitiesLinkRequest calls the generic DevUsersIdentitiesLink builder with application/json body
func NewDevUsersIdentitiesLinkRequest(server string, body DevUsersIdentitiesLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersIdentitiesLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersIdentitiesLinkRequestWithBody generates requests for DevUsersIdentitiesLink with any type of body
func NewDevUsersIdentitiesLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.identities.link")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersIdentitiesUnlinkRequest calls the generic DevUsersIdentitiesUnlink builder with application/json body
func NewDevUsersIdentitiesUnlinkRequest(server string, body DevUsersIdentitiesUnlinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersIdentitiesUnlinkRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersIdentitiesUnlinkRequestWithBody generates requests for DevUsersIdentitiesUnlink with any type of body
func NewDevUsersIdentitiesUnlinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.identities.unlink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersListRequest generates requests for DevUsersList
func NewDevUsersListRequest(server string, params *DevUsersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalIdentityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_identity.id", runtime.ParamLocationQuery, *params.ExternalIdentityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalIdentityIssuer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_identity.issuer", runtime.ParamLocationQuery, *params.ExternalIdentityIssuer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevUsersListPostRequest calls the generic DevUsersListPost builder with application/json body
func NewDevUsersListPostRequest(server string, body DevUsersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersListPostRequestWithBody generates requests for DevUsersListPost with any type of body
func NewDevUsersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersMergeRequest calls the generic DevUsersMerge builder with application/json body
func NewDevUsersMergeRequest(server string, body DevUsersMergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersMergeRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersMergeRequestWithBody generates requests for DevUsersMerge with any type of body
func NewDevUsersMergeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersSelfRequest generates requests for DevUsersSelf
func NewDevUsersSelfRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevUsersSelfPostRequest calls the generic DevUsersSelfPost builder with application/json body
func NewDevUsersSelfPostRequest(server string, body DevUsersSelfPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersSelfPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersSelfPostRequestWithBody generates requests for DevUsersSelfPost with any type of body
func NewDevUsersSelfPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersSelfUpdateRequest calls the generic DevUsersSelfUpdate builder with application/json body
func NewDevUsersSelfUpdateRequest(server string, body DevUsersSelfUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersSelfUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersSelfUpdateRequestWithBody generates requests for DevUsersSelfUpdate with any type of body
func NewDevUsersSelfUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.self.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevUsersUpdateRequest calls the generic DevUsersUpdate builder with application/json body
func NewDevUsersUpdateRequest(server string, body DevUsersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevUsersUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevUsersUpdateRequestWithBody generates requests for DevUsersUpdate with any type of body
func NewDevUsersUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev-users.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesCountRequest generates requests for DirectoriesCount
func NewDirectoriesCountRequest(server string, params *DirectoriesCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDirectoriesCountPostRequest calls the generic DirectoriesCountPost builder with application/json body
func NewDirectoriesCountPostRequest(server string, body DirectoriesCountPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesCountPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesCountPostRequestWithBody generates requests for DirectoriesCountPost with any type of body
func NewDirectoriesCountPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesCreateRequest calls the generic DirectoriesCreate builder with application/json body
func NewDirectoriesCreateRequest(server string, body DirectoriesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesCreateRequestWithBody generates requests for DirectoriesCreate with any type of body
func NewDirectoriesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesDeleteRequest calls the generic DirectoriesDelete builder with application/json body
func NewDirectoriesDeleteRequest(server string, body DirectoriesDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesDeleteRequestWithBody generates requests for DirectoriesDelete with any type of body
func NewDirectoriesDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesGetRequest generates requests for DirectoriesGet
func NewDirectoriesGetRequest(server string, params *DirectoriesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dev_org", runtime.ParamLocationQuery, *params.DevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDirectoriesGetPostRequest calls the generic DirectoriesGetPost builder with application/json body
func NewDirectoriesGetPostRequest(server string, body DirectoriesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesGetPostRequestWithBody generates requests for DirectoriesGetPost with any type of body
func NewDirectoriesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesListRequest generates requests for DirectoriesList
func NewDirectoriesListRequest(server string, params *DirectoriesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dev_org", runtime.ParamLocationQuery, *params.DevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDirectoriesListPostRequest calls the generic DirectoriesListPost builder with application/json body
func NewDirectoriesListPostRequest(server string, body DirectoriesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesListPostRequestWithBody generates requests for DirectoriesListPost with any type of body
func NewDirectoriesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectoriesUpdateRequest calls the generic DirectoriesUpdate builder with application/json body
func NewDirectoriesUpdateRequest(server string, body DirectoriesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectoriesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewDirectoriesUpdateRequestWithBody generates requests for DirectoriesUpdate with any type of body
func NewDirectoriesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directories.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsCountRequest generates requests for EngagementsCount
func NewEngagementsCountRequest(server string, params *EngagementsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engagements.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Members != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "members", runtime.ParamLocationQuery, *params.Members); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsCountPostRequest calls the generic EngagementsCountPost builder with application/json body
func NewEngagementsCountPostRequest(server string, body EngagementsCountPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsCountPostRequestWithBody(server, "application/json", bodyReader)
}

// NewEngagementsCountPostRequestWithBody generates requests for EngagementsCountPost with any type of body
func NewEngagementsCountPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engagements.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsCreateRequest calls the generic EngagementsCreate builder with application/json body
func NewEngagementsCreateRequest(server string, body EngagementsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewEngagementsCreateRequestWithBody generates requests for EngagementsCreate with any type of body
func NewEngagementsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engagements.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsDeleteRequest calls the generic EngagementsDelete builder with application/json body
func NewEngagementsDeleteRequest(server string, body EngagementsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewEngagementsDeleteRequestWithBody generates requests for EngagementsDelete with any type of body
func NewEngagementsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engagements.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsGetRequest generates requests for EngagementsGet
func NewEngagementsGetRequest(server string, params *EngagementsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engagements.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsGetPostRequest calls the generic EngagementsGetPost builder with application/json body
func NewEngagementsGetPostRequest(server string, body EngagementsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewEngagementsGetPostRequestWithBody generates requests for EngagementsGetPost with any type of body
func NewEngagementsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engagements.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsListRequest generates requests for EngagementsList
func NewEngagementsListRequest(server string, params *EngagementsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engagements.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Members != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "members", runtime.ParamLocationQuery, *params.Members); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsListPostRequest calls the generic EngagementsListPost builder with application/json body
func NewEngagementsListPostRequest(server string, body EngagementsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewEngagementsListPostRequestWithBody generates requests for EngagementsListPost with any type of body
func NewEngagementsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engagements.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsUpdateRequest calls the generic EngagementsUpdate builder with application/json body
func NewEngagementsUpdateRequest(server string, body EngagementsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewEngagementsUpdateRequestWithBody generates requests for EngagementsUpdate with any type of body
func NewEngagementsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engagements.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventSourcesGetRequest generates requests for EventSourcesGet
func NewEventSourcesGetRequest(server string, params *EventSourcesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event-sources.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventSourcesGetPostRequest calls the generic EventSourcesGetPost builder with application/json body
func NewEventSourcesGetPostRequest(server string, body EventSourcesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventSourcesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewEventSourcesGetPostRequestWithBody generates requests for EventSourcesGetPost with any type of body
func NewEventSourcesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event-sources.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventSourcesScheduleEventRequest calls the generic EventSourcesScheduleEvent builder with application/json body
func NewEventSourcesScheduleEventRequest(server string, body EventSourcesScheduleEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventSourcesScheduleEventRequestWithBody(server, "application/json", bodyReader)
}

// NewEventSourcesScheduleEventRequestWithBody generates requests for EventSourcesScheduleEvent with any type of body
func NewEventSourcesScheduleEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event-sources.schedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventSourcesDeleteScheduledEventRequest calls the generic EventSourcesDeleteScheduledEvent builder with application/json body
func NewEventSourcesDeleteScheduledEventRequest(server string, body EventSourcesDeleteScheduledEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventSourcesDeleteScheduledEventRequestWithBody(server, "application/json", bodyReader)
}

// NewEventSourcesDeleteScheduledEventRequestWithBody generates requests for EventSourcesDeleteScheduledEvent with any type of body
func NewEventSourcesDeleteScheduledEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event-sources.unschedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupsCreateRequest calls the generic GroupsCreate builder with application/json body
func NewGroupsCreateRequest(server string, body GroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupsCreateRequestWithBody generates requests for GroupsCreate with any type of body
func NewGroupsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupsGetRequest generates requests for GroupsGet
func NewGroupsGetRequest(server string, params *GroupsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupsGetPostRequest calls the generic GroupsGetPost builder with application/json body
func NewGroupsGetPostRequest(server string, body GroupsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupsGetPostRequestWithBody generates requests for GroupsGetPost with any type of body
func NewGroupsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupsListRequest generates requests for GroupsList
func NewGroupsListRequest(server string, params *GroupsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group_type", runtime.ParamLocationQuery, *params.GroupType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IngestionSource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ingestion_source", runtime.ParamLocationQuery, *params.IngestionSource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDefault != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_default", runtime.ParamLocationQuery, *params.IsDefault); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_type", runtime.ParamLocationQuery, *params.MemberType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataExternalReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.external_reference", runtime.ParamLocationQuery, *params.SyncMetadataExternalReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataOriginSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.origin_system", runtime.ParamLocationQuery, *params.SyncMetadataOriginSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupsListPostRequest calls the generic GroupsListPost builder with application/json body
func NewGroupsListPostRequest(server string, body GroupsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupsListPostRequestWithBody generates requests for GroupsListPost with any type of body
func NewGroupsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupMembersAddRequest calls the generic GroupMembersAdd builder with application/json body
func NewGroupMembersAddRequest(server string, body GroupMembersAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupMembersAddRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupMembersAddRequestWithBody generates requests for GroupMembersAdd with any type of body
func NewGroupMembersAddRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.members.add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupMembersListRequest generates requests for GroupMembersList
func NewGroupMembersListRequest(server string, params *GroupMembersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.members.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group", runtime.ParamLocationQuery, params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupMembersListPostRequest calls the generic GroupMembersListPost builder with application/json body
func NewGroupMembersListPostRequest(server string, body GroupMembersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupMembersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupMembersListPostRequestWithBody generates requests for GroupMembersListPost with any type of body
func NewGroupMembersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.members.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupMembersRemoveRequest calls the generic GroupMembersRemove builder with application/json body
func NewGroupMembersRemoveRequest(server string, body GroupMembersRemoveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupMembersRemoveRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupMembersRemoveRequestWithBody generates requests for GroupMembersRemove with any type of body
func NewGroupMembersRemoveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.members.remove")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupsUpdateRequest calls the generic GroupsUpdate builder with application/json body
func NewGroupsUpdateRequest(server string, body GroupsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupsUpdateRequestWithBody generates requests for GroupsUpdate with any type of body
func NewGroupsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIncidentsCreateRequest calls the generic IncidentsCreate builder with application/json body
func NewIncidentsCreateRequest(server string, body IncidentsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIncidentsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewIncidentsCreateRequestWithBody generates requests for IncidentsCreate with any type of body
func NewIncidentsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIncidentsDeleteRequest calls the generic IncidentsDelete builder with application/json body
func NewIncidentsDeleteRequest(server string, body IncidentsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIncidentsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewIncidentsDeleteRequestWithBody generates requests for IncidentsDelete with any type of body
func NewIncidentsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIncidentsGetRequest generates requests for IncidentsGet
func NewIncidentsGetRequest(server string, params *IncidentsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIncidentsGetPostRequest calls the generic IncidentsGetPost builder with application/json body
func NewIncidentsGetPostRequest(server string, body IncidentsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIncidentsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewIncidentsGetPostRequestWithBody generates requests for IncidentsGetPost with any type of body
func NewIncidentsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIncidentsGroupRequest generates requests for IncidentsGroup
func NewIncidentsGroupRequest(server string, params *IncidentsGroupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents.group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group_by", runtime.ParamLocationQuery, params.GroupBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.AppliesToParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_parts", runtime.ParamLocationQuery, *params.AppliesToParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitPerGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit_per_group", runtime.ParamLocationQuery, *params.LimitPerGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pia != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pia", runtime.ParamLocationQuery, *params.Pia); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Playbooks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "playbooks", runtime.ParamLocationQuery, *params.Playbooks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelatedDocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "related_docs", runtime.ParamLocationQuery, *params.RelatedDocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reported_by", runtime.ParamLocationQuery, *params.ReportedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Severity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage", runtime.ParamLocationQuery, *params.Stage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StagedInfoIsStaged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "staged_info.is_staged", runtime.ParamLocationQuery, *params.StagedInfoIsStaged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subtype", runtime.ParamLocationQuery, *params.Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataExternalReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.external_reference", runtime.ParamLocationQuery, *params.SyncMetadataExternalReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataOriginSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.origin_system", runtime.ParamLocationQuery, *params.SyncMetadataOriginSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIncidentsGroupPostRequest calls the generic IncidentsGroupPost builder with application/json body
func NewIncidentsGroupPostRequest(server string, body IncidentsGroupPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIncidentsGroupPostRequestWithBody(server, "application/json", bodyReader)
}

// NewIncidentsGroupPostRequestWithBody generates requests for IncidentsGroupPost with any type of body
func NewIncidentsGroupPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents.group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIncidentsListRequest generates requests for IncidentsList
func NewIncidentsListRequest(server string, params *IncidentsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_parts", runtime.ParamLocationQuery, *params.AppliesToParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pia != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pia", runtime.ParamLocationQuery, *params.Pia); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Playbooks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "playbooks", runtime.ParamLocationQuery, *params.Playbooks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelatedDocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "related_docs", runtime.ParamLocationQuery, *params.RelatedDocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reported_by", runtime.ParamLocationQuery, *params.ReportedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Severity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage", runtime.ParamLocationQuery, *params.Stage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StagedInfoIsStaged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "staged_info.is_staged", runtime.ParamLocationQuery, *params.StagedInfoIsStaged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subtype", runtime.ParamLocationQuery, *params.Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataExternalReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.external_reference", runtime.ParamLocationQuery, *params.SyncMetadataExternalReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataOriginSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.origin_system", runtime.ParamLocationQuery, *params.SyncMetadataOriginSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIncidentsListPostRequest calls the generic IncidentsListPost builder with application/json body
func NewIncidentsListPostRequest(server string, body IncidentsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIncidentsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewIncidentsListPostRequestWithBody generates requests for IncidentsListPost with any type of body
func NewIncidentsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIncidentsUpdateRequest calls the generic IncidentsUpdate builder with application/json body
func NewIncidentsUpdateRequest(server string, body IncidentsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIncidentsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewIncidentsUpdateRequestWithBody generates requests for IncidentsUpdate with any type of body
func NewIncidentsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewKeyringsCreateCallbackRequest generates requests for KeyringsCreateCallback
func NewKeyringsCreateCallbackRequest(server string, params *KeyringsCreateCallbackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keyrings.authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "code", runtime.ParamLocationQuery, params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewKeyringsCreateCallbackPostRequest calls the generic KeyringsCreateCallbackPost builder with application/json body
func NewKeyringsCreateCallbackPostRequest(server string, body KeyringsCreateCallbackPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewKeyringsCreateCallbackPostRequestWithBody(server, "application/json", bodyReader)
}

// NewKeyringsCreateCallbackPostRequestWithBody generates requests for KeyringsCreateCallbackPost with any type of body
func NewKeyringsCreateCallbackPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keyrings.authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomLinkTypeCreateRequest calls the generic CustomLinkTypeCreate builder with application/json body
func NewCustomLinkTypeCreateRequest(server string, body CustomLinkTypeCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomLinkTypeCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomLinkTypeCreateRequestWithBody generates requests for CustomLinkTypeCreate with any type of body
func NewCustomLinkTypeCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/link-types.custom.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomLinkTypeGetRequest generates requests for CustomLinkTypeGet
func NewCustomLinkTypeGetRequest(server string, params *CustomLinkTypeGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/link-types.custom.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomLinkTypeGetPostRequest calls the generic CustomLinkTypeGetPost builder with application/json body
func NewCustomLinkTypeGetPostRequest(server string, body CustomLinkTypeGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomLinkTypeGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomLinkTypeGetPostRequestWithBody generates requests for CustomLinkTypeGetPost with any type of body
func NewCustomLinkTypeGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/link-types.custom.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomLinkTypeListRequest generates requests for CustomLinkTypeList
func NewCustomLinkTypeListRequest(server string, params *CustomLinkTypeListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/link-types.custom.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "deprecated", runtime.ParamLocationQuery, *params.Deprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_deprecated", runtime.ParamLocationQuery, *params.IsDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceTypesV2IsCustomLeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_types_v2.is_custom_leaf_type", runtime.ParamLocationQuery, *params.SourceTypesV2IsCustomLeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceTypesV2LeafOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_types_v2.leaf_only", runtime.ParamLocationQuery, *params.SourceTypesV2LeafOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceTypesV2LeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_types_v2.leaf_type", runtime.ParamLocationQuery, *params.SourceTypesV2LeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceTypesV2Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_types_v2.subtype", runtime.ParamLocationQuery, *params.SourceTypesV2Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetTypesV2IsCustomLeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "target_types_v2.is_custom_leaf_type", runtime.ParamLocationQuery, *params.TargetTypesV2IsCustomLeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetTypesV2LeafOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "target_types_v2.leaf_only", runtime.ParamLocationQuery, *params.TargetTypesV2LeafOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetTypesV2LeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "target_types_v2.leaf_type", runtime.ParamLocationQuery, *params.TargetTypesV2LeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetTypesV2Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "target_types_v2.subtype", runtime.ParamLocationQuery, *params.TargetTypesV2Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomLinkTypeListPostRequest calls the generic CustomLinkTypeListPost builder with application/json body
func NewCustomLinkTypeListPostRequest(server string, body CustomLinkTypeListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomLinkTypeListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomLinkTypeListPostRequestWithBody generates requests for CustomLinkTypeListPost with any type of body
func NewCustomLinkTypeListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/link-types.custom.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomLinkTypeUpdateRequest calls the generic CustomLinkTypeUpdate builder with application/json body
func NewCustomLinkTypeUpdateRequest(server string, body CustomLinkTypeUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomLinkTypeUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomLinkTypeUpdateRequestWithBody generates requests for CustomLinkTypeUpdate with any type of body
func NewCustomLinkTypeUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/link-types.custom.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksCreateRequest calls the generic LinksCreate builder with application/json body
func NewLinksCreateRequest(server string, body LinksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksCreateRequestWithBody generates requests for LinksCreate with any type of body
func NewLinksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksDeleteRequest calls the generic LinksDelete builder with application/json body
func NewLinksDeleteRequest(server string, body LinksDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksDeleteRequestWithBody generates requests for LinksDelete with any type of body
func NewLinksDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksGetRequest generates requests for LinksGet
func NewLinksGetRequest(server string, params *LinksGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinksGetPostRequest calls the generic LinksGetPost builder with application/json body
func NewLinksGetPostRequest(server string, body LinksGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksGetPostRequestWithBody generates requests for LinksGetPost with any type of body
func NewLinksGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksListRequest generates requests for LinksList
func NewLinksListRequest(server string, params *LinksListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object", runtime.ParamLocationQuery, params.Object); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "link_type", runtime.ParamLocationQuery, *params.LinkType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object_types", runtime.ParamLocationQuery, *params.ObjectTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinksListPostRequest calls the generic LinksListPost builder with application/json body
func NewLinksListPostRequest(server string, body LinksListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksListPostRequestWithBody generates requests for LinksListPost with any type of body
func NewLinksListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinksReplaceRequest calls the generic LinksReplace builder with application/json body
func NewLinksReplaceRequest(server string, body LinksReplaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinksReplaceRequestWithBody(server, "application/json", bodyReader)
}

// NewLinksReplaceRequestWithBody generates requests for LinksReplace with any type of body
func NewLinksReplaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links.replace")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsCountRequest generates requests for MeetingsCount
func NewMeetingsCountRequest(server string, params *MeetingsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Channel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "channel", runtime.ParamLocationQuery, *params.Channel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksLinkType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.link_type", runtime.ParamLocationQuery, *params.LinksLinkType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksTarget != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.target", runtime.ParamLocationQuery, *params.LinksTarget); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksTargetObjectType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.target_object_type", runtime.ParamLocationQuery, *params.LinksTargetObjectType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Members != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "members", runtime.ParamLocationQuery, *params.Members); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Organizer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "organizer", runtime.ParamLocationQuery, *params.Organizer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingsCountPostRequest calls the generic MeetingsCountPost builder with application/json body
func NewMeetingsCountPostRequest(server string, body MeetingsCountPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsCountPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsCountPostRequestWithBody generates requests for MeetingsCountPost with any type of body
func NewMeetingsCountPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsCreateRequest calls the generic MeetingsCreate builder with application/json body
func NewMeetingsCreateRequest(server string, body MeetingsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsCreateRequestWithBody generates requests for MeetingsCreate with any type of body
func NewMeetingsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsDeleteRequest calls the generic MeetingsDelete builder with application/json body
func NewMeetingsDeleteRequest(server string, body MeetingsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsDeleteRequestWithBody generates requests for MeetingsDelete with any type of body
func NewMeetingsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsGetRequest generates requests for MeetingsGet
func NewMeetingsGetRequest(server string, params *MeetingsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingsGetPostRequest calls the generic MeetingsGetPost builder with application/json body
func NewMeetingsGetPostRequest(server string, body MeetingsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsGetPostRequestWithBody generates requests for MeetingsGetPost with any type of body
func NewMeetingsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsListRequest generates requests for MeetingsList
func NewMeetingsListRequest(server string, params *MeetingsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Channel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "channel", runtime.ParamLocationQuery, *params.Channel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksLinkType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.link_type", runtime.ParamLocationQuery, *params.LinksLinkType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksTarget != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.target", runtime.ParamLocationQuery, *params.LinksTarget); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinksTargetObjectType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "links.target_object_type", runtime.ParamLocationQuery, *params.LinksTargetObjectType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Members != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "members", runtime.ParamLocationQuery, *params.Members); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Organizer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "organizer", runtime.ParamLocationQuery, *params.Organizer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingsListPostRequest calls the generic MeetingsListPost builder with application/json body
func NewMeetingsListPostRequest(server string, body MeetingsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsListPostRequestWithBody generates requests for MeetingsListPost with any type of body
func NewMeetingsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsUpdateRequest calls the generic MeetingsUpdate builder with application/json body
func NewMeetingsUpdateRequest(server string, body MeetingsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewMeetingsUpdateRequestWithBody generates requests for MeetingsUpdate with any type of body
func NewMeetingsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricActionExecuteRequest calls the generic MetricActionExecute builder with application/json body
func NewMetricActionExecuteRequest(server string, body MetricActionExecuteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricActionExecuteRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricActionExecuteRequestWithBody generates requests for MetricActionExecute with any type of body
func NewMetricActionExecuteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-action.execute")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsCreateRequest calls the generic MetricDefinitionsCreate builder with application/json body
func NewMetricDefinitionsCreateRequest(server string, body MetricDefinitionsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsCreateRequestWithBody generates requests for MetricDefinitionsCreate with any type of body
func NewMetricDefinitionsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsDeleteRequest calls the generic MetricDefinitionsDelete builder with application/json body
func NewMetricDefinitionsDeleteRequest(server string, body MetricDefinitionsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsDeleteRequestWithBody generates requests for MetricDefinitionsDelete with any type of body
func NewMetricDefinitionsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsGetRequest generates requests for MetricDefinitionsGet
func NewMetricDefinitionsGetRequest(server string, params *MetricDefinitionsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricDefinitionsGetPostRequest calls the generic MetricDefinitionsGetPost builder with application/json body
func NewMetricDefinitionsGetPostRequest(server string, body MetricDefinitionsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsGetPostRequestWithBody generates requests for MetricDefinitionsGetPost with any type of body
func NewMetricDefinitionsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsListRequest generates requests for MetricDefinitionsList
func NewMetricDefinitionsListRequest(server string, params *MetricDefinitionsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_type", runtime.ParamLocationQuery, *params.AppliesToType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeCustomMetrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include_custom_metrics", runtime.ParamLocationQuery, *params.IncludeCustomMetrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricDefinitionsListPostRequest calls the generic MetricDefinitionsListPost builder with application/json body
func NewMetricDefinitionsListPostRequest(server string, body MetricDefinitionsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsListPostRequestWithBody generates requests for MetricDefinitionsListPost with any type of body
func NewMetricDefinitionsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricDefinitionsUpdateRequest calls the generic MetricDefinitionsUpdate builder with application/json body
func NewMetricDefinitionsUpdateRequest(server string, body MetricDefinitionsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricDefinitionsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricDefinitionsUpdateRequestWithBody generates requests for MetricDefinitionsUpdate with any type of body
func NewMetricDefinitionsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-definitions.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricTrackersGetRequest generates requests for MetricTrackersGet
func NewMetricTrackersGetRequest(server string, params *MetricTrackersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-trackers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metric", runtime.ParamLocationQuery, params.Metric); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object", runtime.ParamLocationQuery, params.Object); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricTrackersGetPostRequest calls the generic MetricTrackersGetPost builder with application/json body
func NewMetricTrackersGetPostRequest(server string, body MetricTrackersGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricTrackersGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricTrackersGetPostRequestWithBody generates requests for MetricTrackersGetPost with any type of body
func NewMetricTrackersGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric-trackers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricsDevrevIngestRequest calls the generic MetricsDevrevIngest builder with application/json body
func NewMetricsDevrevIngestRequest(server string, body MetricsDevrevIngestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetricsDevrevIngestRequestWithBody(server, "application/json", bodyReader)
}

// NewMetricsDevrevIngestRequestWithBody generates requests for MetricsDevrevIngest with any type of body
func NewMetricsDevrevIngestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics.devrev.ingest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNotificationsSendRequest calls the generic NotificationsSend builder with application/json body
func NewNotificationsSendRequest(server string, body NotificationsSendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNotificationsSendRequestWithBody(server, "application/json", bodyReader)
}

// NewNotificationsSendRequestWithBody generates requests for NotificationsSend with any type of body
func NewNotificationsSendRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications.send")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgScheduleFragmentsCreateRequest calls the generic OrgScheduleFragmentsCreate builder with application/json body
func NewOrgScheduleFragmentsCreateRequest(server string, body OrgScheduleFragmentsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgScheduleFragmentsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgScheduleFragmentsCreateRequestWithBody generates requests for OrgScheduleFragmentsCreate with any type of body
func NewOrgScheduleFragmentsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedule-fragments.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgScheduleFragmentsGetRequest generates requests for OrgScheduleFragmentsGet
func NewOrgScheduleFragmentsGetRequest(server string, params *OrgScheduleFragmentsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedule-fragments.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgScheduleFragmentsGetPostRequest calls the generic OrgScheduleFragmentsGetPost builder with application/json body
func NewOrgScheduleFragmentsGetPostRequest(server string, body OrgScheduleFragmentsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgScheduleFragmentsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgScheduleFragmentsGetPostRequestWithBody generates requests for OrgScheduleFragmentsGetPost with any type of body
func NewOrgScheduleFragmentsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedule-fragments.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgScheduleFragmentsTransitionRequest calls the generic OrgScheduleFragmentsTransition builder with application/json body
func NewOrgScheduleFragmentsTransitionRequest(server string, body OrgScheduleFragmentsTransitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgScheduleFragmentsTransitionRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgScheduleFragmentsTransitionRequestWithBody generates requests for OrgScheduleFragmentsTransition with any type of body
func NewOrgScheduleFragmentsTransitionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedule-fragments.transition")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesCreateRequest calls the generic OrgSchedulesCreate builder with application/json body
func NewOrgSchedulesCreateRequest(server string, body OrgSchedulesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesCreateRequestWithBody generates requests for OrgSchedulesCreate with any type of body
func NewOrgSchedulesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesEvaluateRequest generates requests for OrgSchedulesEvaluate
func NewOrgSchedulesEvaluateRequest(server string, params *OrgSchedulesEvaluateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.evaluate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instants", runtime.ParamLocationQuery, params.Instants); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgSchedulesEvaluatePostRequest calls the generic OrgSchedulesEvaluatePost builder with application/json body
func NewOrgSchedulesEvaluatePostRequest(server string, body OrgSchedulesEvaluatePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesEvaluatePostRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesEvaluatePostRequestWithBody generates requests for OrgSchedulesEvaluatePost with any type of body
func NewOrgSchedulesEvaluatePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.evaluate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesGetRequest generates requests for OrgSchedulesGet
func NewOrgSchedulesGetRequest(server string, params *OrgSchedulesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgSchedulesGetPostRequest calls the generic OrgSchedulesGetPost builder with application/json body
func NewOrgSchedulesGetPostRequest(server string, body OrgSchedulesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesGetPostRequestWithBody generates requests for OrgSchedulesGetPost with any type of body
func NewOrgSchedulesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesListRequest generates requests for OrgSchedulesList
func NewOrgSchedulesListRequest(server string, params *OrgSchedulesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedById != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by_id", runtime.ParamLocationQuery, *params.CreatedById); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgSchedulesListPostRequest calls the generic OrgSchedulesListPost builder with application/json body
func NewOrgSchedulesListPostRequest(server string, body OrgSchedulesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesListPostRequestWithBody generates requests for OrgSchedulesListPost with any type of body
func NewOrgSchedulesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesSetFutureRequest calls the generic OrgSchedulesSetFuture builder with application/json body
func NewOrgSchedulesSetFutureRequest(server string, body OrgSchedulesSetFutureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesSetFutureRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesSetFutureRequestWithBody generates requests for OrgSchedulesSetFuture with any type of body
func NewOrgSchedulesSetFutureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.set-future")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesTransitionRequest calls the generic OrgSchedulesTransition builder with application/json body
func NewOrgSchedulesTransitionRequest(server string, body OrgSchedulesTransitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesTransitionRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesTransitionRequestWithBody generates requests for OrgSchedulesTransition with any type of body
func NewOrgSchedulesTransitionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.transition")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgSchedulesUpdateRequest calls the generic OrgSchedulesUpdate builder with application/json body
func NewOrgSchedulesUpdateRequest(server string, body OrgSchedulesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgSchedulesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewOrgSchedulesUpdateRequestWithBody generates requests for OrgSchedulesUpdate with any type of body
func NewOrgSchedulesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org-schedules.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsCreateRequest calls the generic PartsCreate builder with application/json body
func NewPartsCreateRequest(server string, body PartsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsCreateRequestWithBody generates requests for PartsCreate with any type of body
func NewPartsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsDeleteRequest calls the generic PartsDelete builder with application/json body
func NewPartsDeleteRequest(server string, body PartsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsDeleteRequestWithBody generates requests for PartsDelete with any type of body
func NewPartsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsGetRequest generates requests for PartsGet
func NewPartsGetRequest(server string, params *PartsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPartsGetPostRequest calls the generic PartsGetPost builder with application/json body
func NewPartsGetPostRequest(server string, body PartsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsGetPostRequestWithBody generates requests for PartsGetPost with any type of body
func NewPartsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsListRequest generates requests for PartsList
func NewPartsListRequest(server string, params *PartsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementAccounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.accounts", runtime.ParamLocationQuery, *params.EnhancementAccounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementActualCloseDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.actual_close_date.after", runtime.ParamLocationQuery, *params.EnhancementActualCloseDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementActualCloseDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.actual_close_date.before", runtime.ParamLocationQuery, *params.EnhancementActualCloseDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementActualStartDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.actual_start_date.after", runtime.ParamLocationQuery, *params.EnhancementActualStartDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementActualStartDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.actual_start_date.before", runtime.ParamLocationQuery, *params.EnhancementActualStartDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementOpportunities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.opportunities", runtime.ParamLocationQuery, *params.EnhancementOpportunities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementRevScoreTier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.rev_score_tier", runtime.ParamLocationQuery, *params.EnhancementRevScoreTier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementStageV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.stage_v2", runtime.ParamLocationQuery, *params.EnhancementStageV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementStateV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.state_v2", runtime.ParamLocationQuery, *params.EnhancementStateV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementTargetCloseDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.target_close_date.after", runtime.ParamLocationQuery, *params.EnhancementTargetCloseDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementTargetCloseDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.target_close_date.before", runtime.ParamLocationQuery, *params.EnhancementTargetCloseDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementTargetStartDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.target_start_date.after", runtime.ParamLocationQuery, *params.EnhancementTargetStartDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementTargetStartDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.target_start_date.before", runtime.ParamLocationQuery, *params.EnhancementTargetStartDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnhancementTickets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "enhancement.tickets", runtime.ParamLocationQuery, *params.EnhancementTickets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentPartLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_part.level", runtime.ParamLocationQuery, *params.ParentPartLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentPartParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_part.parts", runtime.ParamLocationQuery, *params.ParentPartParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subtype", runtime.ParamLocationQuery, *params.Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPartsListPostRequest calls the generic PartsListPost builder with application/json body
func NewPartsListPostRequest(server string, body PartsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsListPostRequestWithBody generates requests for PartsListPost with any type of body
func NewPartsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPartsUpdateRequest calls the generic PartsUpdate builder with application/json body
func NewPartsUpdateRequest(server string, body PartsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewPartsUpdateRequestWithBody generates requests for PartsUpdate with any type of body
func NewPartsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreferencesGetRequest generates requests for PreferencesGet
func NewPreferencesGetRequest(server string, params *PreferencesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/preferences.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object", runtime.ParamLocationQuery, params.Object); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LanguageCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "language_code", runtime.ParamLocationQuery, *params.LanguageCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreferencesGetPostRequest calls the generic PreferencesGetPost builder with application/json body
func NewPreferencesGetPostRequest(server string, body PreferencesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreferencesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewPreferencesGetPostRequestWithBody generates requests for PreferencesGetPost with any type of body
func NewPreferencesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/preferences.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreferencesUpdateRequest calls the generic PreferencesUpdate builder with application/json body
func NewPreferencesUpdateRequest(server string, body PreferencesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreferencesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewPreferencesUpdateRequestWithBody generates requests for PreferencesUpdate with any type of body
func NewPreferencesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/preferences.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateQuestionAnswerRequest calls the generic CreateQuestionAnswer builder with application/json body
func NewCreateQuestionAnswerRequest(server string, body CreateQuestionAnswerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateQuestionAnswerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateQuestionAnswerRequestWithBody generates requests for CreateQuestionAnswer with any type of body
func NewCreateQuestionAnswerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/question-answers.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteQuestionAnswerRequest calls the generic DeleteQuestionAnswer builder with application/json body
func NewDeleteQuestionAnswerRequest(server string, body DeleteQuestionAnswerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteQuestionAnswerRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteQuestionAnswerRequestWithBody generates requests for DeleteQuestionAnswer with any type of body
func NewDeleteQuestionAnswerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/question-answers.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetQuestionAnswerRequest generates requests for GetQuestionAnswer
func NewGetQuestionAnswerRequest(server string, params *GetQuestionAnswerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/question-answers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQuestionAnswerPostRequest calls the generic GetQuestionAnswerPost builder with application/json body
func NewGetQuestionAnswerPostRequest(server string, body GetQuestionAnswerPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetQuestionAnswerPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGetQuestionAnswerPostRequestWithBody generates requests for GetQuestionAnswerPost with any type of body
func NewGetQuestionAnswerPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/question-answers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListQuestionAnswersRequest generates requests for ListQuestionAnswers
func NewListQuestionAnswersRequest(server string, params *ListQuestionAnswersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/question-answers.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToArticles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_articles", runtime.ParamLocationQuery, *params.AppliesToArticles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AppliesToParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_parts", runtime.ParamLocationQuery, *params.AppliesToParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListQuestionAnswersPostRequest calls the generic ListQuestionAnswersPost builder with application/json body
func NewListQuestionAnswersPostRequest(server string, body ListQuestionAnswersPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListQuestionAnswersPostRequestWithBody(server, "application/json", bodyReader)
}

// NewListQuestionAnswersPostRequestWithBody generates requests for ListQuestionAnswersPost with any type of body
func NewListQuestionAnswersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/question-answers.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateQuestionAnswerRequest calls the generic UpdateQuestionAnswer builder with application/json body
func NewUpdateQuestionAnswerRequest(server string, body UpdateQuestionAnswerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateQuestionAnswerRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateQuestionAnswerRequestWithBody generates requests for UpdateQuestionAnswer with any type of body
func NewUpdateQuestionAnswerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/question-answers.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsListRequest generates requests for ReactionsList
func NewReactionsListRequest(server string, params *ReactionsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reactions.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "emoji", runtime.ParamLocationQuery, params.Emoji); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object", runtime.ParamLocationQuery, params.Object); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionsListPostRequest calls the generic ReactionsListPost builder with application/json body
func NewReactionsListPostRequest(server string, body ReactionsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewReactionsListPostRequestWithBody generates requests for ReactionsListPost with any type of body
func NewReactionsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reactions.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsUpdateRequest calls the generic ReactionsUpdate builder with application/json body
func NewReactionsUpdateRequest(server string, body ReactionsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewReactionsUpdateRequestWithBody generates requests for ReactionsUpdate with any type of body
func NewReactionsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reactions.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatCompletionsRequest calls the generic ChatCompletions builder with application/json body
func NewChatCompletionsRequest(server string, body ChatCompletionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatCompletionsRequestWithBody(server, "application/json", bodyReader)
}

// NewChatCompletionsRequestWithBody generates requests for ChatCompletions with any type of body
func NewChatCompletionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations.chat.completions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReplyRequest calls the generic GetReply builder with application/json body
func NewGetReplyRequest(server string, body GetReplyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetReplyRequestWithBody(server, "application/json", bodyReader)
}

// NewGetReplyRequestWithBody generates requests for GetReply with any type of body
func NewGetReplyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations.get-reply")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecordTemplateGetRequest generates requests for RecordTemplateGet
func NewRecordTemplateGetRequest(server string, params *RecordTemplateGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/record-templates.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecordTemplateGetPostRequest calls the generic RecordTemplateGetPost builder with application/json body
func NewRecordTemplateGetPostRequest(server string, body RecordTemplateGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecordTemplateGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRecordTemplateGetPostRequestWithBody generates requests for RecordTemplateGetPost with any type of body
func NewRecordTemplateGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/record-templates.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsCreateRequest calls the generic RevOrgsCreate builder with application/json body
func NewRevOrgsCreateRequest(server string, body RevOrgsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsCreateRequestWithBody generates requests for RevOrgsCreate with any type of body
func NewRevOrgsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsDeleteRequest calls the generic RevOrgsDelete builder with application/json body
func NewRevOrgsDeleteRequest(server string, body RevOrgsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsDeleteRequestWithBody generates requests for RevOrgsDelete with any type of body
func NewRevOrgsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsGetRequest generates requests for RevOrgsGet
func NewRevOrgsGetRequest(server string, params *RevOrgsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevOrgsGetPostRequest calls the generic RevOrgsGetPost builder with application/json body
func NewRevOrgsGetPostRequest(server string, body RevOrgsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsGetPostRequestWithBody generates requests for RevOrgsGetPost with any type of body
func NewRevOrgsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsListRequest generates requests for RevOrgsList
func NewRevOrgsListRequest(server string, params *RevOrgsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFieldFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_field_filter", runtime.ParamLocationQuery, *params.CustomFieldFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "display_name", runtime.ParamLocationQuery, *params.DisplayName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevOrgsListPostRequest calls the generic RevOrgsListPost builder with application/json body
func NewRevOrgsListPostRequest(server string, body RevOrgsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsListPostRequestWithBody generates requests for RevOrgsListPost with any type of body
func NewRevOrgsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevOrgsUpdateRequest calls the generic RevOrgsUpdate builder with application/json body
func NewRevOrgsUpdateRequest(server string, body RevOrgsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevOrgsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewRevOrgsUpdateRequestWithBody generates requests for RevOrgsUpdate with any type of body
func NewRevOrgsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-orgs.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersAssociationsAddRequest calls the generic RevUsersAssociationsAdd builder with application/json body
func NewRevUsersAssociationsAddRequest(server string, body RevUsersAssociationsAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersAssociationsAddRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersAssociationsAddRequestWithBody generates requests for RevUsersAssociationsAdd with any type of body
func NewRevUsersAssociationsAddRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.associations.add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersAssociationsListRequest generates requests for RevUsersAssociationsList
func NewRevUsersAssociationsListRequest(server string, params *RevUsersAssociationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.associations.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_user_id", runtime.ParamLocationQuery, params.RevUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevUsersAssociationsListPostRequest calls the generic RevUsersAssociationsListPost builder with application/json body
func NewRevUsersAssociationsListPostRequest(server string, body RevUsersAssociationsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersAssociationsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersAssociationsListPostRequestWithBody generates requests for RevUsersAssociationsListPost with any type of body
func NewRevUsersAssociationsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.associations.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersAssociationsRemoveRequest calls the generic RevUsersAssociationsRemove builder with application/json body
func NewRevUsersAssociationsRemoveRequest(server string, body RevUsersAssociationsRemoveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersAssociationsRemoveRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersAssociationsRemoveRequestWithBody generates requests for RevUsersAssociationsRemove with any type of body
func NewRevUsersAssociationsRemoveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.associations.remove")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersCreateRequest calls the generic RevUsersCreate builder with application/json body
func NewRevUsersCreateRequest(server string, body RevUsersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersCreateRequestWithBody generates requests for RevUsersCreate with any type of body
func NewRevUsersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersDeleteRequest calls the generic RevUsersDelete builder with application/json body
func NewRevUsersDeleteRequest(server string, body RevUsersDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersDeleteRequestWithBody generates requests for RevUsersDelete with any type of body
func NewRevUsersDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRevUsersPersonalDataRequest calls the generic DeleteRevUsersPersonalData builder with application/json body
func NewDeleteRevUsersPersonalDataRequest(server string, body DeleteRevUsersPersonalDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRevUsersPersonalDataRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteRevUsersPersonalDataRequestWithBody generates requests for DeleteRevUsersPersonalData with any type of body
func NewDeleteRevUsersPersonalDataRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.delete-personal-data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersGetRequest generates requests for RevUsersGet
func NewRevUsersGetRequest(server string, params *RevUsersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevUsersGetPostRequest calls the generic RevUsersGetPost builder with application/json body
func NewRevUsersGetPostRequest(server string, body RevUsersGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersGetPostRequestWithBody generates requests for RevUsersGetPost with any type of body
func NewRevUsersGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkRevUserToRevOrgRequest calls the generic LinkRevUserToRevOrg builder with application/json body
func NewLinkRevUserToRevOrgRequest(server string, body LinkRevUserToRevOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkRevUserToRevOrgRequestWithBody(server, "application/json", bodyReader)
}

// NewLinkRevUserToRevOrgRequestWithBody generates requests for LinkRevUserToRevOrg with any type of body
func NewLinkRevUserToRevOrgRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.link")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersListRequest generates requests for RevUsersList
func NewRevUsersListRequest(server string, params *RevUsersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Associations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "associations", runtime.ParamLocationQuery, *params.Associations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRefs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_refs", runtime.ParamLocationQuery, *params.ExternalRefs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsVerified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_verified", runtime.ParamLocationQuery, *params.IsVerified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PhoneNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "phone_numbers", runtime.ParamLocationQuery, *params.PhoneNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_org", runtime.ParamLocationQuery, *params.RevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevUsersListPostRequest calls the generic RevUsersListPost builder with application/json body
func NewRevUsersListPostRequest(server string, body RevUsersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersListPostRequestWithBody generates requests for RevUsersListPost with any type of body
func NewRevUsersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersMergeRequest calls the generic RevUsersMerge builder with application/json body
func NewRevUsersMergeRequest(server string, body RevUsersMergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersMergeRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersMergeRequestWithBody generates requests for RevUsersMerge with any type of body
func NewRevUsersMergeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRevUsersPersonalDataRequest calls the generic GetRevUsersPersonalData builder with application/json body
func NewGetRevUsersPersonalDataRequest(server string, body GetRevUsersPersonalDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetRevUsersPersonalDataRequestWithBody(server, "application/json", bodyReader)
}

// NewGetRevUsersPersonalDataRequestWithBody generates requests for GetRevUsersPersonalData with any type of body
func NewGetRevUsersPersonalDataRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.personal-data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersScanRequest generates requests for RevUsersScan
func NewRevUsersScanRequest(server string, params *RevUsersScanParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.scan")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Associations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "associations", runtime.ParamLocationQuery, *params.Associations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalRefs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_refs", runtime.ParamLocationQuery, *params.ExternalRefs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsVerified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_verified", runtime.ParamLocationQuery, *params.IsVerified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PhoneNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "phone_numbers", runtime.ParamLocationQuery, *params.PhoneNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rev_org", runtime.ParamLocationQuery, *params.RevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevUsersScanPostRequest calls the generic RevUsersScanPost builder with application/json body
func NewRevUsersScanPostRequest(server string, body RevUsersScanPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersScanPostRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersScanPostRequestWithBody generates requests for RevUsersScanPost with any type of body
func NewRevUsersScanPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.scan")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkRevUserFromRevOrgRequest calls the generic UnlinkRevUserFromRevOrg builder with application/json body
func NewUnlinkRevUserFromRevOrgRequest(server string, body UnlinkRevUserFromRevOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkRevUserFromRevOrgRequestWithBody(server, "application/json", bodyReader)
}

// NewUnlinkRevUserFromRevOrgRequestWithBody generates requests for UnlinkRevUserFromRevOrg with any type of body
func NewUnlinkRevUserFromRevOrgRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.unlink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevUsersUpdateRequest calls the generic RevUsersUpdate builder with application/json body
func NewRevUsersUpdateRequest(server string, body RevUsersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevUsersUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewRevUsersUpdateRequestWithBody generates requests for RevUsersUpdate with any type of body
func NewRevUsersUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rev-users.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRolesApplyRequest calls the generic RolesApply builder with application/json body
func NewRolesApplyRequest(server string, body RolesApplyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRolesApplyRequestWithBody(server, "application/json", bodyReader)
}

// NewRolesApplyRequestWithBody generates requests for RolesApply with any type of body
func NewRolesApplyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles.apply")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRolesCreateRequest calls the generic RolesCreate builder with application/json body
func NewRolesCreateRequest(server string, body RolesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRolesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewRolesCreateRequestWithBody generates requests for RolesCreate with any type of body
func NewRolesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAggregatedSchemaGetRequest generates requests for AggregatedSchemaGet
func NewAggregatedSchemaGetRequest(server string, params *AggregatedSchemaGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.aggregated.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CustomSchemaFragmentIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_schema_fragment_ids", runtime.ParamLocationQuery, *params.CustomSchemaFragmentIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomSchemaSpecApps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_schema_spec.apps", runtime.ParamLocationQuery, *params.CustomSchemaSpecApps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomSchemaSpecSubtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_schema_spec.subtype", runtime.ParamLocationQuery, *params.CustomSchemaSpecSubtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsCustomLeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_custom_leaf_type", runtime.ParamLocationQuery, *params.IsCustomLeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_type", runtime.ParamLocationQuery, *params.LeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StockSchemaFragmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stock_schema_fragment_id", runtime.ParamLocationQuery, *params.StockSchemaFragmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAggregatedSchemaGetPostRequest calls the generic AggregatedSchemaGetPost builder with application/json body
func NewAggregatedSchemaGetPostRequest(server string, body AggregatedSchemaGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAggregatedSchemaGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewAggregatedSchemaGetPostRequestWithBody generates requests for AggregatedSchemaGetPost with any type of body
func NewAggregatedSchemaGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.aggregated.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomSchemaFragmentsGetRequest generates requests for CustomSchemaFragmentsGet
func NewCustomSchemaFragmentsGetRequest(server string, params *CustomSchemaFragmentsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.custom.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomSchemaFragmentsGetPostRequest calls the generic CustomSchemaFragmentsGetPost builder with application/json body
func NewCustomSchemaFragmentsGetPostRequest(server string, body CustomSchemaFragmentsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomSchemaFragmentsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomSchemaFragmentsGetPostRequestWithBody generates requests for CustomSchemaFragmentsGetPost with any type of body
func NewCustomSchemaFragmentsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.custom.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomSchemaFragmentsListRequest generates requests for CustomSchemaFragmentsList
func NewCustomSchemaFragmentsListRequest(server string, params *CustomSchemaFragmentsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.custom.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.App != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "app", runtime.ParamLocationQuery, *params.App); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "deprecated", runtime.ParamLocationQuery, *params.Deprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsCustomLeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_custom_leaf_type", runtime.ParamLocationQuery, *params.IsCustomLeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_deprecated", runtime.ParamLocationQuery, *params.IsDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_type", runtime.ParamLocationQuery, *params.LeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prune != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "prune", runtime.ParamLocationQuery, *params.Prune); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subtype", runtime.ParamLocationQuery, *params.Subtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomSchemaFragmentsListPostRequest calls the generic CustomSchemaFragmentsListPost builder with application/json body
func NewCustomSchemaFragmentsListPostRequest(server string, body CustomSchemaFragmentsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomSchemaFragmentsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomSchemaFragmentsListPostRequestWithBody generates requests for CustomSchemaFragmentsListPost with any type of body
func NewCustomSchemaFragmentsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.custom.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomSchemaFragmentsSetRequest calls the generic CustomSchemaFragmentsSet builder with application/json body
func NewCustomSchemaFragmentsSetRequest(server string, body CustomSchemaFragmentsSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomSchemaFragmentsSetRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomSchemaFragmentsSetRequestWithBody generates requests for CustomSchemaFragmentsSet with any type of body
func NewCustomSchemaFragmentsSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.custom.set")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStockSchemaFragmentsGetRequest generates requests for StockSchemaFragmentsGet
func NewStockSchemaFragmentsGetRequest(server string, params *StockSchemaFragmentsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.stock.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_type", runtime.ParamLocationQuery, *params.LeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStockSchemaFragmentsGetPostRequest calls the generic StockSchemaFragmentsGetPost builder with application/json body
func NewStockSchemaFragmentsGetPostRequest(server string, body StockSchemaFragmentsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStockSchemaFragmentsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewStockSchemaFragmentsGetPostRequestWithBody generates requests for StockSchemaFragmentsGetPost with any type of body
func NewStockSchemaFragmentsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.stock.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStockSchemaFragmentsListRequest generates requests for StockSchemaFragmentsList
func NewStockSchemaFragmentsListRequest(server string, params *StockSchemaFragmentsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.stock.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterPreset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "filter_preset", runtime.ParamLocationQuery, *params.FilterPreset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_type", runtime.ParamLocationQuery, *params.LeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prune != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "prune", runtime.ParamLocationQuery, *params.Prune); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStockSchemaFragmentsListPostRequest calls the generic StockSchemaFragmentsListPost builder with application/json body
func NewStockSchemaFragmentsListPostRequest(server string, body StockSchemaFragmentsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStockSchemaFragmentsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewStockSchemaFragmentsListPostRequestWithBody generates requests for StockSchemaFragmentsListPost with any type of body
func NewStockSchemaFragmentsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.stock.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSubtypesListRequest generates requests for SubtypesList
func NewSubtypesListRequest(server string, params *SubtypesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.subtypes.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_type", runtime.ParamLocationQuery, *params.LeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeafTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_types", runtime.ParamLocationQuery, *params.LeafTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubtypesListPostRequest calls the generic SubtypesListPost builder with application/json body
func NewSubtypesListPostRequest(server string, body SubtypesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubtypesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSubtypesListPostRequestWithBody generates requests for SubtypesListPost with any type of body
func NewSubtypesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.subtypes.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSchemasSubtypePrepareUpdateGetRequest calls the generic SchemasSubtypePrepareUpdateGet builder with application/json body
func NewSchemasSubtypePrepareUpdateGetRequest(server string, body SchemasSubtypePrepareUpdateGetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSchemasSubtypePrepareUpdateGetRequestWithBody(server, "application/json", bodyReader)
}

// NewSchemasSubtypePrepareUpdateGetRequestWithBody generates requests for SchemasSubtypePrepareUpdateGet with any type of body
func NewSchemasSubtypePrepareUpdateGetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas.subtypes.prepare-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchCoreRequest generates requests for SearchCore
func NewSearchCoreRequest(server string, params *SearchCoreParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search.core")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespaces != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "namespaces", runtime.ParamLocationQuery, *params.Namespaces); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_order", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchCorePostRequest calls the generic SearchCorePost builder with application/json body
func NewSearchCorePostRequest(server string, body SearchCorePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchCorePostRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchCorePostRequestWithBody generates requests for SearchCorePost with any type of body
func NewSearchCorePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search.core")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchHybridRequest generates requests for SearchHybrid
func NewSearchHybridRequest(server string, params *SearchHybridParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search.hybrid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "namespace", runtime.ParamLocationQuery, params.Namespace); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SemanticWeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "semantic_weight", runtime.ParamLocationQuery, *params.SemanticWeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchHybridPostRequest calls the generic SearchHybridPost builder with application/json body
func NewSearchHybridPostRequest(server string, body SearchHybridPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchHybridPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchHybridPostRequestWithBody generates requests for SearchHybridPost with any type of body
func NewSearchHybridPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search.hybrid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewServiceAccountsCreateRequest calls the generic ServiceAccountsCreate builder with application/json body
func NewServiceAccountsCreateRequest(server string, body ServiceAccountsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewServiceAccountsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewServiceAccountsCreateRequestWithBody generates requests for ServiceAccountsCreate with any type of body
func NewServiceAccountsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewServiceAccountsGetRequest generates requests for ServiceAccountsGet
func NewServiceAccountsGetRequest(server string, params *ServiceAccountsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServiceAccountsGetPostRequest calls the generic ServiceAccountsGetPost builder with application/json body
func NewServiceAccountsGetPostRequest(server string, body ServiceAccountsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewServiceAccountsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewServiceAccountsGetPostRequestWithBody generates requests for ServiceAccountsGetPost with any type of body
func NewServiceAccountsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewServiceAccountsUpdateRequest calls the generic ServiceAccountsUpdate builder with application/json body
func NewServiceAccountsUpdateRequest(server string, body ServiceAccountsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewServiceAccountsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewServiceAccountsUpdateRequestWithBody generates requests for ServiceAccountsUpdate with any type of body
func NewServiceAccountsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlaTrackersGetRequest generates requests for SlaTrackersGet
func NewSlaTrackersGetRequest(server string, params *SlaTrackersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sla-trackers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlaTrackersGetPostRequest calls the generic SlaTrackersGetPost builder with application/json body
func NewSlaTrackersGetPostRequest(server string, body SlaTrackersGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlaTrackersGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSlaTrackersGetPostRequestWithBody generates requests for SlaTrackersGetPost with any type of body
func NewSlaTrackersGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sla-trackers.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlaTrackersListRequest generates requests for SlaTrackersList
func NewSlaTrackersListRequest(server string, params *SlaTrackersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sla-trackers.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.after", runtime.ParamLocationQuery, *params.CreatedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_date.before", runtime.ParamLocationQuery, *params.CreatedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.after", runtime.ParamLocationQuery, *params.ModifiedDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_date.before", runtime.ParamLocationQuery, *params.ModifiedDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage", runtime.ParamLocationQuery, *params.Stage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlaTrackersListPostRequest calls the generic SlaTrackersListPost builder with application/json body
func NewSlaTrackersListPostRequest(server string, body SlaTrackersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlaTrackersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSlaTrackersListPostRequestWithBody generates requests for SlaTrackersListPost with any type of body
func NewSlaTrackersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sla-trackers.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlaTrackersRemoveMetricRequest calls the generic SlaTrackersRemoveMetric builder with application/json body
func NewSlaTrackersRemoveMetricRequest(server string, body SlaTrackersRemoveMetricJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlaTrackersRemoveMetricRequestWithBody(server, "application/json", bodyReader)
}

// NewSlaTrackersRemoveMetricRequestWithBody generates requests for SlaTrackersRemoveMetric with any type of body
func NewSlaTrackersRemoveMetricRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sla-trackers.remove-metric")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasAssignRequest calls the generic SlasAssign builder with application/json body
func NewSlasAssignRequest(server string, body SlasAssignJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasAssignRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasAssignRequestWithBody generates requests for SlasAssign with any type of body
func NewSlasAssignRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.assign")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasCreateRequest calls the generic SlasCreate builder with application/json body
func NewSlasCreateRequest(server string, body SlasCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasCreateRequestWithBody generates requests for SlasCreate with any type of body
func NewSlasCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasGetRequest generates requests for SlasGet
func NewSlasGetRequest(server string, params *SlasGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlasGetPostRequest calls the generic SlasGetPost builder with application/json body
func NewSlasGetPostRequest(server string, body SlasGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasGetPostRequestWithBody generates requests for SlasGetPost with any type of body
func NewSlasGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasListRequest generates requests for SlasList
func NewSlasListRequest(server string, params *SlasListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to", runtime.ParamLocationQuery, *params.AppliesTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AppliesToOp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_op", runtime.ParamLocationQuery, *params.AppliesToOp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SlaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sla_type", runtime.ParamLocationQuery, *params.SlaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlasListPostRequest calls the generic SlasListPost builder with application/json body
func NewSlasListPostRequest(server string, body SlasListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasListPostRequestWithBody generates requests for SlasListPost with any type of body
func NewSlasListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasTransitionRequest calls the generic SlasTransition builder with application/json body
func NewSlasTransitionRequest(server string, body SlasTransitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasTransitionRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasTransitionRequestWithBody generates requests for SlasTransition with any type of body
func NewSlasTransitionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.transition")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlasUpdateRequest calls the generic SlasUpdate builder with application/json body
func NewSlasUpdateRequest(server string, body SlasUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlasUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlasUpdateRequestWithBody generates requests for SlasUpdate with any type of body
func NewSlasUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slas.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSnapInsResourcesRequest generates requests for SnapInsResources
func NewSnapInsResourcesRequest(server string, params *SnapInsResourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snap-ins.resources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnapInsResourcesPostRequest calls the generic SnapInsResourcesPost builder with application/json body
func NewSnapInsResourcesPostRequest(server string, body SnapInsResourcesPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnapInsResourcesPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSnapInsResourcesPostRequestWithBody generates requests for SnapInsResourcesPost with any type of body
func NewSnapInsResourcesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snap-ins.resources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSnapInsUpdateRequest calls the generic SnapInsUpdate builder with application/json body
func NewSnapInsUpdateRequest(server string, body SnapInsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnapInsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSnapInsUpdateRequestWithBody generates requests for SnapInsUpdate with any type of body
func NewSnapInsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snap-ins.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSnapKitActionExecuteDeferredRequest calls the generic SnapKitActionExecuteDeferred builder with application/json body
func NewSnapKitActionExecuteDeferredRequest(server string, body SnapKitActionExecuteDeferredJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnapKitActionExecuteDeferredRequestWithBody(server, "application/json", bodyReader)
}

// NewSnapKitActionExecuteDeferredRequestWithBody generates requests for SnapKitActionExecuteDeferred with any type of body
func NewSnapKitActionExecuteDeferredRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snap-kit-action.execute.deferred")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSnapWidgetsCreateRequest calls the generic SnapWidgetsCreate builder with application/json body
func NewSnapWidgetsCreateRequest(server string, body SnapWidgetsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnapWidgetsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSnapWidgetsCreateRequestWithBody generates requests for SnapWidgetsCreate with any type of body
func NewSnapWidgetsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snap-widgets.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStageDiagramsCreateRequest calls the generic StageDiagramsCreate builder with application/json body
func NewStageDiagramsCreateRequest(server string, body StageDiagramsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStageDiagramsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewStageDiagramsCreateRequestWithBody generates requests for StageDiagramsCreate with any type of body
func NewStageDiagramsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stage-diagrams.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStageDiagramsGetRequest generates requests for StageDiagramsGet
func NewStageDiagramsGetRequest(server string, params *StageDiagramsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stage-diagrams.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsCustomLeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_custom_leaf_type", runtime.ParamLocationQuery, *params.IsCustomLeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_type", runtime.ParamLocationQuery, *params.LeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStageDiagramsGetPostRequest calls the generic StageDiagramsGetPost builder with application/json body
func NewStageDiagramsGetPostRequest(server string, body StageDiagramsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStageDiagramsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewStageDiagramsGetPostRequestWithBody generates requests for StageDiagramsGetPost with any type of body
func NewStageDiagramsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stage-diagrams.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStageDiagramsListRequest generates requests for StageDiagramsList
func NewStageDiagramsListRequest(server string, params *StageDiagramsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stage-diagrams.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsCustomLeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_custom_leaf_type", runtime.ParamLocationQuery, *params.IsCustomLeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LeafType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "leaf_type", runtime.ParamLocationQuery, *params.LeafType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStageDiagramsListPostRequest calls the generic StageDiagramsListPost builder with application/json body
func NewStageDiagramsListPostRequest(server string, body StageDiagramsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStageDiagramsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewStageDiagramsListPostRequestWithBody generates requests for StageDiagramsListPost with any type of body
func NewStageDiagramsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stage-diagrams.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStageDiagramsUpdateRequest calls the generic StageDiagramsUpdate builder with application/json body
func NewStageDiagramsUpdateRequest(server string, body StageDiagramsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStageDiagramsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewStageDiagramsUpdateRequestWithBody generates requests for StageDiagramsUpdate with any type of body
func NewStageDiagramsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stage-diagrams.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomStagesCreateRequest calls the generic CustomStagesCreate builder with application/json body
func NewCustomStagesCreateRequest(server string, body CustomStagesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomStagesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomStagesCreateRequestWithBody generates requests for CustomStagesCreate with any type of body
func NewCustomStagesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages.custom.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomStagesGetRequest generates requests for CustomStagesGet
func NewCustomStagesGetRequest(server string, params *CustomStagesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages.custom.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomStagesGetPostRequest calls the generic CustomStagesGetPost builder with application/json body
func NewCustomStagesGetPostRequest(server string, body CustomStagesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomStagesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomStagesGetPostRequestWithBody generates requests for CustomStagesGetPost with any type of body
func NewCustomStagesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages.custom.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomStagesListRequest generates requests for CustomStagesList
func NewCustomStagesListRequest(server string, params *CustomStagesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages.custom.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ordinal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ordinal", runtime.ParamLocationQuery, *params.Ordinal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomStagesListPostRequest calls the generic CustomStagesListPost builder with application/json body
func NewCustomStagesListPostRequest(server string, body CustomStagesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomStagesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomStagesListPostRequestWithBody generates requests for CustomStagesListPost with any type of body
func NewCustomStagesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages.custom.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomStagesUpdateRequest calls the generic CustomStagesUpdate builder with application/json body
func NewCustomStagesUpdateRequest(server string, body CustomStagesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomStagesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomStagesUpdateRequestWithBody generates requests for CustomStagesUpdate with any type of body
func NewCustomStagesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages.custom.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomStatesCreateRequest calls the generic CustomStatesCreate builder with application/json body
func NewCustomStatesCreateRequest(server string, body CustomStatesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomStatesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomStatesCreateRequestWithBody generates requests for CustomStatesCreate with any type of body
func NewCustomStatesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/states.custom.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomStatesGetRequest generates requests for CustomStatesGet
func NewCustomStatesGetRequest(server string, params *CustomStatesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/states.custom.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomStatesGetPostRequest calls the generic CustomStatesGetPost builder with application/json body
func NewCustomStatesGetPostRequest(server string, body CustomStatesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomStatesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomStatesGetPostRequestWithBody generates requests for CustomStatesGetPost with any type of body
func NewCustomStatesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/states.custom.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomStatesListRequest generates requests for CustomStatesList
func NewCustomStatesListRequest(server string, params *CustomStatesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/states.custom.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFinal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "is_final", runtime.ParamLocationQuery, *params.IsFinal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ordinal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ordinal", runtime.ParamLocationQuery, *params.Ordinal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomStatesListPostRequest calls the generic CustomStatesListPost builder with application/json body
func NewCustomStatesListPostRequest(server string, body CustomStatesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomStatesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomStatesListPostRequestWithBody generates requests for CustomStatesListPost with any type of body
func NewCustomStatesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/states.custom.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomStatesUpdateRequest calls the generic CustomStatesUpdate builder with application/json body
func NewCustomStatesUpdateRequest(server string, body CustomStatesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomStatesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomStatesUpdateRequestWithBody generates requests for CustomStatesUpdate with any type of body
func NewCustomStatesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/states.custom.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSubscribersListRequest generates requests for SubscribersList
func NewSubscribersListRequest(server string, params *SubscribersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscribers.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscribersListPostRequest calls the generic SubscribersListPost builder with application/json body
func NewSubscribersListPostRequest(server string, body SubscribersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubscribersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSubscribersListPostRequestWithBody generates requests for SubscribersListPost with any type of body
func NewSubscribersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscribers.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSubscribersUpdateRequest calls the generic SubscribersUpdate builder with application/json body
func NewSubscribersUpdateRequest(server string, body SubscribersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubscribersUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSubscribersUpdateRequestWithBody generates requests for SubscribersUpdate with any type of body
func NewSubscribersUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscribers.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysCreateRequest calls the generic SurveysCreate builder with application/json body
func NewSurveysCreateRequest(server string, body SurveysCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysCreateRequestWithBody generates requests for SurveysCreate with any type of body
func NewSurveysCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysDeleteRequest calls the generic SurveysDelete builder with application/json body
func NewSurveysDeleteRequest(server string, body SurveysDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysDeleteRequestWithBody generates requests for SurveysDelete with any type of body
func NewSurveysDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysGetRequest generates requests for SurveysGet
func NewSurveysGetRequest(server string, params *SurveysGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSurveysGetPostRequest calls the generic SurveysGetPost builder with application/json body
func NewSurveysGetPostRequest(server string, body SurveysGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysGetPostRequestWithBody generates requests for SurveysGetPost with any type of body
func NewSurveysGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysListRequest generates requests for SurveysList
func NewSurveysListRequest(server string, params *SurveysListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSurveysListPostRequest calls the generic SurveysListPost builder with application/json body
func NewSurveysListPostRequest(server string, body SurveysListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysListPostRequestWithBody generates requests for SurveysListPost with any type of body
func NewSurveysListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysResponsesListRequest generates requests for SurveysResponsesList
func NewSurveysResponsesListRequest(server string, params *SurveysResponsesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.responses.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DispatchIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dispatch_ids", runtime.ParamLocationQuery, *params.DispatchIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Objects != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "objects", runtime.ParamLocationQuery, *params.Objects); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recipient != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "recipient", runtime.ParamLocationQuery, *params.Recipient); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stages", runtime.ParamLocationQuery, *params.Stages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Surveys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "surveys", runtime.ParamLocationQuery, *params.Surveys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSurveysResponsesListPostRequest calls the generic SurveysResponsesListPost builder with application/json body
func NewSurveysResponsesListPostRequest(server string, body SurveysResponsesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysResponsesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysResponsesListPostRequestWithBody generates requests for SurveysResponsesListPost with any type of body
func NewSurveysResponsesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.responses.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysResponsesUpdateRequest calls the generic SurveysResponsesUpdate builder with application/json body
func NewSurveysResponsesUpdateRequest(server string, body SurveysResponsesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysResponsesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysResponsesUpdateRequestWithBody generates requests for SurveysResponsesUpdate with any type of body
func NewSurveysResponsesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.responses.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysSendRequest calls the generic SurveysSend builder with application/json body
func NewSurveysSendRequest(server string, body SurveysSendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysSendRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysSendRequestWithBody generates requests for SurveysSend with any type of body
func NewSurveysSendRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.send")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysSubmitRequest calls the generic SurveysSubmit builder with application/json body
func NewSurveysSubmitRequest(server string, body SurveysSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysSubmitRequestWithBody generates requests for SurveysSubmit with any type of body
func NewSurveysSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSurveysUpdateRequest calls the generic SurveysUpdate builder with application/json body
func NewSurveysUpdateRequest(server string, body SurveysUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSurveysUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSurveysUpdateRequestWithBody generates requests for SurveysUpdate with any type of body
func NewSurveysUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/surveys.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSysUsersListRequest generates requests for SysUsersList
func NewSysUsersListRequest(server string, params *SysUsersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sys-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSysUsersListPostRequest calls the generic SysUsersListPost builder with application/json body
func NewSysUsersListPostRequest(server string, body SysUsersListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSysUsersListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSysUsersListPostRequestWithBody generates requests for SysUsersListPost with any type of body
func NewSysUsersListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sys-users.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSysUsersUpdateRequest calls the generic SysUsersUpdate builder with application/json body
func NewSysUsersUpdateRequest(server string, body SysUsersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSysUsersUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewSysUsersUpdateRequestWithBody generates requests for SysUsersUpdate with any type of body
func NewSysUsersUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sys-users.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsCreateRequest calls the generic TagsCreate builder with application/json body
func NewTagsCreateRequest(server string, body TagsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsCreateRequestWithBody generates requests for TagsCreate with any type of body
func NewTagsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsDeleteRequest calls the generic TagsDelete builder with application/json body
func NewTagsDeleteRequest(server string, body TagsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsDeleteRequestWithBody generates requests for TagsDelete with any type of body
func NewTagsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsGetRequest generates requests for TagsGet
func NewTagsGetRequest(server string, params *TagsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsGetPostRequest calls the generic TagsGetPost builder with application/json body
func NewTagsGetPostRequest(server string, body TagsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsGetPostRequestWithBody generates requests for TagsGetPost with any type of body
func NewTagsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsListRequest generates requests for TagsList
func NewTagsListRequest(server string, params *TagsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsListPostRequest calls the generic TagsListPost builder with application/json body
func NewTagsListPostRequest(server string, body TagsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsListPostRequestWithBody generates requests for TagsListPost with any type of body
func NewTagsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsUpdateRequest calls the generic TagsUpdate builder with application/json body
func NewTagsUpdateRequest(server string, body TagsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsUpdateRequestWithBody generates requests for TagsUpdate with any type of body
func NewTagsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesCreateRequest calls the generic TimelineEntriesCreate builder with application/json body
func NewTimelineEntriesCreateRequest(server string, body TimelineEntriesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesCreateRequestWithBody generates requests for TimelineEntriesCreate with any type of body
func NewTimelineEntriesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesDeleteRequest calls the generic TimelineEntriesDelete builder with application/json body
func NewTimelineEntriesDeleteRequest(server string, body TimelineEntriesDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesDeleteRequestWithBody generates requests for TimelineEntriesDelete with any type of body
func NewTimelineEntriesDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesGetRequest generates requests for TimelineEntriesGet
func NewTimelineEntriesGetRequest(server string, params *TimelineEntriesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ExternalRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "external_ref", runtime.ParamLocationQuery, *params.ExternalRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTimelineEntriesGetPostRequest calls the generic TimelineEntriesGetPost builder with application/json body
func NewTimelineEntriesGetPostRequest(server string, body TimelineEntriesGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesGetPostRequestWithBody generates requests for TimelineEntriesGetPost with any type of body
func NewTimelineEntriesGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesListRequest generates requests for TimelineEntriesList
func NewTimelineEntriesListRequest(server string, params *TimelineEntriesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "object", runtime.ParamLocationQuery, params.Object); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Collections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "collections", runtime.ParamLocationQuery, *params.Collections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Visibility != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "visibility", runtime.ParamLocationQuery, *params.Visibility); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTimelineEntriesListPostRequest calls the generic TimelineEntriesListPost builder with application/json body
func NewTimelineEntriesListPostRequest(server string, body TimelineEntriesListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesListPostRequestWithBody generates requests for TimelineEntriesListPost with any type of body
func NewTimelineEntriesListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTimelineEntriesUpdateRequest calls the generic TimelineEntriesUpdate builder with application/json body
func NewTimelineEntriesUpdateRequest(server string, body TimelineEntriesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelineEntriesUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewTimelineEntriesUpdateRequestWithBody generates requests for TimelineEntriesUpdate with any type of body
func NewTimelineEntriesUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timeline-entries.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTrackEventsPublishRequest calls the generic TrackEventsPublish builder with application/json body
func NewTrackEventsPublishRequest(server string, body TrackEventsPublishJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTrackEventsPublishRequestWithBody(server, "application/json", bodyReader)
}

// NewTrackEventsPublishRequestWithBody generates requests for TrackEventsPublish with any type of body
func NewTrackEventsPublishRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/track-events.publish")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUomsCountRequest generates requests for UomsCount
func NewUomsCountRequest(server string, params *UomsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uoms.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AggregationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "aggregation_types", runtime.ParamLocationQuery, *params.AggregationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MetricNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metric_names", runtime.ParamLocationQuery, *params.MetricNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PartIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "part_ids", runtime.ParamLocationQuery, *params.PartIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "product_ids", runtime.ParamLocationQuery, *params.ProductIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnitTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "unit_types", runtime.ParamLocationQuery, *params.UnitTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUomsCountPostRequest calls the generic UomsCountPost builder with application/json body
func NewUomsCountPostRequest(server string, body UomsCountPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUomsCountPostRequestWithBody(server, "application/json", bodyReader)
}

// NewUomsCountPostRequestWithBody generates requests for UomsCountPost with any type of body
func NewUomsCountPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uoms.count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUomsCreateRequest calls the generic UomsCreate builder with application/json body
func NewUomsCreateRequest(server string, body UomsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUomsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUomsCreateRequestWithBody generates requests for UomsCreate with any type of body
func NewUomsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uoms.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUomsDeleteRequest calls the generic UomsDelete builder with application/json body
func NewUomsDeleteRequest(server string, body UomsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUomsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewUomsDeleteRequestWithBody generates requests for UomsDelete with any type of body
func NewUomsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uoms.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUomsGetRequest generates requests for UomsGet
func NewUomsGetRequest(server string, params *UomsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uoms.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUomsGetPostRequest calls the generic UomsGetPost builder with application/json body
func NewUomsGetPostRequest(server string, body UomsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUomsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewUomsGetPostRequestWithBody generates requests for UomsGetPost with any type of body
func NewUomsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uoms.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUomsListRequest generates requests for UomsList
func NewUomsListRequest(server string, params *UomsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uoms.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AggregationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "aggregation_types", runtime.ParamLocationQuery, *params.AggregationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MetricNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metric_names", runtime.ParamLocationQuery, *params.MetricNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PartIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "part_ids", runtime.ParamLocationQuery, *params.PartIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "product_ids", runtime.ParamLocationQuery, *params.ProductIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnitTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "unit_types", runtime.ParamLocationQuery, *params.UnitTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUomsListPostRequest calls the generic UomsListPost builder with application/json body
func NewUomsListPostRequest(server string, body UomsListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUomsListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewUomsListPostRequestWithBody generates requests for UomsListPost with any type of body
func NewUomsListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uoms.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUomsUpdateRequest calls the generic UomsUpdate builder with application/json body
func NewUomsUpdateRequest(server string, body UomsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUomsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewUomsUpdateRequestWithBody generates requests for UomsUpdate with any type of body
func NewUomsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uoms.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebCrawlerJobsControlRequest calls the generic WebCrawlerJobsControl builder with application/json body
func NewWebCrawlerJobsControlRequest(server string, body WebCrawlerJobsControlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebCrawlerJobsControlRequestWithBody(server, "application/json", bodyReader)
}

// NewWebCrawlerJobsControlRequestWithBody generates requests for WebCrawlerJobsControl with any type of body
func NewWebCrawlerJobsControlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.control")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWebCrawlerJobRequest calls the generic CreateWebCrawlerJob builder with application/json body
func NewCreateWebCrawlerJobRequest(server string, body CreateWebCrawlerJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebCrawlerJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWebCrawlerJobRequestWithBody generates requests for CreateWebCrawlerJob with any type of body
func NewCreateWebCrawlerJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWebCrawlerJobRequest generates requests for GetWebCrawlerJob
func NewGetWebCrawlerJobRequest(server string, params *GetWebCrawlerJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebCrawlerJobPostRequest calls the generic GetWebCrawlerJobPost builder with application/json body
func NewGetWebCrawlerJobPostRequest(server string, body GetWebCrawlerJobPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetWebCrawlerJobPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGetWebCrawlerJobPostRequestWithBody generates requests for GetWebCrawlerJobPost with any type of body
func NewGetWebCrawlerJobPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWebCrawlerJobsRequest generates requests for ListWebCrawlerJobs
func NewListWebCrawlerJobsRequest(server string, params *ListWebCrawlerJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWebCrawlerJobsPostRequest calls the generic ListWebCrawlerJobsPost builder with application/json body
func NewListWebCrawlerJobsPostRequest(server string, body ListWebCrawlerJobsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListWebCrawlerJobsPostRequestWithBody(server, "application/json", bodyReader)
}

// NewListWebCrawlerJobsPostRequestWithBody generates requests for ListWebCrawlerJobsPost with any type of body
func NewListWebCrawlerJobsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web-crawler-jobs.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksCreateRequest calls the generic WebhooksCreate builder with application/json body
func NewWebhooksCreateRequest(server string, body WebhooksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksCreateRequestWithBody generates requests for WebhooksCreate with any type of body
func NewWebhooksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksDeleteRequest calls the generic WebhooksDelete builder with application/json body
func NewWebhooksDeleteRequest(server string, body WebhooksDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksDeleteRequestWithBody generates requests for WebhooksDelete with any type of body
func NewWebhooksDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksEventRequest calls the generic WebhooksEvent builder with application/json body
func NewWebhooksEventRequest(server string, body WebhooksEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksEventRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksEventRequestWithBody generates requests for WebhooksEvent with any type of body
func NewWebhooksEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.event")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksFetchRequest calls the generic WebhooksFetch builder with application/json body
func NewWebhooksFetchRequest(server string, body WebhooksFetchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksFetchRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksFetchRequestWithBody generates requests for WebhooksFetch with any type of body
func NewWebhooksFetchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.fetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksGetRequest generates requests for WebhooksGet
func NewWebhooksGetRequest(server string, params *WebhooksGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksGetPostRequest calls the generic WebhooksGetPost builder with application/json body
func NewWebhooksGetPostRequest(server string, body WebhooksGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksGetPostRequestWithBody generates requests for WebhooksGetPost with any type of body
func NewWebhooksGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksListRequest generates requests for WebhooksList
func NewWebhooksListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksListPostRequest calls the generic WebhooksListPost builder with application/json body
func NewWebhooksListPostRequest(server string, body WebhooksListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksListPostRequestWithBody generates requests for WebhooksListPost with any type of body
func NewWebhooksListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksUpdateRequest calls the generic WebhooksUpdate builder with application/json body
func NewWebhooksUpdateRequest(server string, body WebhooksUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksUpdateRequestWithBody generates requests for WebhooksUpdate with any type of body
func NewWebhooksUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWidgetsGetRequest generates requests for WidgetsGet
func NewWidgetsGetRequest(server string, params *WidgetsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/widgets.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWidgetsGetPostRequest calls the generic WidgetsGetPost builder with application/json body
func NewWidgetsGetPostRequest(server string, body WidgetsGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWidgetsGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWidgetsGetPostRequestWithBody generates requests for WidgetsGetPost with any type of body
func NewWidgetsGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/widgets.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksCreateRequest calls the generic WorksCreate builder with application/json body
func NewWorksCreateRequest(server string, body WorksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksCreateRequestWithBody generates requests for WorksCreate with any type of body
func NewWorksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksDeleteRequest calls the generic WorksDelete builder with application/json body
func NewWorksDeleteRequest(server string, body WorksDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksDeleteRequestWithBody generates requests for WorksDelete with any type of body
func NewWorksDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksExportRequest generates requests for WorksExport
func NewWorksExportRequest(server string, params *WorksExportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToPart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_part", runtime.ParamLocationQuery, *params.AppliesToPart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueAccounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.accounts", runtime.ParamLocationQuery, *params.IssueAccounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuePriority != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.priority", runtime.ParamLocationQuery, *params.IssuePriority); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuePriorityV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.priority_v2", runtime.ParamLocationQuery, *params.IssuePriorityV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueRevOrgs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.rev_orgs", runtime.ParamLocationQuery, *params.IssueRevOrgs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.sla_summary.stage", runtime.ParamLocationQuery, *params.IssueSlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSprint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.sprint", runtime.ParamLocationQuery, *params.IssueSprint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSubtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.subtype", runtime.ParamLocationQuery, *params.IssueSubtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpportunityAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "opportunity.account", runtime.ParamLocationQuery, *params.OpportunityAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpportunityContacts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "opportunity.contacts", runtime.ParamLocationQuery, *params.OpportunityContacts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpportunityForecastCategoryV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "opportunity.forecast_category_v2", runtime.ParamLocationQuery, *params.OpportunityForecastCategoryV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpportunitySubtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "opportunity.subtype", runtime.ParamLocationQuery, *params.OpportunitySubtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reported_by", runtime.ParamLocationQuery, *params.ReportedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage.name", runtime.ParamLocationQuery, *params.StageName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StagedInfoIsStaged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "staged_info.is_staged", runtime.ParamLocationQuery, *params.StagedInfoIsStaged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataExternalReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.external_reference", runtime.ParamLocationQuery, *params.SyncMetadataExternalReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataOriginSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.origin_system", runtime.ParamLocationQuery, *params.SyncMetadataOriginSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketBrand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.brand", runtime.ParamLocationQuery, *params.TicketBrand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.channels", runtime.ParamLocationQuery, *params.TicketChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketChannelsV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.channels_v2", runtime.ParamLocationQuery, *params.TicketChannelsV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.group", runtime.ParamLocationQuery, *params.TicketGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketIsFrozen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.is_frozen", runtime.ParamLocationQuery, *params.TicketIsFrozen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketIsSpam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.is_spam", runtime.ParamLocationQuery, *params.TicketIsSpam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketNeedsResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.needs_response", runtime.ParamLocationQuery, *params.TicketNeedsResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketRevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.rev_org", runtime.ParamLocationQuery, *params.TicketRevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSeverity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.severity", runtime.ParamLocationQuery, *params.TicketSeverity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.sla_summary.stage", runtime.ParamLocationQuery, *params.TicketSlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSourceChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.source_channel", runtime.ParamLocationQuery, *params.TicketSourceChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSourceChannelV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.source_channel_v2", runtime.ParamLocationQuery, *params.TicketSourceChannelV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSubtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.subtype", runtime.ParamLocationQuery, *params.TicketSubtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorksExportPostRequest calls the generic WorksExportPost builder with application/json body
func NewWorksExportPostRequest(server string, body WorksExportPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksExportPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksExportPostRequestWithBody generates requests for WorksExportPost with any type of body
func NewWorksExportPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksGetRequest generates requests for WorksGet
func NewWorksGetRequest(server string, params *WorksGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorksGetPostRequest calls the generic WorksGetPost builder with application/json body
func NewWorksGetPostRequest(server string, body WorksGetPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksGetPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksGetPostRequestWithBody generates requests for WorksGetPost with any type of body
func NewWorksGetPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksListRequest generates requests for WorksList
func NewWorksListRequest(server string, params *WorksListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppliesToPart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "applies_to_part", runtime.ParamLocationQuery, *params.AppliesToPart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "custom_fields", runtime.ParamLocationQuery, *params.CustomFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueAccounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.accounts", runtime.ParamLocationQuery, *params.IssueAccounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuePriority != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.priority", runtime.ParamLocationQuery, *params.IssuePriority); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuePriorityV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.priority_v2", runtime.ParamLocationQuery, *params.IssuePriorityV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueRevOrgs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.rev_orgs", runtime.ParamLocationQuery, *params.IssueRevOrgs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.sla_summary.stage", runtime.ParamLocationQuery, *params.IssueSlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSprint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.sprint", runtime.ParamLocationQuery, *params.IssueSprint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueSubtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "issue.subtype", runtime.ParamLocationQuery, *params.IssueSubtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "modified_by", runtime.ParamLocationQuery, *params.ModifiedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpportunityAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "opportunity.account", runtime.ParamLocationQuery, *params.OpportunityAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpportunityContacts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "opportunity.contacts", runtime.ParamLocationQuery, *params.OpportunityContacts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpportunityForecastCategoryV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "opportunity.forecast_category_v2", runtime.ParamLocationQuery, *params.OpportunityForecastCategoryV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OpportunitySubtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "opportunity.subtype", runtime.ParamLocationQuery, *params.OpportunitySubtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owned_by", runtime.ParamLocationQuery, *params.OwnedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reported_by", runtime.ParamLocationQuery, *params.ReportedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stage.name", runtime.ParamLocationQuery, *params.StageName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StagedInfoIsStaged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "staged_info.is_staged", runtime.ParamLocationQuery, *params.StagedInfoIsStaged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataExternalReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.external_reference", runtime.ParamLocationQuery, *params.SyncMetadataExternalReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncInSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_in.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncInSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.status", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_history", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataLastSyncOutSyncUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.last_sync_out.sync_unit", runtime.ParamLocationQuery, *params.SyncMetadataLastSyncOutSyncUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SyncMetadataOriginSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sync_metadata.origin_system", runtime.ParamLocationQuery, *params.SyncMetadataOriginSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketBrand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.brand", runtime.ParamLocationQuery, *params.TicketBrand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.channels", runtime.ParamLocationQuery, *params.TicketChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketChannelsV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.channels_v2", runtime.ParamLocationQuery, *params.TicketChannelsV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.group", runtime.ParamLocationQuery, *params.TicketGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketIsFrozen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.is_frozen", runtime.ParamLocationQuery, *params.TicketIsFrozen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketIsSpam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.is_spam", runtime.ParamLocationQuery, *params.TicketIsSpam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketNeedsResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.needs_response", runtime.ParamLocationQuery, *params.TicketNeedsResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketRevOrg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.rev_org", runtime.ParamLocationQuery, *params.TicketRevOrg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSeverity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.severity", runtime.ParamLocationQuery, *params.TicketSeverity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSlaSummaryStage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.sla_summary.stage", runtime.ParamLocationQuery, *params.TicketSlaSummaryStage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSourceChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.source_channel", runtime.ParamLocationQuery, *params.TicketSourceChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSourceChannelV2 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.source_channel_v2", runtime.ParamLocationQuery, *params.TicketSourceChannelV2); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TicketSubtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ticket.subtype", runtime.ParamLocationQuery, *params.TicketSubtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorksListPostRequest calls the generic WorksListPost builder with application/json body
func NewWorksListPostRequest(server string, body WorksListPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksListPostRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksListPostRequestWithBody generates requests for WorksListPost with any type of body
func NewWorksListPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorksUpdateRequest calls the generic WorksUpdate builder with application/json body
func NewWorksUpdateRequest(server string, body WorksUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorksUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewWorksUpdateRequestWithBody generates requests for WorksUpdate with any type of body
func NewWorksUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/works.update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AccountsCreateWithBodyWithResponse request with any body
	AccountsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsCreateResponse, error)

	AccountsCreateWithResponse(ctx context.Context, body AccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsCreateResponse, error)

	// AccountsDeleteWithBodyWithResponse request with any body
	AccountsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsDeleteResponse, error)

	AccountsDeleteWithResponse(ctx context.Context, body AccountsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsDeleteResponse, error)

	// AccountsExportWithResponse request
	AccountsExportWithResponse(ctx context.Context, params *AccountsExportParams, reqEditors ...RequestEditorFn) (*AccountsExportResponse, error)

	// AccountsExportPostWithBodyWithResponse request with any body
	AccountsExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsExportPostResponse, error)

	AccountsExportPostWithResponse(ctx context.Context, body AccountsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsExportPostResponse, error)

	// AccountsGetWithResponse request
	AccountsGetWithResponse(ctx context.Context, params *AccountsGetParams, reqEditors ...RequestEditorFn) (*AccountsGetResponse, error)

	// AccountsGetPostWithBodyWithResponse request with any body
	AccountsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsGetPostResponse, error)

	AccountsGetPostWithResponse(ctx context.Context, body AccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsGetPostResponse, error)

	// AccountsListWithResponse request
	AccountsListWithResponse(ctx context.Context, params *AccountsListParams, reqEditors ...RequestEditorFn) (*AccountsListResponse, error)

	// AccountsListPostWithBodyWithResponse request with any body
	AccountsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsListPostResponse, error)

	AccountsListPostWithResponse(ctx context.Context, body AccountsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsListPostResponse, error)

	// AccountsMergeWithBodyWithResponse request with any body
	AccountsMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsMergeResponse, error)

	AccountsMergeWithResponse(ctx context.Context, body AccountsMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsMergeResponse, error)

	// AccountsUpdateWithBodyWithResponse request with any body
	AccountsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsUpdateResponse, error)

	AccountsUpdateWithResponse(ctx context.Context, body AccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsUpdateResponse, error)

	// AiAgentEventsExecuteAsyncWithBodyWithResponse request with any body
	AiAgentEventsExecuteAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AiAgentEventsExecuteAsyncResponse, error)

	AiAgentEventsExecuteAsyncWithResponse(ctx context.Context, body AiAgentEventsExecuteAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*AiAgentEventsExecuteAsyncResponse, error)

	// AirdropSyncUnitsGetWithResponse request
	AirdropSyncUnitsGetWithResponse(ctx context.Context, params *AirdropSyncUnitsGetParams, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsGetResponse, error)

	// AirdropSyncUnitsGetPostWithBodyWithResponse request with any body
	AirdropSyncUnitsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsGetPostResponse, error)

	AirdropSyncUnitsGetPostWithResponse(ctx context.Context, body AirdropSyncUnitsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsGetPostResponse, error)

	// AirdropSyncUnitsHistoryWithResponse request
	AirdropSyncUnitsHistoryWithResponse(ctx context.Context, params *AirdropSyncUnitsHistoryParams, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsHistoryResponse, error)

	// AirdropSyncUnitsHistoryPostWithBodyWithResponse request with any body
	AirdropSyncUnitsHistoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsHistoryPostResponse, error)

	AirdropSyncUnitsHistoryPostWithResponse(ctx context.Context, body AirdropSyncUnitsHistoryPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsHistoryPostResponse, error)

	// ArticlesCountWithResponse request
	ArticlesCountWithResponse(ctx context.Context, params *ArticlesCountParams, reqEditors ...RequestEditorFn) (*ArticlesCountResponse, error)

	// ArticlesCountPostWithBodyWithResponse request with any body
	ArticlesCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArticlesCountPostResponse, error)

	ArticlesCountPostWithResponse(ctx context.Context, body ArticlesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArticlesCountPostResponse, error)

	// CreateArticleWithBodyWithResponse request with any body
	CreateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error)

	CreateArticleWithResponse(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error)

	// DeleteArticleWithBodyWithResponse request with any body
	DeleteArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteArticleResponse, error)

	DeleteArticleWithResponse(ctx context.Context, body DeleteArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteArticleResponse, error)

	// GetArticleWithResponse request
	GetArticleWithResponse(ctx context.Context, params *GetArticleParams, reqEditors ...RequestEditorFn) (*GetArticleResponse, error)

	// GetArticlePostWithBodyWithResponse request with any body
	GetArticlePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetArticlePostResponse, error)

	GetArticlePostWithResponse(ctx context.Context, body GetArticlePostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetArticlePostResponse, error)

	// ListArticlesWithResponse request
	ListArticlesWithResponse(ctx context.Context, params *ListArticlesParams, reqEditors ...RequestEditorFn) (*ListArticlesResponse, error)

	// ListArticlesPostWithBodyWithResponse request with any body
	ListArticlesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListArticlesPostResponse, error)

	ListArticlesPostWithResponse(ctx context.Context, body ListArticlesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListArticlesPostResponse, error)

	// UpdateArticleWithBodyWithResponse request with any body
	UpdateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error)

	UpdateArticleWithResponse(ctx context.Context, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error)

	// ArtifactsGetWithResponse request
	ArtifactsGetWithResponse(ctx context.Context, params *ArtifactsGetParams, reqEditors ...RequestEditorFn) (*ArtifactsGetResponse, error)

	// ArtifactsGetPostWithBodyWithResponse request with any body
	ArtifactsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsGetPostResponse, error)

	ArtifactsGetPostWithResponse(ctx context.Context, body ArtifactsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsGetPostResponse, error)

	// ArtifactsListWithResponse request
	ArtifactsListWithResponse(ctx context.Context, params *ArtifactsListParams, reqEditors ...RequestEditorFn) (*ArtifactsListResponse, error)

	// ArtifactsListPostWithBodyWithResponse request with any body
	ArtifactsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsListPostResponse, error)

	ArtifactsListPostWithResponse(ctx context.Context, body ArtifactsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsListPostResponse, error)

	// ArtifactsLocateWithResponse request
	ArtifactsLocateWithResponse(ctx context.Context, params *ArtifactsLocateParams, reqEditors ...RequestEditorFn) (*ArtifactsLocateResponse, error)

	// ArtifactsLocatePostWithBodyWithResponse request with any body
	ArtifactsLocatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsLocatePostResponse, error)

	ArtifactsLocatePostWithResponse(ctx context.Context, body ArtifactsLocatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsLocatePostResponse, error)

	// ArtifactsPrepareWithBodyWithResponse request with any body
	ArtifactsPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsPrepareResponse, error)

	ArtifactsPrepareWithResponse(ctx context.Context, body ArtifactsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsPrepareResponse, error)

	// ArtifactsHardDeleteVersionWithBodyWithResponse request with any body
	ArtifactsHardDeleteVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsHardDeleteVersionResponse, error)

	ArtifactsHardDeleteVersionWithResponse(ctx context.Context, body ArtifactsHardDeleteVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsHardDeleteVersionResponse, error)

	// ArtifactsVersionsPrepareWithBodyWithResponse request with any body
	ArtifactsVersionsPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsVersionsPrepareResponse, error)

	ArtifactsVersionsPrepareWithResponse(ctx context.Context, body ArtifactsVersionsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsVersionsPrepareResponse, error)

	// AtomsGetWithResponse request
	AtomsGetWithResponse(ctx context.Context, params *AtomsGetParams, reqEditors ...RequestEditorFn) (*AtomsGetResponse, error)

	// AtomsGetPostWithBodyWithResponse request with any body
	AtomsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AtomsGetPostResponse, error)

	AtomsGetPostWithResponse(ctx context.Context, body AtomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AtomsGetPostResponse, error)

	// ExportAuditLogsWithBodyWithResponse request with any body
	ExportAuditLogsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportAuditLogsResponse, error)

	ExportAuditLogsWithResponse(ctx context.Context, body ExportAuditLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportAuditLogsResponse, error)

	// AuthTokensCreateWithBodyWithResponse request with any body
	AuthTokensCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensCreateResponse, error)

	AuthTokensCreateWithResponse(ctx context.Context, body AuthTokensCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensCreateResponse, error)

	// AuthTokensDeleteWithBodyWithResponse request with any body
	AuthTokensDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensDeleteResponse, error)

	AuthTokensDeleteWithResponse(ctx context.Context, body AuthTokensDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensDeleteResponse, error)

	// AuthTokensGetWithResponse request
	AuthTokensGetWithResponse(ctx context.Context, params *AuthTokensGetParams, reqEditors ...RequestEditorFn) (*AuthTokensGetResponse, error)

	// AuthTokensGetPostWithBodyWithResponse request with any body
	AuthTokensGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensGetPostResponse, error)

	AuthTokensGetPostWithResponse(ctx context.Context, body AuthTokensGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensGetPostResponse, error)

	// AuthTokensInfoWithResponse request
	AuthTokensInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthTokensInfoResponse, error)

	// AuthTokensInfoPostWithBodyWithResponse request with any body
	AuthTokensInfoPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensInfoPostResponse, error)

	AuthTokensInfoPostWithResponse(ctx context.Context, body AuthTokensInfoPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensInfoPostResponse, error)

	// AuthTokensListWithResponse request
	AuthTokensListWithResponse(ctx context.Context, params *AuthTokensListParams, reqEditors ...RequestEditorFn) (*AuthTokensListResponse, error)

	// AuthTokensListPostWithBodyWithResponse request with any body
	AuthTokensListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensListPostResponse, error)

	AuthTokensListPostWithResponse(ctx context.Context, body AuthTokensListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensListPostResponse, error)

	// AuthTokensSelfDeleteWithBodyWithResponse request with any body
	AuthTokensSelfDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensSelfDeleteResponse, error)

	AuthTokensSelfDeleteWithResponse(ctx context.Context, body AuthTokensSelfDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensSelfDeleteResponse, error)

	// AuthTokensUpdateWithBodyWithResponse request with any body
	AuthTokensUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensUpdateResponse, error)

	AuthTokensUpdateWithResponse(ctx context.Context, body AuthTokensUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensUpdateResponse, error)

	// BrandsCreateWithBodyWithResponse request with any body
	BrandsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsCreateResponse, error)

	BrandsCreateWithResponse(ctx context.Context, body BrandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsCreateResponse, error)

	// BrandsDeleteWithBodyWithResponse request with any body
	BrandsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsDeleteResponse, error)

	BrandsDeleteWithResponse(ctx context.Context, body BrandsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsDeleteResponse, error)

	// BrandsGetWithResponse request
	BrandsGetWithResponse(ctx context.Context, params *BrandsGetParams, reqEditors ...RequestEditorFn) (*BrandsGetResponse, error)

	// BrandsGetPostWithBodyWithResponse request with any body
	BrandsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsGetPostResponse, error)

	BrandsGetPostWithResponse(ctx context.Context, body BrandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsGetPostResponse, error)

	// BrandsListWithResponse request
	BrandsListWithResponse(ctx context.Context, params *BrandsListParams, reqEditors ...RequestEditorFn) (*BrandsListResponse, error)

	// BrandsListPostWithBodyWithResponse request with any body
	BrandsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsListPostResponse, error)

	BrandsListPostWithResponse(ctx context.Context, body BrandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsListPostResponse, error)

	// BrandsUpdateWithBodyWithResponse request with any body
	BrandsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsUpdateResponse, error)

	BrandsUpdateWithResponse(ctx context.Context, body BrandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsUpdateResponse, error)

	// ChatsCreateWithBodyWithResponse request with any body
	ChatsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsCreateResponse, error)

	ChatsCreateWithResponse(ctx context.Context, body ChatsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsCreateResponse, error)

	// ChatsGetWithResponse request
	ChatsGetWithResponse(ctx context.Context, params *ChatsGetParams, reqEditors ...RequestEditorFn) (*ChatsGetResponse, error)

	// ChatsGetPostWithBodyWithResponse request with any body
	ChatsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsGetPostResponse, error)

	ChatsGetPostWithResponse(ctx context.Context, body ChatsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsGetPostResponse, error)

	// ChatsUpdateWithBodyWithResponse request with any body
	ChatsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsUpdateResponse, error)

	ChatsUpdateWithResponse(ctx context.Context, body ChatsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsUpdateResponse, error)

	// CodeChangesCreateWithBodyWithResponse request with any body
	CodeChangesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesCreateResponse, error)

	CodeChangesCreateWithResponse(ctx context.Context, body CodeChangesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesCreateResponse, error)

	// CodeChangesDeleteWithBodyWithResponse request with any body
	CodeChangesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesDeleteResponse, error)

	CodeChangesDeleteWithResponse(ctx context.Context, body CodeChangesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesDeleteResponse, error)

	// CodeChangesGetWithResponse request
	CodeChangesGetWithResponse(ctx context.Context, params *CodeChangesGetParams, reqEditors ...RequestEditorFn) (*CodeChangesGetResponse, error)

	// CodeChangesGetPostWithBodyWithResponse request with any body
	CodeChangesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesGetPostResponse, error)

	CodeChangesGetPostWithResponse(ctx context.Context, body CodeChangesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesGetPostResponse, error)

	// CodeChangesListWithResponse request
	CodeChangesListWithResponse(ctx context.Context, params *CodeChangesListParams, reqEditors ...RequestEditorFn) (*CodeChangesListResponse, error)

	// CodeChangesListPostWithBodyWithResponse request with any body
	CodeChangesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesListPostResponse, error)

	CodeChangesListPostWithResponse(ctx context.Context, body CodeChangesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesListPostResponse, error)

	// CodeChangesUpdateWithBodyWithResponse request with any body
	CodeChangesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesUpdateResponse, error)

	CodeChangesUpdateWithResponse(ctx context.Context, body CodeChangesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesUpdateResponse, error)

	// CommandsCreateWithBodyWithResponse request with any body
	CommandsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsCreateResponse, error)

	CommandsCreateWithResponse(ctx context.Context, body CommandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsCreateResponse, error)

	// CommandsGetWithResponse request
	CommandsGetWithResponse(ctx context.Context, params *CommandsGetParams, reqEditors ...RequestEditorFn) (*CommandsGetResponse, error)

	// CommandsGetPostWithBodyWithResponse request with any body
	CommandsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsGetPostResponse, error)

	CommandsGetPostWithResponse(ctx context.Context, body CommandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsGetPostResponse, error)

	// CommandsListWithResponse request
	CommandsListWithResponse(ctx context.Context, params *CommandsListParams, reqEditors ...RequestEditorFn) (*CommandsListResponse, error)

	// CommandsListPostWithBodyWithResponse request with any body
	CommandsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsListPostResponse, error)

	CommandsListPostWithResponse(ctx context.Context, body CommandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsListPostResponse, error)

	// CommandsUpdateWithBodyWithResponse request with any body
	CommandsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsUpdateResponse, error)

	CommandsUpdateWithResponse(ctx context.Context, body CommandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsUpdateResponse, error)

	// ContentTemplateCreateWithBodyWithResponse request with any body
	ContentTemplateCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContentTemplateCreateResponse, error)

	ContentTemplateCreateWithResponse(ctx context.Context, body ContentTemplateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ContentTemplateCreateResponse, error)

	// ContentTemplateGetWithResponse request
	ContentTemplateGetWithResponse(ctx context.Context, params *ContentTemplateGetParams, reqEditors ...RequestEditorFn) (*ContentTemplateGetResponse, error)

	// ContentTemplateGetPostWithBodyWithResponse request with any body
	ContentTemplateGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContentTemplateGetPostResponse, error)

	ContentTemplateGetPostWithResponse(ctx context.Context, body ContentTemplateGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ContentTemplateGetPostResponse, error)

	// ContentTemplateListWithResponse request
	ContentTemplateListWithResponse(ctx context.Context, params *ContentTemplateListParams, reqEditors ...RequestEditorFn) (*ContentTemplateListResponse, error)

	// ContentTemplateListPostWithBodyWithResponse request with any body
	ContentTemplateListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContentTemplateListPostResponse, error)

	ContentTemplateListPostWithResponse(ctx context.Context, body ContentTemplateListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ContentTemplateListPostResponse, error)

	// ConversationsCreateWithBodyWithResponse request with any body
	ConversationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsCreateResponse, error)

	ConversationsCreateWithResponse(ctx context.Context, body ConversationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsCreateResponse, error)

	// ConversationsDeleteWithBodyWithResponse request with any body
	ConversationsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsDeleteResponse, error)

	ConversationsDeleteWithResponse(ctx context.Context, body ConversationsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsDeleteResponse, error)

	// ConversationsExportWithResponse request
	ConversationsExportWithResponse(ctx context.Context, params *ConversationsExportParams, reqEditors ...RequestEditorFn) (*ConversationsExportResponse, error)

	// ConversationsExportPostWithBodyWithResponse request with any body
	ConversationsExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsExportPostResponse, error)

	ConversationsExportPostWithResponse(ctx context.Context, body ConversationsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsExportPostResponse, error)

	// ConversationsGetWithResponse request
	ConversationsGetWithResponse(ctx context.Context, params *ConversationsGetParams, reqEditors ...RequestEditorFn) (*ConversationsGetResponse, error)

	// ConversationsGetPostWithBodyWithResponse request with any body
	ConversationsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsGetPostResponse, error)

	ConversationsGetPostWithResponse(ctx context.Context, body ConversationsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsGetPostResponse, error)

	// ConversationsListWithResponse request
	ConversationsListWithResponse(ctx context.Context, params *ConversationsListParams, reqEditors ...RequestEditorFn) (*ConversationsListResponse, error)

	// ConversationsListPostWithBodyWithResponse request with any body
	ConversationsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsListPostResponse, error)

	ConversationsListPostWithResponse(ctx context.Context, body ConversationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsListPostResponse, error)

	// ConversationsUpdateWithBodyWithResponse request with any body
	ConversationsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsUpdateResponse, error)

	ConversationsUpdateWithResponse(ctx context.Context, body ConversationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsUpdateResponse, error)

	// CustomObjectsCountWithResponse request
	CustomObjectsCountWithResponse(ctx context.Context, params *CustomObjectsCountParams, reqEditors ...RequestEditorFn) (*CustomObjectsCountResponse, error)

	// CustomObjectsCountPostWithBodyWithResponse request with any body
	CustomObjectsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsCountPostResponse, error)

	CustomObjectsCountPostWithResponse(ctx context.Context, body CustomObjectsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsCountPostResponse, error)

	// CustomObjectsCreateWithBodyWithResponse request with any body
	CustomObjectsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsCreateResponse, error)

	CustomObjectsCreateWithResponse(ctx context.Context, body CustomObjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsCreateResponse, error)

	// CustomObjectsDeleteWithBodyWithResponse request with any body
	CustomObjectsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsDeleteResponse, error)

	CustomObjectsDeleteWithResponse(ctx context.Context, body CustomObjectsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsDeleteResponse, error)

	// CustomObjectsGetWithResponse request
	CustomObjectsGetWithResponse(ctx context.Context, params *CustomObjectsGetParams, reqEditors ...RequestEditorFn) (*CustomObjectsGetResponse, error)

	// CustomObjectsGetPostWithBodyWithResponse request with any body
	CustomObjectsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsGetPostResponse, error)

	CustomObjectsGetPostWithResponse(ctx context.Context, body CustomObjectsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsGetPostResponse, error)

	// CustomObjectsListWithResponse request
	CustomObjectsListWithResponse(ctx context.Context, params *CustomObjectsListParams, reqEditors ...RequestEditorFn) (*CustomObjectsListResponse, error)

	// CustomObjectsListPostWithBodyWithResponse request with any body
	CustomObjectsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsListPostResponse, error)

	CustomObjectsListPostWithResponse(ctx context.Context, body CustomObjectsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsListPostResponse, error)

	// CustomObjectsUpdateWithBodyWithResponse request with any body
	CustomObjectsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsUpdateResponse, error)

	CustomObjectsUpdateWithResponse(ctx context.Context, body CustomObjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsUpdateResponse, error)

	// DevOrgAuthConnectionsCreateWithBodyWithResponse request with any body
	DevOrgAuthConnectionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsCreateResponse, error)

	DevOrgAuthConnectionsCreateWithResponse(ctx context.Context, body DevOrgAuthConnectionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsCreateResponse, error)

	// DevOrgAuthConnectionsDeleteWithBodyWithResponse request with any body
	DevOrgAuthConnectionsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsDeleteResponse, error)

	DevOrgAuthConnectionsDeleteWithResponse(ctx context.Context, body DevOrgAuthConnectionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsDeleteResponse, error)

	// DevOrgAuthConnectionsGetWithResponse request
	DevOrgAuthConnectionsGetWithResponse(ctx context.Context, params *DevOrgAuthConnectionsGetParams, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetResponse, error)

	// DevOrgAuthConnectionsGetPostWithBodyWithResponse request with any body
	DevOrgAuthConnectionsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetPostResponse, error)

	DevOrgAuthConnectionsGetPostWithResponse(ctx context.Context, body DevOrgAuthConnectionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetPostResponse, error)

	// DevOrgAuthConnectionsListWithResponse request
	DevOrgAuthConnectionsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListResponse, error)

	// DevOrgAuthConnectionsListPostWithBodyWithResponse request with any body
	DevOrgAuthConnectionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListPostResponse, error)

	DevOrgAuthConnectionsListPostWithResponse(ctx context.Context, body DevOrgAuthConnectionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListPostResponse, error)

	// DevOrgAuthConnectionsToggleWithBodyWithResponse request with any body
	DevOrgAuthConnectionsToggleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsToggleResponse, error)

	DevOrgAuthConnectionsToggleWithResponse(ctx context.Context, body DevOrgAuthConnectionsToggleJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsToggleResponse, error)

	// DevOrgAuthConnectionsUpdateWithBodyWithResponse request with any body
	DevOrgAuthConnectionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsUpdateResponse, error)

	DevOrgAuthConnectionsUpdateWithResponse(ctx context.Context, body DevOrgAuthConnectionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsUpdateResponse, error)

	// DevOrgsGetWithResponse request
	DevOrgsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevOrgsGetResponse, error)

	// DevOrgsGetPostWithBodyWithResponse request with any body
	DevOrgsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgsGetPostResponse, error)

	DevOrgsGetPostWithResponse(ctx context.Context, body DevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgsGetPostResponse, error)

	// DevUsersActivateWithBodyWithResponse request with any body
	DevUsersActivateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersActivateResponse, error)

	DevUsersActivateWithResponse(ctx context.Context, body DevUsersActivateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersActivateResponse, error)

	// DevUsersCreateWithBodyWithResponse request with any body
	DevUsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersCreateResponse, error)

	DevUsersCreateWithResponse(ctx context.Context, body DevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersCreateResponse, error)

	// DevUsersDeactivateWithBodyWithResponse request with any body
	DevUsersDeactivateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersDeactivateResponse, error)

	DevUsersDeactivateWithResponse(ctx context.Context, body DevUsersDeactivateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersDeactivateResponse, error)

	// DevUsersGetWithResponse request
	DevUsersGetWithResponse(ctx context.Context, params *DevUsersGetParams, reqEditors ...RequestEditorFn) (*DevUsersGetResponse, error)

	// DevUsersGetPostWithBodyWithResponse request with any body
	DevUsersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersGetPostResponse, error)

	DevUsersGetPostWithResponse(ctx context.Context, body DevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersGetPostResponse, error)

	// DevUsersIdentitiesLinkWithBodyWithResponse request with any body
	DevUsersIdentitiesLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesLinkResponse, error)

	DevUsersIdentitiesLinkWithResponse(ctx context.Context, body DevUsersIdentitiesLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesLinkResponse, error)

	// DevUsersIdentitiesUnlinkWithBodyWithResponse request with any body
	DevUsersIdentitiesUnlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesUnlinkResponse, error)

	DevUsersIdentitiesUnlinkWithResponse(ctx context.Context, body DevUsersIdentitiesUnlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesUnlinkResponse, error)

	// DevUsersListWithResponse request
	DevUsersListWithResponse(ctx context.Context, params *DevUsersListParams, reqEditors ...RequestEditorFn) (*DevUsersListResponse, error)

	// DevUsersListPostWithBodyWithResponse request with any body
	DevUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersListPostResponse, error)

	DevUsersListPostWithResponse(ctx context.Context, body DevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersListPostResponse, error)

	// DevUsersMergeWithBodyWithResponse request with any body
	DevUsersMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersMergeResponse, error)

	DevUsersMergeWithResponse(ctx context.Context, body DevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersMergeResponse, error)

	// DevUsersSelfWithResponse request
	DevUsersSelfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevUsersSelfResponse, error)

	// DevUsersSelfPostWithBodyWithResponse request with any body
	DevUsersSelfPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersSelfPostResponse, error)

	DevUsersSelfPostWithResponse(ctx context.Context, body DevUsersSelfPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersSelfPostResponse, error)

	// DevUsersSelfUpdateWithBodyWithResponse request with any body
	DevUsersSelfUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersSelfUpdateResponse, error)

	DevUsersSelfUpdateWithResponse(ctx context.Context, body DevUsersSelfUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersSelfUpdateResponse, error)

	// DevUsersUpdateWithBodyWithResponse request with any body
	DevUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersUpdateResponse, error)

	DevUsersUpdateWithResponse(ctx context.Context, body DevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersUpdateResponse, error)

	// DirectoriesCountWithResponse request
	DirectoriesCountWithResponse(ctx context.Context, params *DirectoriesCountParams, reqEditors ...RequestEditorFn) (*DirectoriesCountResponse, error)

	// DirectoriesCountPostWithBodyWithResponse request with any body
	DirectoriesCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesCountPostResponse, error)

	DirectoriesCountPostWithResponse(ctx context.Context, body DirectoriesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesCountPostResponse, error)

	// DirectoriesCreateWithBodyWithResponse request with any body
	DirectoriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesCreateResponse, error)

	DirectoriesCreateWithResponse(ctx context.Context, body DirectoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesCreateResponse, error)

	// DirectoriesDeleteWithBodyWithResponse request with any body
	DirectoriesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesDeleteResponse, error)

	DirectoriesDeleteWithResponse(ctx context.Context, body DirectoriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesDeleteResponse, error)

	// DirectoriesGetWithResponse request
	DirectoriesGetWithResponse(ctx context.Context, params *DirectoriesGetParams, reqEditors ...RequestEditorFn) (*DirectoriesGetResponse, error)

	// DirectoriesGetPostWithBodyWithResponse request with any body
	DirectoriesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesGetPostResponse, error)

	DirectoriesGetPostWithResponse(ctx context.Context, body DirectoriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesGetPostResponse, error)

	// DirectoriesListWithResponse request
	DirectoriesListWithResponse(ctx context.Context, params *DirectoriesListParams, reqEditors ...RequestEditorFn) (*DirectoriesListResponse, error)

	// DirectoriesListPostWithBodyWithResponse request with any body
	DirectoriesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesListPostResponse, error)

	DirectoriesListPostWithResponse(ctx context.Context, body DirectoriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesListPostResponse, error)

	// DirectoriesUpdateWithBodyWithResponse request with any body
	DirectoriesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesUpdateResponse, error)

	DirectoriesUpdateWithResponse(ctx context.Context, body DirectoriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesUpdateResponse, error)

	// EngagementsCountWithResponse request
	EngagementsCountWithResponse(ctx context.Context, params *EngagementsCountParams, reqEditors ...RequestEditorFn) (*EngagementsCountResponse, error)

	// EngagementsCountPostWithBodyWithResponse request with any body
	EngagementsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsCountPostResponse, error)

	EngagementsCountPostWithResponse(ctx context.Context, body EngagementsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsCountPostResponse, error)

	// EngagementsCreateWithBodyWithResponse request with any body
	EngagementsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsCreateResponse, error)

	EngagementsCreateWithResponse(ctx context.Context, body EngagementsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsCreateResponse, error)

	// EngagementsDeleteWithBodyWithResponse request with any body
	EngagementsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsDeleteResponse, error)

	EngagementsDeleteWithResponse(ctx context.Context, body EngagementsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsDeleteResponse, error)

	// EngagementsGetWithResponse request
	EngagementsGetWithResponse(ctx context.Context, params *EngagementsGetParams, reqEditors ...RequestEditorFn) (*EngagementsGetResponse, error)

	// EngagementsGetPostWithBodyWithResponse request with any body
	EngagementsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsGetPostResponse, error)

	EngagementsGetPostWithResponse(ctx context.Context, body EngagementsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsGetPostResponse, error)

	// EngagementsListWithResponse request
	EngagementsListWithResponse(ctx context.Context, params *EngagementsListParams, reqEditors ...RequestEditorFn) (*EngagementsListResponse, error)

	// EngagementsListPostWithBodyWithResponse request with any body
	EngagementsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsListPostResponse, error)

	EngagementsListPostWithResponse(ctx context.Context, body EngagementsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsListPostResponse, error)

	// EngagementsUpdateWithBodyWithResponse request with any body
	EngagementsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsUpdateResponse, error)

	EngagementsUpdateWithResponse(ctx context.Context, body EngagementsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsUpdateResponse, error)

	// EventSourcesGetWithResponse request
	EventSourcesGetWithResponse(ctx context.Context, params *EventSourcesGetParams, reqEditors ...RequestEditorFn) (*EventSourcesGetResponse, error)

	// EventSourcesGetPostWithBodyWithResponse request with any body
	EventSourcesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventSourcesGetPostResponse, error)

	EventSourcesGetPostWithResponse(ctx context.Context, body EventSourcesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EventSourcesGetPostResponse, error)

	// EventSourcesScheduleEventWithBodyWithResponse request with any body
	EventSourcesScheduleEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventSourcesScheduleEventResponse, error)

	EventSourcesScheduleEventWithResponse(ctx context.Context, body EventSourcesScheduleEventJSONRequestBody, reqEditors ...RequestEditorFn) (*EventSourcesScheduleEventResponse, error)

	// EventSourcesDeleteScheduledEventWithBodyWithResponse request with any body
	EventSourcesDeleteScheduledEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventSourcesDeleteScheduledEventResponse, error)

	EventSourcesDeleteScheduledEventWithResponse(ctx context.Context, body EventSourcesDeleteScheduledEventJSONRequestBody, reqEditors ...RequestEditorFn) (*EventSourcesDeleteScheduledEventResponse, error)

	// GroupsCreateWithBodyWithResponse request with any body
	GroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error)

	GroupsCreateWithResponse(ctx context.Context, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error)

	// GroupsGetWithResponse request
	GroupsGetWithResponse(ctx context.Context, params *GroupsGetParams, reqEditors ...RequestEditorFn) (*GroupsGetResponse, error)

	// GroupsGetPostWithBodyWithResponse request with any body
	GroupsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsGetPostResponse, error)

	GroupsGetPostWithResponse(ctx context.Context, body GroupsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsGetPostResponse, error)

	// GroupsListWithResponse request
	GroupsListWithResponse(ctx context.Context, params *GroupsListParams, reqEditors ...RequestEditorFn) (*GroupsListResponse, error)

	// GroupsListPostWithBodyWithResponse request with any body
	GroupsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsListPostResponse, error)

	GroupsListPostWithResponse(ctx context.Context, body GroupsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsListPostResponse, error)

	// GroupMembersAddWithBodyWithResponse request with any body
	GroupMembersAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersAddResponse, error)

	GroupMembersAddWithResponse(ctx context.Context, body GroupMembersAddJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersAddResponse, error)

	// GroupMembersListWithResponse request
	GroupMembersListWithResponse(ctx context.Context, params *GroupMembersListParams, reqEditors ...RequestEditorFn) (*GroupMembersListResponse, error)

	// GroupMembersListPostWithBodyWithResponse request with any body
	GroupMembersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersListPostResponse, error)

	GroupMembersListPostWithResponse(ctx context.Context, body GroupMembersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersListPostResponse, error)

	// GroupMembersRemoveWithBodyWithResponse request with any body
	GroupMembersRemoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersRemoveResponse, error)

	GroupMembersRemoveWithResponse(ctx context.Context, body GroupMembersRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersRemoveResponse, error)

	// GroupsUpdateWithBodyWithResponse request with any body
	GroupsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsUpdateResponse, error)

	GroupsUpdateWithResponse(ctx context.Context, body GroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsUpdateResponse, error)

	// IncidentsCreateWithBodyWithResponse request with any body
	IncidentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsCreateResponse, error)

	IncidentsCreateWithResponse(ctx context.Context, body IncidentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsCreateResponse, error)

	// IncidentsDeleteWithBodyWithResponse request with any body
	IncidentsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsDeleteResponse, error)

	IncidentsDeleteWithResponse(ctx context.Context, body IncidentsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsDeleteResponse, error)

	// IncidentsGetWithResponse request
	IncidentsGetWithResponse(ctx context.Context, params *IncidentsGetParams, reqEditors ...RequestEditorFn) (*IncidentsGetResponse, error)

	// IncidentsGetPostWithBodyWithResponse request with any body
	IncidentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsGetPostResponse, error)

	IncidentsGetPostWithResponse(ctx context.Context, body IncidentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsGetPostResponse, error)

	// IncidentsGroupWithResponse request
	IncidentsGroupWithResponse(ctx context.Context, params *IncidentsGroupParams, reqEditors ...RequestEditorFn) (*IncidentsGroupResponse, error)

	// IncidentsGroupPostWithBodyWithResponse request with any body
	IncidentsGroupPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsGroupPostResponse, error)

	IncidentsGroupPostWithResponse(ctx context.Context, body IncidentsGroupPostJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsGroupPostResponse, error)

	// IncidentsListWithResponse request
	IncidentsListWithResponse(ctx context.Context, params *IncidentsListParams, reqEditors ...RequestEditorFn) (*IncidentsListResponse, error)

	// IncidentsListPostWithBodyWithResponse request with any body
	IncidentsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsListPostResponse, error)

	IncidentsListPostWithResponse(ctx context.Context, body IncidentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsListPostResponse, error)

	// IncidentsUpdateWithBodyWithResponse request with any body
	IncidentsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsUpdateResponse, error)

	IncidentsUpdateWithResponse(ctx context.Context, body IncidentsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsUpdateResponse, error)

	// KeyringsCreateCallbackWithResponse request
	KeyringsCreateCallbackWithResponse(ctx context.Context, params *KeyringsCreateCallbackParams, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackResponse, error)

	// KeyringsCreateCallbackPostWithBodyWithResponse request with any body
	KeyringsCreateCallbackPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackPostResponse, error)

	KeyringsCreateCallbackPostWithResponse(ctx context.Context, body KeyringsCreateCallbackPostJSONRequestBody, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackPostResponse, error)

	// CustomLinkTypeCreateWithBodyWithResponse request with any body
	CustomLinkTypeCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomLinkTypeCreateResponse, error)

	CustomLinkTypeCreateWithResponse(ctx context.Context, body CustomLinkTypeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomLinkTypeCreateResponse, error)

	// CustomLinkTypeGetWithResponse request
	CustomLinkTypeGetWithResponse(ctx context.Context, params *CustomLinkTypeGetParams, reqEditors ...RequestEditorFn) (*CustomLinkTypeGetResponse, error)

	// CustomLinkTypeGetPostWithBodyWithResponse request with any body
	CustomLinkTypeGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomLinkTypeGetPostResponse, error)

	CustomLinkTypeGetPostWithResponse(ctx context.Context, body CustomLinkTypeGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomLinkTypeGetPostResponse, error)

	// CustomLinkTypeListWithResponse request
	CustomLinkTypeListWithResponse(ctx context.Context, params *CustomLinkTypeListParams, reqEditors ...RequestEditorFn) (*CustomLinkTypeListResponse, error)

	// CustomLinkTypeListPostWithBodyWithResponse request with any body
	CustomLinkTypeListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomLinkTypeListPostResponse, error)

	CustomLinkTypeListPostWithResponse(ctx context.Context, body CustomLinkTypeListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomLinkTypeListPostResponse, error)

	// CustomLinkTypeUpdateWithBodyWithResponse request with any body
	CustomLinkTypeUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomLinkTypeUpdateResponse, error)

	CustomLinkTypeUpdateWithResponse(ctx context.Context, body CustomLinkTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomLinkTypeUpdateResponse, error)

	// LinksCreateWithBodyWithResponse request with any body
	LinksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksCreateResponse, error)

	LinksCreateWithResponse(ctx context.Context, body LinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksCreateResponse, error)

	// LinksDeleteWithBodyWithResponse request with any body
	LinksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksDeleteResponse, error)

	LinksDeleteWithResponse(ctx context.Context, body LinksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksDeleteResponse, error)

	// LinksGetWithResponse request
	LinksGetWithResponse(ctx context.Context, params *LinksGetParams, reqEditors ...RequestEditorFn) (*LinksGetResponse, error)

	// LinksGetPostWithBodyWithResponse request with any body
	LinksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksGetPostResponse, error)

	LinksGetPostWithResponse(ctx context.Context, body LinksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksGetPostResponse, error)

	// LinksListWithResponse request
	LinksListWithResponse(ctx context.Context, params *LinksListParams, reqEditors ...RequestEditorFn) (*LinksListResponse, error)

	// LinksListPostWithBodyWithResponse request with any body
	LinksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksListPostResponse, error)

	LinksListPostWithResponse(ctx context.Context, body LinksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksListPostResponse, error)

	// LinksReplaceWithBodyWithResponse request with any body
	LinksReplaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksReplaceResponse, error)

	LinksReplaceWithResponse(ctx context.Context, body LinksReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksReplaceResponse, error)

	// MeetingsCountWithResponse request
	MeetingsCountWithResponse(ctx context.Context, params *MeetingsCountParams, reqEditors ...RequestEditorFn) (*MeetingsCountResponse, error)

	// MeetingsCountPostWithBodyWithResponse request with any body
	MeetingsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsCountPostResponse, error)

	MeetingsCountPostWithResponse(ctx context.Context, body MeetingsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsCountPostResponse, error)

	// MeetingsCreateWithBodyWithResponse request with any body
	MeetingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsCreateResponse, error)

	MeetingsCreateWithResponse(ctx context.Context, body MeetingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsCreateResponse, error)

	// MeetingsDeleteWithBodyWithResponse request with any body
	MeetingsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsDeleteResponse, error)

	MeetingsDeleteWithResponse(ctx context.Context, body MeetingsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsDeleteResponse, error)

	// MeetingsGetWithResponse request
	MeetingsGetWithResponse(ctx context.Context, params *MeetingsGetParams, reqEditors ...RequestEditorFn) (*MeetingsGetResponse, error)

	// MeetingsGetPostWithBodyWithResponse request with any body
	MeetingsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsGetPostResponse, error)

	MeetingsGetPostWithResponse(ctx context.Context, body MeetingsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsGetPostResponse, error)

	// MeetingsListWithResponse request
	MeetingsListWithResponse(ctx context.Context, params *MeetingsListParams, reqEditors ...RequestEditorFn) (*MeetingsListResponse, error)

	// MeetingsListPostWithBodyWithResponse request with any body
	MeetingsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsListPostResponse, error)

	MeetingsListPostWithResponse(ctx context.Context, body MeetingsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsListPostResponse, error)

	// MeetingsUpdateWithBodyWithResponse request with any body
	MeetingsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsUpdateResponse, error)

	MeetingsUpdateWithResponse(ctx context.Context, body MeetingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsUpdateResponse, error)

	// MetricActionExecuteWithBodyWithResponse request with any body
	MetricActionExecuteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricActionExecuteResponse, error)

	MetricActionExecuteWithResponse(ctx context.Context, body MetricActionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricActionExecuteResponse, error)

	// MetricDefinitionsCreateWithBodyWithResponse request with any body
	MetricDefinitionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsCreateResponse, error)

	MetricDefinitionsCreateWithResponse(ctx context.Context, body MetricDefinitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsCreateResponse, error)

	// MetricDefinitionsDeleteWithBodyWithResponse request with any body
	MetricDefinitionsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsDeleteResponse, error)

	MetricDefinitionsDeleteWithResponse(ctx context.Context, body MetricDefinitionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsDeleteResponse, error)

	// MetricDefinitionsGetWithResponse request
	MetricDefinitionsGetWithResponse(ctx context.Context, params *MetricDefinitionsGetParams, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetResponse, error)

	// MetricDefinitionsGetPostWithBodyWithResponse request with any body
	MetricDefinitionsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetPostResponse, error)

	MetricDefinitionsGetPostWithResponse(ctx context.Context, body MetricDefinitionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetPostResponse, error)

	// MetricDefinitionsListWithResponse request
	MetricDefinitionsListWithResponse(ctx context.Context, params *MetricDefinitionsListParams, reqEditors ...RequestEditorFn) (*MetricDefinitionsListResponse, error)

	// MetricDefinitionsListPostWithBodyWithResponse request with any body
	MetricDefinitionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsListPostResponse, error)

	MetricDefinitionsListPostWithResponse(ctx context.Context, body MetricDefinitionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsListPostResponse, error)

	// MetricDefinitionsUpdateWithBodyWithResponse request with any body
	MetricDefinitionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsUpdateResponse, error)

	MetricDefinitionsUpdateWithResponse(ctx context.Context, body MetricDefinitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsUpdateResponse, error)

	// MetricTrackersGetWithResponse request
	MetricTrackersGetWithResponse(ctx context.Context, params *MetricTrackersGetParams, reqEditors ...RequestEditorFn) (*MetricTrackersGetResponse, error)

	// MetricTrackersGetPostWithBodyWithResponse request with any body
	MetricTrackersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricTrackersGetPostResponse, error)

	MetricTrackersGetPostWithResponse(ctx context.Context, body MetricTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricTrackersGetPostResponse, error)

	// MetricsDevrevIngestWithBodyWithResponse request with any body
	MetricsDevrevIngestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricsDevrevIngestResponse, error)

	MetricsDevrevIngestWithResponse(ctx context.Context, body MetricsDevrevIngestJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricsDevrevIngestResponse, error)

	// NotificationsSendWithBodyWithResponse request with any body
	NotificationsSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationsSendResponse, error)

	NotificationsSendWithResponse(ctx context.Context, body NotificationsSendJSONRequestBody, reqEditors ...RequestEditorFn) (*NotificationsSendResponse, error)

	// OrgScheduleFragmentsCreateWithBodyWithResponse request with any body
	OrgScheduleFragmentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsCreateResponse, error)

	OrgScheduleFragmentsCreateWithResponse(ctx context.Context, body OrgScheduleFragmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsCreateResponse, error)

	// OrgScheduleFragmentsGetWithResponse request
	OrgScheduleFragmentsGetWithResponse(ctx context.Context, params *OrgScheduleFragmentsGetParams, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetResponse, error)

	// OrgScheduleFragmentsGetPostWithBodyWithResponse request with any body
	OrgScheduleFragmentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetPostResponse, error)

	OrgScheduleFragmentsGetPostWithResponse(ctx context.Context, body OrgScheduleFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetPostResponse, error)

	// OrgScheduleFragmentsTransitionWithBodyWithResponse request with any body
	OrgScheduleFragmentsTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsTransitionResponse, error)

	OrgScheduleFragmentsTransitionWithResponse(ctx context.Context, body OrgScheduleFragmentsTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsTransitionResponse, error)

	// OrgSchedulesCreateWithBodyWithResponse request with any body
	OrgSchedulesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesCreateResponse, error)

	OrgSchedulesCreateWithResponse(ctx context.Context, body OrgSchedulesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesCreateResponse, error)

	// OrgSchedulesEvaluateWithResponse request
	OrgSchedulesEvaluateWithResponse(ctx context.Context, params *OrgSchedulesEvaluateParams, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluateResponse, error)

	// OrgSchedulesEvaluatePostWithBodyWithResponse request with any body
	OrgSchedulesEvaluatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluatePostResponse, error)

	OrgSchedulesEvaluatePostWithResponse(ctx context.Context, body OrgSchedulesEvaluatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluatePostResponse, error)

	// OrgSchedulesGetWithResponse request
	OrgSchedulesGetWithResponse(ctx context.Context, params *OrgSchedulesGetParams, reqEditors ...RequestEditorFn) (*OrgSchedulesGetResponse, error)

	// OrgSchedulesGetPostWithBodyWithResponse request with any body
	OrgSchedulesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesGetPostResponse, error)

	OrgSchedulesGetPostWithResponse(ctx context.Context, body OrgSchedulesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesGetPostResponse, error)

	// OrgSchedulesListWithResponse request
	OrgSchedulesListWithResponse(ctx context.Context, params *OrgSchedulesListParams, reqEditors ...RequestEditorFn) (*OrgSchedulesListResponse, error)

	// OrgSchedulesListPostWithBodyWithResponse request with any body
	OrgSchedulesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesListPostResponse, error)

	OrgSchedulesListPostWithResponse(ctx context.Context, body OrgSchedulesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesListPostResponse, error)

	// OrgSchedulesSetFutureWithBodyWithResponse request with any body
	OrgSchedulesSetFutureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesSetFutureResponse, error)

	OrgSchedulesSetFutureWithResponse(ctx context.Context, body OrgSchedulesSetFutureJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesSetFutureResponse, error)

	// OrgSchedulesTransitionWithBodyWithResponse request with any body
	OrgSchedulesTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesTransitionResponse, error)

	OrgSchedulesTransitionWithResponse(ctx context.Context, body OrgSchedulesTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesTransitionResponse, error)

	// OrgSchedulesUpdateWithBodyWithResponse request with any body
	OrgSchedulesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesUpdateResponse, error)

	OrgSchedulesUpdateWithResponse(ctx context.Context, body OrgSchedulesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesUpdateResponse, error)

	// PartsCreateWithBodyWithResponse request with any body
	PartsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsCreateResponse, error)

	PartsCreateWithResponse(ctx context.Context, body PartsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsCreateResponse, error)

	// PartsDeleteWithBodyWithResponse request with any body
	PartsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsDeleteResponse, error)

	PartsDeleteWithResponse(ctx context.Context, body PartsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsDeleteResponse, error)

	// PartsGetWithResponse request
	PartsGetWithResponse(ctx context.Context, params *PartsGetParams, reqEditors ...RequestEditorFn) (*PartsGetResponse, error)

	// PartsGetPostWithBodyWithResponse request with any body
	PartsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsGetPostResponse, error)

	PartsGetPostWithResponse(ctx context.Context, body PartsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsGetPostResponse, error)

	// PartsListWithResponse request
	PartsListWithResponse(ctx context.Context, params *PartsListParams, reqEditors ...RequestEditorFn) (*PartsListResponse, error)

	// PartsListPostWithBodyWithResponse request with any body
	PartsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsListPostResponse, error)

	PartsListPostWithResponse(ctx context.Context, body PartsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsListPostResponse, error)

	// PartsUpdateWithBodyWithResponse request with any body
	PartsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsUpdateResponse, error)

	PartsUpdateWithResponse(ctx context.Context, body PartsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsUpdateResponse, error)

	// PreferencesGetWithResponse request
	PreferencesGetWithResponse(ctx context.Context, params *PreferencesGetParams, reqEditors ...RequestEditorFn) (*PreferencesGetResponse, error)

	// PreferencesGetPostWithBodyWithResponse request with any body
	PreferencesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreferencesGetPostResponse, error)

	PreferencesGetPostWithResponse(ctx context.Context, body PreferencesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PreferencesGetPostResponse, error)

	// PreferencesUpdateWithBodyWithResponse request with any body
	PreferencesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreferencesUpdateResponse, error)

	PreferencesUpdateWithResponse(ctx context.Context, body PreferencesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreferencesUpdateResponse, error)

	// CreateQuestionAnswerWithBodyWithResponse request with any body
	CreateQuestionAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQuestionAnswerResponse, error)

	CreateQuestionAnswerWithResponse(ctx context.Context, body CreateQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQuestionAnswerResponse, error)

	// DeleteQuestionAnswerWithBodyWithResponse request with any body
	DeleteQuestionAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteQuestionAnswerResponse, error)

	DeleteQuestionAnswerWithResponse(ctx context.Context, body DeleteQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteQuestionAnswerResponse, error)

	// GetQuestionAnswerWithResponse request
	GetQuestionAnswerWithResponse(ctx context.Context, params *GetQuestionAnswerParams, reqEditors ...RequestEditorFn) (*GetQuestionAnswerResponse, error)

	// GetQuestionAnswerPostWithBodyWithResponse request with any body
	GetQuestionAnswerPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetQuestionAnswerPostResponse, error)

	GetQuestionAnswerPostWithResponse(ctx context.Context, body GetQuestionAnswerPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetQuestionAnswerPostResponse, error)

	// ListQuestionAnswersWithResponse request
	ListQuestionAnswersWithResponse(ctx context.Context, params *ListQuestionAnswersParams, reqEditors ...RequestEditorFn) (*ListQuestionAnswersResponse, error)

	// ListQuestionAnswersPostWithBodyWithResponse request with any body
	ListQuestionAnswersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListQuestionAnswersPostResponse, error)

	ListQuestionAnswersPostWithResponse(ctx context.Context, body ListQuestionAnswersPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListQuestionAnswersPostResponse, error)

	// UpdateQuestionAnswerWithBodyWithResponse request with any body
	UpdateQuestionAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateQuestionAnswerResponse, error)

	UpdateQuestionAnswerWithResponse(ctx context.Context, body UpdateQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateQuestionAnswerResponse, error)

	// ReactionsListWithResponse request
	ReactionsListWithResponse(ctx context.Context, params *ReactionsListParams, reqEditors ...RequestEditorFn) (*ReactionsListResponse, error)

	// ReactionsListPostWithBodyWithResponse request with any body
	ReactionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionsListPostResponse, error)

	ReactionsListPostWithResponse(ctx context.Context, body ReactionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionsListPostResponse, error)

	// ReactionsUpdateWithBodyWithResponse request with any body
	ReactionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionsUpdateResponse, error)

	ReactionsUpdateWithResponse(ctx context.Context, body ReactionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionsUpdateResponse, error)

	// ChatCompletionsWithBodyWithResponse request with any body
	ChatCompletionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatCompletionsResponse, error)

	ChatCompletionsWithResponse(ctx context.Context, body ChatCompletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatCompletionsResponse, error)

	// GetReplyWithBodyWithResponse request with any body
	GetReplyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetReplyResponse, error)

	GetReplyWithResponse(ctx context.Context, body GetReplyJSONRequestBody, reqEditors ...RequestEditorFn) (*GetReplyResponse, error)

	// RecordTemplateGetWithResponse request
	RecordTemplateGetWithResponse(ctx context.Context, params *RecordTemplateGetParams, reqEditors ...RequestEditorFn) (*RecordTemplateGetResponse, error)

	// RecordTemplateGetPostWithBodyWithResponse request with any body
	RecordTemplateGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecordTemplateGetPostResponse, error)

	RecordTemplateGetPostWithResponse(ctx context.Context, body RecordTemplateGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RecordTemplateGetPostResponse, error)

	// RevOrgsCreateWithBodyWithResponse request with any body
	RevOrgsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsCreateResponse, error)

	RevOrgsCreateWithResponse(ctx context.Context, body RevOrgsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsCreateResponse, error)

	// RevOrgsDeleteWithBodyWithResponse request with any body
	RevOrgsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsDeleteResponse, error)

	RevOrgsDeleteWithResponse(ctx context.Context, body RevOrgsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsDeleteResponse, error)

	// RevOrgsGetWithResponse request
	RevOrgsGetWithResponse(ctx context.Context, params *RevOrgsGetParams, reqEditors ...RequestEditorFn) (*RevOrgsGetResponse, error)

	// RevOrgsGetPostWithBodyWithResponse request with any body
	RevOrgsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsGetPostResponse, error)

	RevOrgsGetPostWithResponse(ctx context.Context, body RevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsGetPostResponse, error)

	// RevOrgsListWithResponse request
	RevOrgsListWithResponse(ctx context.Context, params *RevOrgsListParams, reqEditors ...RequestEditorFn) (*RevOrgsListResponse, error)

	// RevOrgsListPostWithBodyWithResponse request with any body
	RevOrgsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsListPostResponse, error)

	RevOrgsListPostWithResponse(ctx context.Context, body RevOrgsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsListPostResponse, error)

	// RevOrgsUpdateWithBodyWithResponse request with any body
	RevOrgsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsUpdateResponse, error)

	RevOrgsUpdateWithResponse(ctx context.Context, body RevOrgsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsUpdateResponse, error)

	// RevUsersAssociationsAddWithBodyWithResponse request with any body
	RevUsersAssociationsAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersAssociationsAddResponse, error)

	RevUsersAssociationsAddWithResponse(ctx context.Context, body RevUsersAssociationsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersAssociationsAddResponse, error)

	// RevUsersAssociationsListWithResponse request
	RevUsersAssociationsListWithResponse(ctx context.Context, params *RevUsersAssociationsListParams, reqEditors ...RequestEditorFn) (*RevUsersAssociationsListResponse, error)

	// RevUsersAssociationsListPostWithBodyWithResponse request with any body
	RevUsersAssociationsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersAssociationsListPostResponse, error)

	RevUsersAssociationsListPostWithResponse(ctx context.Context, body RevUsersAssociationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersAssociationsListPostResponse, error)

	// RevUsersAssociationsRemoveWithBodyWithResponse request with any body
	RevUsersAssociationsRemoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersAssociationsRemoveResponse, error)

	RevUsersAssociationsRemoveWithResponse(ctx context.Context, body RevUsersAssociationsRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersAssociationsRemoveResponse, error)

	// RevUsersCreateWithBodyWithResponse request with any body
	RevUsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersCreateResponse, error)

	RevUsersCreateWithResponse(ctx context.Context, body RevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersCreateResponse, error)

	// RevUsersDeleteWithBodyWithResponse request with any body
	RevUsersDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersDeleteResponse, error)

	RevUsersDeleteWithResponse(ctx context.Context, body RevUsersDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersDeleteResponse, error)

	// DeleteRevUsersPersonalDataWithBodyWithResponse request with any body
	DeleteRevUsersPersonalDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRevUsersPersonalDataResponse, error)

	DeleteRevUsersPersonalDataWithResponse(ctx context.Context, body DeleteRevUsersPersonalDataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRevUsersPersonalDataResponse, error)

	// RevUsersGetWithResponse request
	RevUsersGetWithResponse(ctx context.Context, params *RevUsersGetParams, reqEditors ...RequestEditorFn) (*RevUsersGetResponse, error)

	// RevUsersGetPostWithBodyWithResponse request with any body
	RevUsersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersGetPostResponse, error)

	RevUsersGetPostWithResponse(ctx context.Context, body RevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersGetPostResponse, error)

	// LinkRevUserToRevOrgWithBodyWithResponse request with any body
	LinkRevUserToRevOrgWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRevUserToRevOrgResponse, error)

	LinkRevUserToRevOrgWithResponse(ctx context.Context, body LinkRevUserToRevOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRevUserToRevOrgResponse, error)

	// RevUsersListWithResponse request
	RevUsersListWithResponse(ctx context.Context, params *RevUsersListParams, reqEditors ...RequestEditorFn) (*RevUsersListResponse, error)

	// RevUsersListPostWithBodyWithResponse request with any body
	RevUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersListPostResponse, error)

	RevUsersListPostWithResponse(ctx context.Context, body RevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersListPostResponse, error)

	// RevUsersMergeWithBodyWithResponse request with any body
	RevUsersMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersMergeResponse, error)

	RevUsersMergeWithResponse(ctx context.Context, body RevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersMergeResponse, error)

	// GetRevUsersPersonalDataWithBodyWithResponse request with any body
	GetRevUsersPersonalDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetRevUsersPersonalDataResponse, error)

	GetRevUsersPersonalDataWithResponse(ctx context.Context, body GetRevUsersPersonalDataJSONRequestBody, reqEditors ...RequestEditorFn) (*GetRevUsersPersonalDataResponse, error)

	// RevUsersScanWithResponse request
	RevUsersScanWithResponse(ctx context.Context, params *RevUsersScanParams, reqEditors ...RequestEditorFn) (*RevUsersScanResponse, error)

	// RevUsersScanPostWithBodyWithResponse request with any body
	RevUsersScanPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersScanPostResponse, error)

	RevUsersScanPostWithResponse(ctx context.Context, body RevUsersScanPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersScanPostResponse, error)

	// UnlinkRevUserFromRevOrgWithBodyWithResponse request with any body
	UnlinkRevUserFromRevOrgWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkRevUserFromRevOrgResponse, error)

	UnlinkRevUserFromRevOrgWithResponse(ctx context.Context, body UnlinkRevUserFromRevOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkRevUserFromRevOrgResponse, error)

	// RevUsersUpdateWithBodyWithResponse request with any body
	RevUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersUpdateResponse, error)

	RevUsersUpdateWithResponse(ctx context.Context, body RevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersUpdateResponse, error)

	// RolesApplyWithBodyWithResponse request with any body
	RolesApplyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RolesApplyResponse, error)

	RolesApplyWithResponse(ctx context.Context, body RolesApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*RolesApplyResponse, error)

	// RolesCreateWithBodyWithResponse request with any body
	RolesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RolesCreateResponse, error)

	RolesCreateWithResponse(ctx context.Context, body RolesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RolesCreateResponse, error)

	// AggregatedSchemaGetWithResponse request
	AggregatedSchemaGetWithResponse(ctx context.Context, params *AggregatedSchemaGetParams, reqEditors ...RequestEditorFn) (*AggregatedSchemaGetResponse, error)

	// AggregatedSchemaGetPostWithBodyWithResponse request with any body
	AggregatedSchemaGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AggregatedSchemaGetPostResponse, error)

	AggregatedSchemaGetPostWithResponse(ctx context.Context, body AggregatedSchemaGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AggregatedSchemaGetPostResponse, error)

	// CustomSchemaFragmentsGetWithResponse request
	CustomSchemaFragmentsGetWithResponse(ctx context.Context, params *CustomSchemaFragmentsGetParams, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsGetResponse, error)

	// CustomSchemaFragmentsGetPostWithBodyWithResponse request with any body
	CustomSchemaFragmentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsGetPostResponse, error)

	CustomSchemaFragmentsGetPostWithResponse(ctx context.Context, body CustomSchemaFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsGetPostResponse, error)

	// CustomSchemaFragmentsListWithResponse request
	CustomSchemaFragmentsListWithResponse(ctx context.Context, params *CustomSchemaFragmentsListParams, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsListResponse, error)

	// CustomSchemaFragmentsListPostWithBodyWithResponse request with any body
	CustomSchemaFragmentsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsListPostResponse, error)

	CustomSchemaFragmentsListPostWithResponse(ctx context.Context, body CustomSchemaFragmentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsListPostResponse, error)

	// CustomSchemaFragmentsSetWithBodyWithResponse request with any body
	CustomSchemaFragmentsSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsSetResponse, error)

	CustomSchemaFragmentsSetWithResponse(ctx context.Context, body CustomSchemaFragmentsSetJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsSetResponse, error)

	// StockSchemaFragmentsGetWithResponse request
	StockSchemaFragmentsGetWithResponse(ctx context.Context, params *StockSchemaFragmentsGetParams, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsGetResponse, error)

	// StockSchemaFragmentsGetPostWithBodyWithResponse request with any body
	StockSchemaFragmentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsGetPostResponse, error)

	StockSchemaFragmentsGetPostWithResponse(ctx context.Context, body StockSchemaFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsGetPostResponse, error)

	// StockSchemaFragmentsListWithResponse request
	StockSchemaFragmentsListWithResponse(ctx context.Context, params *StockSchemaFragmentsListParams, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsListResponse, error)

	// StockSchemaFragmentsListPostWithBodyWithResponse request with any body
	StockSchemaFragmentsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsListPostResponse, error)

	StockSchemaFragmentsListPostWithResponse(ctx context.Context, body StockSchemaFragmentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsListPostResponse, error)

	// SubtypesListWithResponse request
	SubtypesListWithResponse(ctx context.Context, params *SubtypesListParams, reqEditors ...RequestEditorFn) (*SubtypesListResponse, error)

	// SubtypesListPostWithBodyWithResponse request with any body
	SubtypesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubtypesListPostResponse, error)

	SubtypesListPostWithResponse(ctx context.Context, body SubtypesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SubtypesListPostResponse, error)

	// SchemasSubtypePrepareUpdateGetWithBodyWithResponse request with any body
	SchemasSubtypePrepareUpdateGetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasSubtypePrepareUpdateGetResponse, error)

	SchemasSubtypePrepareUpdateGetWithResponse(ctx context.Context, body SchemasSubtypePrepareUpdateGetJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasSubtypePrepareUpdateGetResponse, error)

	// SearchCoreWithResponse request
	SearchCoreWithResponse(ctx context.Context, params *SearchCoreParams, reqEditors ...RequestEditorFn) (*SearchCoreResponse, error)

	// SearchCorePostWithBodyWithResponse request with any body
	SearchCorePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCorePostResponse, error)

	SearchCorePostWithResponse(ctx context.Context, body SearchCorePostJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCorePostResponse, error)

	// SearchHybridWithResponse request
	SearchHybridWithResponse(ctx context.Context, params *SearchHybridParams, reqEditors ...RequestEditorFn) (*SearchHybridResponse, error)

	// SearchHybridPostWithBodyWithResponse request with any body
	SearchHybridPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchHybridPostResponse, error)

	SearchHybridPostWithResponse(ctx context.Context, body SearchHybridPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchHybridPostResponse, error)

	// ServiceAccountsCreateWithBodyWithResponse request with any body
	ServiceAccountsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsCreateResponse, error)

	ServiceAccountsCreateWithResponse(ctx context.Context, body ServiceAccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsCreateResponse, error)

	// ServiceAccountsGetWithResponse request
	ServiceAccountsGetWithResponse(ctx context.Context, params *ServiceAccountsGetParams, reqEditors ...RequestEditorFn) (*ServiceAccountsGetResponse, error)

	// ServiceAccountsGetPostWithBodyWithResponse request with any body
	ServiceAccountsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsGetPostResponse, error)

	ServiceAccountsGetPostWithResponse(ctx context.Context, body ServiceAccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsGetPostResponse, error)

	// ServiceAccountsUpdateWithBodyWithResponse request with any body
	ServiceAccountsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsUpdateResponse, error)

	ServiceAccountsUpdateWithResponse(ctx context.Context, body ServiceAccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsUpdateResponse, error)

	// SlaTrackersGetWithResponse request
	SlaTrackersGetWithResponse(ctx context.Context, params *SlaTrackersGetParams, reqEditors ...RequestEditorFn) (*SlaTrackersGetResponse, error)

	// SlaTrackersGetPostWithBodyWithResponse request with any body
	SlaTrackersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersGetPostResponse, error)

	SlaTrackersGetPostWithResponse(ctx context.Context, body SlaTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersGetPostResponse, error)

	// SlaTrackersListWithResponse request
	SlaTrackersListWithResponse(ctx context.Context, params *SlaTrackersListParams, reqEditors ...RequestEditorFn) (*SlaTrackersListResponse, error)

	// SlaTrackersListPostWithBodyWithResponse request with any body
	SlaTrackersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersListPostResponse, error)

	SlaTrackersListPostWithResponse(ctx context.Context, body SlaTrackersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersListPostResponse, error)

	// SlaTrackersRemoveMetricWithBodyWithResponse request with any body
	SlaTrackersRemoveMetricWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersRemoveMetricResponse, error)

	SlaTrackersRemoveMetricWithResponse(ctx context.Context, body SlaTrackersRemoveMetricJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersRemoveMetricResponse, error)

	// SlasAssignWithBodyWithResponse request with any body
	SlasAssignWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasAssignResponse, error)

	SlasAssignWithResponse(ctx context.Context, body SlasAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasAssignResponse, error)

	// SlasCreateWithBodyWithResponse request with any body
	SlasCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasCreateResponse, error)

	SlasCreateWithResponse(ctx context.Context, body SlasCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasCreateResponse, error)

	// SlasGetWithResponse request
	SlasGetWithResponse(ctx context.Context, params *SlasGetParams, reqEditors ...RequestEditorFn) (*SlasGetResponse, error)

	// SlasGetPostWithBodyWithResponse request with any body
	SlasGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasGetPostResponse, error)

	SlasGetPostWithResponse(ctx context.Context, body SlasGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasGetPostResponse, error)

	// SlasListWithResponse request
	SlasListWithResponse(ctx context.Context, params *SlasListParams, reqEditors ...RequestEditorFn) (*SlasListResponse, error)

	// SlasListPostWithBodyWithResponse request with any body
	SlasListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasListPostResponse, error)

	SlasListPostWithResponse(ctx context.Context, body SlasListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasListPostResponse, error)

	// SlasTransitionWithBodyWithResponse request with any body
	SlasTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasTransitionResponse, error)

	SlasTransitionWithResponse(ctx context.Context, body SlasTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasTransitionResponse, error)

	// SlasUpdateWithBodyWithResponse request with any body
	SlasUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasUpdateResponse, error)

	SlasUpdateWithResponse(ctx context.Context, body SlasUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasUpdateResponse, error)

	// SnapInsResourcesWithResponse request
	SnapInsResourcesWithResponse(ctx context.Context, params *SnapInsResourcesParams, reqEditors ...RequestEditorFn) (*SnapInsResourcesResponse, error)

	// SnapInsResourcesPostWithBodyWithResponse request with any body
	SnapInsResourcesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapInsResourcesPostResponse, error)

	SnapInsResourcesPostWithResponse(ctx context.Context, body SnapInsResourcesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapInsResourcesPostResponse, error)

	// SnapInsUpdateWithBodyWithResponse request with any body
	SnapInsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapInsUpdateResponse, error)

	SnapInsUpdateWithResponse(ctx context.Context, body SnapInsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapInsUpdateResponse, error)

	// SnapKitActionExecuteDeferredWithBodyWithResponse request with any body
	SnapKitActionExecuteDeferredWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapKitActionExecuteDeferredResponse, error)

	SnapKitActionExecuteDeferredWithResponse(ctx context.Context, body SnapKitActionExecuteDeferredJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapKitActionExecuteDeferredResponse, error)

	// SnapWidgetsCreateWithBodyWithResponse request with any body
	SnapWidgetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapWidgetsCreateResponse, error)

	SnapWidgetsCreateWithResponse(ctx context.Context, body SnapWidgetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapWidgetsCreateResponse, error)

	// StageDiagramsCreateWithBodyWithResponse request with any body
	StageDiagramsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageDiagramsCreateResponse, error)

	StageDiagramsCreateWithResponse(ctx context.Context, body StageDiagramsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*StageDiagramsCreateResponse, error)

	// StageDiagramsGetWithResponse request
	StageDiagramsGetWithResponse(ctx context.Context, params *StageDiagramsGetParams, reqEditors ...RequestEditorFn) (*StageDiagramsGetResponse, error)

	// StageDiagramsGetPostWithBodyWithResponse request with any body
	StageDiagramsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageDiagramsGetPostResponse, error)

	StageDiagramsGetPostWithResponse(ctx context.Context, body StageDiagramsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*StageDiagramsGetPostResponse, error)

	// StageDiagramsListWithResponse request
	StageDiagramsListWithResponse(ctx context.Context, params *StageDiagramsListParams, reqEditors ...RequestEditorFn) (*StageDiagramsListResponse, error)

	// StageDiagramsListPostWithBodyWithResponse request with any body
	StageDiagramsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageDiagramsListPostResponse, error)

	StageDiagramsListPostWithResponse(ctx context.Context, body StageDiagramsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*StageDiagramsListPostResponse, error)

	// StageDiagramsUpdateWithBodyWithResponse request with any body
	StageDiagramsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageDiagramsUpdateResponse, error)

	StageDiagramsUpdateWithResponse(ctx context.Context, body StageDiagramsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StageDiagramsUpdateResponse, error)

	// CustomStagesCreateWithBodyWithResponse request with any body
	CustomStagesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStagesCreateResponse, error)

	CustomStagesCreateWithResponse(ctx context.Context, body CustomStagesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStagesCreateResponse, error)

	// CustomStagesGetWithResponse request
	CustomStagesGetWithResponse(ctx context.Context, params *CustomStagesGetParams, reqEditors ...RequestEditorFn) (*CustomStagesGetResponse, error)

	// CustomStagesGetPostWithBodyWithResponse request with any body
	CustomStagesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStagesGetPostResponse, error)

	CustomStagesGetPostWithResponse(ctx context.Context, body CustomStagesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStagesGetPostResponse, error)

	// CustomStagesListWithResponse request
	CustomStagesListWithResponse(ctx context.Context, params *CustomStagesListParams, reqEditors ...RequestEditorFn) (*CustomStagesListResponse, error)

	// CustomStagesListPostWithBodyWithResponse request with any body
	CustomStagesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStagesListPostResponse, error)

	CustomStagesListPostWithResponse(ctx context.Context, body CustomStagesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStagesListPostResponse, error)

	// CustomStagesUpdateWithBodyWithResponse request with any body
	CustomStagesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStagesUpdateResponse, error)

	CustomStagesUpdateWithResponse(ctx context.Context, body CustomStagesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStagesUpdateResponse, error)

	// CustomStatesCreateWithBodyWithResponse request with any body
	CustomStatesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStatesCreateResponse, error)

	CustomStatesCreateWithResponse(ctx context.Context, body CustomStatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStatesCreateResponse, error)

	// CustomStatesGetWithResponse request
	CustomStatesGetWithResponse(ctx context.Context, params *CustomStatesGetParams, reqEditors ...RequestEditorFn) (*CustomStatesGetResponse, error)

	// CustomStatesGetPostWithBodyWithResponse request with any body
	CustomStatesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStatesGetPostResponse, error)

	CustomStatesGetPostWithResponse(ctx context.Context, body CustomStatesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStatesGetPostResponse, error)

	// CustomStatesListWithResponse request
	CustomStatesListWithResponse(ctx context.Context, params *CustomStatesListParams, reqEditors ...RequestEditorFn) (*CustomStatesListResponse, error)

	// CustomStatesListPostWithBodyWithResponse request with any body
	CustomStatesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStatesListPostResponse, error)

	CustomStatesListPostWithResponse(ctx context.Context, body CustomStatesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStatesListPostResponse, error)

	// CustomStatesUpdateWithBodyWithResponse request with any body
	CustomStatesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStatesUpdateResponse, error)

	CustomStatesUpdateWithResponse(ctx context.Context, body CustomStatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStatesUpdateResponse, error)

	// SubscribersListWithResponse request
	SubscribersListWithResponse(ctx context.Context, params *SubscribersListParams, reqEditors ...RequestEditorFn) (*SubscribersListResponse, error)

	// SubscribersListPostWithBodyWithResponse request with any body
	SubscribersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscribersListPostResponse, error)

	SubscribersListPostWithResponse(ctx context.Context, body SubscribersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscribersListPostResponse, error)

	// SubscribersUpdateWithBodyWithResponse request with any body
	SubscribersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscribersUpdateResponse, error)

	SubscribersUpdateWithResponse(ctx context.Context, body SubscribersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscribersUpdateResponse, error)

	// SurveysCreateWithBodyWithResponse request with any body
	SurveysCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysCreateResponse, error)

	SurveysCreateWithResponse(ctx context.Context, body SurveysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysCreateResponse, error)

	// SurveysDeleteWithBodyWithResponse request with any body
	SurveysDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysDeleteResponse, error)

	SurveysDeleteWithResponse(ctx context.Context, body SurveysDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysDeleteResponse, error)

	// SurveysGetWithResponse request
	SurveysGetWithResponse(ctx context.Context, params *SurveysGetParams, reqEditors ...RequestEditorFn) (*SurveysGetResponse, error)

	// SurveysGetPostWithBodyWithResponse request with any body
	SurveysGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysGetPostResponse, error)

	SurveysGetPostWithResponse(ctx context.Context, body SurveysGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysGetPostResponse, error)

	// SurveysListWithResponse request
	SurveysListWithResponse(ctx context.Context, params *SurveysListParams, reqEditors ...RequestEditorFn) (*SurveysListResponse, error)

	// SurveysListPostWithBodyWithResponse request with any body
	SurveysListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysListPostResponse, error)

	SurveysListPostWithResponse(ctx context.Context, body SurveysListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysListPostResponse, error)

	// SurveysResponsesListWithResponse request
	SurveysResponsesListWithResponse(ctx context.Context, params *SurveysResponsesListParams, reqEditors ...RequestEditorFn) (*SurveysResponsesListResponse, error)

	// SurveysResponsesListPostWithBodyWithResponse request with any body
	SurveysResponsesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysResponsesListPostResponse, error)

	SurveysResponsesListPostWithResponse(ctx context.Context, body SurveysResponsesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysResponsesListPostResponse, error)

	// SurveysResponsesUpdateWithBodyWithResponse request with any body
	SurveysResponsesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysResponsesUpdateResponse, error)

	SurveysResponsesUpdateWithResponse(ctx context.Context, body SurveysResponsesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysResponsesUpdateResponse, error)

	// SurveysSendWithBodyWithResponse request with any body
	SurveysSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysSendResponse, error)

	SurveysSendWithResponse(ctx context.Context, body SurveysSendJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysSendResponse, error)

	// SurveysSubmitWithBodyWithResponse request with any body
	SurveysSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysSubmitResponse, error)

	SurveysSubmitWithResponse(ctx context.Context, body SurveysSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysSubmitResponse, error)

	// SurveysUpdateWithBodyWithResponse request with any body
	SurveysUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysUpdateResponse, error)

	SurveysUpdateWithResponse(ctx context.Context, body SurveysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysUpdateResponse, error)

	// SysUsersListWithResponse request
	SysUsersListWithResponse(ctx context.Context, params *SysUsersListParams, reqEditors ...RequestEditorFn) (*SysUsersListResponse, error)

	// SysUsersListPostWithBodyWithResponse request with any body
	SysUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SysUsersListPostResponse, error)

	SysUsersListPostWithResponse(ctx context.Context, body SysUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SysUsersListPostResponse, error)

	// SysUsersUpdateWithBodyWithResponse request with any body
	SysUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SysUsersUpdateResponse, error)

	SysUsersUpdateWithResponse(ctx context.Context, body SysUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SysUsersUpdateResponse, error)

	// TagsCreateWithBodyWithResponse request with any body
	TagsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsCreateResponse, error)

	TagsCreateWithResponse(ctx context.Context, body TagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsCreateResponse, error)

	// TagsDeleteWithBodyWithResponse request with any body
	TagsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsDeleteResponse, error)

	TagsDeleteWithResponse(ctx context.Context, body TagsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsDeleteResponse, error)

	// TagsGetWithResponse request
	TagsGetWithResponse(ctx context.Context, params *TagsGetParams, reqEditors ...RequestEditorFn) (*TagsGetResponse, error)

	// TagsGetPostWithBodyWithResponse request with any body
	TagsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsGetPostResponse, error)

	TagsGetPostWithResponse(ctx context.Context, body TagsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsGetPostResponse, error)

	// TagsListWithResponse request
	TagsListWithResponse(ctx context.Context, params *TagsListParams, reqEditors ...RequestEditorFn) (*TagsListResponse, error)

	// TagsListPostWithBodyWithResponse request with any body
	TagsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsListPostResponse, error)

	TagsListPostWithResponse(ctx context.Context, body TagsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsListPostResponse, error)

	// TagsUpdateWithBodyWithResponse request with any body
	TagsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsUpdateResponse, error)

	TagsUpdateWithResponse(ctx context.Context, body TagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsUpdateResponse, error)

	// TimelineEntriesCreateWithBodyWithResponse request with any body
	TimelineEntriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesCreateResponse, error)

	TimelineEntriesCreateWithResponse(ctx context.Context, body TimelineEntriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesCreateResponse, error)

	// TimelineEntriesDeleteWithBodyWithResponse request with any body
	TimelineEntriesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesDeleteResponse, error)

	TimelineEntriesDeleteWithResponse(ctx context.Context, body TimelineEntriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesDeleteResponse, error)

	// TimelineEntriesGetWithResponse request
	TimelineEntriesGetWithResponse(ctx context.Context, params *TimelineEntriesGetParams, reqEditors ...RequestEditorFn) (*TimelineEntriesGetResponse, error)

	// TimelineEntriesGetPostWithBodyWithResponse request with any body
	TimelineEntriesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesGetPostResponse, error)

	TimelineEntriesGetPostWithResponse(ctx context.Context, body TimelineEntriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesGetPostResponse, error)

	// TimelineEntriesListWithResponse request
	TimelineEntriesListWithResponse(ctx context.Context, params *TimelineEntriesListParams, reqEditors ...RequestEditorFn) (*TimelineEntriesListResponse, error)

	// TimelineEntriesListPostWithBodyWithResponse request with any body
	TimelineEntriesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesListPostResponse, error)

	TimelineEntriesListPostWithResponse(ctx context.Context, body TimelineEntriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesListPostResponse, error)

	// TimelineEntriesUpdateWithBodyWithResponse request with any body
	TimelineEntriesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesUpdateResponse, error)

	TimelineEntriesUpdateWithResponse(ctx context.Context, body TimelineEntriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesUpdateResponse, error)

	// TrackEventsPublishWithBodyWithResponse request with any body
	TrackEventsPublishWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TrackEventsPublishResponse, error)

	TrackEventsPublishWithResponse(ctx context.Context, body TrackEventsPublishJSONRequestBody, reqEditors ...RequestEditorFn) (*TrackEventsPublishResponse, error)

	// UomsCountWithResponse request
	UomsCountWithResponse(ctx context.Context, params *UomsCountParams, reqEditors ...RequestEditorFn) (*UomsCountResponse, error)

	// UomsCountPostWithBodyWithResponse request with any body
	UomsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsCountPostResponse, error)

	UomsCountPostWithResponse(ctx context.Context, body UomsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsCountPostResponse, error)

	// UomsCreateWithBodyWithResponse request with any body
	UomsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsCreateResponse, error)

	UomsCreateWithResponse(ctx context.Context, body UomsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsCreateResponse, error)

	// UomsDeleteWithBodyWithResponse request with any body
	UomsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsDeleteResponse, error)

	UomsDeleteWithResponse(ctx context.Context, body UomsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsDeleteResponse, error)

	// UomsGetWithResponse request
	UomsGetWithResponse(ctx context.Context, params *UomsGetParams, reqEditors ...RequestEditorFn) (*UomsGetResponse, error)

	// UomsGetPostWithBodyWithResponse request with any body
	UomsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsGetPostResponse, error)

	UomsGetPostWithResponse(ctx context.Context, body UomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsGetPostResponse, error)

	// UomsListWithResponse request
	UomsListWithResponse(ctx context.Context, params *UomsListParams, reqEditors ...RequestEditorFn) (*UomsListResponse, error)

	// UomsListPostWithBodyWithResponse request with any body
	UomsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsListPostResponse, error)

	UomsListPostWithResponse(ctx context.Context, body UomsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsListPostResponse, error)

	// UomsUpdateWithBodyWithResponse request with any body
	UomsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsUpdateResponse, error)

	UomsUpdateWithResponse(ctx context.Context, body UomsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsUpdateResponse, error)

	// WebCrawlerJobsControlWithBodyWithResponse request with any body
	WebCrawlerJobsControlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebCrawlerJobsControlResponse, error)

	WebCrawlerJobsControlWithResponse(ctx context.Context, body WebCrawlerJobsControlJSONRequestBody, reqEditors ...RequestEditorFn) (*WebCrawlerJobsControlResponse, error)

	// CreateWebCrawlerJobWithBodyWithResponse request with any body
	CreateWebCrawlerJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebCrawlerJobResponse, error)

	CreateWebCrawlerJobWithResponse(ctx context.Context, body CreateWebCrawlerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebCrawlerJobResponse, error)

	// GetWebCrawlerJobWithResponse request
	GetWebCrawlerJobWithResponse(ctx context.Context, params *GetWebCrawlerJobParams, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobResponse, error)

	// GetWebCrawlerJobPostWithBodyWithResponse request with any body
	GetWebCrawlerJobPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobPostResponse, error)

	GetWebCrawlerJobPostWithResponse(ctx context.Context, body GetWebCrawlerJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobPostResponse, error)

	// ListWebCrawlerJobsWithResponse request
	ListWebCrawlerJobsWithResponse(ctx context.Context, params *ListWebCrawlerJobsParams, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsResponse, error)

	// ListWebCrawlerJobsPostWithBodyWithResponse request with any body
	ListWebCrawlerJobsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsPostResponse, error)

	ListWebCrawlerJobsPostWithResponse(ctx context.Context, body ListWebCrawlerJobsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsPostResponse, error)

	// WebhooksCreateWithBodyWithResponse request with any body
	WebhooksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error)

	WebhooksCreateWithResponse(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error)

	// WebhooksDeleteWithBodyWithResponse request with any body
	WebhooksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error)

	WebhooksDeleteWithResponse(ctx context.Context, body WebhooksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error)

	// WebhooksEventWithBodyWithResponse request with any body
	WebhooksEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksEventResponse, error)

	WebhooksEventWithResponse(ctx context.Context, body WebhooksEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksEventResponse, error)

	// WebhooksFetchWithBodyWithResponse request with any body
	WebhooksFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksFetchResponse, error)

	WebhooksFetchWithResponse(ctx context.Context, body WebhooksFetchJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksFetchResponse, error)

	// WebhooksGetWithResponse request
	WebhooksGetWithResponse(ctx context.Context, params *WebhooksGetParams, reqEditors ...RequestEditorFn) (*WebhooksGetResponse, error)

	// WebhooksGetPostWithBodyWithResponse request with any body
	WebhooksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksGetPostResponse, error)

	WebhooksGetPostWithResponse(ctx context.Context, body WebhooksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksGetPostResponse, error)

	// WebhooksListWithResponse request
	WebhooksListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WebhooksListResponse, error)

	// WebhooksListPostWithBodyWithResponse request with any body
	WebhooksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksListPostResponse, error)

	WebhooksListPostWithResponse(ctx context.Context, body WebhooksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksListPostResponse, error)

	// WebhooksUpdateWithBodyWithResponse request with any body
	WebhooksUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error)

	WebhooksUpdateWithResponse(ctx context.Context, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error)

	// WidgetsGetWithResponse request
	WidgetsGetWithResponse(ctx context.Context, params *WidgetsGetParams, reqEditors ...RequestEditorFn) (*WidgetsGetResponse, error)

	// WidgetsGetPostWithBodyWithResponse request with any body
	WidgetsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WidgetsGetPostResponse, error)

	WidgetsGetPostWithResponse(ctx context.Context, body WidgetsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WidgetsGetPostResponse, error)

	// WorksCreateWithBodyWithResponse request with any body
	WorksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksCreateResponse, error)

	WorksCreateWithResponse(ctx context.Context, body WorksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksCreateResponse, error)

	// WorksDeleteWithBodyWithResponse request with any body
	WorksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksDeleteResponse, error)

	WorksDeleteWithResponse(ctx context.Context, body WorksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksDeleteResponse, error)

	// WorksExportWithResponse request
	WorksExportWithResponse(ctx context.Context, params *WorksExportParams, reqEditors ...RequestEditorFn) (*WorksExportResponse, error)

	// WorksExportPostWithBodyWithResponse request with any body
	WorksExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksExportPostResponse, error)

	WorksExportPostWithResponse(ctx context.Context, body WorksExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksExportPostResponse, error)

	// WorksGetWithResponse request
	WorksGetWithResponse(ctx context.Context, params *WorksGetParams, reqEditors ...RequestEditorFn) (*WorksGetResponse, error)

	// WorksGetPostWithBodyWithResponse request with any body
	WorksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksGetPostResponse, error)

	WorksGetPostWithResponse(ctx context.Context, body WorksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksGetPostResponse, error)

	// WorksListWithResponse request
	WorksListWithResponse(ctx context.Context, params *WorksListParams, reqEditors ...RequestEditorFn) (*WorksListResponse, error)

	// WorksListPostWithBodyWithResponse request with any body
	WorksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksListPostResponse, error)

	WorksListPostWithResponse(ctx context.Context, body WorksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksListPostResponse, error)

	// WorksUpdateWithBodyWithResponse request with any body
	WorksUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksUpdateResponse, error)

	WorksUpdateWithResponse(ctx context.Context, body WorksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksUpdateResponse, error)
}

type AccountsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccountsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsExportPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsExportPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsExportPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsMergeResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AccountsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AiAgentEventsExecuteAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AiAgentEventsExecuteAsyncResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AiAgentEventsExecuteAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AiAgentEventsExecuteAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AirdropSyncUnitsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AirdropSyncUnitsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AirdropSyncUnitsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AirdropSyncUnitsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AirdropSyncUnitsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AirdropSyncUnitsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AirdropSyncUnitsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AirdropSyncUnitsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AirdropSyncUnitsHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AirdropSyncUnitsHistoryResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AirdropSyncUnitsHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AirdropSyncUnitsHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AirdropSyncUnitsHistoryPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AirdropSyncUnitsHistoryResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AirdropSyncUnitsHistoryPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AirdropSyncUnitsHistoryPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArticlesCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArticlesCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArticlesCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArticlesCountPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArticlesCountPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArticlesCountPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ArticlesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArticlePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetArticlePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArticlePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListArticlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListArticlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListArticlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListArticlesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListArticlesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListArticlesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateArticleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArticlesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateArticleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateArticleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsLocateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsLocateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsLocateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsLocateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsLocatePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsLocateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsLocatePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsLocatePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsPrepareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsPrepareResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsPrepareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsPrepareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsHardDeleteVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsHardDeleteVersionResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsHardDeleteVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsHardDeleteVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtifactsVersionsPrepareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtifactsVersionsPrepareResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ArtifactsVersionsPrepareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtifactsVersionsPrepareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AtomsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AtomsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AtomsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AtomsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AtomsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AtomsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AtomsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AtomsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExportAuditLogsResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ExportAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthTokensCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensInfoResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensInfoPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensInfoResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensInfoPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensInfoPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensSelfDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensSelfDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensSelfDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthTokensUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokensUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AuthTokensUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthTokensUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrandsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BrandsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r BrandsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrandsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrandsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *BrandsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r BrandsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrandsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrandsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r BrandsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrandsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrandsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r BrandsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrandsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrandsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r BrandsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrandsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrandsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r BrandsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrandsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrandsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r BrandsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrandsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ChatsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ChatsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ChatsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ChatsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeChangesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeChangesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CodeChangesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeChangesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommandsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CommandsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommandsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContentTemplateCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ContentTemplateCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ContentTemplateCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContentTemplateCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContentTemplateGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentTemplateGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ContentTemplateGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContentTemplateGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContentTemplateGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentTemplateGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ContentTemplateGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContentTemplateGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContentTemplateListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentTemplateListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ContentTemplateListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContentTemplateListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContentTemplateListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentTemplateListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ContentTemplateListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContentTemplateListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsExportPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsExportPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsExportPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConversationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ConversationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConversationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomObjectsCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomObjectsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomObjectsCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomObjectsCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomObjectsCountPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomObjectsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomObjectsCountPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomObjectsCountPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomObjectsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CustomObjectsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomObjectsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomObjectsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomObjectsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomObjectsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomObjectsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomObjectsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomObjectsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomObjectsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomObjectsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomObjectsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomObjectsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomObjectsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomObjectsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomObjectsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomObjectsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomObjectsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomObjectsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomObjectsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomObjectsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomObjectsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomObjectsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomObjectsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomObjectsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomObjectsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomObjectsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomObjectsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DevOrgAuthConnectionsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgAuthConnectionsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgAuthConnectionsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgAuthConnectionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgAuthConnectionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsToggleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsToggleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsToggleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgAuthConnectionsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DevOrgAuthConnectionsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgAuthConnectionsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgAuthConnectionsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevOrgsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevOrgsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevOrgsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevOrgsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersActivateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersActivateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersActivateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersActivateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DevUsersCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersDeactivateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersDeactivateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersDeactivateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersDeactivateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersIdentitiesLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersIdentitiesLinkResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersIdentitiesLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersIdentitiesLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersIdentitiesUnlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersIdentitiesUnlinkResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersIdentitiesUnlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersIdentitiesUnlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersMergeResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersSelfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersSelfResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersSelfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersSelfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersSelfPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersSelfResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersSelfPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersSelfPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersSelfUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersSelfUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersSelfUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevUsersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevUsersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DevUsersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevUsersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesCountPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesCountPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesCountPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DirectoriesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectoriesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoriesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DirectoriesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectoriesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EngagementsCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsCountPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EngagementsCountPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsCountPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EngagementsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EngagementsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EngagementsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EngagementsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EngagementsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EngagementsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EngagementsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EngagementsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventSourcesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventSourceGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EventSourcesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventSourcesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventSourcesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventSourceGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EventSourcesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventSourcesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventSourcesScheduleEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventSourcesScheduleEventResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EventSourcesScheduleEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventSourcesScheduleEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventSourcesDeleteScheduledEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EventSourcesDeleteScheduledEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventSourcesDeleteScheduledEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GroupsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupMembersAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMembersAddResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupMembersAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupMembersAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupMembersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMembersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupMembersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupMembersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupMembersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMembersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupMembersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupMembersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupMembersRemoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMembersRemoveResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupMembersRemoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupMembersRemoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GroupsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncidentsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IncidentsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncidentsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncidentsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncidentsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncidentsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncidentsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncidentsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncidentsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncidentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncidentsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncidentsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncidentsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncidentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncidentsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncidentsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncidentsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncidentsGroupResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncidentsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncidentsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncidentsGroupPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncidentsGroupResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncidentsGroupPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncidentsGroupPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncidentsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncidentsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncidentsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncidentsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncidentsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncidentsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncidentsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncidentsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncidentsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncidentsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncidentsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncidentsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type KeyringsCreateCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r KeyringsCreateCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r KeyringsCreateCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type KeyringsCreateCallbackPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r KeyringsCreateCallbackPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r KeyringsCreateCallbackPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomLinkTypeCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CustomLinkTypeCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomLinkTypeCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomLinkTypeCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomLinkTypeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomLinkTypeGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomLinkTypeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomLinkTypeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomLinkTypeGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomLinkTypeGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomLinkTypeGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomLinkTypeGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomLinkTypeListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomLinkTypeListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomLinkTypeListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomLinkTypeListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomLinkTypeListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomLinkTypeListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomLinkTypeListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomLinkTypeListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomLinkTypeUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomLinkTypeUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomLinkTypeUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomLinkTypeUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LinksCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinksReplaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LinksReplaceResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinksReplaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinksReplaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsCountPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsCountPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsCountPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MeetingsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeetingsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MeetingsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricActionExecuteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricActionExecuteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricActionExecuteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricActionExecuteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MetricDefinitionsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *MetricDefinitionsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricDefinitionsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricDefinitionsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricDefinitionsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricDefinitionsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricTrackersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricTrackersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricTrackersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricTrackersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricTrackersGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricTrackersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricTrackersGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricTrackersGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsDevrevIngestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MetricsDevrevIngestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsDevrevIngestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsSendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationsSendResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r NotificationsSendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsSendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgScheduleFragmentsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OrgScheduleFragmentsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgScheduleFragmentsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgScheduleFragmentsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgScheduleFragmentsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgScheduleFragmentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgScheduleFragmentsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgScheduleFragmentsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgScheduleFragmentsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgScheduleFragmentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgScheduleFragmentsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgScheduleFragmentsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgScheduleFragmentsTransitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgScheduleFragmentsTransitionResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgScheduleFragmentsTransitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgScheduleFragmentsTransitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OrgSchedulesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesEvaluateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesEvaluateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesEvaluateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesEvaluateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesEvaluatePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesEvaluateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesEvaluatePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesEvaluatePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesSetFutureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesSetFutureResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesSetFutureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesSetFutureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesTransitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSchedulesTransitionResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesTransitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesTransitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgSchedulesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OrgSchedulesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r OrgSchedulesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgSchedulesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PartsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PartsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreferencesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreferencesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PreferencesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreferencesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreferencesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreferencesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PreferencesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreferencesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreferencesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreferencesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PreferencesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreferencesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateQuestionAnswerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *QuestionAnswersCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateQuestionAnswerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateQuestionAnswerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteQuestionAnswerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteQuestionAnswerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQuestionAnswerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQuestionAnswerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuestionAnswersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetQuestionAnswerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQuestionAnswerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQuestionAnswerPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuestionAnswersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetQuestionAnswerPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQuestionAnswerPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQuestionAnswersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuestionAnswersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListQuestionAnswersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQuestionAnswersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQuestionAnswersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuestionAnswersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListQuestionAnswersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQuestionAnswersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateQuestionAnswerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuestionAnswersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateQuestionAnswerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateQuestionAnswerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReactionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ReactionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReactionsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ReactionsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReactionsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ReactionsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatCompletionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatCompletionsResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ChatCompletionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatCompletionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetReplyResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetReplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecordTemplateGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordTemplateGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RecordTemplateGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecordTemplateGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecordTemplateGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordTemplateGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RecordTemplateGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecordTemplateGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RevOrgsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevOrgsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevOrgsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevOrgsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevOrgsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersAssociationsAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RevUsersAssociationsAddResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersAssociationsAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersAssociationsAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersAssociationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersAssociationsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersAssociationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersAssociationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersAssociationsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersAssociationsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersAssociationsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersAssociationsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersAssociationsRemoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *RevUsersAssociationsRemoveResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersAssociationsRemoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersAssociationsRemoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RevUsersCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRevUsersPersonalDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteRevUsersPersonalDataResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteRevUsersPersonalDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRevUsersPersonalDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkRevUserToRevOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkRevUserToRevOrgResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r LinkRevUserToRevOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkRevUserToRevOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersMergeResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRevUsersPersonalDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRevUsersPersonalDataResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetRevUsersPersonalDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRevUsersPersonalDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersScanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersScanResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersScanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersScanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersScanPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersScanResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersScanPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersScanPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkRevUserFromRevOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnlinkRevUserFromRevOrgResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnlinkRevUserFromRevOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkRevUserFromRevOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevUsersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevUsersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RevUsersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevUsersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RolesApplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RolesApplyResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RolesApplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RolesApplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RolesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RolesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r RolesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RolesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AggregatedSchemaGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AggregatedSchemaGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AggregatedSchemaGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AggregatedSchemaGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AggregatedSchemaGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AggregatedSchemaGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AggregatedSchemaGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AggregatedSchemaGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomSchemaFragmentsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomSchemaFragmentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomSchemaFragmentsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomSchemaFragmentsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomSchemaFragmentsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomSchemaFragmentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomSchemaFragmentsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomSchemaFragmentsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomSchemaFragmentsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomSchemaFragmentsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomSchemaFragmentsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomSchemaFragmentsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomSchemaFragmentsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomSchemaFragmentsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomSchemaFragmentsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomSchemaFragmentsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomSchemaFragmentsSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CustomSchemaFragmentsSetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomSchemaFragmentsSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomSchemaFragmentsSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StockSchemaFragmentsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StockSchemaFragmentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StockSchemaFragmentsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StockSchemaFragmentsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StockSchemaFragmentsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StockSchemaFragmentsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StockSchemaFragmentsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StockSchemaFragmentsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StockSchemaFragmentsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StockSchemaFragmentsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StockSchemaFragmentsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StockSchemaFragmentsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StockSchemaFragmentsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StockSchemaFragmentsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StockSchemaFragmentsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StockSchemaFragmentsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubtypesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubtypesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SubtypesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubtypesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubtypesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubtypesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SubtypesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubtypesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasSubtypePrepareUpdateGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemasSubtypePrepareUpdateGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SchemasSubtypePrepareUpdateGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasSubtypePrepareUpdateGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchCoreResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SearchCoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCorePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchCoreResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SearchCorePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCorePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchHybridResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchHybridResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SearchHybridResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchHybridResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchHybridPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchHybridResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SearchHybridPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchHybridPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServiceAccountsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ServiceAccountsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServiceAccountsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServiceAccountsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ServiceAccountsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServiceAccountsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServiceAccountsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ServiceAccountsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServiceAccountsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServiceAccountsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ServiceAccountsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServiceAccountsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaTrackersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlaTrackersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlaTrackersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaTrackersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaTrackersGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlaTrackersGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlaTrackersGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaTrackersGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaTrackersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlaTrackersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlaTrackersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaTrackersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaTrackersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlaTrackersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlaTrackersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaTrackersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaTrackersRemoveMetricResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlaTrackersRemoveMetricResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlaTrackersRemoveMetricResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaTrackersRemoveMetricResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasAssignResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasAssignResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasAssignResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasAssignResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SlasCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasTransitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlasTransitionResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasTransitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasTransitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlasUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SlasUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SlasUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlasUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapInsResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapInsResourcesResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SnapInsResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapInsResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapInsResourcesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapInsResourcesResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SnapInsResourcesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapInsResourcesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapInsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapInsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SnapInsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapInsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapKitActionExecuteDeferredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapKitActionExecuteDeferredResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SnapKitActionExecuteDeferredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapKitActionExecuteDeferredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapWidgetsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SnapWidgetsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SnapWidgetsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapWidgetsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageDiagramsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StageDiagramsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StageDiagramsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageDiagramsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageDiagramsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StageDiagramsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StageDiagramsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageDiagramsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageDiagramsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StageDiagramsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StageDiagramsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageDiagramsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageDiagramsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StageDiagramsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StageDiagramsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageDiagramsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageDiagramsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StageDiagramsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StageDiagramsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageDiagramsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageDiagramsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StageDiagramsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r StageDiagramsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageDiagramsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStagesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CustomStagesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStagesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStagesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStagesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStagesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStagesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStagesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStagesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStagesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStagesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStagesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStagesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStagesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStagesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStagesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStagesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStagesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStagesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStagesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStagesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStagesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStagesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStagesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStatesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CustomStatesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStatesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStatesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStatesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStatesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStatesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStatesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStatesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStatesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStatesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStatesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStatesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStatesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStatesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStatesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStatesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStatesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStatesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStatesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomStatesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomStatesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CustomStatesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomStatesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubscribersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SubscribersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubscribersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SubscribersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubscribersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SubscribersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SurveysCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysResponsesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysResponsesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysResponsesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysResponsesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysResponsesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysResponsesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysResponsesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysResponsesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysResponsesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SurveysResponsesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysResponsesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysResponsesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysSendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysSendResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysSendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysSendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SurveysSubmitResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SurveysUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SurveysUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SurveysUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SurveysUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SysUsersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SysUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SysUsersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SysUsersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SysUsersListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SysUsersListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SysUsersListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SysUsersListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SysUsersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SysUsersUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SysUsersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SysUsersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TagsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TagsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TimelineEntriesCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelineEntriesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimelineEntriesUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TimelineEntriesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelineEntriesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackEventsPublishResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrackEventsPublishResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r TrackEventsPublishResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackEventsPublishResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UomsCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UomsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UomsCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UomsCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UomsCountPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UomsCountResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UomsCountPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UomsCountPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UomsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UomsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UomsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UomsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UomsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UomsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UomsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UomsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UomsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UomsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UomsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UomsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UomsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UomsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UomsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UomsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UomsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UomsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UomsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UomsListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UomsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UomsListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UomsListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UomsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UomsUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UomsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UomsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebCrawlerJobsControlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsControlResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebCrawlerJobsControlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebCrawlerJobsControlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebCrawlerJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebCrawlerJobsCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateWebCrawlerJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebCrawlerJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebCrawlerJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetWebCrawlerJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebCrawlerJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebCrawlerJobPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetWebCrawlerJobPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebCrawlerJobPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebCrawlerJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListWebCrawlerJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebCrawlerJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebCrawlerJobsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebCrawlerJobsListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListWebCrawlerJobsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebCrawlerJobsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebhooksCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookEventResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksFetchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksFetchResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksFetchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksFetchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhooksUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WebhooksUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WidgetsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WidgetsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WidgetsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WidgetsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WidgetsGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WidgetsGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WidgetsGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WidgetsGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WorksCreateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksDeleteResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksExportPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksExportResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksExportPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksExportPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksGetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksGetResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksGetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksGetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksListPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksListResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksListPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksListPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorksUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorksUpdateResponseBody
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r WorksUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorksUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AccountsCreateWithBodyWithResponse request with arbitrary body returning *AccountsCreateResponse
func (c *ClientWithResponses) AccountsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsCreateResponse, error) {
	rsp, err := c.AccountsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsCreateResponse(rsp)
}

func (c *ClientWithResponses) AccountsCreateWithResponse(ctx context.Context, body AccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsCreateResponse, error) {
	rsp, err := c.AccountsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsCreateResponse(rsp)
}

// AccountsDeleteWithBodyWithResponse request with arbitrary body returning *AccountsDeleteResponse
func (c *ClientWithResponses) AccountsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsDeleteResponse, error) {
	rsp, err := c.AccountsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsDeleteResponse(rsp)
}

func (c *ClientWithResponses) AccountsDeleteWithResponse(ctx context.Context, body AccountsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsDeleteResponse, error) {
	rsp, err := c.AccountsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsDeleteResponse(rsp)
}

// AccountsExportWithResponse request returning *AccountsExportResponse
func (c *ClientWithResponses) AccountsExportWithResponse(ctx context.Context, params *AccountsExportParams, reqEditors ...RequestEditorFn) (*AccountsExportResponse, error) {
	rsp, err := c.AccountsExport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsExportResponse(rsp)
}

// AccountsExportPostWithBodyWithResponse request with arbitrary body returning *AccountsExportPostResponse
func (c *ClientWithResponses) AccountsExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsExportPostResponse, error) {
	rsp, err := c.AccountsExportPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsExportPostResponse(rsp)
}

func (c *ClientWithResponses) AccountsExportPostWithResponse(ctx context.Context, body AccountsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsExportPostResponse, error) {
	rsp, err := c.AccountsExportPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsExportPostResponse(rsp)
}

// AccountsGetWithResponse request returning *AccountsGetResponse
func (c *ClientWithResponses) AccountsGetWithResponse(ctx context.Context, params *AccountsGetParams, reqEditors ...RequestEditorFn) (*AccountsGetResponse, error) {
	rsp, err := c.AccountsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsGetResponse(rsp)
}

// AccountsGetPostWithBodyWithResponse request with arbitrary body returning *AccountsGetPostResponse
func (c *ClientWithResponses) AccountsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsGetPostResponse, error) {
	rsp, err := c.AccountsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsGetPostResponse(rsp)
}

func (c *ClientWithResponses) AccountsGetPostWithResponse(ctx context.Context, body AccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsGetPostResponse, error) {
	rsp, err := c.AccountsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsGetPostResponse(rsp)
}

// AccountsListWithResponse request returning *AccountsListResponse
func (c *ClientWithResponses) AccountsListWithResponse(ctx context.Context, params *AccountsListParams, reqEditors ...RequestEditorFn) (*AccountsListResponse, error) {
	rsp, err := c.AccountsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsListResponse(rsp)
}

// AccountsListPostWithBodyWithResponse request with arbitrary body returning *AccountsListPostResponse
func (c *ClientWithResponses) AccountsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsListPostResponse, error) {
	rsp, err := c.AccountsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsListPostResponse(rsp)
}

func (c *ClientWithResponses) AccountsListPostWithResponse(ctx context.Context, body AccountsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsListPostResponse, error) {
	rsp, err := c.AccountsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsListPostResponse(rsp)
}

// AccountsMergeWithBodyWithResponse request with arbitrary body returning *AccountsMergeResponse
func (c *ClientWithResponses) AccountsMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsMergeResponse, error) {
	rsp, err := c.AccountsMergeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsMergeResponse(rsp)
}

func (c *ClientWithResponses) AccountsMergeWithResponse(ctx context.Context, body AccountsMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsMergeResponse, error) {
	rsp, err := c.AccountsMerge(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsMergeResponse(rsp)
}

// AccountsUpdateWithBodyWithResponse request with arbitrary body returning *AccountsUpdateResponse
func (c *ClientWithResponses) AccountsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccountsUpdateResponse, error) {
	rsp, err := c.AccountsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsUpdateResponse(rsp)
}

func (c *ClientWithResponses) AccountsUpdateWithResponse(ctx context.Context, body AccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AccountsUpdateResponse, error) {
	rsp, err := c.AccountsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsUpdateResponse(rsp)
}

// AiAgentEventsExecuteAsyncWithBodyWithResponse request with arbitrary body returning *AiAgentEventsExecuteAsyncResponse
func (c *ClientWithResponses) AiAgentEventsExecuteAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AiAgentEventsExecuteAsyncResponse, error) {
	rsp, err := c.AiAgentEventsExecuteAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAiAgentEventsExecuteAsyncResponse(rsp)
}

func (c *ClientWithResponses) AiAgentEventsExecuteAsyncWithResponse(ctx context.Context, body AiAgentEventsExecuteAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*AiAgentEventsExecuteAsyncResponse, error) {
	rsp, err := c.AiAgentEventsExecuteAsync(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAiAgentEventsExecuteAsyncResponse(rsp)
}

// AirdropSyncUnitsGetWithResponse request returning *AirdropSyncUnitsGetResponse
func (c *ClientWithResponses) AirdropSyncUnitsGetWithResponse(ctx context.Context, params *AirdropSyncUnitsGetParams, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsGetResponse, error) {
	rsp, err := c.AirdropSyncUnitsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAirdropSyncUnitsGetResponse(rsp)
}

// AirdropSyncUnitsGetPostWithBodyWithResponse request with arbitrary body returning *AirdropSyncUnitsGetPostResponse
func (c *ClientWithResponses) AirdropSyncUnitsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsGetPostResponse, error) {
	rsp, err := c.AirdropSyncUnitsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAirdropSyncUnitsGetPostResponse(rsp)
}

func (c *ClientWithResponses) AirdropSyncUnitsGetPostWithResponse(ctx context.Context, body AirdropSyncUnitsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsGetPostResponse, error) {
	rsp, err := c.AirdropSyncUnitsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAirdropSyncUnitsGetPostResponse(rsp)
}

// AirdropSyncUnitsHistoryWithResponse request returning *AirdropSyncUnitsHistoryResponse
func (c *ClientWithResponses) AirdropSyncUnitsHistoryWithResponse(ctx context.Context, params *AirdropSyncUnitsHistoryParams, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsHistoryResponse, error) {
	rsp, err := c.AirdropSyncUnitsHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAirdropSyncUnitsHistoryResponse(rsp)
}

// AirdropSyncUnitsHistoryPostWithBodyWithResponse request with arbitrary body returning *AirdropSyncUnitsHistoryPostResponse
func (c *ClientWithResponses) AirdropSyncUnitsHistoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsHistoryPostResponse, error) {
	rsp, err := c.AirdropSyncUnitsHistoryPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAirdropSyncUnitsHistoryPostResponse(rsp)
}

func (c *ClientWithResponses) AirdropSyncUnitsHistoryPostWithResponse(ctx context.Context, body AirdropSyncUnitsHistoryPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AirdropSyncUnitsHistoryPostResponse, error) {
	rsp, err := c.AirdropSyncUnitsHistoryPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAirdropSyncUnitsHistoryPostResponse(rsp)
}

// ArticlesCountWithResponse request returning *ArticlesCountResponse
func (c *ClientWithResponses) ArticlesCountWithResponse(ctx context.Context, params *ArticlesCountParams, reqEditors ...RequestEditorFn) (*ArticlesCountResponse, error) {
	rsp, err := c.ArticlesCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArticlesCountResponse(rsp)
}

// ArticlesCountPostWithBodyWithResponse request with arbitrary body returning *ArticlesCountPostResponse
func (c *ClientWithResponses) ArticlesCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArticlesCountPostResponse, error) {
	rsp, err := c.ArticlesCountPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArticlesCountPostResponse(rsp)
}

func (c *ClientWithResponses) ArticlesCountPostWithResponse(ctx context.Context, body ArticlesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArticlesCountPostResponse, error) {
	rsp, err := c.ArticlesCountPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArticlesCountPostResponse(rsp)
}

// CreateArticleWithBodyWithResponse request with arbitrary body returning *CreateArticleResponse
func (c *ClientWithResponses) CreateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error) {
	rsp, err := c.CreateArticleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateArticleResponse(rsp)
}

func (c *ClientWithResponses) CreateArticleWithResponse(ctx context.Context, body CreateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateArticleResponse, error) {
	rsp, err := c.CreateArticle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateArticleResponse(rsp)
}

// DeleteArticleWithBodyWithResponse request with arbitrary body returning *DeleteArticleResponse
func (c *ClientWithResponses) DeleteArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteArticleResponse, error) {
	rsp, err := c.DeleteArticleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteArticleResponse(rsp)
}

func (c *ClientWithResponses) DeleteArticleWithResponse(ctx context.Context, body DeleteArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteArticleResponse, error) {
	rsp, err := c.DeleteArticle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteArticleResponse(rsp)
}

// GetArticleWithResponse request returning *GetArticleResponse
func (c *ClientWithResponses) GetArticleWithResponse(ctx context.Context, params *GetArticleParams, reqEditors ...RequestEditorFn) (*GetArticleResponse, error) {
	rsp, err := c.GetArticle(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticleResponse(rsp)
}

// GetArticlePostWithBodyWithResponse request with arbitrary body returning *GetArticlePostResponse
func (c *ClientWithResponses) GetArticlePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetArticlePostResponse, error) {
	rsp, err := c.GetArticlePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticlePostResponse(rsp)
}

func (c *ClientWithResponses) GetArticlePostWithResponse(ctx context.Context, body GetArticlePostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetArticlePostResponse, error) {
	rsp, err := c.GetArticlePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArticlePostResponse(rsp)
}

// ListArticlesWithResponse request returning *ListArticlesResponse
func (c *ClientWithResponses) ListArticlesWithResponse(ctx context.Context, params *ListArticlesParams, reqEditors ...RequestEditorFn) (*ListArticlesResponse, error) {
	rsp, err := c.ListArticles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListArticlesResponse(rsp)
}

// ListArticlesPostWithBodyWithResponse request with arbitrary body returning *ListArticlesPostResponse
func (c *ClientWithResponses) ListArticlesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListArticlesPostResponse, error) {
	rsp, err := c.ListArticlesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListArticlesPostResponse(rsp)
}

func (c *ClientWithResponses) ListArticlesPostWithResponse(ctx context.Context, body ListArticlesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListArticlesPostResponse, error) {
	rsp, err := c.ListArticlesPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListArticlesPostResponse(rsp)
}

// UpdateArticleWithBodyWithResponse request with arbitrary body returning *UpdateArticleResponse
func (c *ClientWithResponses) UpdateArticleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error) {
	rsp, err := c.UpdateArticleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateArticleResponse(rsp)
}

func (c *ClientWithResponses) UpdateArticleWithResponse(ctx context.Context, body UpdateArticleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateArticleResponse, error) {
	rsp, err := c.UpdateArticle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateArticleResponse(rsp)
}

// ArtifactsGetWithResponse request returning *ArtifactsGetResponse
func (c *ClientWithResponses) ArtifactsGetWithResponse(ctx context.Context, params *ArtifactsGetParams, reqEditors ...RequestEditorFn) (*ArtifactsGetResponse, error) {
	rsp, err := c.ArtifactsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsGetResponse(rsp)
}

// ArtifactsGetPostWithBodyWithResponse request with arbitrary body returning *ArtifactsGetPostResponse
func (c *ClientWithResponses) ArtifactsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsGetPostResponse, error) {
	rsp, err := c.ArtifactsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsGetPostResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsGetPostWithResponse(ctx context.Context, body ArtifactsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsGetPostResponse, error) {
	rsp, err := c.ArtifactsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsGetPostResponse(rsp)
}

// ArtifactsListWithResponse request returning *ArtifactsListResponse
func (c *ClientWithResponses) ArtifactsListWithResponse(ctx context.Context, params *ArtifactsListParams, reqEditors ...RequestEditorFn) (*ArtifactsListResponse, error) {
	rsp, err := c.ArtifactsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsListResponse(rsp)
}

// ArtifactsListPostWithBodyWithResponse request with arbitrary body returning *ArtifactsListPostResponse
func (c *ClientWithResponses) ArtifactsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsListPostResponse, error) {
	rsp, err := c.ArtifactsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsListPostResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsListPostWithResponse(ctx context.Context, body ArtifactsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsListPostResponse, error) {
	rsp, err := c.ArtifactsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsListPostResponse(rsp)
}

// ArtifactsLocateWithResponse request returning *ArtifactsLocateResponse
func (c *ClientWithResponses) ArtifactsLocateWithResponse(ctx context.Context, params *ArtifactsLocateParams, reqEditors ...RequestEditorFn) (*ArtifactsLocateResponse, error) {
	rsp, err := c.ArtifactsLocate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsLocateResponse(rsp)
}

// ArtifactsLocatePostWithBodyWithResponse request with arbitrary body returning *ArtifactsLocatePostResponse
func (c *ClientWithResponses) ArtifactsLocatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsLocatePostResponse, error) {
	rsp, err := c.ArtifactsLocatePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsLocatePostResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsLocatePostWithResponse(ctx context.Context, body ArtifactsLocatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsLocatePostResponse, error) {
	rsp, err := c.ArtifactsLocatePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsLocatePostResponse(rsp)
}

// ArtifactsPrepareWithBodyWithResponse request with arbitrary body returning *ArtifactsPrepareResponse
func (c *ClientWithResponses) ArtifactsPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsPrepareResponse, error) {
	rsp, err := c.ArtifactsPrepareWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsPrepareResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsPrepareWithResponse(ctx context.Context, body ArtifactsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsPrepareResponse, error) {
	rsp, err := c.ArtifactsPrepare(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsPrepareResponse(rsp)
}

// ArtifactsHardDeleteVersionWithBodyWithResponse request with arbitrary body returning *ArtifactsHardDeleteVersionResponse
func (c *ClientWithResponses) ArtifactsHardDeleteVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsHardDeleteVersionResponse, error) {
	rsp, err := c.ArtifactsHardDeleteVersionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsHardDeleteVersionResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsHardDeleteVersionWithResponse(ctx context.Context, body ArtifactsHardDeleteVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsHardDeleteVersionResponse, error) {
	rsp, err := c.ArtifactsHardDeleteVersion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsHardDeleteVersionResponse(rsp)
}

// ArtifactsVersionsPrepareWithBodyWithResponse request with arbitrary body returning *ArtifactsVersionsPrepareResponse
func (c *ClientWithResponses) ArtifactsVersionsPrepareWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtifactsVersionsPrepareResponse, error) {
	rsp, err := c.ArtifactsVersionsPrepareWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsVersionsPrepareResponse(rsp)
}

func (c *ClientWithResponses) ArtifactsVersionsPrepareWithResponse(ctx context.Context, body ArtifactsVersionsPrepareJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtifactsVersionsPrepareResponse, error) {
	rsp, err := c.ArtifactsVersionsPrepare(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtifactsVersionsPrepareResponse(rsp)
}

// AtomsGetWithResponse request returning *AtomsGetResponse
func (c *ClientWithResponses) AtomsGetWithResponse(ctx context.Context, params *AtomsGetParams, reqEditors ...RequestEditorFn) (*AtomsGetResponse, error) {
	rsp, err := c.AtomsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAtomsGetResponse(rsp)
}

// AtomsGetPostWithBodyWithResponse request with arbitrary body returning *AtomsGetPostResponse
func (c *ClientWithResponses) AtomsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AtomsGetPostResponse, error) {
	rsp, err := c.AtomsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAtomsGetPostResponse(rsp)
}

func (c *ClientWithResponses) AtomsGetPostWithResponse(ctx context.Context, body AtomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AtomsGetPostResponse, error) {
	rsp, err := c.AtomsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAtomsGetPostResponse(rsp)
}

// ExportAuditLogsWithBodyWithResponse request with arbitrary body returning *ExportAuditLogsResponse
func (c *ClientWithResponses) ExportAuditLogsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportAuditLogsResponse, error) {
	rsp, err := c.ExportAuditLogsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportAuditLogsResponse(rsp)
}

func (c *ClientWithResponses) ExportAuditLogsWithResponse(ctx context.Context, body ExportAuditLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportAuditLogsResponse, error) {
	rsp, err := c.ExportAuditLogs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportAuditLogsResponse(rsp)
}

// AuthTokensCreateWithBodyWithResponse request with arbitrary body returning *AuthTokensCreateResponse
func (c *ClientWithResponses) AuthTokensCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensCreateResponse, error) {
	rsp, err := c.AuthTokensCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensCreateResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensCreateWithResponse(ctx context.Context, body AuthTokensCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensCreateResponse, error) {
	rsp, err := c.AuthTokensCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensCreateResponse(rsp)
}

// AuthTokensDeleteWithBodyWithResponse request with arbitrary body returning *AuthTokensDeleteResponse
func (c *ClientWithResponses) AuthTokensDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensDeleteResponse, error) {
	rsp, err := c.AuthTokensDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensDeleteResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensDeleteWithResponse(ctx context.Context, body AuthTokensDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensDeleteResponse, error) {
	rsp, err := c.AuthTokensDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensDeleteResponse(rsp)
}

// AuthTokensGetWithResponse request returning *AuthTokensGetResponse
func (c *ClientWithResponses) AuthTokensGetWithResponse(ctx context.Context, params *AuthTokensGetParams, reqEditors ...RequestEditorFn) (*AuthTokensGetResponse, error) {
	rsp, err := c.AuthTokensGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensGetResponse(rsp)
}

// AuthTokensGetPostWithBodyWithResponse request with arbitrary body returning *AuthTokensGetPostResponse
func (c *ClientWithResponses) AuthTokensGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensGetPostResponse, error) {
	rsp, err := c.AuthTokensGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensGetPostResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensGetPostWithResponse(ctx context.Context, body AuthTokensGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensGetPostResponse, error) {
	rsp, err := c.AuthTokensGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensGetPostResponse(rsp)
}

// AuthTokensInfoWithResponse request returning *AuthTokensInfoResponse
func (c *ClientWithResponses) AuthTokensInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthTokensInfoResponse, error) {
	rsp, err := c.AuthTokensInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensInfoResponse(rsp)
}

// AuthTokensInfoPostWithBodyWithResponse request with arbitrary body returning *AuthTokensInfoPostResponse
func (c *ClientWithResponses) AuthTokensInfoPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensInfoPostResponse, error) {
	rsp, err := c.AuthTokensInfoPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensInfoPostResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensInfoPostWithResponse(ctx context.Context, body AuthTokensInfoPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensInfoPostResponse, error) {
	rsp, err := c.AuthTokensInfoPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensInfoPostResponse(rsp)
}

// AuthTokensListWithResponse request returning *AuthTokensListResponse
func (c *ClientWithResponses) AuthTokensListWithResponse(ctx context.Context, params *AuthTokensListParams, reqEditors ...RequestEditorFn) (*AuthTokensListResponse, error) {
	rsp, err := c.AuthTokensList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensListResponse(rsp)
}

// AuthTokensListPostWithBodyWithResponse request with arbitrary body returning *AuthTokensListPostResponse
func (c *ClientWithResponses) AuthTokensListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensListPostResponse, error) {
	rsp, err := c.AuthTokensListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensListPostResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensListPostWithResponse(ctx context.Context, body AuthTokensListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensListPostResponse, error) {
	rsp, err := c.AuthTokensListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensListPostResponse(rsp)
}

// AuthTokensSelfDeleteWithBodyWithResponse request with arbitrary body returning *AuthTokensSelfDeleteResponse
func (c *ClientWithResponses) AuthTokensSelfDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensSelfDeleteResponse, error) {
	rsp, err := c.AuthTokensSelfDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensSelfDeleteResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensSelfDeleteWithResponse(ctx context.Context, body AuthTokensSelfDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensSelfDeleteResponse, error) {
	rsp, err := c.AuthTokensSelfDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensSelfDeleteResponse(rsp)
}

// AuthTokensUpdateWithBodyWithResponse request with arbitrary body returning *AuthTokensUpdateResponse
func (c *ClientWithResponses) AuthTokensUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthTokensUpdateResponse, error) {
	rsp, err := c.AuthTokensUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensUpdateResponse(rsp)
}

func (c *ClientWithResponses) AuthTokensUpdateWithResponse(ctx context.Context, body AuthTokensUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthTokensUpdateResponse, error) {
	rsp, err := c.AuthTokensUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthTokensUpdateResponse(rsp)
}

// BrandsCreateWithBodyWithResponse request with arbitrary body returning *BrandsCreateResponse
func (c *ClientWithResponses) BrandsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsCreateResponse, error) {
	rsp, err := c.BrandsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsCreateResponse(rsp)
}

func (c *ClientWithResponses) BrandsCreateWithResponse(ctx context.Context, body BrandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsCreateResponse, error) {
	rsp, err := c.BrandsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsCreateResponse(rsp)
}

// BrandsDeleteWithBodyWithResponse request with arbitrary body returning *BrandsDeleteResponse
func (c *ClientWithResponses) BrandsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsDeleteResponse, error) {
	rsp, err := c.BrandsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsDeleteResponse(rsp)
}

func (c *ClientWithResponses) BrandsDeleteWithResponse(ctx context.Context, body BrandsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsDeleteResponse, error) {
	rsp, err := c.BrandsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsDeleteResponse(rsp)
}

// BrandsGetWithResponse request returning *BrandsGetResponse
func (c *ClientWithResponses) BrandsGetWithResponse(ctx context.Context, params *BrandsGetParams, reqEditors ...RequestEditorFn) (*BrandsGetResponse, error) {
	rsp, err := c.BrandsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsGetResponse(rsp)
}

// BrandsGetPostWithBodyWithResponse request with arbitrary body returning *BrandsGetPostResponse
func (c *ClientWithResponses) BrandsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsGetPostResponse, error) {
	rsp, err := c.BrandsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsGetPostResponse(rsp)
}

func (c *ClientWithResponses) BrandsGetPostWithResponse(ctx context.Context, body BrandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsGetPostResponse, error) {
	rsp, err := c.BrandsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsGetPostResponse(rsp)
}

// BrandsListWithResponse request returning *BrandsListResponse
func (c *ClientWithResponses) BrandsListWithResponse(ctx context.Context, params *BrandsListParams, reqEditors ...RequestEditorFn) (*BrandsListResponse, error) {
	rsp, err := c.BrandsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsListResponse(rsp)
}

// BrandsListPostWithBodyWithResponse request with arbitrary body returning *BrandsListPostResponse
func (c *ClientWithResponses) BrandsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsListPostResponse, error) {
	rsp, err := c.BrandsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsListPostResponse(rsp)
}

func (c *ClientWithResponses) BrandsListPostWithResponse(ctx context.Context, body BrandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsListPostResponse, error) {
	rsp, err := c.BrandsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsListPostResponse(rsp)
}

// BrandsUpdateWithBodyWithResponse request with arbitrary body returning *BrandsUpdateResponse
func (c *ClientWithResponses) BrandsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BrandsUpdateResponse, error) {
	rsp, err := c.BrandsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsUpdateResponse(rsp)
}

func (c *ClientWithResponses) BrandsUpdateWithResponse(ctx context.Context, body BrandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*BrandsUpdateResponse, error) {
	rsp, err := c.BrandsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrandsUpdateResponse(rsp)
}

// ChatsCreateWithBodyWithResponse request with arbitrary body returning *ChatsCreateResponse
func (c *ClientWithResponses) ChatsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsCreateResponse, error) {
	rsp, err := c.ChatsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsCreateResponse(rsp)
}

func (c *ClientWithResponses) ChatsCreateWithResponse(ctx context.Context, body ChatsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsCreateResponse, error) {
	rsp, err := c.ChatsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsCreateResponse(rsp)
}

// ChatsGetWithResponse request returning *ChatsGetResponse
func (c *ClientWithResponses) ChatsGetWithResponse(ctx context.Context, params *ChatsGetParams, reqEditors ...RequestEditorFn) (*ChatsGetResponse, error) {
	rsp, err := c.ChatsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsGetResponse(rsp)
}

// ChatsGetPostWithBodyWithResponse request with arbitrary body returning *ChatsGetPostResponse
func (c *ClientWithResponses) ChatsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsGetPostResponse, error) {
	rsp, err := c.ChatsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsGetPostResponse(rsp)
}

func (c *ClientWithResponses) ChatsGetPostWithResponse(ctx context.Context, body ChatsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsGetPostResponse, error) {
	rsp, err := c.ChatsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsGetPostResponse(rsp)
}

// ChatsUpdateWithBodyWithResponse request with arbitrary body returning *ChatsUpdateResponse
func (c *ClientWithResponses) ChatsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatsUpdateResponse, error) {
	rsp, err := c.ChatsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ChatsUpdateWithResponse(ctx context.Context, body ChatsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatsUpdateResponse, error) {
	rsp, err := c.ChatsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatsUpdateResponse(rsp)
}

// CodeChangesCreateWithBodyWithResponse request with arbitrary body returning *CodeChangesCreateResponse
func (c *ClientWithResponses) CodeChangesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesCreateResponse, error) {
	rsp, err := c.CodeChangesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesCreateResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesCreateWithResponse(ctx context.Context, body CodeChangesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesCreateResponse, error) {
	rsp, err := c.CodeChangesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesCreateResponse(rsp)
}

// CodeChangesDeleteWithBodyWithResponse request with arbitrary body returning *CodeChangesDeleteResponse
func (c *ClientWithResponses) CodeChangesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesDeleteResponse, error) {
	rsp, err := c.CodeChangesDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesDeleteResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesDeleteWithResponse(ctx context.Context, body CodeChangesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesDeleteResponse, error) {
	rsp, err := c.CodeChangesDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesDeleteResponse(rsp)
}

// CodeChangesGetWithResponse request returning *CodeChangesGetResponse
func (c *ClientWithResponses) CodeChangesGetWithResponse(ctx context.Context, params *CodeChangesGetParams, reqEditors ...RequestEditorFn) (*CodeChangesGetResponse, error) {
	rsp, err := c.CodeChangesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesGetResponse(rsp)
}

// CodeChangesGetPostWithBodyWithResponse request with arbitrary body returning *CodeChangesGetPostResponse
func (c *ClientWithResponses) CodeChangesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesGetPostResponse, error) {
	rsp, err := c.CodeChangesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesGetPostResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesGetPostWithResponse(ctx context.Context, body CodeChangesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesGetPostResponse, error) {
	rsp, err := c.CodeChangesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesGetPostResponse(rsp)
}

// CodeChangesListWithResponse request returning *CodeChangesListResponse
func (c *ClientWithResponses) CodeChangesListWithResponse(ctx context.Context, params *CodeChangesListParams, reqEditors ...RequestEditorFn) (*CodeChangesListResponse, error) {
	rsp, err := c.CodeChangesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesListResponse(rsp)
}

// CodeChangesListPostWithBodyWithResponse request with arbitrary body returning *CodeChangesListPostResponse
func (c *ClientWithResponses) CodeChangesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesListPostResponse, error) {
	rsp, err := c.CodeChangesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesListPostResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesListPostWithResponse(ctx context.Context, body CodeChangesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesListPostResponse, error) {
	rsp, err := c.CodeChangesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesListPostResponse(rsp)
}

// CodeChangesUpdateWithBodyWithResponse request with arbitrary body returning *CodeChangesUpdateResponse
func (c *ClientWithResponses) CodeChangesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeChangesUpdateResponse, error) {
	rsp, err := c.CodeChangesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesUpdateResponse(rsp)
}

func (c *ClientWithResponses) CodeChangesUpdateWithResponse(ctx context.Context, body CodeChangesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeChangesUpdateResponse, error) {
	rsp, err := c.CodeChangesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeChangesUpdateResponse(rsp)
}

// CommandsCreateWithBodyWithResponse request with arbitrary body returning *CommandsCreateResponse
func (c *ClientWithResponses) CommandsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsCreateResponse, error) {
	rsp, err := c.CommandsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsCreateResponse(rsp)
}

func (c *ClientWithResponses) CommandsCreateWithResponse(ctx context.Context, body CommandsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsCreateResponse, error) {
	rsp, err := c.CommandsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsCreateResponse(rsp)
}

// CommandsGetWithResponse request returning *CommandsGetResponse
func (c *ClientWithResponses) CommandsGetWithResponse(ctx context.Context, params *CommandsGetParams, reqEditors ...RequestEditorFn) (*CommandsGetResponse, error) {
	rsp, err := c.CommandsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsGetResponse(rsp)
}

// CommandsGetPostWithBodyWithResponse request with arbitrary body returning *CommandsGetPostResponse
func (c *ClientWithResponses) CommandsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsGetPostResponse, error) {
	rsp, err := c.CommandsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsGetPostResponse(rsp)
}

func (c *ClientWithResponses) CommandsGetPostWithResponse(ctx context.Context, body CommandsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsGetPostResponse, error) {
	rsp, err := c.CommandsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsGetPostResponse(rsp)
}

// CommandsListWithResponse request returning *CommandsListResponse
func (c *ClientWithResponses) CommandsListWithResponse(ctx context.Context, params *CommandsListParams, reqEditors ...RequestEditorFn) (*CommandsListResponse, error) {
	rsp, err := c.CommandsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsListResponse(rsp)
}

// CommandsListPostWithBodyWithResponse request with arbitrary body returning *CommandsListPostResponse
func (c *ClientWithResponses) CommandsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsListPostResponse, error) {
	rsp, err := c.CommandsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsListPostResponse(rsp)
}

func (c *ClientWithResponses) CommandsListPostWithResponse(ctx context.Context, body CommandsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsListPostResponse, error) {
	rsp, err := c.CommandsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsListPostResponse(rsp)
}

// CommandsUpdateWithBodyWithResponse request with arbitrary body returning *CommandsUpdateResponse
func (c *ClientWithResponses) CommandsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommandsUpdateResponse, error) {
	rsp, err := c.CommandsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsUpdateResponse(rsp)
}

func (c *ClientWithResponses) CommandsUpdateWithResponse(ctx context.Context, body CommandsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommandsUpdateResponse, error) {
	rsp, err := c.CommandsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommandsUpdateResponse(rsp)
}

// ContentTemplateCreateWithBodyWithResponse request with arbitrary body returning *ContentTemplateCreateResponse
func (c *ClientWithResponses) ContentTemplateCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContentTemplateCreateResponse, error) {
	rsp, err := c.ContentTemplateCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContentTemplateCreateResponse(rsp)
}

func (c *ClientWithResponses) ContentTemplateCreateWithResponse(ctx context.Context, body ContentTemplateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ContentTemplateCreateResponse, error) {
	rsp, err := c.ContentTemplateCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContentTemplateCreateResponse(rsp)
}

// ContentTemplateGetWithResponse request returning *ContentTemplateGetResponse
func (c *ClientWithResponses) ContentTemplateGetWithResponse(ctx context.Context, params *ContentTemplateGetParams, reqEditors ...RequestEditorFn) (*ContentTemplateGetResponse, error) {
	rsp, err := c.ContentTemplateGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContentTemplateGetResponse(rsp)
}

// ContentTemplateGetPostWithBodyWithResponse request with arbitrary body returning *ContentTemplateGetPostResponse
func (c *ClientWithResponses) ContentTemplateGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContentTemplateGetPostResponse, error) {
	rsp, err := c.ContentTemplateGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContentTemplateGetPostResponse(rsp)
}

func (c *ClientWithResponses) ContentTemplateGetPostWithResponse(ctx context.Context, body ContentTemplateGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ContentTemplateGetPostResponse, error) {
	rsp, err := c.ContentTemplateGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContentTemplateGetPostResponse(rsp)
}

// ContentTemplateListWithResponse request returning *ContentTemplateListResponse
func (c *ClientWithResponses) ContentTemplateListWithResponse(ctx context.Context, params *ContentTemplateListParams, reqEditors ...RequestEditorFn) (*ContentTemplateListResponse, error) {
	rsp, err := c.ContentTemplateList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContentTemplateListResponse(rsp)
}

// ContentTemplateListPostWithBodyWithResponse request with arbitrary body returning *ContentTemplateListPostResponse
func (c *ClientWithResponses) ContentTemplateListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContentTemplateListPostResponse, error) {
	rsp, err := c.ContentTemplateListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContentTemplateListPostResponse(rsp)
}

func (c *ClientWithResponses) ContentTemplateListPostWithResponse(ctx context.Context, body ContentTemplateListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ContentTemplateListPostResponse, error) {
	rsp, err := c.ContentTemplateListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContentTemplateListPostResponse(rsp)
}

// ConversationsCreateWithBodyWithResponse request with arbitrary body returning *ConversationsCreateResponse
func (c *ClientWithResponses) ConversationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsCreateResponse, error) {
	rsp, err := c.ConversationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsCreateResponse(rsp)
}

func (c *ClientWithResponses) ConversationsCreateWithResponse(ctx context.Context, body ConversationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsCreateResponse, error) {
	rsp, err := c.ConversationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsCreateResponse(rsp)
}

// ConversationsDeleteWithBodyWithResponse request with arbitrary body returning *ConversationsDeleteResponse
func (c *ClientWithResponses) ConversationsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsDeleteResponse, error) {
	rsp, err := c.ConversationsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsDeleteResponse(rsp)
}

func (c *ClientWithResponses) ConversationsDeleteWithResponse(ctx context.Context, body ConversationsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsDeleteResponse, error) {
	rsp, err := c.ConversationsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsDeleteResponse(rsp)
}

// ConversationsExportWithResponse request returning *ConversationsExportResponse
func (c *ClientWithResponses) ConversationsExportWithResponse(ctx context.Context, params *ConversationsExportParams, reqEditors ...RequestEditorFn) (*ConversationsExportResponse, error) {
	rsp, err := c.ConversationsExport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsExportResponse(rsp)
}

// ConversationsExportPostWithBodyWithResponse request with arbitrary body returning *ConversationsExportPostResponse
func (c *ClientWithResponses) ConversationsExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsExportPostResponse, error) {
	rsp, err := c.ConversationsExportPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsExportPostResponse(rsp)
}

func (c *ClientWithResponses) ConversationsExportPostWithResponse(ctx context.Context, body ConversationsExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsExportPostResponse, error) {
	rsp, err := c.ConversationsExportPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsExportPostResponse(rsp)
}

// ConversationsGetWithResponse request returning *ConversationsGetResponse
func (c *ClientWithResponses) ConversationsGetWithResponse(ctx context.Context, params *ConversationsGetParams, reqEditors ...RequestEditorFn) (*ConversationsGetResponse, error) {
	rsp, err := c.ConversationsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsGetResponse(rsp)
}

// ConversationsGetPostWithBodyWithResponse request with arbitrary body returning *ConversationsGetPostResponse
func (c *ClientWithResponses) ConversationsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsGetPostResponse, error) {
	rsp, err := c.ConversationsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsGetPostResponse(rsp)
}

func (c *ClientWithResponses) ConversationsGetPostWithResponse(ctx context.Context, body ConversationsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsGetPostResponse, error) {
	rsp, err := c.ConversationsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsGetPostResponse(rsp)
}

// ConversationsListWithResponse request returning *ConversationsListResponse
func (c *ClientWithResponses) ConversationsListWithResponse(ctx context.Context, params *ConversationsListParams, reqEditors ...RequestEditorFn) (*ConversationsListResponse, error) {
	rsp, err := c.ConversationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsListResponse(rsp)
}

// ConversationsListPostWithBodyWithResponse request with arbitrary body returning *ConversationsListPostResponse
func (c *ClientWithResponses) ConversationsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsListPostResponse, error) {
	rsp, err := c.ConversationsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsListPostResponse(rsp)
}

func (c *ClientWithResponses) ConversationsListPostWithResponse(ctx context.Context, body ConversationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsListPostResponse, error) {
	rsp, err := c.ConversationsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsListPostResponse(rsp)
}

// ConversationsUpdateWithBodyWithResponse request with arbitrary body returning *ConversationsUpdateResponse
func (c *ClientWithResponses) ConversationsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConversationsUpdateResponse, error) {
	rsp, err := c.ConversationsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ConversationsUpdateWithResponse(ctx context.Context, body ConversationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConversationsUpdateResponse, error) {
	rsp, err := c.ConversationsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConversationsUpdateResponse(rsp)
}

// CustomObjectsCountWithResponse request returning *CustomObjectsCountResponse
func (c *ClientWithResponses) CustomObjectsCountWithResponse(ctx context.Context, params *CustomObjectsCountParams, reqEditors ...RequestEditorFn) (*CustomObjectsCountResponse, error) {
	rsp, err := c.CustomObjectsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsCountResponse(rsp)
}

// CustomObjectsCountPostWithBodyWithResponse request with arbitrary body returning *CustomObjectsCountPostResponse
func (c *ClientWithResponses) CustomObjectsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsCountPostResponse, error) {
	rsp, err := c.CustomObjectsCountPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsCountPostResponse(rsp)
}

func (c *ClientWithResponses) CustomObjectsCountPostWithResponse(ctx context.Context, body CustomObjectsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsCountPostResponse, error) {
	rsp, err := c.CustomObjectsCountPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsCountPostResponse(rsp)
}

// CustomObjectsCreateWithBodyWithResponse request with arbitrary body returning *CustomObjectsCreateResponse
func (c *ClientWithResponses) CustomObjectsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsCreateResponse, error) {
	rsp, err := c.CustomObjectsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsCreateResponse(rsp)
}

func (c *ClientWithResponses) CustomObjectsCreateWithResponse(ctx context.Context, body CustomObjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsCreateResponse, error) {
	rsp, err := c.CustomObjectsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsCreateResponse(rsp)
}

// CustomObjectsDeleteWithBodyWithResponse request with arbitrary body returning *CustomObjectsDeleteResponse
func (c *ClientWithResponses) CustomObjectsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsDeleteResponse, error) {
	rsp, err := c.CustomObjectsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsDeleteResponse(rsp)
}

func (c *ClientWithResponses) CustomObjectsDeleteWithResponse(ctx context.Context, body CustomObjectsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsDeleteResponse, error) {
	rsp, err := c.CustomObjectsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsDeleteResponse(rsp)
}

// CustomObjectsGetWithResponse request returning *CustomObjectsGetResponse
func (c *ClientWithResponses) CustomObjectsGetWithResponse(ctx context.Context, params *CustomObjectsGetParams, reqEditors ...RequestEditorFn) (*CustomObjectsGetResponse, error) {
	rsp, err := c.CustomObjectsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsGetResponse(rsp)
}

// CustomObjectsGetPostWithBodyWithResponse request with arbitrary body returning *CustomObjectsGetPostResponse
func (c *ClientWithResponses) CustomObjectsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsGetPostResponse, error) {
	rsp, err := c.CustomObjectsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsGetPostResponse(rsp)
}

func (c *ClientWithResponses) CustomObjectsGetPostWithResponse(ctx context.Context, body CustomObjectsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsGetPostResponse, error) {
	rsp, err := c.CustomObjectsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsGetPostResponse(rsp)
}

// CustomObjectsListWithResponse request returning *CustomObjectsListResponse
func (c *ClientWithResponses) CustomObjectsListWithResponse(ctx context.Context, params *CustomObjectsListParams, reqEditors ...RequestEditorFn) (*CustomObjectsListResponse, error) {
	rsp, err := c.CustomObjectsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsListResponse(rsp)
}

// CustomObjectsListPostWithBodyWithResponse request with arbitrary body returning *CustomObjectsListPostResponse
func (c *ClientWithResponses) CustomObjectsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsListPostResponse, error) {
	rsp, err := c.CustomObjectsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsListPostResponse(rsp)
}

func (c *ClientWithResponses) CustomObjectsListPostWithResponse(ctx context.Context, body CustomObjectsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsListPostResponse, error) {
	rsp, err := c.CustomObjectsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsListPostResponse(rsp)
}

// CustomObjectsUpdateWithBodyWithResponse request with arbitrary body returning *CustomObjectsUpdateResponse
func (c *ClientWithResponses) CustomObjectsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomObjectsUpdateResponse, error) {
	rsp, err := c.CustomObjectsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsUpdateResponse(rsp)
}

func (c *ClientWithResponses) CustomObjectsUpdateWithResponse(ctx context.Context, body CustomObjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomObjectsUpdateResponse, error) {
	rsp, err := c.CustomObjectsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomObjectsUpdateResponse(rsp)
}

// DevOrgAuthConnectionsCreateWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsCreateResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsCreateResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsCreateResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsCreateWithResponse(ctx context.Context, body DevOrgAuthConnectionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsCreateResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsCreateResponse(rsp)
}

// DevOrgAuthConnectionsDeleteWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsDeleteResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsDeleteResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsDeleteResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsDeleteWithResponse(ctx context.Context, body DevOrgAuthConnectionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsDeleteResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsDeleteResponse(rsp)
}

// DevOrgAuthConnectionsGetWithResponse request returning *DevOrgAuthConnectionsGetResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsGetWithResponse(ctx context.Context, params *DevOrgAuthConnectionsGetParams, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsGetResponse(rsp)
}

// DevOrgAuthConnectionsGetPostWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsGetPostResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetPostResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsGetPostResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsGetPostWithResponse(ctx context.Context, body DevOrgAuthConnectionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsGetPostResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsGetPostResponse(rsp)
}

// DevOrgAuthConnectionsListWithResponse request returning *DevOrgAuthConnectionsListResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsListResponse(rsp)
}

// DevOrgAuthConnectionsListPostWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsListPostResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListPostResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsListPostResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsListPostWithResponse(ctx context.Context, body DevOrgAuthConnectionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsListPostResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsListPostResponse(rsp)
}

// DevOrgAuthConnectionsToggleWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsToggleResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsToggleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsToggleResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsToggleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsToggleResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsToggleWithResponse(ctx context.Context, body DevOrgAuthConnectionsToggleJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsToggleResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsToggle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsToggleResponse(rsp)
}

// DevOrgAuthConnectionsUpdateWithBodyWithResponse request with arbitrary body returning *DevOrgAuthConnectionsUpdateResponse
func (c *ClientWithResponses) DevOrgAuthConnectionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsUpdateResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsUpdateResponse(rsp)
}

func (c *ClientWithResponses) DevOrgAuthConnectionsUpdateWithResponse(ctx context.Context, body DevOrgAuthConnectionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgAuthConnectionsUpdateResponse, error) {
	rsp, err := c.DevOrgAuthConnectionsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgAuthConnectionsUpdateResponse(rsp)
}

// DevOrgsGetWithResponse request returning *DevOrgsGetResponse
func (c *ClientWithResponses) DevOrgsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevOrgsGetResponse, error) {
	rsp, err := c.DevOrgsGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgsGetResponse(rsp)
}

// DevOrgsGetPostWithBodyWithResponse request with arbitrary body returning *DevOrgsGetPostResponse
func (c *ClientWithResponses) DevOrgsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevOrgsGetPostResponse, error) {
	rsp, err := c.DevOrgsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgsGetPostResponse(rsp)
}

func (c *ClientWithResponses) DevOrgsGetPostWithResponse(ctx context.Context, body DevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevOrgsGetPostResponse, error) {
	rsp, err := c.DevOrgsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevOrgsGetPostResponse(rsp)
}

// DevUsersActivateWithBodyWithResponse request with arbitrary body returning *DevUsersActivateResponse
func (c *ClientWithResponses) DevUsersActivateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersActivateResponse, error) {
	rsp, err := c.DevUsersActivateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersActivateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersActivateWithResponse(ctx context.Context, body DevUsersActivateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersActivateResponse, error) {
	rsp, err := c.DevUsersActivate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersActivateResponse(rsp)
}

// DevUsersCreateWithBodyWithResponse request with arbitrary body returning *DevUsersCreateResponse
func (c *ClientWithResponses) DevUsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersCreateResponse, error) {
	rsp, err := c.DevUsersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersCreateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersCreateWithResponse(ctx context.Context, body DevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersCreateResponse, error) {
	rsp, err := c.DevUsersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersCreateResponse(rsp)
}

// DevUsersDeactivateWithBodyWithResponse request with arbitrary body returning *DevUsersDeactivateResponse
func (c *ClientWithResponses) DevUsersDeactivateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersDeactivateResponse, error) {
	rsp, err := c.DevUsersDeactivateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersDeactivateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersDeactivateWithResponse(ctx context.Context, body DevUsersDeactivateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersDeactivateResponse, error) {
	rsp, err := c.DevUsersDeactivate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersDeactivateResponse(rsp)
}

// DevUsersGetWithResponse request returning *DevUsersGetResponse
func (c *ClientWithResponses) DevUsersGetWithResponse(ctx context.Context, params *DevUsersGetParams, reqEditors ...RequestEditorFn) (*DevUsersGetResponse, error) {
	rsp, err := c.DevUsersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersGetResponse(rsp)
}

// DevUsersGetPostWithBodyWithResponse request with arbitrary body returning *DevUsersGetPostResponse
func (c *ClientWithResponses) DevUsersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersGetPostResponse, error) {
	rsp, err := c.DevUsersGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersGetPostResponse(rsp)
}

func (c *ClientWithResponses) DevUsersGetPostWithResponse(ctx context.Context, body DevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersGetPostResponse, error) {
	rsp, err := c.DevUsersGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersGetPostResponse(rsp)
}

// DevUsersIdentitiesLinkWithBodyWithResponse request with arbitrary body returning *DevUsersIdentitiesLinkResponse
func (c *ClientWithResponses) DevUsersIdentitiesLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesLinkResponse, error) {
	rsp, err := c.DevUsersIdentitiesLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersIdentitiesLinkResponse(rsp)
}

func (c *ClientWithResponses) DevUsersIdentitiesLinkWithResponse(ctx context.Context, body DevUsersIdentitiesLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesLinkResponse, error) {
	rsp, err := c.DevUsersIdentitiesLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersIdentitiesLinkResponse(rsp)
}

// DevUsersIdentitiesUnlinkWithBodyWithResponse request with arbitrary body returning *DevUsersIdentitiesUnlinkResponse
func (c *ClientWithResponses) DevUsersIdentitiesUnlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesUnlinkResponse, error) {
	rsp, err := c.DevUsersIdentitiesUnlinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersIdentitiesUnlinkResponse(rsp)
}

func (c *ClientWithResponses) DevUsersIdentitiesUnlinkWithResponse(ctx context.Context, body DevUsersIdentitiesUnlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersIdentitiesUnlinkResponse, error) {
	rsp, err := c.DevUsersIdentitiesUnlink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersIdentitiesUnlinkResponse(rsp)
}

// DevUsersListWithResponse request returning *DevUsersListResponse
func (c *ClientWithResponses) DevUsersListWithResponse(ctx context.Context, params *DevUsersListParams, reqEditors ...RequestEditorFn) (*DevUsersListResponse, error) {
	rsp, err := c.DevUsersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersListResponse(rsp)
}

// DevUsersListPostWithBodyWithResponse request with arbitrary body returning *DevUsersListPostResponse
func (c *ClientWithResponses) DevUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersListPostResponse, error) {
	rsp, err := c.DevUsersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersListPostResponse(rsp)
}

func (c *ClientWithResponses) DevUsersListPostWithResponse(ctx context.Context, body DevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersListPostResponse, error) {
	rsp, err := c.DevUsersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersListPostResponse(rsp)
}

// DevUsersMergeWithBodyWithResponse request with arbitrary body returning *DevUsersMergeResponse
func (c *ClientWithResponses) DevUsersMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersMergeResponse, error) {
	rsp, err := c.DevUsersMergeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersMergeResponse(rsp)
}

func (c *ClientWithResponses) DevUsersMergeWithResponse(ctx context.Context, body DevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersMergeResponse, error) {
	rsp, err := c.DevUsersMerge(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersMergeResponse(rsp)
}

// DevUsersSelfWithResponse request returning *DevUsersSelfResponse
func (c *ClientWithResponses) DevUsersSelfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DevUsersSelfResponse, error) {
	rsp, err := c.DevUsersSelf(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfResponse(rsp)
}

// DevUsersSelfPostWithBodyWithResponse request with arbitrary body returning *DevUsersSelfPostResponse
func (c *ClientWithResponses) DevUsersSelfPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersSelfPostResponse, error) {
	rsp, err := c.DevUsersSelfPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfPostResponse(rsp)
}

func (c *ClientWithResponses) DevUsersSelfPostWithResponse(ctx context.Context, body DevUsersSelfPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersSelfPostResponse, error) {
	rsp, err := c.DevUsersSelfPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfPostResponse(rsp)
}

// DevUsersSelfUpdateWithBodyWithResponse request with arbitrary body returning *DevUsersSelfUpdateResponse
func (c *ClientWithResponses) DevUsersSelfUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersSelfUpdateResponse, error) {
	rsp, err := c.DevUsersSelfUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfUpdateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersSelfUpdateWithResponse(ctx context.Context, body DevUsersSelfUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersSelfUpdateResponse, error) {
	rsp, err := c.DevUsersSelfUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersSelfUpdateResponse(rsp)
}

// DevUsersUpdateWithBodyWithResponse request with arbitrary body returning *DevUsersUpdateResponse
func (c *ClientWithResponses) DevUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevUsersUpdateResponse, error) {
	rsp, err := c.DevUsersUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersUpdateResponse(rsp)
}

func (c *ClientWithResponses) DevUsersUpdateWithResponse(ctx context.Context, body DevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevUsersUpdateResponse, error) {
	rsp, err := c.DevUsersUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevUsersUpdateResponse(rsp)
}

// DirectoriesCountWithResponse request returning *DirectoriesCountResponse
func (c *ClientWithResponses) DirectoriesCountWithResponse(ctx context.Context, params *DirectoriesCountParams, reqEditors ...RequestEditorFn) (*DirectoriesCountResponse, error) {
	rsp, err := c.DirectoriesCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCountResponse(rsp)
}

// DirectoriesCountPostWithBodyWithResponse request with arbitrary body returning *DirectoriesCountPostResponse
func (c *ClientWithResponses) DirectoriesCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesCountPostResponse, error) {
	rsp, err := c.DirectoriesCountPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCountPostResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesCountPostWithResponse(ctx context.Context, body DirectoriesCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesCountPostResponse, error) {
	rsp, err := c.DirectoriesCountPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCountPostResponse(rsp)
}

// DirectoriesCreateWithBodyWithResponse request with arbitrary body returning *DirectoriesCreateResponse
func (c *ClientWithResponses) DirectoriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesCreateResponse, error) {
	rsp, err := c.DirectoriesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCreateResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesCreateWithResponse(ctx context.Context, body DirectoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesCreateResponse, error) {
	rsp, err := c.DirectoriesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesCreateResponse(rsp)
}

// DirectoriesDeleteWithBodyWithResponse request with arbitrary body returning *DirectoriesDeleteResponse
func (c *ClientWithResponses) DirectoriesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesDeleteResponse, error) {
	rsp, err := c.DirectoriesDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesDeleteResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesDeleteWithResponse(ctx context.Context, body DirectoriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesDeleteResponse, error) {
	rsp, err := c.DirectoriesDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesDeleteResponse(rsp)
}

// DirectoriesGetWithResponse request returning *DirectoriesGetResponse
func (c *ClientWithResponses) DirectoriesGetWithResponse(ctx context.Context, params *DirectoriesGetParams, reqEditors ...RequestEditorFn) (*DirectoriesGetResponse, error) {
	rsp, err := c.DirectoriesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesGetResponse(rsp)
}

// DirectoriesGetPostWithBodyWithResponse request with arbitrary body returning *DirectoriesGetPostResponse
func (c *ClientWithResponses) DirectoriesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesGetPostResponse, error) {
	rsp, err := c.DirectoriesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesGetPostResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesGetPostWithResponse(ctx context.Context, body DirectoriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesGetPostResponse, error) {
	rsp, err := c.DirectoriesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesGetPostResponse(rsp)
}

// DirectoriesListWithResponse request returning *DirectoriesListResponse
func (c *ClientWithResponses) DirectoriesListWithResponse(ctx context.Context, params *DirectoriesListParams, reqEditors ...RequestEditorFn) (*DirectoriesListResponse, error) {
	rsp, err := c.DirectoriesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesListResponse(rsp)
}

// DirectoriesListPostWithBodyWithResponse request with arbitrary body returning *DirectoriesListPostResponse
func (c *ClientWithResponses) DirectoriesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesListPostResponse, error) {
	rsp, err := c.DirectoriesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesListPostResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesListPostWithResponse(ctx context.Context, body DirectoriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesListPostResponse, error) {
	rsp, err := c.DirectoriesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesListPostResponse(rsp)
}

// DirectoriesUpdateWithBodyWithResponse request with arbitrary body returning *DirectoriesUpdateResponse
func (c *ClientWithResponses) DirectoriesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectoriesUpdateResponse, error) {
	rsp, err := c.DirectoriesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesUpdateResponse(rsp)
}

func (c *ClientWithResponses) DirectoriesUpdateWithResponse(ctx context.Context, body DirectoriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectoriesUpdateResponse, error) {
	rsp, err := c.DirectoriesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectoriesUpdateResponse(rsp)
}

// EngagementsCountWithResponse request returning *EngagementsCountResponse
func (c *ClientWithResponses) EngagementsCountWithResponse(ctx context.Context, params *EngagementsCountParams, reqEditors ...RequestEditorFn) (*EngagementsCountResponse, error) {
	rsp, err := c.EngagementsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsCountResponse(rsp)
}

// EngagementsCountPostWithBodyWithResponse request with arbitrary body returning *EngagementsCountPostResponse
func (c *ClientWithResponses) EngagementsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsCountPostResponse, error) {
	rsp, err := c.EngagementsCountPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsCountPostResponse(rsp)
}

func (c *ClientWithResponses) EngagementsCountPostWithResponse(ctx context.Context, body EngagementsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsCountPostResponse, error) {
	rsp, err := c.EngagementsCountPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsCountPostResponse(rsp)
}

// EngagementsCreateWithBodyWithResponse request with arbitrary body returning *EngagementsCreateResponse
func (c *ClientWithResponses) EngagementsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsCreateResponse, error) {
	rsp, err := c.EngagementsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsCreateResponse(rsp)
}

func (c *ClientWithResponses) EngagementsCreateWithResponse(ctx context.Context, body EngagementsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsCreateResponse, error) {
	rsp, err := c.EngagementsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsCreateResponse(rsp)
}

// EngagementsDeleteWithBodyWithResponse request with arbitrary body returning *EngagementsDeleteResponse
func (c *ClientWithResponses) EngagementsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsDeleteResponse, error) {
	rsp, err := c.EngagementsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsDeleteResponse(rsp)
}

func (c *ClientWithResponses) EngagementsDeleteWithResponse(ctx context.Context, body EngagementsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsDeleteResponse, error) {
	rsp, err := c.EngagementsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsDeleteResponse(rsp)
}

// EngagementsGetWithResponse request returning *EngagementsGetResponse
func (c *ClientWithResponses) EngagementsGetWithResponse(ctx context.Context, params *EngagementsGetParams, reqEditors ...RequestEditorFn) (*EngagementsGetResponse, error) {
	rsp, err := c.EngagementsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsGetResponse(rsp)
}

// EngagementsGetPostWithBodyWithResponse request with arbitrary body returning *EngagementsGetPostResponse
func (c *ClientWithResponses) EngagementsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsGetPostResponse, error) {
	rsp, err := c.EngagementsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsGetPostResponse(rsp)
}

func (c *ClientWithResponses) EngagementsGetPostWithResponse(ctx context.Context, body EngagementsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsGetPostResponse, error) {
	rsp, err := c.EngagementsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsGetPostResponse(rsp)
}

// EngagementsListWithResponse request returning *EngagementsListResponse
func (c *ClientWithResponses) EngagementsListWithResponse(ctx context.Context, params *EngagementsListParams, reqEditors ...RequestEditorFn) (*EngagementsListResponse, error) {
	rsp, err := c.EngagementsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsListResponse(rsp)
}

// EngagementsListPostWithBodyWithResponse request with arbitrary body returning *EngagementsListPostResponse
func (c *ClientWithResponses) EngagementsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsListPostResponse, error) {
	rsp, err := c.EngagementsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsListPostResponse(rsp)
}

func (c *ClientWithResponses) EngagementsListPostWithResponse(ctx context.Context, body EngagementsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsListPostResponse, error) {
	rsp, err := c.EngagementsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsListPostResponse(rsp)
}

// EngagementsUpdateWithBodyWithResponse request with arbitrary body returning *EngagementsUpdateResponse
func (c *ClientWithResponses) EngagementsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsUpdateResponse, error) {
	rsp, err := c.EngagementsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsUpdateResponse(rsp)
}

func (c *ClientWithResponses) EngagementsUpdateWithResponse(ctx context.Context, body EngagementsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsUpdateResponse, error) {
	rsp, err := c.EngagementsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsUpdateResponse(rsp)
}

// EventSourcesGetWithResponse request returning *EventSourcesGetResponse
func (c *ClientWithResponses) EventSourcesGetWithResponse(ctx context.Context, params *EventSourcesGetParams, reqEditors ...RequestEditorFn) (*EventSourcesGetResponse, error) {
	rsp, err := c.EventSourcesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventSourcesGetResponse(rsp)
}

// EventSourcesGetPostWithBodyWithResponse request with arbitrary body returning *EventSourcesGetPostResponse
func (c *ClientWithResponses) EventSourcesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventSourcesGetPostResponse, error) {
	rsp, err := c.EventSourcesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventSourcesGetPostResponse(rsp)
}

func (c *ClientWithResponses) EventSourcesGetPostWithResponse(ctx context.Context, body EventSourcesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EventSourcesGetPostResponse, error) {
	rsp, err := c.EventSourcesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventSourcesGetPostResponse(rsp)
}

// EventSourcesScheduleEventWithBodyWithResponse request with arbitrary body returning *EventSourcesScheduleEventResponse
func (c *ClientWithResponses) EventSourcesScheduleEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventSourcesScheduleEventResponse, error) {
	rsp, err := c.EventSourcesScheduleEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventSourcesScheduleEventResponse(rsp)
}

func (c *ClientWithResponses) EventSourcesScheduleEventWithResponse(ctx context.Context, body EventSourcesScheduleEventJSONRequestBody, reqEditors ...RequestEditorFn) (*EventSourcesScheduleEventResponse, error) {
	rsp, err := c.EventSourcesScheduleEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventSourcesScheduleEventResponse(rsp)
}

// EventSourcesDeleteScheduledEventWithBodyWithResponse request with arbitrary body returning *EventSourcesDeleteScheduledEventResponse
func (c *ClientWithResponses) EventSourcesDeleteScheduledEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventSourcesDeleteScheduledEventResponse, error) {
	rsp, err := c.EventSourcesDeleteScheduledEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventSourcesDeleteScheduledEventResponse(rsp)
}

func (c *ClientWithResponses) EventSourcesDeleteScheduledEventWithResponse(ctx context.Context, body EventSourcesDeleteScheduledEventJSONRequestBody, reqEditors ...RequestEditorFn) (*EventSourcesDeleteScheduledEventResponse, error) {
	rsp, err := c.EventSourcesDeleteScheduledEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventSourcesDeleteScheduledEventResponse(rsp)
}

// GroupsCreateWithBodyWithResponse request with arbitrary body returning *GroupsCreateResponse
func (c *ClientWithResponses) GroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error) {
	rsp, err := c.GroupsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) GroupsCreateWithResponse(ctx context.Context, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error) {
	rsp, err := c.GroupsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsCreateResponse(rsp)
}

// GroupsGetWithResponse request returning *GroupsGetResponse
func (c *ClientWithResponses) GroupsGetWithResponse(ctx context.Context, params *GroupsGetParams, reqEditors ...RequestEditorFn) (*GroupsGetResponse, error) {
	rsp, err := c.GroupsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsGetResponse(rsp)
}

// GroupsGetPostWithBodyWithResponse request with arbitrary body returning *GroupsGetPostResponse
func (c *ClientWithResponses) GroupsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsGetPostResponse, error) {
	rsp, err := c.GroupsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsGetPostResponse(rsp)
}

func (c *ClientWithResponses) GroupsGetPostWithResponse(ctx context.Context, body GroupsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsGetPostResponse, error) {
	rsp, err := c.GroupsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsGetPostResponse(rsp)
}

// GroupsListWithResponse request returning *GroupsListResponse
func (c *ClientWithResponses) GroupsListWithResponse(ctx context.Context, params *GroupsListParams, reqEditors ...RequestEditorFn) (*GroupsListResponse, error) {
	rsp, err := c.GroupsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsListResponse(rsp)
}

// GroupsListPostWithBodyWithResponse request with arbitrary body returning *GroupsListPostResponse
func (c *ClientWithResponses) GroupsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsListPostResponse, error) {
	rsp, err := c.GroupsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsListPostResponse(rsp)
}

func (c *ClientWithResponses) GroupsListPostWithResponse(ctx context.Context, body GroupsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsListPostResponse, error) {
	rsp, err := c.GroupsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsListPostResponse(rsp)
}

// GroupMembersAddWithBodyWithResponse request with arbitrary body returning *GroupMembersAddResponse
func (c *ClientWithResponses) GroupMembersAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersAddResponse, error) {
	rsp, err := c.GroupMembersAddWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersAddResponse(rsp)
}

func (c *ClientWithResponses) GroupMembersAddWithResponse(ctx context.Context, body GroupMembersAddJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersAddResponse, error) {
	rsp, err := c.GroupMembersAdd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersAddResponse(rsp)
}

// GroupMembersListWithResponse request returning *GroupMembersListResponse
func (c *ClientWithResponses) GroupMembersListWithResponse(ctx context.Context, params *GroupMembersListParams, reqEditors ...RequestEditorFn) (*GroupMembersListResponse, error) {
	rsp, err := c.GroupMembersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersListResponse(rsp)
}

// GroupMembersListPostWithBodyWithResponse request with arbitrary body returning *GroupMembersListPostResponse
func (c *ClientWithResponses) GroupMembersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersListPostResponse, error) {
	rsp, err := c.GroupMembersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersListPostResponse(rsp)
}

func (c *ClientWithResponses) GroupMembersListPostWithResponse(ctx context.Context, body GroupMembersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersListPostResponse, error) {
	rsp, err := c.GroupMembersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersListPostResponse(rsp)
}

// GroupMembersRemoveWithBodyWithResponse request with arbitrary body returning *GroupMembersRemoveResponse
func (c *ClientWithResponses) GroupMembersRemoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupMembersRemoveResponse, error) {
	rsp, err := c.GroupMembersRemoveWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersRemoveResponse(rsp)
}

func (c *ClientWithResponses) GroupMembersRemoveWithResponse(ctx context.Context, body GroupMembersRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupMembersRemoveResponse, error) {
	rsp, err := c.GroupMembersRemove(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupMembersRemoveResponse(rsp)
}

// GroupsUpdateWithBodyWithResponse request with arbitrary body returning *GroupsUpdateResponse
func (c *ClientWithResponses) GroupsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsUpdateResponse, error) {
	rsp, err := c.GroupsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsUpdateResponse(rsp)
}

func (c *ClientWithResponses) GroupsUpdateWithResponse(ctx context.Context, body GroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsUpdateResponse, error) {
	rsp, err := c.GroupsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsUpdateResponse(rsp)
}

// IncidentsCreateWithBodyWithResponse request with arbitrary body returning *IncidentsCreateResponse
func (c *ClientWithResponses) IncidentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsCreateResponse, error) {
	rsp, err := c.IncidentsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsCreateResponse(rsp)
}

func (c *ClientWithResponses) IncidentsCreateWithResponse(ctx context.Context, body IncidentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsCreateResponse, error) {
	rsp, err := c.IncidentsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsCreateResponse(rsp)
}

// IncidentsDeleteWithBodyWithResponse request with arbitrary body returning *IncidentsDeleteResponse
func (c *ClientWithResponses) IncidentsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsDeleteResponse, error) {
	rsp, err := c.IncidentsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsDeleteResponse(rsp)
}

func (c *ClientWithResponses) IncidentsDeleteWithResponse(ctx context.Context, body IncidentsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsDeleteResponse, error) {
	rsp, err := c.IncidentsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsDeleteResponse(rsp)
}

// IncidentsGetWithResponse request returning *IncidentsGetResponse
func (c *ClientWithResponses) IncidentsGetWithResponse(ctx context.Context, params *IncidentsGetParams, reqEditors ...RequestEditorFn) (*IncidentsGetResponse, error) {
	rsp, err := c.IncidentsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsGetResponse(rsp)
}

// IncidentsGetPostWithBodyWithResponse request with arbitrary body returning *IncidentsGetPostResponse
func (c *ClientWithResponses) IncidentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsGetPostResponse, error) {
	rsp, err := c.IncidentsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsGetPostResponse(rsp)
}

func (c *ClientWithResponses) IncidentsGetPostWithResponse(ctx context.Context, body IncidentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsGetPostResponse, error) {
	rsp, err := c.IncidentsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsGetPostResponse(rsp)
}

// IncidentsGroupWithResponse request returning *IncidentsGroupResponse
func (c *ClientWithResponses) IncidentsGroupWithResponse(ctx context.Context, params *IncidentsGroupParams, reqEditors ...RequestEditorFn) (*IncidentsGroupResponse, error) {
	rsp, err := c.IncidentsGroup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsGroupResponse(rsp)
}

// IncidentsGroupPostWithBodyWithResponse request with arbitrary body returning *IncidentsGroupPostResponse
func (c *ClientWithResponses) IncidentsGroupPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsGroupPostResponse, error) {
	rsp, err := c.IncidentsGroupPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsGroupPostResponse(rsp)
}

func (c *ClientWithResponses) IncidentsGroupPostWithResponse(ctx context.Context, body IncidentsGroupPostJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsGroupPostResponse, error) {
	rsp, err := c.IncidentsGroupPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsGroupPostResponse(rsp)
}

// IncidentsListWithResponse request returning *IncidentsListResponse
func (c *ClientWithResponses) IncidentsListWithResponse(ctx context.Context, params *IncidentsListParams, reqEditors ...RequestEditorFn) (*IncidentsListResponse, error) {
	rsp, err := c.IncidentsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsListResponse(rsp)
}

// IncidentsListPostWithBodyWithResponse request with arbitrary body returning *IncidentsListPostResponse
func (c *ClientWithResponses) IncidentsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsListPostResponse, error) {
	rsp, err := c.IncidentsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsListPostResponse(rsp)
}

func (c *ClientWithResponses) IncidentsListPostWithResponse(ctx context.Context, body IncidentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsListPostResponse, error) {
	rsp, err := c.IncidentsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsListPostResponse(rsp)
}

// IncidentsUpdateWithBodyWithResponse request with arbitrary body returning *IncidentsUpdateResponse
func (c *ClientWithResponses) IncidentsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncidentsUpdateResponse, error) {
	rsp, err := c.IncidentsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsUpdateResponse(rsp)
}

func (c *ClientWithResponses) IncidentsUpdateWithResponse(ctx context.Context, body IncidentsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*IncidentsUpdateResponse, error) {
	rsp, err := c.IncidentsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncidentsUpdateResponse(rsp)
}

// KeyringsCreateCallbackWithResponse request returning *KeyringsCreateCallbackResponse
func (c *ClientWithResponses) KeyringsCreateCallbackWithResponse(ctx context.Context, params *KeyringsCreateCallbackParams, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackResponse, error) {
	rsp, err := c.KeyringsCreateCallback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKeyringsCreateCallbackResponse(rsp)
}

// KeyringsCreateCallbackPostWithBodyWithResponse request with arbitrary body returning *KeyringsCreateCallbackPostResponse
func (c *ClientWithResponses) KeyringsCreateCallbackPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackPostResponse, error) {
	rsp, err := c.KeyringsCreateCallbackPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKeyringsCreateCallbackPostResponse(rsp)
}

func (c *ClientWithResponses) KeyringsCreateCallbackPostWithResponse(ctx context.Context, body KeyringsCreateCallbackPostJSONRequestBody, reqEditors ...RequestEditorFn) (*KeyringsCreateCallbackPostResponse, error) {
	rsp, err := c.KeyringsCreateCallbackPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKeyringsCreateCallbackPostResponse(rsp)
}

// CustomLinkTypeCreateWithBodyWithResponse request with arbitrary body returning *CustomLinkTypeCreateResponse
func (c *ClientWithResponses) CustomLinkTypeCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomLinkTypeCreateResponse, error) {
	rsp, err := c.CustomLinkTypeCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeCreateResponse(rsp)
}

func (c *ClientWithResponses) CustomLinkTypeCreateWithResponse(ctx context.Context, body CustomLinkTypeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomLinkTypeCreateResponse, error) {
	rsp, err := c.CustomLinkTypeCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeCreateResponse(rsp)
}

// CustomLinkTypeGetWithResponse request returning *CustomLinkTypeGetResponse
func (c *ClientWithResponses) CustomLinkTypeGetWithResponse(ctx context.Context, params *CustomLinkTypeGetParams, reqEditors ...RequestEditorFn) (*CustomLinkTypeGetResponse, error) {
	rsp, err := c.CustomLinkTypeGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeGetResponse(rsp)
}

// CustomLinkTypeGetPostWithBodyWithResponse request with arbitrary body returning *CustomLinkTypeGetPostResponse
func (c *ClientWithResponses) CustomLinkTypeGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomLinkTypeGetPostResponse, error) {
	rsp, err := c.CustomLinkTypeGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeGetPostResponse(rsp)
}

func (c *ClientWithResponses) CustomLinkTypeGetPostWithResponse(ctx context.Context, body CustomLinkTypeGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomLinkTypeGetPostResponse, error) {
	rsp, err := c.CustomLinkTypeGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeGetPostResponse(rsp)
}

// CustomLinkTypeListWithResponse request returning *CustomLinkTypeListResponse
func (c *ClientWithResponses) CustomLinkTypeListWithResponse(ctx context.Context, params *CustomLinkTypeListParams, reqEditors ...RequestEditorFn) (*CustomLinkTypeListResponse, error) {
	rsp, err := c.CustomLinkTypeList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeListResponse(rsp)
}

// CustomLinkTypeListPostWithBodyWithResponse request with arbitrary body returning *CustomLinkTypeListPostResponse
func (c *ClientWithResponses) CustomLinkTypeListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomLinkTypeListPostResponse, error) {
	rsp, err := c.CustomLinkTypeListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeListPostResponse(rsp)
}

func (c *ClientWithResponses) CustomLinkTypeListPostWithResponse(ctx context.Context, body CustomLinkTypeListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomLinkTypeListPostResponse, error) {
	rsp, err := c.CustomLinkTypeListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeListPostResponse(rsp)
}

// CustomLinkTypeUpdateWithBodyWithResponse request with arbitrary body returning *CustomLinkTypeUpdateResponse
func (c *ClientWithResponses) CustomLinkTypeUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomLinkTypeUpdateResponse, error) {
	rsp, err := c.CustomLinkTypeUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeUpdateResponse(rsp)
}

func (c *ClientWithResponses) CustomLinkTypeUpdateWithResponse(ctx context.Context, body CustomLinkTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomLinkTypeUpdateResponse, error) {
	rsp, err := c.CustomLinkTypeUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomLinkTypeUpdateResponse(rsp)
}

// LinksCreateWithBodyWithResponse request with arbitrary body returning *LinksCreateResponse
func (c *ClientWithResponses) LinksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksCreateResponse, error) {
	rsp, err := c.LinksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksCreateResponse(rsp)
}

func (c *ClientWithResponses) LinksCreateWithResponse(ctx context.Context, body LinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksCreateResponse, error) {
	rsp, err := c.LinksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksCreateResponse(rsp)
}

// LinksDeleteWithBodyWithResponse request with arbitrary body returning *LinksDeleteResponse
func (c *ClientWithResponses) LinksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksDeleteResponse, error) {
	rsp, err := c.LinksDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksDeleteResponse(rsp)
}

func (c *ClientWithResponses) LinksDeleteWithResponse(ctx context.Context, body LinksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksDeleteResponse, error) {
	rsp, err := c.LinksDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksDeleteResponse(rsp)
}

// LinksGetWithResponse request returning *LinksGetResponse
func (c *ClientWithResponses) LinksGetWithResponse(ctx context.Context, params *LinksGetParams, reqEditors ...RequestEditorFn) (*LinksGetResponse, error) {
	rsp, err := c.LinksGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksGetResponse(rsp)
}

// LinksGetPostWithBodyWithResponse request with arbitrary body returning *LinksGetPostResponse
func (c *ClientWithResponses) LinksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksGetPostResponse, error) {
	rsp, err := c.LinksGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksGetPostResponse(rsp)
}

func (c *ClientWithResponses) LinksGetPostWithResponse(ctx context.Context, body LinksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksGetPostResponse, error) {
	rsp, err := c.LinksGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksGetPostResponse(rsp)
}

// LinksListWithResponse request returning *LinksListResponse
func (c *ClientWithResponses) LinksListWithResponse(ctx context.Context, params *LinksListParams, reqEditors ...RequestEditorFn) (*LinksListResponse, error) {
	rsp, err := c.LinksList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksListResponse(rsp)
}

// LinksListPostWithBodyWithResponse request with arbitrary body returning *LinksListPostResponse
func (c *ClientWithResponses) LinksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksListPostResponse, error) {
	rsp, err := c.LinksListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksListPostResponse(rsp)
}

func (c *ClientWithResponses) LinksListPostWithResponse(ctx context.Context, body LinksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksListPostResponse, error) {
	rsp, err := c.LinksListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksListPostResponse(rsp)
}

// LinksReplaceWithBodyWithResponse request with arbitrary body returning *LinksReplaceResponse
func (c *ClientWithResponses) LinksReplaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinksReplaceResponse, error) {
	rsp, err := c.LinksReplaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksReplaceResponse(rsp)
}

func (c *ClientWithResponses) LinksReplaceWithResponse(ctx context.Context, body LinksReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*LinksReplaceResponse, error) {
	rsp, err := c.LinksReplace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinksReplaceResponse(rsp)
}

// MeetingsCountWithResponse request returning *MeetingsCountResponse
func (c *ClientWithResponses) MeetingsCountWithResponse(ctx context.Context, params *MeetingsCountParams, reqEditors ...RequestEditorFn) (*MeetingsCountResponse, error) {
	rsp, err := c.MeetingsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCountResponse(rsp)
}

// MeetingsCountPostWithBodyWithResponse request with arbitrary body returning *MeetingsCountPostResponse
func (c *ClientWithResponses) MeetingsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsCountPostResponse, error) {
	rsp, err := c.MeetingsCountPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCountPostResponse(rsp)
}

func (c *ClientWithResponses) MeetingsCountPostWithResponse(ctx context.Context, body MeetingsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsCountPostResponse, error) {
	rsp, err := c.MeetingsCountPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCountPostResponse(rsp)
}

// MeetingsCreateWithBodyWithResponse request with arbitrary body returning *MeetingsCreateResponse
func (c *ClientWithResponses) MeetingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsCreateResponse, error) {
	rsp, err := c.MeetingsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCreateResponse(rsp)
}

func (c *ClientWithResponses) MeetingsCreateWithResponse(ctx context.Context, body MeetingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsCreateResponse, error) {
	rsp, err := c.MeetingsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsCreateResponse(rsp)
}

// MeetingsDeleteWithBodyWithResponse request with arbitrary body returning *MeetingsDeleteResponse
func (c *ClientWithResponses) MeetingsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsDeleteResponse, error) {
	rsp, err := c.MeetingsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsDeleteResponse(rsp)
}

func (c *ClientWithResponses) MeetingsDeleteWithResponse(ctx context.Context, body MeetingsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsDeleteResponse, error) {
	rsp, err := c.MeetingsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsDeleteResponse(rsp)
}

// MeetingsGetWithResponse request returning *MeetingsGetResponse
func (c *ClientWithResponses) MeetingsGetWithResponse(ctx context.Context, params *MeetingsGetParams, reqEditors ...RequestEditorFn) (*MeetingsGetResponse, error) {
	rsp, err := c.MeetingsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsGetResponse(rsp)
}

// MeetingsGetPostWithBodyWithResponse request with arbitrary body returning *MeetingsGetPostResponse
func (c *ClientWithResponses) MeetingsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsGetPostResponse, error) {
	rsp, err := c.MeetingsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsGetPostResponse(rsp)
}

func (c *ClientWithResponses) MeetingsGetPostWithResponse(ctx context.Context, body MeetingsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsGetPostResponse, error) {
	rsp, err := c.MeetingsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsGetPostResponse(rsp)
}

// MeetingsListWithResponse request returning *MeetingsListResponse
func (c *ClientWithResponses) MeetingsListWithResponse(ctx context.Context, params *MeetingsListParams, reqEditors ...RequestEditorFn) (*MeetingsListResponse, error) {
	rsp, err := c.MeetingsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsListResponse(rsp)
}

// MeetingsListPostWithBodyWithResponse request with arbitrary body returning *MeetingsListPostResponse
func (c *ClientWithResponses) MeetingsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsListPostResponse, error) {
	rsp, err := c.MeetingsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsListPostResponse(rsp)
}

func (c *ClientWithResponses) MeetingsListPostWithResponse(ctx context.Context, body MeetingsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsListPostResponse, error) {
	rsp, err := c.MeetingsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsListPostResponse(rsp)
}

// MeetingsUpdateWithBodyWithResponse request with arbitrary body returning *MeetingsUpdateResponse
func (c *ClientWithResponses) MeetingsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingsUpdateResponse, error) {
	rsp, err := c.MeetingsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsUpdateResponse(rsp)
}

func (c *ClientWithResponses) MeetingsUpdateWithResponse(ctx context.Context, body MeetingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingsUpdateResponse, error) {
	rsp, err := c.MeetingsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsUpdateResponse(rsp)
}

// MetricActionExecuteWithBodyWithResponse request with arbitrary body returning *MetricActionExecuteResponse
func (c *ClientWithResponses) MetricActionExecuteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricActionExecuteResponse, error) {
	rsp, err := c.MetricActionExecuteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricActionExecuteResponse(rsp)
}

func (c *ClientWithResponses) MetricActionExecuteWithResponse(ctx context.Context, body MetricActionExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricActionExecuteResponse, error) {
	rsp, err := c.MetricActionExecute(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricActionExecuteResponse(rsp)
}

// MetricDefinitionsCreateWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsCreateResponse
func (c *ClientWithResponses) MetricDefinitionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsCreateResponse, error) {
	rsp, err := c.MetricDefinitionsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsCreateResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsCreateWithResponse(ctx context.Context, body MetricDefinitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsCreateResponse, error) {
	rsp, err := c.MetricDefinitionsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsCreateResponse(rsp)
}

// MetricDefinitionsDeleteWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsDeleteResponse
func (c *ClientWithResponses) MetricDefinitionsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsDeleteResponse, error) {
	rsp, err := c.MetricDefinitionsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsDeleteResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsDeleteWithResponse(ctx context.Context, body MetricDefinitionsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsDeleteResponse, error) {
	rsp, err := c.MetricDefinitionsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsDeleteResponse(rsp)
}

// MetricDefinitionsGetWithResponse request returning *MetricDefinitionsGetResponse
func (c *ClientWithResponses) MetricDefinitionsGetWithResponse(ctx context.Context, params *MetricDefinitionsGetParams, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetResponse, error) {
	rsp, err := c.MetricDefinitionsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsGetResponse(rsp)
}

// MetricDefinitionsGetPostWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsGetPostResponse
func (c *ClientWithResponses) MetricDefinitionsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetPostResponse, error) {
	rsp, err := c.MetricDefinitionsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsGetPostResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsGetPostWithResponse(ctx context.Context, body MetricDefinitionsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsGetPostResponse, error) {
	rsp, err := c.MetricDefinitionsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsGetPostResponse(rsp)
}

// MetricDefinitionsListWithResponse request returning *MetricDefinitionsListResponse
func (c *ClientWithResponses) MetricDefinitionsListWithResponse(ctx context.Context, params *MetricDefinitionsListParams, reqEditors ...RequestEditorFn) (*MetricDefinitionsListResponse, error) {
	rsp, err := c.MetricDefinitionsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsListResponse(rsp)
}

// MetricDefinitionsListPostWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsListPostResponse
func (c *ClientWithResponses) MetricDefinitionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsListPostResponse, error) {
	rsp, err := c.MetricDefinitionsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsListPostResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsListPostWithResponse(ctx context.Context, body MetricDefinitionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsListPostResponse, error) {
	rsp, err := c.MetricDefinitionsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsListPostResponse(rsp)
}

// MetricDefinitionsUpdateWithBodyWithResponse request with arbitrary body returning *MetricDefinitionsUpdateResponse
func (c *ClientWithResponses) MetricDefinitionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricDefinitionsUpdateResponse, error) {
	rsp, err := c.MetricDefinitionsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsUpdateResponse(rsp)
}

func (c *ClientWithResponses) MetricDefinitionsUpdateWithResponse(ctx context.Context, body MetricDefinitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricDefinitionsUpdateResponse, error) {
	rsp, err := c.MetricDefinitionsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricDefinitionsUpdateResponse(rsp)
}

// MetricTrackersGetWithResponse request returning *MetricTrackersGetResponse
func (c *ClientWithResponses) MetricTrackersGetWithResponse(ctx context.Context, params *MetricTrackersGetParams, reqEditors ...RequestEditorFn) (*MetricTrackersGetResponse, error) {
	rsp, err := c.MetricTrackersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricTrackersGetResponse(rsp)
}

// MetricTrackersGetPostWithBodyWithResponse request with arbitrary body returning *MetricTrackersGetPostResponse
func (c *ClientWithResponses) MetricTrackersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricTrackersGetPostResponse, error) {
	rsp, err := c.MetricTrackersGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricTrackersGetPostResponse(rsp)
}

func (c *ClientWithResponses) MetricTrackersGetPostWithResponse(ctx context.Context, body MetricTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricTrackersGetPostResponse, error) {
	rsp, err := c.MetricTrackersGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricTrackersGetPostResponse(rsp)
}

// MetricsDevrevIngestWithBodyWithResponse request with arbitrary body returning *MetricsDevrevIngestResponse
func (c *ClientWithResponses) MetricsDevrevIngestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetricsDevrevIngestResponse, error) {
	rsp, err := c.MetricsDevrevIngestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsDevrevIngestResponse(rsp)
}

func (c *ClientWithResponses) MetricsDevrevIngestWithResponse(ctx context.Context, body MetricsDevrevIngestJSONRequestBody, reqEditors ...RequestEditorFn) (*MetricsDevrevIngestResponse, error) {
	rsp, err := c.MetricsDevrevIngest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsDevrevIngestResponse(rsp)
}

// NotificationsSendWithBodyWithResponse request with arbitrary body returning *NotificationsSendResponse
func (c *ClientWithResponses) NotificationsSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationsSendResponse, error) {
	rsp, err := c.NotificationsSendWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsSendResponse(rsp)
}

func (c *ClientWithResponses) NotificationsSendWithResponse(ctx context.Context, body NotificationsSendJSONRequestBody, reqEditors ...RequestEditorFn) (*NotificationsSendResponse, error) {
	rsp, err := c.NotificationsSend(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsSendResponse(rsp)
}

// OrgScheduleFragmentsCreateWithBodyWithResponse request with arbitrary body returning *OrgScheduleFragmentsCreateResponse
func (c *ClientWithResponses) OrgScheduleFragmentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsCreateResponse, error) {
	rsp, err := c.OrgScheduleFragmentsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsCreateResponse(rsp)
}

func (c *ClientWithResponses) OrgScheduleFragmentsCreateWithResponse(ctx context.Context, body OrgScheduleFragmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsCreateResponse, error) {
	rsp, err := c.OrgScheduleFragmentsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsCreateResponse(rsp)
}

// OrgScheduleFragmentsGetWithResponse request returning *OrgScheduleFragmentsGetResponse
func (c *ClientWithResponses) OrgScheduleFragmentsGetWithResponse(ctx context.Context, params *OrgScheduleFragmentsGetParams, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetResponse, error) {
	rsp, err := c.OrgScheduleFragmentsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsGetResponse(rsp)
}

// OrgScheduleFragmentsGetPostWithBodyWithResponse request with arbitrary body returning *OrgScheduleFragmentsGetPostResponse
func (c *ClientWithResponses) OrgScheduleFragmentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetPostResponse, error) {
	rsp, err := c.OrgScheduleFragmentsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsGetPostResponse(rsp)
}

func (c *ClientWithResponses) OrgScheduleFragmentsGetPostWithResponse(ctx context.Context, body OrgScheduleFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsGetPostResponse, error) {
	rsp, err := c.OrgScheduleFragmentsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsGetPostResponse(rsp)
}

// OrgScheduleFragmentsTransitionWithBodyWithResponse request with arbitrary body returning *OrgScheduleFragmentsTransitionResponse
func (c *ClientWithResponses) OrgScheduleFragmentsTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsTransitionResponse, error) {
	rsp, err := c.OrgScheduleFragmentsTransitionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsTransitionResponse(rsp)
}

func (c *ClientWithResponses) OrgScheduleFragmentsTransitionWithResponse(ctx context.Context, body OrgScheduleFragmentsTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgScheduleFragmentsTransitionResponse, error) {
	rsp, err := c.OrgScheduleFragmentsTransition(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgScheduleFragmentsTransitionResponse(rsp)
}

// OrgSchedulesCreateWithBodyWithResponse request with arbitrary body returning *OrgSchedulesCreateResponse
func (c *ClientWithResponses) OrgSchedulesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesCreateResponse, error) {
	rsp, err := c.OrgSchedulesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesCreateResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesCreateWithResponse(ctx context.Context, body OrgSchedulesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesCreateResponse, error) {
	rsp, err := c.OrgSchedulesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesCreateResponse(rsp)
}

// OrgSchedulesEvaluateWithResponse request returning *OrgSchedulesEvaluateResponse
func (c *ClientWithResponses) OrgSchedulesEvaluateWithResponse(ctx context.Context, params *OrgSchedulesEvaluateParams, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluateResponse, error) {
	rsp, err := c.OrgSchedulesEvaluate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesEvaluateResponse(rsp)
}

// OrgSchedulesEvaluatePostWithBodyWithResponse request with arbitrary body returning *OrgSchedulesEvaluatePostResponse
func (c *ClientWithResponses) OrgSchedulesEvaluatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluatePostResponse, error) {
	rsp, err := c.OrgSchedulesEvaluatePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesEvaluatePostResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesEvaluatePostWithResponse(ctx context.Context, body OrgSchedulesEvaluatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesEvaluatePostResponse, error) {
	rsp, err := c.OrgSchedulesEvaluatePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesEvaluatePostResponse(rsp)
}

// OrgSchedulesGetWithResponse request returning *OrgSchedulesGetResponse
func (c *ClientWithResponses) OrgSchedulesGetWithResponse(ctx context.Context, params *OrgSchedulesGetParams, reqEditors ...RequestEditorFn) (*OrgSchedulesGetResponse, error) {
	rsp, err := c.OrgSchedulesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesGetResponse(rsp)
}

// OrgSchedulesGetPostWithBodyWithResponse request with arbitrary body returning *OrgSchedulesGetPostResponse
func (c *ClientWithResponses) OrgSchedulesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesGetPostResponse, error) {
	rsp, err := c.OrgSchedulesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesGetPostResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesGetPostWithResponse(ctx context.Context, body OrgSchedulesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesGetPostResponse, error) {
	rsp, err := c.OrgSchedulesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesGetPostResponse(rsp)
}

// OrgSchedulesListWithResponse request returning *OrgSchedulesListResponse
func (c *ClientWithResponses) OrgSchedulesListWithResponse(ctx context.Context, params *OrgSchedulesListParams, reqEditors ...RequestEditorFn) (*OrgSchedulesListResponse, error) {
	rsp, err := c.OrgSchedulesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesListResponse(rsp)
}

// OrgSchedulesListPostWithBodyWithResponse request with arbitrary body returning *OrgSchedulesListPostResponse
func (c *ClientWithResponses) OrgSchedulesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesListPostResponse, error) {
	rsp, err := c.OrgSchedulesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesListPostResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesListPostWithResponse(ctx context.Context, body OrgSchedulesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesListPostResponse, error) {
	rsp, err := c.OrgSchedulesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesListPostResponse(rsp)
}

// OrgSchedulesSetFutureWithBodyWithResponse request with arbitrary body returning *OrgSchedulesSetFutureResponse
func (c *ClientWithResponses) OrgSchedulesSetFutureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesSetFutureResponse, error) {
	rsp, err := c.OrgSchedulesSetFutureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesSetFutureResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesSetFutureWithResponse(ctx context.Context, body OrgSchedulesSetFutureJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesSetFutureResponse, error) {
	rsp, err := c.OrgSchedulesSetFuture(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesSetFutureResponse(rsp)
}

// OrgSchedulesTransitionWithBodyWithResponse request with arbitrary body returning *OrgSchedulesTransitionResponse
func (c *ClientWithResponses) OrgSchedulesTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesTransitionResponse, error) {
	rsp, err := c.OrgSchedulesTransitionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesTransitionResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesTransitionWithResponse(ctx context.Context, body OrgSchedulesTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesTransitionResponse, error) {
	rsp, err := c.OrgSchedulesTransition(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesTransitionResponse(rsp)
}

// OrgSchedulesUpdateWithBodyWithResponse request with arbitrary body returning *OrgSchedulesUpdateResponse
func (c *ClientWithResponses) OrgSchedulesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgSchedulesUpdateResponse, error) {
	rsp, err := c.OrgSchedulesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesUpdateResponse(rsp)
}

func (c *ClientWithResponses) OrgSchedulesUpdateWithResponse(ctx context.Context, body OrgSchedulesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgSchedulesUpdateResponse, error) {
	rsp, err := c.OrgSchedulesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgSchedulesUpdateResponse(rsp)
}

// PartsCreateWithBodyWithResponse request with arbitrary body returning *PartsCreateResponse
func (c *ClientWithResponses) PartsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsCreateResponse, error) {
	rsp, err := c.PartsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsCreateResponse(rsp)
}

func (c *ClientWithResponses) PartsCreateWithResponse(ctx context.Context, body PartsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsCreateResponse, error) {
	rsp, err := c.PartsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsCreateResponse(rsp)
}

// PartsDeleteWithBodyWithResponse request with arbitrary body returning *PartsDeleteResponse
func (c *ClientWithResponses) PartsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsDeleteResponse, error) {
	rsp, err := c.PartsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsDeleteResponse(rsp)
}

func (c *ClientWithResponses) PartsDeleteWithResponse(ctx context.Context, body PartsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsDeleteResponse, error) {
	rsp, err := c.PartsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsDeleteResponse(rsp)
}

// PartsGetWithResponse request returning *PartsGetResponse
func (c *ClientWithResponses) PartsGetWithResponse(ctx context.Context, params *PartsGetParams, reqEditors ...RequestEditorFn) (*PartsGetResponse, error) {
	rsp, err := c.PartsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsGetResponse(rsp)
}

// PartsGetPostWithBodyWithResponse request with arbitrary body returning *PartsGetPostResponse
func (c *ClientWithResponses) PartsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsGetPostResponse, error) {
	rsp, err := c.PartsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsGetPostResponse(rsp)
}

func (c *ClientWithResponses) PartsGetPostWithResponse(ctx context.Context, body PartsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsGetPostResponse, error) {
	rsp, err := c.PartsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsGetPostResponse(rsp)
}

// PartsListWithResponse request returning *PartsListResponse
func (c *ClientWithResponses) PartsListWithResponse(ctx context.Context, params *PartsListParams, reqEditors ...RequestEditorFn) (*PartsListResponse, error) {
	rsp, err := c.PartsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsListResponse(rsp)
}

// PartsListPostWithBodyWithResponse request with arbitrary body returning *PartsListPostResponse
func (c *ClientWithResponses) PartsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsListPostResponse, error) {
	rsp, err := c.PartsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsListPostResponse(rsp)
}

func (c *ClientWithResponses) PartsListPostWithResponse(ctx context.Context, body PartsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsListPostResponse, error) {
	rsp, err := c.PartsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsListPostResponse(rsp)
}

// PartsUpdateWithBodyWithResponse request with arbitrary body returning *PartsUpdateResponse
func (c *ClientWithResponses) PartsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartsUpdateResponse, error) {
	rsp, err := c.PartsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsUpdateResponse(rsp)
}

func (c *ClientWithResponses) PartsUpdateWithResponse(ctx context.Context, body PartsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartsUpdateResponse, error) {
	rsp, err := c.PartsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePartsUpdateResponse(rsp)
}

// PreferencesGetWithResponse request returning *PreferencesGetResponse
func (c *ClientWithResponses) PreferencesGetWithResponse(ctx context.Context, params *PreferencesGetParams, reqEditors ...RequestEditorFn) (*PreferencesGetResponse, error) {
	rsp, err := c.PreferencesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreferencesGetResponse(rsp)
}

// PreferencesGetPostWithBodyWithResponse request with arbitrary body returning *PreferencesGetPostResponse
func (c *ClientWithResponses) PreferencesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreferencesGetPostResponse, error) {
	rsp, err := c.PreferencesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreferencesGetPostResponse(rsp)
}

func (c *ClientWithResponses) PreferencesGetPostWithResponse(ctx context.Context, body PreferencesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PreferencesGetPostResponse, error) {
	rsp, err := c.PreferencesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreferencesGetPostResponse(rsp)
}

// PreferencesUpdateWithBodyWithResponse request with arbitrary body returning *PreferencesUpdateResponse
func (c *ClientWithResponses) PreferencesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreferencesUpdateResponse, error) {
	rsp, err := c.PreferencesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreferencesUpdateResponse(rsp)
}

func (c *ClientWithResponses) PreferencesUpdateWithResponse(ctx context.Context, body PreferencesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreferencesUpdateResponse, error) {
	rsp, err := c.PreferencesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreferencesUpdateResponse(rsp)
}

// CreateQuestionAnswerWithBodyWithResponse request with arbitrary body returning *CreateQuestionAnswerResponse
func (c *ClientWithResponses) CreateQuestionAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQuestionAnswerResponse, error) {
	rsp, err := c.CreateQuestionAnswerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQuestionAnswerResponse(rsp)
}

func (c *ClientWithResponses) CreateQuestionAnswerWithResponse(ctx context.Context, body CreateQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQuestionAnswerResponse, error) {
	rsp, err := c.CreateQuestionAnswer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQuestionAnswerResponse(rsp)
}

// DeleteQuestionAnswerWithBodyWithResponse request with arbitrary body returning *DeleteQuestionAnswerResponse
func (c *ClientWithResponses) DeleteQuestionAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteQuestionAnswerResponse, error) {
	rsp, err := c.DeleteQuestionAnswerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQuestionAnswerResponse(rsp)
}

func (c *ClientWithResponses) DeleteQuestionAnswerWithResponse(ctx context.Context, body DeleteQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteQuestionAnswerResponse, error) {
	rsp, err := c.DeleteQuestionAnswer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQuestionAnswerResponse(rsp)
}

// GetQuestionAnswerWithResponse request returning *GetQuestionAnswerResponse
func (c *ClientWithResponses) GetQuestionAnswerWithResponse(ctx context.Context, params *GetQuestionAnswerParams, reqEditors ...RequestEditorFn) (*GetQuestionAnswerResponse, error) {
	rsp, err := c.GetQuestionAnswer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQuestionAnswerResponse(rsp)
}

// GetQuestionAnswerPostWithBodyWithResponse request with arbitrary body returning *GetQuestionAnswerPostResponse
func (c *ClientWithResponses) GetQuestionAnswerPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetQuestionAnswerPostResponse, error) {
	rsp, err := c.GetQuestionAnswerPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQuestionAnswerPostResponse(rsp)
}

func (c *ClientWithResponses) GetQuestionAnswerPostWithResponse(ctx context.Context, body GetQuestionAnswerPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetQuestionAnswerPostResponse, error) {
	rsp, err := c.GetQuestionAnswerPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQuestionAnswerPostResponse(rsp)
}

// ListQuestionAnswersWithResponse request returning *ListQuestionAnswersResponse
func (c *ClientWithResponses) ListQuestionAnswersWithResponse(ctx context.Context, params *ListQuestionAnswersParams, reqEditors ...RequestEditorFn) (*ListQuestionAnswersResponse, error) {
	rsp, err := c.ListQuestionAnswers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQuestionAnswersResponse(rsp)
}

// ListQuestionAnswersPostWithBodyWithResponse request with arbitrary body returning *ListQuestionAnswersPostResponse
func (c *ClientWithResponses) ListQuestionAnswersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListQuestionAnswersPostResponse, error) {
	rsp, err := c.ListQuestionAnswersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQuestionAnswersPostResponse(rsp)
}

func (c *ClientWithResponses) ListQuestionAnswersPostWithResponse(ctx context.Context, body ListQuestionAnswersPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListQuestionAnswersPostResponse, error) {
	rsp, err := c.ListQuestionAnswersPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQuestionAnswersPostResponse(rsp)
}

// UpdateQuestionAnswerWithBodyWithResponse request with arbitrary body returning *UpdateQuestionAnswerResponse
func (c *ClientWithResponses) UpdateQuestionAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateQuestionAnswerResponse, error) {
	rsp, err := c.UpdateQuestionAnswerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateQuestionAnswerResponse(rsp)
}

func (c *ClientWithResponses) UpdateQuestionAnswerWithResponse(ctx context.Context, body UpdateQuestionAnswerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateQuestionAnswerResponse, error) {
	rsp, err := c.UpdateQuestionAnswer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateQuestionAnswerResponse(rsp)
}

// ReactionsListWithResponse request returning *ReactionsListResponse
func (c *ClientWithResponses) ReactionsListWithResponse(ctx context.Context, params *ReactionsListParams, reqEditors ...RequestEditorFn) (*ReactionsListResponse, error) {
	rsp, err := c.ReactionsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsListResponse(rsp)
}

// ReactionsListPostWithBodyWithResponse request with arbitrary body returning *ReactionsListPostResponse
func (c *ClientWithResponses) ReactionsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionsListPostResponse, error) {
	rsp, err := c.ReactionsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsListPostResponse(rsp)
}

func (c *ClientWithResponses) ReactionsListPostWithResponse(ctx context.Context, body ReactionsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionsListPostResponse, error) {
	rsp, err := c.ReactionsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsListPostResponse(rsp)
}

// ReactionsUpdateWithBodyWithResponse request with arbitrary body returning *ReactionsUpdateResponse
func (c *ClientWithResponses) ReactionsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionsUpdateResponse, error) {
	rsp, err := c.ReactionsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ReactionsUpdateWithResponse(ctx context.Context, body ReactionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionsUpdateResponse, error) {
	rsp, err := c.ReactionsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsUpdateResponse(rsp)
}

// ChatCompletionsWithBodyWithResponse request with arbitrary body returning *ChatCompletionsResponse
func (c *ClientWithResponses) ChatCompletionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatCompletionsResponse, error) {
	rsp, err := c.ChatCompletionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatCompletionsResponse(rsp)
}

func (c *ClientWithResponses) ChatCompletionsWithResponse(ctx context.Context, body ChatCompletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatCompletionsResponse, error) {
	rsp, err := c.ChatCompletions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatCompletionsResponse(rsp)
}

// GetReplyWithBodyWithResponse request with arbitrary body returning *GetReplyResponse
func (c *ClientWithResponses) GetReplyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetReplyResponse, error) {
	rsp, err := c.GetReplyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplyResponse(rsp)
}

func (c *ClientWithResponses) GetReplyWithResponse(ctx context.Context, body GetReplyJSONRequestBody, reqEditors ...RequestEditorFn) (*GetReplyResponse, error) {
	rsp, err := c.GetReply(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplyResponse(rsp)
}

// RecordTemplateGetWithResponse request returning *RecordTemplateGetResponse
func (c *ClientWithResponses) RecordTemplateGetWithResponse(ctx context.Context, params *RecordTemplateGetParams, reqEditors ...RequestEditorFn) (*RecordTemplateGetResponse, error) {
	rsp, err := c.RecordTemplateGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordTemplateGetResponse(rsp)
}

// RecordTemplateGetPostWithBodyWithResponse request with arbitrary body returning *RecordTemplateGetPostResponse
func (c *ClientWithResponses) RecordTemplateGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecordTemplateGetPostResponse, error) {
	rsp, err := c.RecordTemplateGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordTemplateGetPostResponse(rsp)
}

func (c *ClientWithResponses) RecordTemplateGetPostWithResponse(ctx context.Context, body RecordTemplateGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RecordTemplateGetPostResponse, error) {
	rsp, err := c.RecordTemplateGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordTemplateGetPostResponse(rsp)
}

// RevOrgsCreateWithBodyWithResponse request with arbitrary body returning *RevOrgsCreateResponse
func (c *ClientWithResponses) RevOrgsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsCreateResponse, error) {
	rsp, err := c.RevOrgsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsCreateResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsCreateWithResponse(ctx context.Context, body RevOrgsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsCreateResponse, error) {
	rsp, err := c.RevOrgsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsCreateResponse(rsp)
}

// RevOrgsDeleteWithBodyWithResponse request with arbitrary body returning *RevOrgsDeleteResponse
func (c *ClientWithResponses) RevOrgsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsDeleteResponse, error) {
	rsp, err := c.RevOrgsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsDeleteResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsDeleteWithResponse(ctx context.Context, body RevOrgsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsDeleteResponse, error) {
	rsp, err := c.RevOrgsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsDeleteResponse(rsp)
}

// RevOrgsGetWithResponse request returning *RevOrgsGetResponse
func (c *ClientWithResponses) RevOrgsGetWithResponse(ctx context.Context, params *RevOrgsGetParams, reqEditors ...RequestEditorFn) (*RevOrgsGetResponse, error) {
	rsp, err := c.RevOrgsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsGetResponse(rsp)
}

// RevOrgsGetPostWithBodyWithResponse request with arbitrary body returning *RevOrgsGetPostResponse
func (c *ClientWithResponses) RevOrgsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsGetPostResponse, error) {
	rsp, err := c.RevOrgsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsGetPostResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsGetPostWithResponse(ctx context.Context, body RevOrgsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsGetPostResponse, error) {
	rsp, err := c.RevOrgsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsGetPostResponse(rsp)
}

// RevOrgsListWithResponse request returning *RevOrgsListResponse
func (c *ClientWithResponses) RevOrgsListWithResponse(ctx context.Context, params *RevOrgsListParams, reqEditors ...RequestEditorFn) (*RevOrgsListResponse, error) {
	rsp, err := c.RevOrgsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsListResponse(rsp)
}

// RevOrgsListPostWithBodyWithResponse request with arbitrary body returning *RevOrgsListPostResponse
func (c *ClientWithResponses) RevOrgsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsListPostResponse, error) {
	rsp, err := c.RevOrgsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsListPostResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsListPostWithResponse(ctx context.Context, body RevOrgsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsListPostResponse, error) {
	rsp, err := c.RevOrgsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsListPostResponse(rsp)
}

// RevOrgsUpdateWithBodyWithResponse request with arbitrary body returning *RevOrgsUpdateResponse
func (c *ClientWithResponses) RevOrgsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevOrgsUpdateResponse, error) {
	rsp, err := c.RevOrgsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsUpdateResponse(rsp)
}

func (c *ClientWithResponses) RevOrgsUpdateWithResponse(ctx context.Context, body RevOrgsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevOrgsUpdateResponse, error) {
	rsp, err := c.RevOrgsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevOrgsUpdateResponse(rsp)
}

// RevUsersAssociationsAddWithBodyWithResponse request with arbitrary body returning *RevUsersAssociationsAddResponse
func (c *ClientWithResponses) RevUsersAssociationsAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersAssociationsAddResponse, error) {
	rsp, err := c.RevUsersAssociationsAddWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersAssociationsAddResponse(rsp)
}

func (c *ClientWithResponses) RevUsersAssociationsAddWithResponse(ctx context.Context, body RevUsersAssociationsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersAssociationsAddResponse, error) {
	rsp, err := c.RevUsersAssociationsAdd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersAssociationsAddResponse(rsp)
}

// RevUsersAssociationsListWithResponse request returning *RevUsersAssociationsListResponse
func (c *ClientWithResponses) RevUsersAssociationsListWithResponse(ctx context.Context, params *RevUsersAssociationsListParams, reqEditors ...RequestEditorFn) (*RevUsersAssociationsListResponse, error) {
	rsp, err := c.RevUsersAssociationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersAssociationsListResponse(rsp)
}

// RevUsersAssociationsListPostWithBodyWithResponse request with arbitrary body returning *RevUsersAssociationsListPostResponse
func (c *ClientWithResponses) RevUsersAssociationsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersAssociationsListPostResponse, error) {
	rsp, err := c.RevUsersAssociationsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersAssociationsListPostResponse(rsp)
}

func (c *ClientWithResponses) RevUsersAssociationsListPostWithResponse(ctx context.Context, body RevUsersAssociationsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersAssociationsListPostResponse, error) {
	rsp, err := c.RevUsersAssociationsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersAssociationsListPostResponse(rsp)
}

// RevUsersAssociationsRemoveWithBodyWithResponse request with arbitrary body returning *RevUsersAssociationsRemoveResponse
func (c *ClientWithResponses) RevUsersAssociationsRemoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersAssociationsRemoveResponse, error) {
	rsp, err := c.RevUsersAssociationsRemoveWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersAssociationsRemoveResponse(rsp)
}

func (c *ClientWithResponses) RevUsersAssociationsRemoveWithResponse(ctx context.Context, body RevUsersAssociationsRemoveJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersAssociationsRemoveResponse, error) {
	rsp, err := c.RevUsersAssociationsRemove(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersAssociationsRemoveResponse(rsp)
}

// RevUsersCreateWithBodyWithResponse request with arbitrary body returning *RevUsersCreateResponse
func (c *ClientWithResponses) RevUsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersCreateResponse, error) {
	rsp, err := c.RevUsersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersCreateResponse(rsp)
}

func (c *ClientWithResponses) RevUsersCreateWithResponse(ctx context.Context, body RevUsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersCreateResponse, error) {
	rsp, err := c.RevUsersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersCreateResponse(rsp)
}

// RevUsersDeleteWithBodyWithResponse request with arbitrary body returning *RevUsersDeleteResponse
func (c *ClientWithResponses) RevUsersDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersDeleteResponse, error) {
	rsp, err := c.RevUsersDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersDeleteResponse(rsp)
}

func (c *ClientWithResponses) RevUsersDeleteWithResponse(ctx context.Context, body RevUsersDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersDeleteResponse, error) {
	rsp, err := c.RevUsersDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersDeleteResponse(rsp)
}

// DeleteRevUsersPersonalDataWithBodyWithResponse request with arbitrary body returning *DeleteRevUsersPersonalDataResponse
func (c *ClientWithResponses) DeleteRevUsersPersonalDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRevUsersPersonalDataResponse, error) {
	rsp, err := c.DeleteRevUsersPersonalDataWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRevUsersPersonalDataResponse(rsp)
}

func (c *ClientWithResponses) DeleteRevUsersPersonalDataWithResponse(ctx context.Context, body DeleteRevUsersPersonalDataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRevUsersPersonalDataResponse, error) {
	rsp, err := c.DeleteRevUsersPersonalData(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRevUsersPersonalDataResponse(rsp)
}

// RevUsersGetWithResponse request returning *RevUsersGetResponse
func (c *ClientWithResponses) RevUsersGetWithResponse(ctx context.Context, params *RevUsersGetParams, reqEditors ...RequestEditorFn) (*RevUsersGetResponse, error) {
	rsp, err := c.RevUsersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersGetResponse(rsp)
}

// RevUsersGetPostWithBodyWithResponse request with arbitrary body returning *RevUsersGetPostResponse
func (c *ClientWithResponses) RevUsersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersGetPostResponse, error) {
	rsp, err := c.RevUsersGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersGetPostResponse(rsp)
}

func (c *ClientWithResponses) RevUsersGetPostWithResponse(ctx context.Context, body RevUsersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersGetPostResponse, error) {
	rsp, err := c.RevUsersGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersGetPostResponse(rsp)
}

// LinkRevUserToRevOrgWithBodyWithResponse request with arbitrary body returning *LinkRevUserToRevOrgResponse
func (c *ClientWithResponses) LinkRevUserToRevOrgWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRevUserToRevOrgResponse, error) {
	rsp, err := c.LinkRevUserToRevOrgWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRevUserToRevOrgResponse(rsp)
}

func (c *ClientWithResponses) LinkRevUserToRevOrgWithResponse(ctx context.Context, body LinkRevUserToRevOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRevUserToRevOrgResponse, error) {
	rsp, err := c.LinkRevUserToRevOrg(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRevUserToRevOrgResponse(rsp)
}

// RevUsersListWithResponse request returning *RevUsersListResponse
func (c *ClientWithResponses) RevUsersListWithResponse(ctx context.Context, params *RevUsersListParams, reqEditors ...RequestEditorFn) (*RevUsersListResponse, error) {
	rsp, err := c.RevUsersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersListResponse(rsp)
}

// RevUsersListPostWithBodyWithResponse request with arbitrary body returning *RevUsersListPostResponse
func (c *ClientWithResponses) RevUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersListPostResponse, error) {
	rsp, err := c.RevUsersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersListPostResponse(rsp)
}

func (c *ClientWithResponses) RevUsersListPostWithResponse(ctx context.Context, body RevUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersListPostResponse, error) {
	rsp, err := c.RevUsersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersListPostResponse(rsp)
}

// RevUsersMergeWithBodyWithResponse request with arbitrary body returning *RevUsersMergeResponse
func (c *ClientWithResponses) RevUsersMergeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersMergeResponse, error) {
	rsp, err := c.RevUsersMergeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersMergeResponse(rsp)
}

func (c *ClientWithResponses) RevUsersMergeWithResponse(ctx context.Context, body RevUsersMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersMergeResponse, error) {
	rsp, err := c.RevUsersMerge(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersMergeResponse(rsp)
}

// GetRevUsersPersonalDataWithBodyWithResponse request with arbitrary body returning *GetRevUsersPersonalDataResponse
func (c *ClientWithResponses) GetRevUsersPersonalDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetRevUsersPersonalDataResponse, error) {
	rsp, err := c.GetRevUsersPersonalDataWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRevUsersPersonalDataResponse(rsp)
}

func (c *ClientWithResponses) GetRevUsersPersonalDataWithResponse(ctx context.Context, body GetRevUsersPersonalDataJSONRequestBody, reqEditors ...RequestEditorFn) (*GetRevUsersPersonalDataResponse, error) {
	rsp, err := c.GetRevUsersPersonalData(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRevUsersPersonalDataResponse(rsp)
}

// RevUsersScanWithResponse request returning *RevUsersScanResponse
func (c *ClientWithResponses) RevUsersScanWithResponse(ctx context.Context, params *RevUsersScanParams, reqEditors ...RequestEditorFn) (*RevUsersScanResponse, error) {
	rsp, err := c.RevUsersScan(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersScanResponse(rsp)
}

// RevUsersScanPostWithBodyWithResponse request with arbitrary body returning *RevUsersScanPostResponse
func (c *ClientWithResponses) RevUsersScanPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersScanPostResponse, error) {
	rsp, err := c.RevUsersScanPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersScanPostResponse(rsp)
}

func (c *ClientWithResponses) RevUsersScanPostWithResponse(ctx context.Context, body RevUsersScanPostJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersScanPostResponse, error) {
	rsp, err := c.RevUsersScanPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersScanPostResponse(rsp)
}

// UnlinkRevUserFromRevOrgWithBodyWithResponse request with arbitrary body returning *UnlinkRevUserFromRevOrgResponse
func (c *ClientWithResponses) UnlinkRevUserFromRevOrgWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkRevUserFromRevOrgResponse, error) {
	rsp, err := c.UnlinkRevUserFromRevOrgWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkRevUserFromRevOrgResponse(rsp)
}

func (c *ClientWithResponses) UnlinkRevUserFromRevOrgWithResponse(ctx context.Context, body UnlinkRevUserFromRevOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkRevUserFromRevOrgResponse, error) {
	rsp, err := c.UnlinkRevUserFromRevOrg(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkRevUserFromRevOrgResponse(rsp)
}

// RevUsersUpdateWithBodyWithResponse request with arbitrary body returning *RevUsersUpdateResponse
func (c *ClientWithResponses) RevUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevUsersUpdateResponse, error) {
	rsp, err := c.RevUsersUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersUpdateResponse(rsp)
}

func (c *ClientWithResponses) RevUsersUpdateWithResponse(ctx context.Context, body RevUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RevUsersUpdateResponse, error) {
	rsp, err := c.RevUsersUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevUsersUpdateResponse(rsp)
}

// RolesApplyWithBodyWithResponse request with arbitrary body returning *RolesApplyResponse
func (c *ClientWithResponses) RolesApplyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RolesApplyResponse, error) {
	rsp, err := c.RolesApplyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRolesApplyResponse(rsp)
}

func (c *ClientWithResponses) RolesApplyWithResponse(ctx context.Context, body RolesApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*RolesApplyResponse, error) {
	rsp, err := c.RolesApply(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRolesApplyResponse(rsp)
}

// RolesCreateWithBodyWithResponse request with arbitrary body returning *RolesCreateResponse
func (c *ClientWithResponses) RolesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RolesCreateResponse, error) {
	rsp, err := c.RolesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRolesCreateResponse(rsp)
}

func (c *ClientWithResponses) RolesCreateWithResponse(ctx context.Context, body RolesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RolesCreateResponse, error) {
	rsp, err := c.RolesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRolesCreateResponse(rsp)
}

// AggregatedSchemaGetWithResponse request returning *AggregatedSchemaGetResponse
func (c *ClientWithResponses) AggregatedSchemaGetWithResponse(ctx context.Context, params *AggregatedSchemaGetParams, reqEditors ...RequestEditorFn) (*AggregatedSchemaGetResponse, error) {
	rsp, err := c.AggregatedSchemaGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAggregatedSchemaGetResponse(rsp)
}

// AggregatedSchemaGetPostWithBodyWithResponse request with arbitrary body returning *AggregatedSchemaGetPostResponse
func (c *ClientWithResponses) AggregatedSchemaGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AggregatedSchemaGetPostResponse, error) {
	rsp, err := c.AggregatedSchemaGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAggregatedSchemaGetPostResponse(rsp)
}

func (c *ClientWithResponses) AggregatedSchemaGetPostWithResponse(ctx context.Context, body AggregatedSchemaGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AggregatedSchemaGetPostResponse, error) {
	rsp, err := c.AggregatedSchemaGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAggregatedSchemaGetPostResponse(rsp)
}

// CustomSchemaFragmentsGetWithResponse request returning *CustomSchemaFragmentsGetResponse
func (c *ClientWithResponses) CustomSchemaFragmentsGetWithResponse(ctx context.Context, params *CustomSchemaFragmentsGetParams, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsGetResponse, error) {
	rsp, err := c.CustomSchemaFragmentsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomSchemaFragmentsGetResponse(rsp)
}

// CustomSchemaFragmentsGetPostWithBodyWithResponse request with arbitrary body returning *CustomSchemaFragmentsGetPostResponse
func (c *ClientWithResponses) CustomSchemaFragmentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsGetPostResponse, error) {
	rsp, err := c.CustomSchemaFragmentsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomSchemaFragmentsGetPostResponse(rsp)
}

func (c *ClientWithResponses) CustomSchemaFragmentsGetPostWithResponse(ctx context.Context, body CustomSchemaFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsGetPostResponse, error) {
	rsp, err := c.CustomSchemaFragmentsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomSchemaFragmentsGetPostResponse(rsp)
}

// CustomSchemaFragmentsListWithResponse request returning *CustomSchemaFragmentsListResponse
func (c *ClientWithResponses) CustomSchemaFragmentsListWithResponse(ctx context.Context, params *CustomSchemaFragmentsListParams, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsListResponse, error) {
	rsp, err := c.CustomSchemaFragmentsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomSchemaFragmentsListResponse(rsp)
}

// CustomSchemaFragmentsListPostWithBodyWithResponse request with arbitrary body returning *CustomSchemaFragmentsListPostResponse
func (c *ClientWithResponses) CustomSchemaFragmentsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsListPostResponse, error) {
	rsp, err := c.CustomSchemaFragmentsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomSchemaFragmentsListPostResponse(rsp)
}

func (c *ClientWithResponses) CustomSchemaFragmentsListPostWithResponse(ctx context.Context, body CustomSchemaFragmentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsListPostResponse, error) {
	rsp, err := c.CustomSchemaFragmentsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomSchemaFragmentsListPostResponse(rsp)
}

// CustomSchemaFragmentsSetWithBodyWithResponse request with arbitrary body returning *CustomSchemaFragmentsSetResponse
func (c *ClientWithResponses) CustomSchemaFragmentsSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsSetResponse, error) {
	rsp, err := c.CustomSchemaFragmentsSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomSchemaFragmentsSetResponse(rsp)
}

func (c *ClientWithResponses) CustomSchemaFragmentsSetWithResponse(ctx context.Context, body CustomSchemaFragmentsSetJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomSchemaFragmentsSetResponse, error) {
	rsp, err := c.CustomSchemaFragmentsSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomSchemaFragmentsSetResponse(rsp)
}

// StockSchemaFragmentsGetWithResponse request returning *StockSchemaFragmentsGetResponse
func (c *ClientWithResponses) StockSchemaFragmentsGetWithResponse(ctx context.Context, params *StockSchemaFragmentsGetParams, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsGetResponse, error) {
	rsp, err := c.StockSchemaFragmentsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStockSchemaFragmentsGetResponse(rsp)
}

// StockSchemaFragmentsGetPostWithBodyWithResponse request with arbitrary body returning *StockSchemaFragmentsGetPostResponse
func (c *ClientWithResponses) StockSchemaFragmentsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsGetPostResponse, error) {
	rsp, err := c.StockSchemaFragmentsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStockSchemaFragmentsGetPostResponse(rsp)
}

func (c *ClientWithResponses) StockSchemaFragmentsGetPostWithResponse(ctx context.Context, body StockSchemaFragmentsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsGetPostResponse, error) {
	rsp, err := c.StockSchemaFragmentsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStockSchemaFragmentsGetPostResponse(rsp)
}

// StockSchemaFragmentsListWithResponse request returning *StockSchemaFragmentsListResponse
func (c *ClientWithResponses) StockSchemaFragmentsListWithResponse(ctx context.Context, params *StockSchemaFragmentsListParams, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsListResponse, error) {
	rsp, err := c.StockSchemaFragmentsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStockSchemaFragmentsListResponse(rsp)
}

// StockSchemaFragmentsListPostWithBodyWithResponse request with arbitrary body returning *StockSchemaFragmentsListPostResponse
func (c *ClientWithResponses) StockSchemaFragmentsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsListPostResponse, error) {
	rsp, err := c.StockSchemaFragmentsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStockSchemaFragmentsListPostResponse(rsp)
}

func (c *ClientWithResponses) StockSchemaFragmentsListPostWithResponse(ctx context.Context, body StockSchemaFragmentsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*StockSchemaFragmentsListPostResponse, error) {
	rsp, err := c.StockSchemaFragmentsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStockSchemaFragmentsListPostResponse(rsp)
}

// SubtypesListWithResponse request returning *SubtypesListResponse
func (c *ClientWithResponses) SubtypesListWithResponse(ctx context.Context, params *SubtypesListParams, reqEditors ...RequestEditorFn) (*SubtypesListResponse, error) {
	rsp, err := c.SubtypesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubtypesListResponse(rsp)
}

// SubtypesListPostWithBodyWithResponse request with arbitrary body returning *SubtypesListPostResponse
func (c *ClientWithResponses) SubtypesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubtypesListPostResponse, error) {
	rsp, err := c.SubtypesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubtypesListPostResponse(rsp)
}

func (c *ClientWithResponses) SubtypesListPostWithResponse(ctx context.Context, body SubtypesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SubtypesListPostResponse, error) {
	rsp, err := c.SubtypesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubtypesListPostResponse(rsp)
}

// SchemasSubtypePrepareUpdateGetWithBodyWithResponse request with arbitrary body returning *SchemasSubtypePrepareUpdateGetResponse
func (c *ClientWithResponses) SchemasSubtypePrepareUpdateGetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasSubtypePrepareUpdateGetResponse, error) {
	rsp, err := c.SchemasSubtypePrepareUpdateGetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasSubtypePrepareUpdateGetResponse(rsp)
}

func (c *ClientWithResponses) SchemasSubtypePrepareUpdateGetWithResponse(ctx context.Context, body SchemasSubtypePrepareUpdateGetJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasSubtypePrepareUpdateGetResponse, error) {
	rsp, err := c.SchemasSubtypePrepareUpdateGet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasSubtypePrepareUpdateGetResponse(rsp)
}

// SearchCoreWithResponse request returning *SearchCoreResponse
func (c *ClientWithResponses) SearchCoreWithResponse(ctx context.Context, params *SearchCoreParams, reqEditors ...RequestEditorFn) (*SearchCoreResponse, error) {
	rsp, err := c.SearchCore(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCoreResponse(rsp)
}

// SearchCorePostWithBodyWithResponse request with arbitrary body returning *SearchCorePostResponse
func (c *ClientWithResponses) SearchCorePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCorePostResponse, error) {
	rsp, err := c.SearchCorePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCorePostResponse(rsp)
}

func (c *ClientWithResponses) SearchCorePostWithResponse(ctx context.Context, body SearchCorePostJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCorePostResponse, error) {
	rsp, err := c.SearchCorePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCorePostResponse(rsp)
}

// SearchHybridWithResponse request returning *SearchHybridResponse
func (c *ClientWithResponses) SearchHybridWithResponse(ctx context.Context, params *SearchHybridParams, reqEditors ...RequestEditorFn) (*SearchHybridResponse, error) {
	rsp, err := c.SearchHybrid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchHybridResponse(rsp)
}

// SearchHybridPostWithBodyWithResponse request with arbitrary body returning *SearchHybridPostResponse
func (c *ClientWithResponses) SearchHybridPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchHybridPostResponse, error) {
	rsp, err := c.SearchHybridPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchHybridPostResponse(rsp)
}

func (c *ClientWithResponses) SearchHybridPostWithResponse(ctx context.Context, body SearchHybridPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchHybridPostResponse, error) {
	rsp, err := c.SearchHybridPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchHybridPostResponse(rsp)
}

// ServiceAccountsCreateWithBodyWithResponse request with arbitrary body returning *ServiceAccountsCreateResponse
func (c *ClientWithResponses) ServiceAccountsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsCreateResponse, error) {
	rsp, err := c.ServiceAccountsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsCreateResponse(rsp)
}

func (c *ClientWithResponses) ServiceAccountsCreateWithResponse(ctx context.Context, body ServiceAccountsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsCreateResponse, error) {
	rsp, err := c.ServiceAccountsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsCreateResponse(rsp)
}

// ServiceAccountsGetWithResponse request returning *ServiceAccountsGetResponse
func (c *ClientWithResponses) ServiceAccountsGetWithResponse(ctx context.Context, params *ServiceAccountsGetParams, reqEditors ...RequestEditorFn) (*ServiceAccountsGetResponse, error) {
	rsp, err := c.ServiceAccountsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsGetResponse(rsp)
}

// ServiceAccountsGetPostWithBodyWithResponse request with arbitrary body returning *ServiceAccountsGetPostResponse
func (c *ClientWithResponses) ServiceAccountsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsGetPostResponse, error) {
	rsp, err := c.ServiceAccountsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsGetPostResponse(rsp)
}

func (c *ClientWithResponses) ServiceAccountsGetPostWithResponse(ctx context.Context, body ServiceAccountsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsGetPostResponse, error) {
	rsp, err := c.ServiceAccountsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsGetPostResponse(rsp)
}

// ServiceAccountsUpdateWithBodyWithResponse request with arbitrary body returning *ServiceAccountsUpdateResponse
func (c *ClientWithResponses) ServiceAccountsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceAccountsUpdateResponse, error) {
	rsp, err := c.ServiceAccountsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ServiceAccountsUpdateWithResponse(ctx context.Context, body ServiceAccountsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceAccountsUpdateResponse, error) {
	rsp, err := c.ServiceAccountsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceAccountsUpdateResponse(rsp)
}

// SlaTrackersGetWithResponse request returning *SlaTrackersGetResponse
func (c *ClientWithResponses) SlaTrackersGetWithResponse(ctx context.Context, params *SlaTrackersGetParams, reqEditors ...RequestEditorFn) (*SlaTrackersGetResponse, error) {
	rsp, err := c.SlaTrackersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersGetResponse(rsp)
}

// SlaTrackersGetPostWithBodyWithResponse request with arbitrary body returning *SlaTrackersGetPostResponse
func (c *ClientWithResponses) SlaTrackersGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersGetPostResponse, error) {
	rsp, err := c.SlaTrackersGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersGetPostResponse(rsp)
}

func (c *ClientWithResponses) SlaTrackersGetPostWithResponse(ctx context.Context, body SlaTrackersGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersGetPostResponse, error) {
	rsp, err := c.SlaTrackersGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersGetPostResponse(rsp)
}

// SlaTrackersListWithResponse request returning *SlaTrackersListResponse
func (c *ClientWithResponses) SlaTrackersListWithResponse(ctx context.Context, params *SlaTrackersListParams, reqEditors ...RequestEditorFn) (*SlaTrackersListResponse, error) {
	rsp, err := c.SlaTrackersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersListResponse(rsp)
}

// SlaTrackersListPostWithBodyWithResponse request with arbitrary body returning *SlaTrackersListPostResponse
func (c *ClientWithResponses) SlaTrackersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersListPostResponse, error) {
	rsp, err := c.SlaTrackersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersListPostResponse(rsp)
}

func (c *ClientWithResponses) SlaTrackersListPostWithResponse(ctx context.Context, body SlaTrackersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersListPostResponse, error) {
	rsp, err := c.SlaTrackersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersListPostResponse(rsp)
}

// SlaTrackersRemoveMetricWithBodyWithResponse request with arbitrary body returning *SlaTrackersRemoveMetricResponse
func (c *ClientWithResponses) SlaTrackersRemoveMetricWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaTrackersRemoveMetricResponse, error) {
	rsp, err := c.SlaTrackersRemoveMetricWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersRemoveMetricResponse(rsp)
}

func (c *ClientWithResponses) SlaTrackersRemoveMetricWithResponse(ctx context.Context, body SlaTrackersRemoveMetricJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaTrackersRemoveMetricResponse, error) {
	rsp, err := c.SlaTrackersRemoveMetric(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaTrackersRemoveMetricResponse(rsp)
}

// SlasAssignWithBodyWithResponse request with arbitrary body returning *SlasAssignResponse
func (c *ClientWithResponses) SlasAssignWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasAssignResponse, error) {
	rsp, err := c.SlasAssignWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasAssignResponse(rsp)
}

func (c *ClientWithResponses) SlasAssignWithResponse(ctx context.Context, body SlasAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasAssignResponse, error) {
	rsp, err := c.SlasAssign(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasAssignResponse(rsp)
}

// SlasCreateWithBodyWithResponse request with arbitrary body returning *SlasCreateResponse
func (c *ClientWithResponses) SlasCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasCreateResponse, error) {
	rsp, err := c.SlasCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasCreateResponse(rsp)
}

func (c *ClientWithResponses) SlasCreateWithResponse(ctx context.Context, body SlasCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasCreateResponse, error) {
	rsp, err := c.SlasCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasCreateResponse(rsp)
}

// SlasGetWithResponse request returning *SlasGetResponse
func (c *ClientWithResponses) SlasGetWithResponse(ctx context.Context, params *SlasGetParams, reqEditors ...RequestEditorFn) (*SlasGetResponse, error) {
	rsp, err := c.SlasGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasGetResponse(rsp)
}

// SlasGetPostWithBodyWithResponse request with arbitrary body returning *SlasGetPostResponse
func (c *ClientWithResponses) SlasGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasGetPostResponse, error) {
	rsp, err := c.SlasGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasGetPostResponse(rsp)
}

func (c *ClientWithResponses) SlasGetPostWithResponse(ctx context.Context, body SlasGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasGetPostResponse, error) {
	rsp, err := c.SlasGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasGetPostResponse(rsp)
}

// SlasListWithResponse request returning *SlasListResponse
func (c *ClientWithResponses) SlasListWithResponse(ctx context.Context, params *SlasListParams, reqEditors ...RequestEditorFn) (*SlasListResponse, error) {
	rsp, err := c.SlasList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasListResponse(rsp)
}

// SlasListPostWithBodyWithResponse request with arbitrary body returning *SlasListPostResponse
func (c *ClientWithResponses) SlasListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasListPostResponse, error) {
	rsp, err := c.SlasListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasListPostResponse(rsp)
}

func (c *ClientWithResponses) SlasListPostWithResponse(ctx context.Context, body SlasListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasListPostResponse, error) {
	rsp, err := c.SlasListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasListPostResponse(rsp)
}

// SlasTransitionWithBodyWithResponse request with arbitrary body returning *SlasTransitionResponse
func (c *ClientWithResponses) SlasTransitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasTransitionResponse, error) {
	rsp, err := c.SlasTransitionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasTransitionResponse(rsp)
}

func (c *ClientWithResponses) SlasTransitionWithResponse(ctx context.Context, body SlasTransitionJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasTransitionResponse, error) {
	rsp, err := c.SlasTransition(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasTransitionResponse(rsp)
}

// SlasUpdateWithBodyWithResponse request with arbitrary body returning *SlasUpdateResponse
func (c *ClientWithResponses) SlasUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlasUpdateResponse, error) {
	rsp, err := c.SlasUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasUpdateResponse(rsp)
}

func (c *ClientWithResponses) SlasUpdateWithResponse(ctx context.Context, body SlasUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlasUpdateResponse, error) {
	rsp, err := c.SlasUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlasUpdateResponse(rsp)
}

// SnapInsResourcesWithResponse request returning *SnapInsResourcesResponse
func (c *ClientWithResponses) SnapInsResourcesWithResponse(ctx context.Context, params *SnapInsResourcesParams, reqEditors ...RequestEditorFn) (*SnapInsResourcesResponse, error) {
	rsp, err := c.SnapInsResources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapInsResourcesResponse(rsp)
}

// SnapInsResourcesPostWithBodyWithResponse request with arbitrary body returning *SnapInsResourcesPostResponse
func (c *ClientWithResponses) SnapInsResourcesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapInsResourcesPostResponse, error) {
	rsp, err := c.SnapInsResourcesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapInsResourcesPostResponse(rsp)
}

func (c *ClientWithResponses) SnapInsResourcesPostWithResponse(ctx context.Context, body SnapInsResourcesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapInsResourcesPostResponse, error) {
	rsp, err := c.SnapInsResourcesPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapInsResourcesPostResponse(rsp)
}

// SnapInsUpdateWithBodyWithResponse request with arbitrary body returning *SnapInsUpdateResponse
func (c *ClientWithResponses) SnapInsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapInsUpdateResponse, error) {
	rsp, err := c.SnapInsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapInsUpdateResponse(rsp)
}

func (c *ClientWithResponses) SnapInsUpdateWithResponse(ctx context.Context, body SnapInsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapInsUpdateResponse, error) {
	rsp, err := c.SnapInsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapInsUpdateResponse(rsp)
}

// SnapKitActionExecuteDeferredWithBodyWithResponse request with arbitrary body returning *SnapKitActionExecuteDeferredResponse
func (c *ClientWithResponses) SnapKitActionExecuteDeferredWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapKitActionExecuteDeferredResponse, error) {
	rsp, err := c.SnapKitActionExecuteDeferredWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapKitActionExecuteDeferredResponse(rsp)
}

func (c *ClientWithResponses) SnapKitActionExecuteDeferredWithResponse(ctx context.Context, body SnapKitActionExecuteDeferredJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapKitActionExecuteDeferredResponse, error) {
	rsp, err := c.SnapKitActionExecuteDeferred(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapKitActionExecuteDeferredResponse(rsp)
}

// SnapWidgetsCreateWithBodyWithResponse request with arbitrary body returning *SnapWidgetsCreateResponse
func (c *ClientWithResponses) SnapWidgetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapWidgetsCreateResponse, error) {
	rsp, err := c.SnapWidgetsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapWidgetsCreateResponse(rsp)
}

func (c *ClientWithResponses) SnapWidgetsCreateWithResponse(ctx context.Context, body SnapWidgetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapWidgetsCreateResponse, error) {
	rsp, err := c.SnapWidgetsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapWidgetsCreateResponse(rsp)
}

// StageDiagramsCreateWithBodyWithResponse request with arbitrary body returning *StageDiagramsCreateResponse
func (c *ClientWithResponses) StageDiagramsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageDiagramsCreateResponse, error) {
	rsp, err := c.StageDiagramsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsCreateResponse(rsp)
}

func (c *ClientWithResponses) StageDiagramsCreateWithResponse(ctx context.Context, body StageDiagramsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*StageDiagramsCreateResponse, error) {
	rsp, err := c.StageDiagramsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsCreateResponse(rsp)
}

// StageDiagramsGetWithResponse request returning *StageDiagramsGetResponse
func (c *ClientWithResponses) StageDiagramsGetWithResponse(ctx context.Context, params *StageDiagramsGetParams, reqEditors ...RequestEditorFn) (*StageDiagramsGetResponse, error) {
	rsp, err := c.StageDiagramsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsGetResponse(rsp)
}

// StageDiagramsGetPostWithBodyWithResponse request with arbitrary body returning *StageDiagramsGetPostResponse
func (c *ClientWithResponses) StageDiagramsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageDiagramsGetPostResponse, error) {
	rsp, err := c.StageDiagramsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsGetPostResponse(rsp)
}

func (c *ClientWithResponses) StageDiagramsGetPostWithResponse(ctx context.Context, body StageDiagramsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*StageDiagramsGetPostResponse, error) {
	rsp, err := c.StageDiagramsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsGetPostResponse(rsp)
}

// StageDiagramsListWithResponse request returning *StageDiagramsListResponse
func (c *ClientWithResponses) StageDiagramsListWithResponse(ctx context.Context, params *StageDiagramsListParams, reqEditors ...RequestEditorFn) (*StageDiagramsListResponse, error) {
	rsp, err := c.StageDiagramsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsListResponse(rsp)
}

// StageDiagramsListPostWithBodyWithResponse request with arbitrary body returning *StageDiagramsListPostResponse
func (c *ClientWithResponses) StageDiagramsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageDiagramsListPostResponse, error) {
	rsp, err := c.StageDiagramsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsListPostResponse(rsp)
}

func (c *ClientWithResponses) StageDiagramsListPostWithResponse(ctx context.Context, body StageDiagramsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*StageDiagramsListPostResponse, error) {
	rsp, err := c.StageDiagramsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsListPostResponse(rsp)
}

// StageDiagramsUpdateWithBodyWithResponse request with arbitrary body returning *StageDiagramsUpdateResponse
func (c *ClientWithResponses) StageDiagramsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageDiagramsUpdateResponse, error) {
	rsp, err := c.StageDiagramsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsUpdateResponse(rsp)
}

func (c *ClientWithResponses) StageDiagramsUpdateWithResponse(ctx context.Context, body StageDiagramsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StageDiagramsUpdateResponse, error) {
	rsp, err := c.StageDiagramsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageDiagramsUpdateResponse(rsp)
}

// CustomStagesCreateWithBodyWithResponse request with arbitrary body returning *CustomStagesCreateResponse
func (c *ClientWithResponses) CustomStagesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStagesCreateResponse, error) {
	rsp, err := c.CustomStagesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesCreateResponse(rsp)
}

func (c *ClientWithResponses) CustomStagesCreateWithResponse(ctx context.Context, body CustomStagesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStagesCreateResponse, error) {
	rsp, err := c.CustomStagesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesCreateResponse(rsp)
}

// CustomStagesGetWithResponse request returning *CustomStagesGetResponse
func (c *ClientWithResponses) CustomStagesGetWithResponse(ctx context.Context, params *CustomStagesGetParams, reqEditors ...RequestEditorFn) (*CustomStagesGetResponse, error) {
	rsp, err := c.CustomStagesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesGetResponse(rsp)
}

// CustomStagesGetPostWithBodyWithResponse request with arbitrary body returning *CustomStagesGetPostResponse
func (c *ClientWithResponses) CustomStagesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStagesGetPostResponse, error) {
	rsp, err := c.CustomStagesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesGetPostResponse(rsp)
}

func (c *ClientWithResponses) CustomStagesGetPostWithResponse(ctx context.Context, body CustomStagesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStagesGetPostResponse, error) {
	rsp, err := c.CustomStagesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesGetPostResponse(rsp)
}

// CustomStagesListWithResponse request returning *CustomStagesListResponse
func (c *ClientWithResponses) CustomStagesListWithResponse(ctx context.Context, params *CustomStagesListParams, reqEditors ...RequestEditorFn) (*CustomStagesListResponse, error) {
	rsp, err := c.CustomStagesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesListResponse(rsp)
}

// CustomStagesListPostWithBodyWithResponse request with arbitrary body returning *CustomStagesListPostResponse
func (c *ClientWithResponses) CustomStagesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStagesListPostResponse, error) {
	rsp, err := c.CustomStagesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesListPostResponse(rsp)
}

func (c *ClientWithResponses) CustomStagesListPostWithResponse(ctx context.Context, body CustomStagesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStagesListPostResponse, error) {
	rsp, err := c.CustomStagesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesListPostResponse(rsp)
}

// CustomStagesUpdateWithBodyWithResponse request with arbitrary body returning *CustomStagesUpdateResponse
func (c *ClientWithResponses) CustomStagesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStagesUpdateResponse, error) {
	rsp, err := c.CustomStagesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesUpdateResponse(rsp)
}

func (c *ClientWithResponses) CustomStagesUpdateWithResponse(ctx context.Context, body CustomStagesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStagesUpdateResponse, error) {
	rsp, err := c.CustomStagesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStagesUpdateResponse(rsp)
}

// CustomStatesCreateWithBodyWithResponse request with arbitrary body returning *CustomStatesCreateResponse
func (c *ClientWithResponses) CustomStatesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStatesCreateResponse, error) {
	rsp, err := c.CustomStatesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesCreateResponse(rsp)
}

func (c *ClientWithResponses) CustomStatesCreateWithResponse(ctx context.Context, body CustomStatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStatesCreateResponse, error) {
	rsp, err := c.CustomStatesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesCreateResponse(rsp)
}

// CustomStatesGetWithResponse request returning *CustomStatesGetResponse
func (c *ClientWithResponses) CustomStatesGetWithResponse(ctx context.Context, params *CustomStatesGetParams, reqEditors ...RequestEditorFn) (*CustomStatesGetResponse, error) {
	rsp, err := c.CustomStatesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesGetResponse(rsp)
}

// CustomStatesGetPostWithBodyWithResponse request with arbitrary body returning *CustomStatesGetPostResponse
func (c *ClientWithResponses) CustomStatesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStatesGetPostResponse, error) {
	rsp, err := c.CustomStatesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesGetPostResponse(rsp)
}

func (c *ClientWithResponses) CustomStatesGetPostWithResponse(ctx context.Context, body CustomStatesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStatesGetPostResponse, error) {
	rsp, err := c.CustomStatesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesGetPostResponse(rsp)
}

// CustomStatesListWithResponse request returning *CustomStatesListResponse
func (c *ClientWithResponses) CustomStatesListWithResponse(ctx context.Context, params *CustomStatesListParams, reqEditors ...RequestEditorFn) (*CustomStatesListResponse, error) {
	rsp, err := c.CustomStatesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesListResponse(rsp)
}

// CustomStatesListPostWithBodyWithResponse request with arbitrary body returning *CustomStatesListPostResponse
func (c *ClientWithResponses) CustomStatesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStatesListPostResponse, error) {
	rsp, err := c.CustomStatesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesListPostResponse(rsp)
}

func (c *ClientWithResponses) CustomStatesListPostWithResponse(ctx context.Context, body CustomStatesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStatesListPostResponse, error) {
	rsp, err := c.CustomStatesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesListPostResponse(rsp)
}

// CustomStatesUpdateWithBodyWithResponse request with arbitrary body returning *CustomStatesUpdateResponse
func (c *ClientWithResponses) CustomStatesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomStatesUpdateResponse, error) {
	rsp, err := c.CustomStatesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesUpdateResponse(rsp)
}

func (c *ClientWithResponses) CustomStatesUpdateWithResponse(ctx context.Context, body CustomStatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomStatesUpdateResponse, error) {
	rsp, err := c.CustomStatesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomStatesUpdateResponse(rsp)
}

// SubscribersListWithResponse request returning *SubscribersListResponse
func (c *ClientWithResponses) SubscribersListWithResponse(ctx context.Context, params *SubscribersListParams, reqEditors ...RequestEditorFn) (*SubscribersListResponse, error) {
	rsp, err := c.SubscribersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribersListResponse(rsp)
}

// SubscribersListPostWithBodyWithResponse request with arbitrary body returning *SubscribersListPostResponse
func (c *ClientWithResponses) SubscribersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscribersListPostResponse, error) {
	rsp, err := c.SubscribersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribersListPostResponse(rsp)
}

func (c *ClientWithResponses) SubscribersListPostWithResponse(ctx context.Context, body SubscribersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscribersListPostResponse, error) {
	rsp, err := c.SubscribersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribersListPostResponse(rsp)
}

// SubscribersUpdateWithBodyWithResponse request with arbitrary body returning *SubscribersUpdateResponse
func (c *ClientWithResponses) SubscribersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscribersUpdateResponse, error) {
	rsp, err := c.SubscribersUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribersUpdateResponse(rsp)
}

func (c *ClientWithResponses) SubscribersUpdateWithResponse(ctx context.Context, body SubscribersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscribersUpdateResponse, error) {
	rsp, err := c.SubscribersUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribersUpdateResponse(rsp)
}

// SurveysCreateWithBodyWithResponse request with arbitrary body returning *SurveysCreateResponse
func (c *ClientWithResponses) SurveysCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysCreateResponse, error) {
	rsp, err := c.SurveysCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysCreateResponse(rsp)
}

func (c *ClientWithResponses) SurveysCreateWithResponse(ctx context.Context, body SurveysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysCreateResponse, error) {
	rsp, err := c.SurveysCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysCreateResponse(rsp)
}

// SurveysDeleteWithBodyWithResponse request with arbitrary body returning *SurveysDeleteResponse
func (c *ClientWithResponses) SurveysDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysDeleteResponse, error) {
	rsp, err := c.SurveysDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysDeleteResponse(rsp)
}

func (c *ClientWithResponses) SurveysDeleteWithResponse(ctx context.Context, body SurveysDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysDeleteResponse, error) {
	rsp, err := c.SurveysDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysDeleteResponse(rsp)
}

// SurveysGetWithResponse request returning *SurveysGetResponse
func (c *ClientWithResponses) SurveysGetWithResponse(ctx context.Context, params *SurveysGetParams, reqEditors ...RequestEditorFn) (*SurveysGetResponse, error) {
	rsp, err := c.SurveysGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysGetResponse(rsp)
}

// SurveysGetPostWithBodyWithResponse request with arbitrary body returning *SurveysGetPostResponse
func (c *ClientWithResponses) SurveysGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysGetPostResponse, error) {
	rsp, err := c.SurveysGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysGetPostResponse(rsp)
}

func (c *ClientWithResponses) SurveysGetPostWithResponse(ctx context.Context, body SurveysGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysGetPostResponse, error) {
	rsp, err := c.SurveysGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysGetPostResponse(rsp)
}

// SurveysListWithResponse request returning *SurveysListResponse
func (c *ClientWithResponses) SurveysListWithResponse(ctx context.Context, params *SurveysListParams, reqEditors ...RequestEditorFn) (*SurveysListResponse, error) {
	rsp, err := c.SurveysList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysListResponse(rsp)
}

// SurveysListPostWithBodyWithResponse request with arbitrary body returning *SurveysListPostResponse
func (c *ClientWithResponses) SurveysListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysListPostResponse, error) {
	rsp, err := c.SurveysListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysListPostResponse(rsp)
}

func (c *ClientWithResponses) SurveysListPostWithResponse(ctx context.Context, body SurveysListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysListPostResponse, error) {
	rsp, err := c.SurveysListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysListPostResponse(rsp)
}

// SurveysResponsesListWithResponse request returning *SurveysResponsesListResponse
func (c *ClientWithResponses) SurveysResponsesListWithResponse(ctx context.Context, params *SurveysResponsesListParams, reqEditors ...RequestEditorFn) (*SurveysResponsesListResponse, error) {
	rsp, err := c.SurveysResponsesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesListResponse(rsp)
}

// SurveysResponsesListPostWithBodyWithResponse request with arbitrary body returning *SurveysResponsesListPostResponse
func (c *ClientWithResponses) SurveysResponsesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysResponsesListPostResponse, error) {
	rsp, err := c.SurveysResponsesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesListPostResponse(rsp)
}

func (c *ClientWithResponses) SurveysResponsesListPostWithResponse(ctx context.Context, body SurveysResponsesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysResponsesListPostResponse, error) {
	rsp, err := c.SurveysResponsesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesListPostResponse(rsp)
}

// SurveysResponsesUpdateWithBodyWithResponse request with arbitrary body returning *SurveysResponsesUpdateResponse
func (c *ClientWithResponses) SurveysResponsesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysResponsesUpdateResponse, error) {
	rsp, err := c.SurveysResponsesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesUpdateResponse(rsp)
}

func (c *ClientWithResponses) SurveysResponsesUpdateWithResponse(ctx context.Context, body SurveysResponsesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysResponsesUpdateResponse, error) {
	rsp, err := c.SurveysResponsesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysResponsesUpdateResponse(rsp)
}

// SurveysSendWithBodyWithResponse request with arbitrary body returning *SurveysSendResponse
func (c *ClientWithResponses) SurveysSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysSendResponse, error) {
	rsp, err := c.SurveysSendWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysSendResponse(rsp)
}

func (c *ClientWithResponses) SurveysSendWithResponse(ctx context.Context, body SurveysSendJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysSendResponse, error) {
	rsp, err := c.SurveysSend(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysSendResponse(rsp)
}

// SurveysSubmitWithBodyWithResponse request with arbitrary body returning *SurveysSubmitResponse
func (c *ClientWithResponses) SurveysSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysSubmitResponse, error) {
	rsp, err := c.SurveysSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysSubmitResponse(rsp)
}

func (c *ClientWithResponses) SurveysSubmitWithResponse(ctx context.Context, body SurveysSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysSubmitResponse, error) {
	rsp, err := c.SurveysSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysSubmitResponse(rsp)
}

// SurveysUpdateWithBodyWithResponse request with arbitrary body returning *SurveysUpdateResponse
func (c *ClientWithResponses) SurveysUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SurveysUpdateResponse, error) {
	rsp, err := c.SurveysUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysUpdateResponse(rsp)
}

func (c *ClientWithResponses) SurveysUpdateWithResponse(ctx context.Context, body SurveysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SurveysUpdateResponse, error) {
	rsp, err := c.SurveysUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSurveysUpdateResponse(rsp)
}

// SysUsersListWithResponse request returning *SysUsersListResponse
func (c *ClientWithResponses) SysUsersListWithResponse(ctx context.Context, params *SysUsersListParams, reqEditors ...RequestEditorFn) (*SysUsersListResponse, error) {
	rsp, err := c.SysUsersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersListResponse(rsp)
}

// SysUsersListPostWithBodyWithResponse request with arbitrary body returning *SysUsersListPostResponse
func (c *ClientWithResponses) SysUsersListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SysUsersListPostResponse, error) {
	rsp, err := c.SysUsersListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersListPostResponse(rsp)
}

func (c *ClientWithResponses) SysUsersListPostWithResponse(ctx context.Context, body SysUsersListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SysUsersListPostResponse, error) {
	rsp, err := c.SysUsersListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersListPostResponse(rsp)
}

// SysUsersUpdateWithBodyWithResponse request with arbitrary body returning *SysUsersUpdateResponse
func (c *ClientWithResponses) SysUsersUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SysUsersUpdateResponse, error) {
	rsp, err := c.SysUsersUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersUpdateResponse(rsp)
}

func (c *ClientWithResponses) SysUsersUpdateWithResponse(ctx context.Context, body SysUsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SysUsersUpdateResponse, error) {
	rsp, err := c.SysUsersUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSysUsersUpdateResponse(rsp)
}

// TagsCreateWithBodyWithResponse request with arbitrary body returning *TagsCreateResponse
func (c *ClientWithResponses) TagsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsCreateResponse, error) {
	rsp, err := c.TagsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsCreateResponse(rsp)
}

func (c *ClientWithResponses) TagsCreateWithResponse(ctx context.Context, body TagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsCreateResponse, error) {
	rsp, err := c.TagsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsCreateResponse(rsp)
}

// TagsDeleteWithBodyWithResponse request with arbitrary body returning *TagsDeleteResponse
func (c *ClientWithResponses) TagsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsDeleteResponse, error) {
	rsp, err := c.TagsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsDeleteResponse(rsp)
}

func (c *ClientWithResponses) TagsDeleteWithResponse(ctx context.Context, body TagsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsDeleteResponse, error) {
	rsp, err := c.TagsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsDeleteResponse(rsp)
}

// TagsGetWithResponse request returning *TagsGetResponse
func (c *ClientWithResponses) TagsGetWithResponse(ctx context.Context, params *TagsGetParams, reqEditors ...RequestEditorFn) (*TagsGetResponse, error) {
	rsp, err := c.TagsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsGetResponse(rsp)
}

// TagsGetPostWithBodyWithResponse request with arbitrary body returning *TagsGetPostResponse
func (c *ClientWithResponses) TagsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsGetPostResponse, error) {
	rsp, err := c.TagsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsGetPostResponse(rsp)
}

func (c *ClientWithResponses) TagsGetPostWithResponse(ctx context.Context, body TagsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsGetPostResponse, error) {
	rsp, err := c.TagsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsGetPostResponse(rsp)
}

// TagsListWithResponse request returning *TagsListResponse
func (c *ClientWithResponses) TagsListWithResponse(ctx context.Context, params *TagsListParams, reqEditors ...RequestEditorFn) (*TagsListResponse, error) {
	rsp, err := c.TagsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListResponse(rsp)
}

// TagsListPostWithBodyWithResponse request with arbitrary body returning *TagsListPostResponse
func (c *ClientWithResponses) TagsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsListPostResponse, error) {
	rsp, err := c.TagsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListPostResponse(rsp)
}

func (c *ClientWithResponses) TagsListPostWithResponse(ctx context.Context, body TagsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsListPostResponse, error) {
	rsp, err := c.TagsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListPostResponse(rsp)
}

// TagsUpdateWithBodyWithResponse request with arbitrary body returning *TagsUpdateResponse
func (c *ClientWithResponses) TagsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsUpdateResponse, error) {
	rsp, err := c.TagsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsUpdateResponse(rsp)
}

func (c *ClientWithResponses) TagsUpdateWithResponse(ctx context.Context, body TagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsUpdateResponse, error) {
	rsp, err := c.TagsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsUpdateResponse(rsp)
}

// TimelineEntriesCreateWithBodyWithResponse request with arbitrary body returning *TimelineEntriesCreateResponse
func (c *ClientWithResponses) TimelineEntriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesCreateResponse, error) {
	rsp, err := c.TimelineEntriesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesCreateResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesCreateWithResponse(ctx context.Context, body TimelineEntriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesCreateResponse, error) {
	rsp, err := c.TimelineEntriesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesCreateResponse(rsp)
}

// TimelineEntriesDeleteWithBodyWithResponse request with arbitrary body returning *TimelineEntriesDeleteResponse
func (c *ClientWithResponses) TimelineEntriesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesDeleteResponse, error) {
	rsp, err := c.TimelineEntriesDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesDeleteResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesDeleteWithResponse(ctx context.Context, body TimelineEntriesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesDeleteResponse, error) {
	rsp, err := c.TimelineEntriesDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesDeleteResponse(rsp)
}

// TimelineEntriesGetWithResponse request returning *TimelineEntriesGetResponse
func (c *ClientWithResponses) TimelineEntriesGetWithResponse(ctx context.Context, params *TimelineEntriesGetParams, reqEditors ...RequestEditorFn) (*TimelineEntriesGetResponse, error) {
	rsp, err := c.TimelineEntriesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesGetResponse(rsp)
}

// TimelineEntriesGetPostWithBodyWithResponse request with arbitrary body returning *TimelineEntriesGetPostResponse
func (c *ClientWithResponses) TimelineEntriesGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesGetPostResponse, error) {
	rsp, err := c.TimelineEntriesGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesGetPostResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesGetPostWithResponse(ctx context.Context, body TimelineEntriesGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesGetPostResponse, error) {
	rsp, err := c.TimelineEntriesGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesGetPostResponse(rsp)
}

// TimelineEntriesListWithResponse request returning *TimelineEntriesListResponse
func (c *ClientWithResponses) TimelineEntriesListWithResponse(ctx context.Context, params *TimelineEntriesListParams, reqEditors ...RequestEditorFn) (*TimelineEntriesListResponse, error) {
	rsp, err := c.TimelineEntriesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesListResponse(rsp)
}

// TimelineEntriesListPostWithBodyWithResponse request with arbitrary body returning *TimelineEntriesListPostResponse
func (c *ClientWithResponses) TimelineEntriesListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesListPostResponse, error) {
	rsp, err := c.TimelineEntriesListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesListPostResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesListPostWithResponse(ctx context.Context, body TimelineEntriesListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesListPostResponse, error) {
	rsp, err := c.TimelineEntriesListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesListPostResponse(rsp)
}

// TimelineEntriesUpdateWithBodyWithResponse request with arbitrary body returning *TimelineEntriesUpdateResponse
func (c *ClientWithResponses) TimelineEntriesUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelineEntriesUpdateResponse, error) {
	rsp, err := c.TimelineEntriesUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesUpdateResponse(rsp)
}

func (c *ClientWithResponses) TimelineEntriesUpdateWithResponse(ctx context.Context, body TimelineEntriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelineEntriesUpdateResponse, error) {
	rsp, err := c.TimelineEntriesUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelineEntriesUpdateResponse(rsp)
}

// TrackEventsPublishWithBodyWithResponse request with arbitrary body returning *TrackEventsPublishResponse
func (c *ClientWithResponses) TrackEventsPublishWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TrackEventsPublishResponse, error) {
	rsp, err := c.TrackEventsPublishWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackEventsPublishResponse(rsp)
}

func (c *ClientWithResponses) TrackEventsPublishWithResponse(ctx context.Context, body TrackEventsPublishJSONRequestBody, reqEditors ...RequestEditorFn) (*TrackEventsPublishResponse, error) {
	rsp, err := c.TrackEventsPublish(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackEventsPublishResponse(rsp)
}

// UomsCountWithResponse request returning *UomsCountResponse
func (c *ClientWithResponses) UomsCountWithResponse(ctx context.Context, params *UomsCountParams, reqEditors ...RequestEditorFn) (*UomsCountResponse, error) {
	rsp, err := c.UomsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsCountResponse(rsp)
}

// UomsCountPostWithBodyWithResponse request with arbitrary body returning *UomsCountPostResponse
func (c *ClientWithResponses) UomsCountPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsCountPostResponse, error) {
	rsp, err := c.UomsCountPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsCountPostResponse(rsp)
}

func (c *ClientWithResponses) UomsCountPostWithResponse(ctx context.Context, body UomsCountPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsCountPostResponse, error) {
	rsp, err := c.UomsCountPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsCountPostResponse(rsp)
}

// UomsCreateWithBodyWithResponse request with arbitrary body returning *UomsCreateResponse
func (c *ClientWithResponses) UomsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsCreateResponse, error) {
	rsp, err := c.UomsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsCreateResponse(rsp)
}

func (c *ClientWithResponses) UomsCreateWithResponse(ctx context.Context, body UomsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsCreateResponse, error) {
	rsp, err := c.UomsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsCreateResponse(rsp)
}

// UomsDeleteWithBodyWithResponse request with arbitrary body returning *UomsDeleteResponse
func (c *ClientWithResponses) UomsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsDeleteResponse, error) {
	rsp, err := c.UomsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsDeleteResponse(rsp)
}

func (c *ClientWithResponses) UomsDeleteWithResponse(ctx context.Context, body UomsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsDeleteResponse, error) {
	rsp, err := c.UomsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsDeleteResponse(rsp)
}

// UomsGetWithResponse request returning *UomsGetResponse
func (c *ClientWithResponses) UomsGetWithResponse(ctx context.Context, params *UomsGetParams, reqEditors ...RequestEditorFn) (*UomsGetResponse, error) {
	rsp, err := c.UomsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsGetResponse(rsp)
}

// UomsGetPostWithBodyWithResponse request with arbitrary body returning *UomsGetPostResponse
func (c *ClientWithResponses) UomsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsGetPostResponse, error) {
	rsp, err := c.UomsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsGetPostResponse(rsp)
}

func (c *ClientWithResponses) UomsGetPostWithResponse(ctx context.Context, body UomsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsGetPostResponse, error) {
	rsp, err := c.UomsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsGetPostResponse(rsp)
}

// UomsListWithResponse request returning *UomsListResponse
func (c *ClientWithResponses) UomsListWithResponse(ctx context.Context, params *UomsListParams, reqEditors ...RequestEditorFn) (*UomsListResponse, error) {
	rsp, err := c.UomsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsListResponse(rsp)
}

// UomsListPostWithBodyWithResponse request with arbitrary body returning *UomsListPostResponse
func (c *ClientWithResponses) UomsListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsListPostResponse, error) {
	rsp, err := c.UomsListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsListPostResponse(rsp)
}

func (c *ClientWithResponses) UomsListPostWithResponse(ctx context.Context, body UomsListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsListPostResponse, error) {
	rsp, err := c.UomsListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsListPostResponse(rsp)
}

// UomsUpdateWithBodyWithResponse request with arbitrary body returning *UomsUpdateResponse
func (c *ClientWithResponses) UomsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UomsUpdateResponse, error) {
	rsp, err := c.UomsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsUpdateResponse(rsp)
}

func (c *ClientWithResponses) UomsUpdateWithResponse(ctx context.Context, body UomsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UomsUpdateResponse, error) {
	rsp, err := c.UomsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUomsUpdateResponse(rsp)
}

// WebCrawlerJobsControlWithBodyWithResponse request with arbitrary body returning *WebCrawlerJobsControlResponse
func (c *ClientWithResponses) WebCrawlerJobsControlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebCrawlerJobsControlResponse, error) {
	rsp, err := c.WebCrawlerJobsControlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebCrawlerJobsControlResponse(rsp)
}

func (c *ClientWithResponses) WebCrawlerJobsControlWithResponse(ctx context.Context, body WebCrawlerJobsControlJSONRequestBody, reqEditors ...RequestEditorFn) (*WebCrawlerJobsControlResponse, error) {
	rsp, err := c.WebCrawlerJobsControl(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebCrawlerJobsControlResponse(rsp)
}

// CreateWebCrawlerJobWithBodyWithResponse request with arbitrary body returning *CreateWebCrawlerJobResponse
func (c *ClientWithResponses) CreateWebCrawlerJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebCrawlerJobResponse, error) {
	rsp, err := c.CreateWebCrawlerJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebCrawlerJobResponse(rsp)
}

func (c *ClientWithResponses) CreateWebCrawlerJobWithResponse(ctx context.Context, body CreateWebCrawlerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebCrawlerJobResponse, error) {
	rsp, err := c.CreateWebCrawlerJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebCrawlerJobResponse(rsp)
}

// GetWebCrawlerJobWithResponse request returning *GetWebCrawlerJobResponse
func (c *ClientWithResponses) GetWebCrawlerJobWithResponse(ctx context.Context, params *GetWebCrawlerJobParams, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobResponse, error) {
	rsp, err := c.GetWebCrawlerJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebCrawlerJobResponse(rsp)
}

// GetWebCrawlerJobPostWithBodyWithResponse request with arbitrary body returning *GetWebCrawlerJobPostResponse
func (c *ClientWithResponses) GetWebCrawlerJobPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobPostResponse, error) {
	rsp, err := c.GetWebCrawlerJobPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebCrawlerJobPostResponse(rsp)
}

func (c *ClientWithResponses) GetWebCrawlerJobPostWithResponse(ctx context.Context, body GetWebCrawlerJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetWebCrawlerJobPostResponse, error) {
	rsp, err := c.GetWebCrawlerJobPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebCrawlerJobPostResponse(rsp)
}

// ListWebCrawlerJobsWithResponse request returning *ListWebCrawlerJobsResponse
func (c *ClientWithResponses) ListWebCrawlerJobsWithResponse(ctx context.Context, params *ListWebCrawlerJobsParams, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsResponse, error) {
	rsp, err := c.ListWebCrawlerJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebCrawlerJobsResponse(rsp)
}

// ListWebCrawlerJobsPostWithBodyWithResponse request with arbitrary body returning *ListWebCrawlerJobsPostResponse
func (c *ClientWithResponses) ListWebCrawlerJobsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsPostResponse, error) {
	rsp, err := c.ListWebCrawlerJobsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebCrawlerJobsPostResponse(rsp)
}

func (c *ClientWithResponses) ListWebCrawlerJobsPostWithResponse(ctx context.Context, body ListWebCrawlerJobsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ListWebCrawlerJobsPostResponse, error) {
	rsp, err := c.ListWebCrawlerJobsPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebCrawlerJobsPostResponse(rsp)
}

// WebhooksCreateWithBodyWithResponse request with arbitrary body returning *WebhooksCreateResponse
func (c *ClientWithResponses) WebhooksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error) {
	rsp, err := c.WebhooksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksCreateResponse(rsp)
}

func (c *ClientWithResponses) WebhooksCreateWithResponse(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error) {
	rsp, err := c.WebhooksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksCreateResponse(rsp)
}

// WebhooksDeleteWithBodyWithResponse request with arbitrary body returning *WebhooksDeleteResponse
func (c *ClientWithResponses) WebhooksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error) {
	rsp, err := c.WebhooksDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksDeleteResponse(rsp)
}

func (c *ClientWithResponses) WebhooksDeleteWithResponse(ctx context.Context, body WebhooksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error) {
	rsp, err := c.WebhooksDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksDeleteResponse(rsp)
}

// WebhooksEventWithBodyWithResponse request with arbitrary body returning *WebhooksEventResponse
func (c *ClientWithResponses) WebhooksEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksEventResponse, error) {
	rsp, err := c.WebhooksEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksEventResponse(rsp)
}

func (c *ClientWithResponses) WebhooksEventWithResponse(ctx context.Context, body WebhooksEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksEventResponse, error) {
	rsp, err := c.WebhooksEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksEventResponse(rsp)
}

// WebhooksFetchWithBodyWithResponse request with arbitrary body returning *WebhooksFetchResponse
func (c *ClientWithResponses) WebhooksFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksFetchResponse, error) {
	rsp, err := c.WebhooksFetchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksFetchResponse(rsp)
}

func (c *ClientWithResponses) WebhooksFetchWithResponse(ctx context.Context, body WebhooksFetchJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksFetchResponse, error) {
	rsp, err := c.WebhooksFetch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksFetchResponse(rsp)
}

// WebhooksGetWithResponse request returning *WebhooksGetResponse
func (c *ClientWithResponses) WebhooksGetWithResponse(ctx context.Context, params *WebhooksGetParams, reqEditors ...RequestEditorFn) (*WebhooksGetResponse, error) {
	rsp, err := c.WebhooksGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksGetResponse(rsp)
}

// WebhooksGetPostWithBodyWithResponse request with arbitrary body returning *WebhooksGetPostResponse
func (c *ClientWithResponses) WebhooksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksGetPostResponse, error) {
	rsp, err := c.WebhooksGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksGetPostResponse(rsp)
}

func (c *ClientWithResponses) WebhooksGetPostWithResponse(ctx context.Context, body WebhooksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksGetPostResponse, error) {
	rsp, err := c.WebhooksGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksGetPostResponse(rsp)
}

// WebhooksListWithResponse request returning *WebhooksListResponse
func (c *ClientWithResponses) WebhooksListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WebhooksListResponse, error) {
	rsp, err := c.WebhooksList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListResponse(rsp)
}

// WebhooksListPostWithBodyWithResponse request with arbitrary body returning *WebhooksListPostResponse
func (c *ClientWithResponses) WebhooksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksListPostResponse, error) {
	rsp, err := c.WebhooksListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListPostResponse(rsp)
}

func (c *ClientWithResponses) WebhooksListPostWithResponse(ctx context.Context, body WebhooksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksListPostResponse, error) {
	rsp, err := c.WebhooksListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListPostResponse(rsp)
}

// WebhooksUpdateWithBodyWithResponse request with arbitrary body returning *WebhooksUpdateResponse
func (c *ClientWithResponses) WebhooksUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error) {
	rsp, err := c.WebhooksUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksUpdateResponse(rsp)
}

func (c *ClientWithResponses) WebhooksUpdateWithResponse(ctx context.Context, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error) {
	rsp, err := c.WebhooksUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksUpdateResponse(rsp)
}

// WidgetsGetWithResponse request returning *WidgetsGetResponse
func (c *ClientWithResponses) WidgetsGetWithResponse(ctx context.Context, params *WidgetsGetParams, reqEditors ...RequestEditorFn) (*WidgetsGetResponse, error) {
	rsp, err := c.WidgetsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWidgetsGetResponse(rsp)
}

// WidgetsGetPostWithBodyWithResponse request with arbitrary body returning *WidgetsGetPostResponse
func (c *ClientWithResponses) WidgetsGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WidgetsGetPostResponse, error) {
	rsp, err := c.WidgetsGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWidgetsGetPostResponse(rsp)
}

func (c *ClientWithResponses) WidgetsGetPostWithResponse(ctx context.Context, body WidgetsGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WidgetsGetPostResponse, error) {
	rsp, err := c.WidgetsGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWidgetsGetPostResponse(rsp)
}

// WorksCreateWithBodyWithResponse request with arbitrary body returning *WorksCreateResponse
func (c *ClientWithResponses) WorksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksCreateResponse, error) {
	rsp, err := c.WorksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksCreateResponse(rsp)
}

func (c *ClientWithResponses) WorksCreateWithResponse(ctx context.Context, body WorksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksCreateResponse, error) {
	rsp, err := c.WorksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksCreateResponse(rsp)
}

// WorksDeleteWithBodyWithResponse request with arbitrary body returning *WorksDeleteResponse
func (c *ClientWithResponses) WorksDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksDeleteResponse, error) {
	rsp, err := c.WorksDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksDeleteResponse(rsp)
}

func (c *ClientWithResponses) WorksDeleteWithResponse(ctx context.Context, body WorksDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksDeleteResponse, error) {
	rsp, err := c.WorksDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksDeleteResponse(rsp)
}

// WorksExportWithResponse request returning *WorksExportResponse
func (c *ClientWithResponses) WorksExportWithResponse(ctx context.Context, params *WorksExportParams, reqEditors ...RequestEditorFn) (*WorksExportResponse, error) {
	rsp, err := c.WorksExport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksExportResponse(rsp)
}

// WorksExportPostWithBodyWithResponse request with arbitrary body returning *WorksExportPostResponse
func (c *ClientWithResponses) WorksExportPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksExportPostResponse, error) {
	rsp, err := c.WorksExportPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksExportPostResponse(rsp)
}

func (c *ClientWithResponses) WorksExportPostWithResponse(ctx context.Context, body WorksExportPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksExportPostResponse, error) {
	rsp, err := c.WorksExportPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksExportPostResponse(rsp)
}

// WorksGetWithResponse request returning *WorksGetResponse
func (c *ClientWithResponses) WorksGetWithResponse(ctx context.Context, params *WorksGetParams, reqEditors ...RequestEditorFn) (*WorksGetResponse, error) {
	rsp, err := c.WorksGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksGetResponse(rsp)
}

// WorksGetPostWithBodyWithResponse request with arbitrary body returning *WorksGetPostResponse
func (c *ClientWithResponses) WorksGetPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksGetPostResponse, error) {
	rsp, err := c.WorksGetPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksGetPostResponse(rsp)
}

func (c *ClientWithResponses) WorksGetPostWithResponse(ctx context.Context, body WorksGetPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksGetPostResponse, error) {
	rsp, err := c.WorksGetPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksGetPostResponse(rsp)
}

// WorksListWithResponse request returning *WorksListResponse
func (c *ClientWithResponses) WorksListWithResponse(ctx context.Context, params *WorksListParams, reqEditors ...RequestEditorFn) (*WorksListResponse, error) {
	rsp, err := c.WorksList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksListResponse(rsp)
}

// WorksListPostWithBodyWithResponse request with arbitrary body returning *WorksListPostResponse
func (c *ClientWithResponses) WorksListPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksListPostResponse, error) {
	rsp, err := c.WorksListPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksListPostResponse(rsp)
}

func (c *ClientWithResponses) WorksListPostWithResponse(ctx context.Context, body WorksListPostJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksListPostResponse, error) {
	rsp, err := c.WorksListPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksListPostResponse(rsp)
}

// WorksUpdateWithBodyWithResponse request with arbitrary body returning *WorksUpdateResponse
func (c *ClientWithResponses) WorksUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorksUpdateResponse, error) {
	rsp, err := c.WorksUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksUpdateResponse(rsp)
}

func (c *ClientWithResponses) WorksUpdateWithResponse(ctx context.Context, body WorksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorksUpdateResponse, error) {
	rsp, err := c.WorksUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorksUpdateResponse(rsp)
}

// ParseAccountsCreateResponse parses an HTTP response from a AccountsCreateWithResponse call
func ParseAccountsCreateResponse(rsp *http.Response) (*AccountsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccountsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsDeleteResponse parses an HTTP response from a AccountsDeleteWithResponse call
func ParseAccountsDeleteResponse(rsp *http.Response) (*AccountsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsExportResponse parses an HTTP response from a AccountsExportWithResponse call
func ParseAccountsExportResponse(rsp *http.Response) (*AccountsExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsExportPostResponse parses an HTTP response from a AccountsExportPostWithResponse call
func ParseAccountsExportPostResponse(rsp *http.Response) (*AccountsExportPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsExportPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsGetResponse parses an HTTP response from a AccountsGetWithResponse call
func ParseAccountsGetResponse(rsp *http.Response) (*AccountsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsGetPostResponse parses an HTTP response from a AccountsGetPostWithResponse call
func ParseAccountsGetPostResponse(rsp *http.Response) (*AccountsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsListResponse parses an HTTP response from a AccountsListWithResponse call
func ParseAccountsListResponse(rsp *http.Response) (*AccountsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsListPostResponse parses an HTTP response from a AccountsListPostWithResponse call
func ParseAccountsListPostResponse(rsp *http.Response) (*AccountsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsMergeResponse parses an HTTP response from a AccountsMergeWithResponse call
func ParseAccountsMergeResponse(rsp *http.Response) (*AccountsMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsMergeResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAccountsUpdateResponse parses an HTTP response from a AccountsUpdateWithResponse call
func ParseAccountsUpdateResponse(rsp *http.Response) (*AccountsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAiAgentEventsExecuteAsyncResponse parses an HTTP response from a AiAgentEventsExecuteAsyncWithResponse call
func ParseAiAgentEventsExecuteAsyncResponse(rsp *http.Response) (*AiAgentEventsExecuteAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AiAgentEventsExecuteAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AiAgentEventsExecuteAsyncResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAirdropSyncUnitsGetResponse parses an HTTP response from a AirdropSyncUnitsGetWithResponse call
func ParseAirdropSyncUnitsGetResponse(rsp *http.Response) (*AirdropSyncUnitsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AirdropSyncUnitsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AirdropSyncUnitsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAirdropSyncUnitsGetPostResponse parses an HTTP response from a AirdropSyncUnitsGetPostWithResponse call
func ParseAirdropSyncUnitsGetPostResponse(rsp *http.Response) (*AirdropSyncUnitsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AirdropSyncUnitsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AirdropSyncUnitsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAirdropSyncUnitsHistoryResponse parses an HTTP response from a AirdropSyncUnitsHistoryWithResponse call
func ParseAirdropSyncUnitsHistoryResponse(rsp *http.Response) (*AirdropSyncUnitsHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AirdropSyncUnitsHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AirdropSyncUnitsHistoryResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAirdropSyncUnitsHistoryPostResponse parses an HTTP response from a AirdropSyncUnitsHistoryPostWithResponse call
func ParseAirdropSyncUnitsHistoryPostResponse(rsp *http.Response) (*AirdropSyncUnitsHistoryPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AirdropSyncUnitsHistoryPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AirdropSyncUnitsHistoryResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArticlesCountResponse parses an HTTP response from a ArticlesCountWithResponse call
func ParseArticlesCountResponse(rsp *http.Response) (*ArticlesCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArticlesCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArticlesCountPostResponse parses an HTTP response from a ArticlesCountPostWithResponse call
func ParseArticlesCountPostResponse(rsp *http.Response) (*ArticlesCountPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArticlesCountPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateArticleResponse parses an HTTP response from a CreateArticleWithResponse call
func ParseCreateArticleResponse(rsp *http.Response) (*CreateArticleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ArticlesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteArticleResponse parses an HTTP response from a DeleteArticleWithResponse call
func ParseDeleteArticleResponse(rsp *http.Response) (*DeleteArticleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetArticleResponse parses an HTTP response from a GetArticleWithResponse call
func ParseGetArticleResponse(rsp *http.Response) (*GetArticleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetArticlePostResponse parses an HTTP response from a GetArticlePostWithResponse call
func ParseGetArticlePostResponse(rsp *http.Response) (*GetArticlePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArticlePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListArticlesResponse parses an HTTP response from a ListArticlesWithResponse call
func ParseListArticlesResponse(rsp *http.Response) (*ListArticlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListArticlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListArticlesPostResponse parses an HTTP response from a ListArticlesPostWithResponse call
func ParseListArticlesPostResponse(rsp *http.Response) (*ListArticlesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListArticlesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateArticleResponse parses an HTTP response from a UpdateArticleWithResponse call
func ParseUpdateArticleResponse(rsp *http.Response) (*UpdateArticleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateArticleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArticlesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsGetResponse parses an HTTP response from a ArtifactsGetWithResponse call
func ParseArtifactsGetResponse(rsp *http.Response) (*ArtifactsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsGetPostResponse parses an HTTP response from a ArtifactsGetPostWithResponse call
func ParseArtifactsGetPostResponse(rsp *http.Response) (*ArtifactsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsListResponse parses an HTTP response from a ArtifactsListWithResponse call
func ParseArtifactsListResponse(rsp *http.Response) (*ArtifactsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsListPostResponse parses an HTTP response from a ArtifactsListPostWithResponse call
func ParseArtifactsListPostResponse(rsp *http.Response) (*ArtifactsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsLocateResponse parses an HTTP response from a ArtifactsLocateWithResponse call
func ParseArtifactsLocateResponse(rsp *http.Response) (*ArtifactsLocateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsLocateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsLocateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsLocatePostResponse parses an HTTP response from a ArtifactsLocatePostWithResponse call
func ParseArtifactsLocatePostResponse(rsp *http.Response) (*ArtifactsLocatePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsLocatePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsLocateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsPrepareResponse parses an HTTP response from a ArtifactsPrepareWithResponse call
func ParseArtifactsPrepareResponse(rsp *http.Response) (*ArtifactsPrepareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsPrepareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsPrepareResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsHardDeleteVersionResponse parses an HTTP response from a ArtifactsHardDeleteVersionWithResponse call
func ParseArtifactsHardDeleteVersionResponse(rsp *http.Response) (*ArtifactsHardDeleteVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsHardDeleteVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsHardDeleteVersionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArtifactsVersionsPrepareResponse parses an HTTP response from a ArtifactsVersionsPrepareWithResponse call
func ParseArtifactsVersionsPrepareResponse(rsp *http.Response) (*ArtifactsVersionsPrepareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtifactsVersionsPrepareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtifactsVersionsPrepareResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAtomsGetResponse parses an HTTP response from a AtomsGetWithResponse call
func ParseAtomsGetResponse(rsp *http.Response) (*AtomsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AtomsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AtomsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAtomsGetPostResponse parses an HTTP response from a AtomsGetPostWithResponse call
func ParseAtomsGetPostResponse(rsp *http.Response) (*AtomsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AtomsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AtomsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportAuditLogsResponse parses an HTTP response from a ExportAuditLogsWithResponse call
func ParseExportAuditLogsResponse(rsp *http.Response) (*ExportAuditLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExportAuditLogsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensCreateResponse parses an HTTP response from a AuthTokensCreateWithResponse call
func ParseAuthTokensCreateResponse(rsp *http.Response) (*AuthTokensCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthTokensCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensDeleteResponse parses an HTTP response from a AuthTokensDeleteWithResponse call
func ParseAuthTokensDeleteResponse(rsp *http.Response) (*AuthTokensDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensGetResponse parses an HTTP response from a AuthTokensGetWithResponse call
func ParseAuthTokensGetResponse(rsp *http.Response) (*AuthTokensGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensGetPostResponse parses an HTTP response from a AuthTokensGetPostWithResponse call
func ParseAuthTokensGetPostResponse(rsp *http.Response) (*AuthTokensGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensInfoResponse parses an HTTP response from a AuthTokensInfoWithResponse call
func ParseAuthTokensInfoResponse(rsp *http.Response) (*AuthTokensInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensInfoResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensInfoPostResponse parses an HTTP response from a AuthTokensInfoPostWithResponse call
func ParseAuthTokensInfoPostResponse(rsp *http.Response) (*AuthTokensInfoPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensInfoPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensInfoResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensListResponse parses an HTTP response from a AuthTokensListWithResponse call
func ParseAuthTokensListResponse(rsp *http.Response) (*AuthTokensListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensListPostResponse parses an HTTP response from a AuthTokensListPostWithResponse call
func ParseAuthTokensListPostResponse(rsp *http.Response) (*AuthTokensListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensSelfDeleteResponse parses an HTTP response from a AuthTokensSelfDeleteWithResponse call
func ParseAuthTokensSelfDeleteResponse(rsp *http.Response) (*AuthTokensSelfDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensSelfDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAuthTokensUpdateResponse parses an HTTP response from a AuthTokensUpdateWithResponse call
func ParseAuthTokensUpdateResponse(rsp *http.Response) (*AuthTokensUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthTokensUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokensUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseBrandsCreateResponse parses an HTTP response from a BrandsCreateWithResponse call
func ParseBrandsCreateResponse(rsp *http.Response) (*BrandsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrandsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BrandsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseBrandsDeleteResponse parses an HTTP response from a BrandsDeleteWithResponse call
func ParseBrandsDeleteResponse(rsp *http.Response) (*BrandsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrandsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest BrandsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseBrandsGetResponse parses an HTTP response from a BrandsGetWithResponse call
func ParseBrandsGetResponse(rsp *http.Response) (*BrandsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrandsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseBrandsGetPostResponse parses an HTTP response from a BrandsGetPostWithResponse call
func ParseBrandsGetPostResponse(rsp *http.Response) (*BrandsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrandsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseBrandsListResponse parses an HTTP response from a BrandsListWithResponse call
func ParseBrandsListResponse(rsp *http.Response) (*BrandsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrandsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseBrandsListPostResponse parses an HTTP response from a BrandsListPostWithResponse call
func ParseBrandsListPostResponse(rsp *http.Response) (*BrandsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrandsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseBrandsUpdateResponse parses an HTTP response from a BrandsUpdateWithResponse call
func ParseBrandsUpdateResponse(rsp *http.Response) (*BrandsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrandsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseChatsCreateResponse parses an HTTP response from a ChatsCreateWithResponse call
func ParseChatsCreateResponse(rsp *http.Response) (*ChatsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseChatsGetResponse parses an HTTP response from a ChatsGetWithResponse call
func ParseChatsGetResponse(rsp *http.Response) (*ChatsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseChatsGetPostResponse parses an HTTP response from a ChatsGetPostWithResponse call
func ParseChatsGetPostResponse(rsp *http.Response) (*ChatsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseChatsUpdateResponse parses an HTTP response from a ChatsUpdateWithResponse call
func ParseChatsUpdateResponse(rsp *http.Response) (*ChatsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesCreateResponse parses an HTTP response from a CodeChangesCreateWithResponse call
func ParseCodeChangesCreateResponse(rsp *http.Response) (*CodeChangesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesDeleteResponse parses an HTTP response from a CodeChangesDeleteWithResponse call
func ParseCodeChangesDeleteResponse(rsp *http.Response) (*CodeChangesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesGetResponse parses an HTTP response from a CodeChangesGetWithResponse call
func ParseCodeChangesGetResponse(rsp *http.Response) (*CodeChangesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesGetPostResponse parses an HTTP response from a CodeChangesGetPostWithResponse call
func ParseCodeChangesGetPostResponse(rsp *http.Response) (*CodeChangesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesListResponse parses an HTTP response from a CodeChangesListWithResponse call
func ParseCodeChangesListResponse(rsp *http.Response) (*CodeChangesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesListPostResponse parses an HTTP response from a CodeChangesListPostWithResponse call
func ParseCodeChangesListPostResponse(rsp *http.Response) (*CodeChangesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeChangesUpdateResponse parses an HTTP response from a CodeChangesUpdateWithResponse call
func ParseCodeChangesUpdateResponse(rsp *http.Response) (*CodeChangesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeChangesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeChangesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsCreateResponse parses an HTTP response from a CommandsCreateWithResponse call
func ParseCommandsCreateResponse(rsp *http.Response) (*CommandsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsGetResponse parses an HTTP response from a CommandsGetWithResponse call
func ParseCommandsGetResponse(rsp *http.Response) (*CommandsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsGetPostResponse parses an HTTP response from a CommandsGetPostWithResponse call
func ParseCommandsGetPostResponse(rsp *http.Response) (*CommandsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsListResponse parses an HTTP response from a CommandsListWithResponse call
func ParseCommandsListResponse(rsp *http.Response) (*CommandsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsListPostResponse parses an HTTP response from a CommandsListPostWithResponse call
func ParseCommandsListPostResponse(rsp *http.Response) (*CommandsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCommandsUpdateResponse parses an HTTP response from a CommandsUpdateWithResponse call
func ParseCommandsUpdateResponse(rsp *http.Response) (*CommandsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommandsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseContentTemplateCreateResponse parses an HTTP response from a ContentTemplateCreateWithResponse call
func ParseContentTemplateCreateResponse(rsp *http.Response) (*ContentTemplateCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContentTemplateCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ContentTemplateCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseContentTemplateGetResponse parses an HTTP response from a ContentTemplateGetWithResponse call
func ParseContentTemplateGetResponse(rsp *http.Response) (*ContentTemplateGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContentTemplateGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentTemplateGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseContentTemplateGetPostResponse parses an HTTP response from a ContentTemplateGetPostWithResponse call
func ParseContentTemplateGetPostResponse(rsp *http.Response) (*ContentTemplateGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContentTemplateGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentTemplateGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseContentTemplateListResponse parses an HTTP response from a ContentTemplateListWithResponse call
func ParseContentTemplateListResponse(rsp *http.Response) (*ContentTemplateListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContentTemplateListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentTemplateListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseContentTemplateListPostResponse parses an HTTP response from a ContentTemplateListPostWithResponse call
func ParseContentTemplateListPostResponse(rsp *http.Response) (*ContentTemplateListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContentTemplateListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentTemplateListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsCreateResponse parses an HTTP response from a ConversationsCreateWithResponse call
func ParseConversationsCreateResponse(rsp *http.Response) (*ConversationsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsDeleteResponse parses an HTTP response from a ConversationsDeleteWithResponse call
func ParseConversationsDeleteResponse(rsp *http.Response) (*ConversationsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsExportResponse parses an HTTP response from a ConversationsExportWithResponse call
func ParseConversationsExportResponse(rsp *http.Response) (*ConversationsExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsExportPostResponse parses an HTTP response from a ConversationsExportPostWithResponse call
func ParseConversationsExportPostResponse(rsp *http.Response) (*ConversationsExportPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsExportPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsGetResponse parses an HTTP response from a ConversationsGetWithResponse call
func ParseConversationsGetResponse(rsp *http.Response) (*ConversationsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsGetPostResponse parses an HTTP response from a ConversationsGetPostWithResponse call
func ParseConversationsGetPostResponse(rsp *http.Response) (*ConversationsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsListResponse parses an HTTP response from a ConversationsListWithResponse call
func ParseConversationsListResponse(rsp *http.Response) (*ConversationsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsListPostResponse parses an HTTP response from a ConversationsListPostWithResponse call
func ParseConversationsListPostResponse(rsp *http.Response) (*ConversationsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConversationsUpdateResponse parses an HTTP response from a ConversationsUpdateWithResponse call
func ParseConversationsUpdateResponse(rsp *http.Response) (*ConversationsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConversationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomObjectsCountResponse parses an HTTP response from a CustomObjectsCountWithResponse call
func ParseCustomObjectsCountResponse(rsp *http.Response) (*CustomObjectsCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomObjectsCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomObjectsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomObjectsCountPostResponse parses an HTTP response from a CustomObjectsCountPostWithResponse call
func ParseCustomObjectsCountPostResponse(rsp *http.Response) (*CustomObjectsCountPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomObjectsCountPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomObjectsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomObjectsCreateResponse parses an HTTP response from a CustomObjectsCreateWithResponse call
func ParseCustomObjectsCreateResponse(rsp *http.Response) (*CustomObjectsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomObjectsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CustomObjectsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomObjectsDeleteResponse parses an HTTP response from a CustomObjectsDeleteWithResponse call
func ParseCustomObjectsDeleteResponse(rsp *http.Response) (*CustomObjectsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomObjectsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomObjectsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomObjectsGetResponse parses an HTTP response from a CustomObjectsGetWithResponse call
func ParseCustomObjectsGetResponse(rsp *http.Response) (*CustomObjectsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomObjectsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomObjectsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomObjectsGetPostResponse parses an HTTP response from a CustomObjectsGetPostWithResponse call
func ParseCustomObjectsGetPostResponse(rsp *http.Response) (*CustomObjectsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomObjectsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomObjectsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomObjectsListResponse parses an HTTP response from a CustomObjectsListWithResponse call
func ParseCustomObjectsListResponse(rsp *http.Response) (*CustomObjectsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomObjectsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomObjectsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomObjectsListPostResponse parses an HTTP response from a CustomObjectsListPostWithResponse call
func ParseCustomObjectsListPostResponse(rsp *http.Response) (*CustomObjectsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomObjectsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomObjectsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomObjectsUpdateResponse parses an HTTP response from a CustomObjectsUpdateWithResponse call
func ParseCustomObjectsUpdateResponse(rsp *http.Response) (*CustomObjectsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomObjectsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomObjectsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsCreateResponse parses an HTTP response from a DevOrgAuthConnectionsCreateWithResponse call
func ParseDevOrgAuthConnectionsCreateResponse(rsp *http.Response) (*DevOrgAuthConnectionsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DevOrgAuthConnectionsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsDeleteResponse parses an HTTP response from a DevOrgAuthConnectionsDeleteWithResponse call
func ParseDevOrgAuthConnectionsDeleteResponse(rsp *http.Response) (*DevOrgAuthConnectionsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsGetResponse parses an HTTP response from a DevOrgAuthConnectionsGetWithResponse call
func ParseDevOrgAuthConnectionsGetResponse(rsp *http.Response) (*DevOrgAuthConnectionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgAuthConnectionsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsGetPostResponse parses an HTTP response from a DevOrgAuthConnectionsGetPostWithResponse call
func ParseDevOrgAuthConnectionsGetPostResponse(rsp *http.Response) (*DevOrgAuthConnectionsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgAuthConnectionsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsListResponse parses an HTTP response from a DevOrgAuthConnectionsListWithResponse call
func ParseDevOrgAuthConnectionsListResponse(rsp *http.Response) (*DevOrgAuthConnectionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgAuthConnectionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsListPostResponse parses an HTTP response from a DevOrgAuthConnectionsListPostWithResponse call
func ParseDevOrgAuthConnectionsListPostResponse(rsp *http.Response) (*DevOrgAuthConnectionsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgAuthConnectionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsToggleResponse parses an HTTP response from a DevOrgAuthConnectionsToggleWithResponse call
func ParseDevOrgAuthConnectionsToggleResponse(rsp *http.Response) (*DevOrgAuthConnectionsToggleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsToggleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgAuthConnectionsUpdateResponse parses an HTTP response from a DevOrgAuthConnectionsUpdateWithResponse call
func ParseDevOrgAuthConnectionsUpdateResponse(rsp *http.Response) (*DevOrgAuthConnectionsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgAuthConnectionsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DevOrgAuthConnectionsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgsGetResponse parses an HTTP response from a DevOrgsGetWithResponse call
func ParseDevOrgsGetResponse(rsp *http.Response) (*DevOrgsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevOrgsGetPostResponse parses an HTTP response from a DevOrgsGetPostWithResponse call
func ParseDevOrgsGetPostResponse(rsp *http.Response) (*DevOrgsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevOrgsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevOrgsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersActivateResponse parses an HTTP response from a DevUsersActivateWithResponse call
func ParseDevUsersActivateResponse(rsp *http.Response) (*DevUsersActivateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersActivateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersActivateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersCreateResponse parses an HTTP response from a DevUsersCreateWithResponse call
func ParseDevUsersCreateResponse(rsp *http.Response) (*DevUsersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DevUsersCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersDeactivateResponse parses an HTTP response from a DevUsersDeactivateWithResponse call
func ParseDevUsersDeactivateResponse(rsp *http.Response) (*DevUsersDeactivateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersDeactivateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersDeactivateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersGetResponse parses an HTTP response from a DevUsersGetWithResponse call
func ParseDevUsersGetResponse(rsp *http.Response) (*DevUsersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersGetPostResponse parses an HTTP response from a DevUsersGetPostWithResponse call
func ParseDevUsersGetPostResponse(rsp *http.Response) (*DevUsersGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersIdentitiesLinkResponse parses an HTTP response from a DevUsersIdentitiesLinkWithResponse call
func ParseDevUsersIdentitiesLinkResponse(rsp *http.Response) (*DevUsersIdentitiesLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersIdentitiesLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersIdentitiesLinkResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersIdentitiesUnlinkResponse parses an HTTP response from a DevUsersIdentitiesUnlinkWithResponse call
func ParseDevUsersIdentitiesUnlinkResponse(rsp *http.Response) (*DevUsersIdentitiesUnlinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersIdentitiesUnlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersIdentitiesUnlinkResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersListResponse parses an HTTP response from a DevUsersListWithResponse call
func ParseDevUsersListResponse(rsp *http.Response) (*DevUsersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersListPostResponse parses an HTTP response from a DevUsersListPostWithResponse call
func ParseDevUsersListPostResponse(rsp *http.Response) (*DevUsersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersMergeResponse parses an HTTP response from a DevUsersMergeWithResponse call
func ParseDevUsersMergeResponse(rsp *http.Response) (*DevUsersMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersMergeResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersSelfResponse parses an HTTP response from a DevUsersSelfWithResponse call
func ParseDevUsersSelfResponse(rsp *http.Response) (*DevUsersSelfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersSelfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersSelfResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersSelfPostResponse parses an HTTP response from a DevUsersSelfPostWithResponse call
func ParseDevUsersSelfPostResponse(rsp *http.Response) (*DevUsersSelfPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersSelfPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersSelfResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersSelfUpdateResponse parses an HTTP response from a DevUsersSelfUpdateWithResponse call
func ParseDevUsersSelfUpdateResponse(rsp *http.Response) (*DevUsersSelfUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersSelfUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDevUsersUpdateResponse parses an HTTP response from a DevUsersUpdateWithResponse call
func ParseDevUsersUpdateResponse(rsp *http.Response) (*DevUsersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevUsersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevUsersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesCountResponse parses an HTTP response from a DirectoriesCountWithResponse call
func ParseDirectoriesCountResponse(rsp *http.Response) (*DirectoriesCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesCountPostResponse parses an HTTP response from a DirectoriesCountPostWithResponse call
func ParseDirectoriesCountPostResponse(rsp *http.Response) (*DirectoriesCountPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesCountPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesCreateResponse parses an HTTP response from a DirectoriesCreateWithResponse call
func ParseDirectoriesCreateResponse(rsp *http.Response) (*DirectoriesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DirectoriesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesDeleteResponse parses an HTTP response from a DirectoriesDeleteWithResponse call
func ParseDirectoriesDeleteResponse(rsp *http.Response) (*DirectoriesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesGetResponse parses an HTTP response from a DirectoriesGetWithResponse call
func ParseDirectoriesGetResponse(rsp *http.Response) (*DirectoriesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesGetPostResponse parses an HTTP response from a DirectoriesGetPostWithResponse call
func ParseDirectoriesGetPostResponse(rsp *http.Response) (*DirectoriesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesListResponse parses an HTTP response from a DirectoriesListWithResponse call
func ParseDirectoriesListResponse(rsp *http.Response) (*DirectoriesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesListPostResponse parses an HTTP response from a DirectoriesListPostWithResponse call
func ParseDirectoriesListPostResponse(rsp *http.Response) (*DirectoriesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDirectoriesUpdateResponse parses an HTTP response from a DirectoriesUpdateWithResponse call
func ParseDirectoriesUpdateResponse(rsp *http.Response) (*DirectoriesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectoriesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoriesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEngagementsCountResponse parses an HTTP response from a EngagementsCountWithResponse call
func ParseEngagementsCountResponse(rsp *http.Response) (*EngagementsCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEngagementsCountPostResponse parses an HTTP response from a EngagementsCountPostWithResponse call
func ParseEngagementsCountPostResponse(rsp *http.Response) (*EngagementsCountPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsCountPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEngagementsCreateResponse parses an HTTP response from a EngagementsCreateWithResponse call
func ParseEngagementsCreateResponse(rsp *http.Response) (*EngagementsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EngagementsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEngagementsDeleteResponse parses an HTTP response from a EngagementsDeleteWithResponse call
func ParseEngagementsDeleteResponse(rsp *http.Response) (*EngagementsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEngagementsGetResponse parses an HTTP response from a EngagementsGetWithResponse call
func ParseEngagementsGetResponse(rsp *http.Response) (*EngagementsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEngagementsGetPostResponse parses an HTTP response from a EngagementsGetPostWithResponse call
func ParseEngagementsGetPostResponse(rsp *http.Response) (*EngagementsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEngagementsListResponse parses an HTTP response from a EngagementsListWithResponse call
func ParseEngagementsListResponse(rsp *http.Response) (*EngagementsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEngagementsListPostResponse parses an HTTP response from a EngagementsListPostWithResponse call
func ParseEngagementsListPostResponse(rsp *http.Response) (*EngagementsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEngagementsUpdateResponse parses an HTTP response from a EngagementsUpdateWithResponse call
func ParseEngagementsUpdateResponse(rsp *http.Response) (*EngagementsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEventSourcesGetResponse parses an HTTP response from a EventSourcesGetWithResponse call
func ParseEventSourcesGetResponse(rsp *http.Response) (*EventSourcesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventSourcesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventSourceGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEventSourcesGetPostResponse parses an HTTP response from a EventSourcesGetPostWithResponse call
func ParseEventSourcesGetPostResponse(rsp *http.Response) (*EventSourcesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventSourcesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventSourceGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEventSourcesScheduleEventResponse parses an HTTP response from a EventSourcesScheduleEventWithResponse call
func ParseEventSourcesScheduleEventResponse(rsp *http.Response) (*EventSourcesScheduleEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventSourcesScheduleEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventSourcesScheduleEventResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEventSourcesDeleteScheduledEventResponse parses an HTTP response from a EventSourcesDeleteScheduledEventWithResponse call
func ParseEventSourcesDeleteScheduledEventResponse(rsp *http.Response) (*EventSourcesDeleteScheduledEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventSourcesDeleteScheduledEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsCreateResponse parses an HTTP response from a GroupsCreateWithResponse call
func ParseGroupsCreateResponse(rsp *http.Response) (*GroupsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GroupsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsGetResponse parses an HTTP response from a GroupsGetWithResponse call
func ParseGroupsGetResponse(rsp *http.Response) (*GroupsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsGetPostResponse parses an HTTP response from a GroupsGetPostWithResponse call
func ParseGroupsGetPostResponse(rsp *http.Response) (*GroupsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsListResponse parses an HTTP response from a GroupsListWithResponse call
func ParseGroupsListResponse(rsp *http.Response) (*GroupsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsListPostResponse parses an HTTP response from a GroupsListPostWithResponse call
func ParseGroupsListPostResponse(rsp *http.Response) (*GroupsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupMembersAddResponse parses an HTTP response from a GroupMembersAddWithResponse call
func ParseGroupMembersAddResponse(rsp *http.Response) (*GroupMembersAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupMembersAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMembersAddResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupMembersListResponse parses an HTTP response from a GroupMembersListWithResponse call
func ParseGroupMembersListResponse(rsp *http.Response) (*GroupMembersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupMembersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMembersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupMembersListPostResponse parses an HTTP response from a GroupMembersListPostWithResponse call
func ParseGroupMembersListPostResponse(rsp *http.Response) (*GroupMembersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupMembersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMembersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupMembersRemoveResponse parses an HTTP response from a GroupMembersRemoveWithResponse call
func ParseGroupMembersRemoveResponse(rsp *http.Response) (*GroupMembersRemoveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupMembersRemoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMembersRemoveResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGroupsUpdateResponse parses an HTTP response from a GroupsUpdateWithResponse call
func ParseGroupsUpdateResponse(rsp *http.Response) (*GroupsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIncidentsCreateResponse parses an HTTP response from a IncidentsCreateWithResponse call
func ParseIncidentsCreateResponse(rsp *http.Response) (*IncidentsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncidentsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IncidentsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIncidentsDeleteResponse parses an HTTP response from a IncidentsDeleteWithResponse call
func ParseIncidentsDeleteResponse(rsp *http.Response) (*IncidentsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncidentsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIncidentsGetResponse parses an HTTP response from a IncidentsGetWithResponse call
func ParseIncidentsGetResponse(rsp *http.Response) (*IncidentsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncidentsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIncidentsGetPostResponse parses an HTTP response from a IncidentsGetPostWithResponse call
func ParseIncidentsGetPostResponse(rsp *http.Response) (*IncidentsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncidentsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIncidentsGroupResponse parses an HTTP response from a IncidentsGroupWithResponse call
func ParseIncidentsGroupResponse(rsp *http.Response) (*IncidentsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncidentsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentsGroupResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIncidentsGroupPostResponse parses an HTTP response from a IncidentsGroupPostWithResponse call
func ParseIncidentsGroupPostResponse(rsp *http.Response) (*IncidentsGroupPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncidentsGroupPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentsGroupResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIncidentsListResponse parses an HTTP response from a IncidentsListWithResponse call
func ParseIncidentsListResponse(rsp *http.Response) (*IncidentsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncidentsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIncidentsListPostResponse parses an HTTP response from a IncidentsListPostWithResponse call
func ParseIncidentsListPostResponse(rsp *http.Response) (*IncidentsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncidentsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIncidentsUpdateResponse parses an HTTP response from a IncidentsUpdateWithResponse call
func ParseIncidentsUpdateResponse(rsp *http.Response) (*IncidentsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncidentsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseKeyringsCreateCallbackResponse parses an HTTP response from a KeyringsCreateCallbackWithResponse call
func ParseKeyringsCreateCallbackResponse(rsp *http.Response) (*KeyringsCreateCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &KeyringsCreateCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseKeyringsCreateCallbackPostResponse parses an HTTP response from a KeyringsCreateCallbackPostWithResponse call
func ParseKeyringsCreateCallbackPostResponse(rsp *http.Response) (*KeyringsCreateCallbackPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &KeyringsCreateCallbackPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomLinkTypeCreateResponse parses an HTTP response from a CustomLinkTypeCreateWithResponse call
func ParseCustomLinkTypeCreateResponse(rsp *http.Response) (*CustomLinkTypeCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomLinkTypeCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CustomLinkTypeCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomLinkTypeGetResponse parses an HTTP response from a CustomLinkTypeGetWithResponse call
func ParseCustomLinkTypeGetResponse(rsp *http.Response) (*CustomLinkTypeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomLinkTypeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomLinkTypeGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomLinkTypeGetPostResponse parses an HTTP response from a CustomLinkTypeGetPostWithResponse call
func ParseCustomLinkTypeGetPostResponse(rsp *http.Response) (*CustomLinkTypeGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomLinkTypeGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomLinkTypeGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomLinkTypeListResponse parses an HTTP response from a CustomLinkTypeListWithResponse call
func ParseCustomLinkTypeListResponse(rsp *http.Response) (*CustomLinkTypeListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomLinkTypeListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomLinkTypeListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomLinkTypeListPostResponse parses an HTTP response from a CustomLinkTypeListPostWithResponse call
func ParseCustomLinkTypeListPostResponse(rsp *http.Response) (*CustomLinkTypeListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomLinkTypeListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomLinkTypeListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomLinkTypeUpdateResponse parses an HTTP response from a CustomLinkTypeUpdateWithResponse call
func ParseCustomLinkTypeUpdateResponse(rsp *http.Response) (*CustomLinkTypeUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomLinkTypeUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomLinkTypeUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksCreateResponse parses an HTTP response from a LinksCreateWithResponse call
func ParseLinksCreateResponse(rsp *http.Response) (*LinksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LinksCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksDeleteResponse parses an HTTP response from a LinksDeleteWithResponse call
func ParseLinksDeleteResponse(rsp *http.Response) (*LinksDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksGetResponse parses an HTTP response from a LinksGetWithResponse call
func ParseLinksGetResponse(rsp *http.Response) (*LinksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksGetPostResponse parses an HTTP response from a LinksGetPostWithResponse call
func ParseLinksGetPostResponse(rsp *http.Response) (*LinksGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksListResponse parses an HTTP response from a LinksListWithResponse call
func ParseLinksListResponse(rsp *http.Response) (*LinksListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksListPostResponse parses an HTTP response from a LinksListPostWithResponse call
func ParseLinksListPostResponse(rsp *http.Response) (*LinksListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinksReplaceResponse parses an HTTP response from a LinksReplaceWithResponse call
func ParseLinksReplaceResponse(rsp *http.Response) (*LinksReplaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinksReplaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LinksReplaceResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsCountResponse parses an HTTP response from a MeetingsCountWithResponse call
func ParseMeetingsCountResponse(rsp *http.Response) (*MeetingsCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsCountPostResponse parses an HTTP response from a MeetingsCountPostWithResponse call
func ParseMeetingsCountPostResponse(rsp *http.Response) (*MeetingsCountPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsCountPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsCreateResponse parses an HTTP response from a MeetingsCreateWithResponse call
func ParseMeetingsCreateResponse(rsp *http.Response) (*MeetingsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MeetingsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsDeleteResponse parses an HTTP response from a MeetingsDeleteWithResponse call
func ParseMeetingsDeleteResponse(rsp *http.Response) (*MeetingsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsGetResponse parses an HTTP response from a MeetingsGetWithResponse call
func ParseMeetingsGetResponse(rsp *http.Response) (*MeetingsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsGetPostResponse parses an HTTP response from a MeetingsGetPostWithResponse call
func ParseMeetingsGetPostResponse(rsp *http.Response) (*MeetingsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsListResponse parses an HTTP response from a MeetingsListWithResponse call
func ParseMeetingsListResponse(rsp *http.Response) (*MeetingsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsListPostResponse parses an HTTP response from a MeetingsListPostWithResponse call
func ParseMeetingsListPostResponse(rsp *http.Response) (*MeetingsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMeetingsUpdateResponse parses an HTTP response from a MeetingsUpdateWithResponse call
func ParseMeetingsUpdateResponse(rsp *http.Response) (*MeetingsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeetingsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricActionExecuteResponse parses an HTTP response from a MetricActionExecuteWithResponse call
func ParseMetricActionExecuteResponse(rsp *http.Response) (*MetricActionExecuteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricActionExecuteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricActionExecuteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsCreateResponse parses an HTTP response from a MetricDefinitionsCreateWithResponse call
func ParseMetricDefinitionsCreateResponse(rsp *http.Response) (*MetricDefinitionsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MetricDefinitionsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsDeleteResponse parses an HTTP response from a MetricDefinitionsDeleteWithResponse call
func ParseMetricDefinitionsDeleteResponse(rsp *http.Response) (*MetricDefinitionsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest MetricDefinitionsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsGetResponse parses an HTTP response from a MetricDefinitionsGetWithResponse call
func ParseMetricDefinitionsGetResponse(rsp *http.Response) (*MetricDefinitionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsGetPostResponse parses an HTTP response from a MetricDefinitionsGetPostWithResponse call
func ParseMetricDefinitionsGetPostResponse(rsp *http.Response) (*MetricDefinitionsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsListResponse parses an HTTP response from a MetricDefinitionsListWithResponse call
func ParseMetricDefinitionsListResponse(rsp *http.Response) (*MetricDefinitionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsListPostResponse parses an HTTP response from a MetricDefinitionsListPostWithResponse call
func ParseMetricDefinitionsListPostResponse(rsp *http.Response) (*MetricDefinitionsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricDefinitionsUpdateResponse parses an HTTP response from a MetricDefinitionsUpdateWithResponse call
func ParseMetricDefinitionsUpdateResponse(rsp *http.Response) (*MetricDefinitionsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricDefinitionsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricDefinitionsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricTrackersGetResponse parses an HTTP response from a MetricTrackersGetWithResponse call
func ParseMetricTrackersGetResponse(rsp *http.Response) (*MetricTrackersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricTrackersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricTrackersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricTrackersGetPostResponse parses an HTTP response from a MetricTrackersGetPostWithResponse call
func ParseMetricTrackersGetPostResponse(rsp *http.Response) (*MetricTrackersGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricTrackersGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricTrackersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseMetricsDevrevIngestResponse parses an HTTP response from a MetricsDevrevIngestWithResponse call
func ParseMetricsDevrevIngestResponse(rsp *http.Response) (*MetricsDevrevIngestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsDevrevIngestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseNotificationsSendResponse parses an HTTP response from a NotificationsSendWithResponse call
func ParseNotificationsSendResponse(rsp *http.Response) (*NotificationsSendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsSendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationsSendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgScheduleFragmentsCreateResponse parses an HTTP response from a OrgScheduleFragmentsCreateWithResponse call
func ParseOrgScheduleFragmentsCreateResponse(rsp *http.Response) (*OrgScheduleFragmentsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgScheduleFragmentsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OrgScheduleFragmentsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgScheduleFragmentsGetResponse parses an HTTP response from a OrgScheduleFragmentsGetWithResponse call
func ParseOrgScheduleFragmentsGetResponse(rsp *http.Response) (*OrgScheduleFragmentsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgScheduleFragmentsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgScheduleFragmentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgScheduleFragmentsGetPostResponse parses an HTTP response from a OrgScheduleFragmentsGetPostWithResponse call
func ParseOrgScheduleFragmentsGetPostResponse(rsp *http.Response) (*OrgScheduleFragmentsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgScheduleFragmentsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgScheduleFragmentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgScheduleFragmentsTransitionResponse parses an HTTP response from a OrgScheduleFragmentsTransitionWithResponse call
func ParseOrgScheduleFragmentsTransitionResponse(rsp *http.Response) (*OrgScheduleFragmentsTransitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgScheduleFragmentsTransitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgScheduleFragmentsTransitionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesCreateResponse parses an HTTP response from a OrgSchedulesCreateWithResponse call
func ParseOrgSchedulesCreateResponse(rsp *http.Response) (*OrgSchedulesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OrgSchedulesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesEvaluateResponse parses an HTTP response from a OrgSchedulesEvaluateWithResponse call
func ParseOrgSchedulesEvaluateResponse(rsp *http.Response) (*OrgSchedulesEvaluateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesEvaluateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesEvaluateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesEvaluatePostResponse parses an HTTP response from a OrgSchedulesEvaluatePostWithResponse call
func ParseOrgSchedulesEvaluatePostResponse(rsp *http.Response) (*OrgSchedulesEvaluatePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesEvaluatePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesEvaluateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesGetResponse parses an HTTP response from a OrgSchedulesGetWithResponse call
func ParseOrgSchedulesGetResponse(rsp *http.Response) (*OrgSchedulesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesGetPostResponse parses an HTTP response from a OrgSchedulesGetPostWithResponse call
func ParseOrgSchedulesGetPostResponse(rsp *http.Response) (*OrgSchedulesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesListResponse parses an HTTP response from a OrgSchedulesListWithResponse call
func ParseOrgSchedulesListResponse(rsp *http.Response) (*OrgSchedulesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesListPostResponse parses an HTTP response from a OrgSchedulesListPostWithResponse call
func ParseOrgSchedulesListPostResponse(rsp *http.Response) (*OrgSchedulesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesSetFutureResponse parses an HTTP response from a OrgSchedulesSetFutureWithResponse call
func ParseOrgSchedulesSetFutureResponse(rsp *http.Response) (*OrgSchedulesSetFutureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesSetFutureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesSetFutureResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesTransitionResponse parses an HTTP response from a OrgSchedulesTransitionWithResponse call
func ParseOrgSchedulesTransitionResponse(rsp *http.Response) (*OrgSchedulesTransitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesTransitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSchedulesTransitionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgSchedulesUpdateResponse parses an HTTP response from a OrgSchedulesUpdateWithResponse call
func ParseOrgSchedulesUpdateResponse(rsp *http.Response) (*OrgSchedulesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgSchedulesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OrgSchedulesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsCreateResponse parses an HTTP response from a PartsCreateWithResponse call
func ParsePartsCreateResponse(rsp *http.Response) (*PartsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PartsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsDeleteResponse parses an HTTP response from a PartsDeleteWithResponse call
func ParsePartsDeleteResponse(rsp *http.Response) (*PartsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsGetResponse parses an HTTP response from a PartsGetWithResponse call
func ParsePartsGetResponse(rsp *http.Response) (*PartsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsGetPostResponse parses an HTTP response from a PartsGetPostWithResponse call
func ParsePartsGetPostResponse(rsp *http.Response) (*PartsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsListResponse parses an HTTP response from a PartsListWithResponse call
func ParsePartsListResponse(rsp *http.Response) (*PartsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsListPostResponse parses an HTTP response from a PartsListPostWithResponse call
func ParsePartsListPostResponse(rsp *http.Response) (*PartsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePartsUpdateResponse parses an HTTP response from a PartsUpdateWithResponse call
func ParsePartsUpdateResponse(rsp *http.Response) (*PartsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePreferencesGetResponse parses an HTTP response from a PreferencesGetWithResponse call
func ParsePreferencesGetResponse(rsp *http.Response) (*PreferencesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreferencesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreferencesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePreferencesGetPostResponse parses an HTTP response from a PreferencesGetPostWithResponse call
func ParsePreferencesGetPostResponse(rsp *http.Response) (*PreferencesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreferencesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreferencesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePreferencesUpdateResponse parses an HTTP response from a PreferencesUpdateWithResponse call
func ParsePreferencesUpdateResponse(rsp *http.Response) (*PreferencesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreferencesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreferencesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateQuestionAnswerResponse parses an HTTP response from a CreateQuestionAnswerWithResponse call
func ParseCreateQuestionAnswerResponse(rsp *http.Response) (*CreateQuestionAnswerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateQuestionAnswerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest QuestionAnswersCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteQuestionAnswerResponse parses an HTTP response from a DeleteQuestionAnswerWithResponse call
func ParseDeleteQuestionAnswerResponse(rsp *http.Response) (*DeleteQuestionAnswerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteQuestionAnswerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetQuestionAnswerResponse parses an HTTP response from a GetQuestionAnswerWithResponse call
func ParseGetQuestionAnswerResponse(rsp *http.Response) (*GetQuestionAnswerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQuestionAnswerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuestionAnswersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetQuestionAnswerPostResponse parses an HTTP response from a GetQuestionAnswerPostWithResponse call
func ParseGetQuestionAnswerPostResponse(rsp *http.Response) (*GetQuestionAnswerPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQuestionAnswerPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuestionAnswersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListQuestionAnswersResponse parses an HTTP response from a ListQuestionAnswersWithResponse call
func ParseListQuestionAnswersResponse(rsp *http.Response) (*ListQuestionAnswersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQuestionAnswersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuestionAnswersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListQuestionAnswersPostResponse parses an HTTP response from a ListQuestionAnswersPostWithResponse call
func ParseListQuestionAnswersPostResponse(rsp *http.Response) (*ListQuestionAnswersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQuestionAnswersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuestionAnswersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateQuestionAnswerResponse parses an HTTP response from a UpdateQuestionAnswerWithResponse call
func ParseUpdateQuestionAnswerResponse(rsp *http.Response) (*UpdateQuestionAnswerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateQuestionAnswerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuestionAnswersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseReactionsListResponse parses an HTTP response from a ReactionsListWithResponse call
func ParseReactionsListResponse(rsp *http.Response) (*ReactionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReactionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseReactionsListPostResponse parses an HTTP response from a ReactionsListPostWithResponse call
func ParseReactionsListPostResponse(rsp *http.Response) (*ReactionsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReactionsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseReactionsUpdateResponse parses an HTTP response from a ReactionsUpdateWithResponse call
func ParseReactionsUpdateResponse(rsp *http.Response) (*ReactionsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReactionsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseChatCompletionsResponse parses an HTTP response from a ChatCompletionsWithResponse call
func ParseChatCompletionsResponse(rsp *http.Response) (*ChatCompletionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatCompletionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatCompletionsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetReplyResponse parses an HTTP response from a GetReplyWithResponse call
func ParseGetReplyResponse(rsp *http.Response) (*GetReplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetReplyResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRecordTemplateGetResponse parses an HTTP response from a RecordTemplateGetWithResponse call
func ParseRecordTemplateGetResponse(rsp *http.Response) (*RecordTemplateGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecordTemplateGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordTemplateGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRecordTemplateGetPostResponse parses an HTTP response from a RecordTemplateGetPostWithResponse call
func ParseRecordTemplateGetPostResponse(rsp *http.Response) (*RecordTemplateGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecordTemplateGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordTemplateGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsCreateResponse parses an HTTP response from a RevOrgsCreateWithResponse call
func ParseRevOrgsCreateResponse(rsp *http.Response) (*RevOrgsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RevOrgsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsDeleteResponse parses an HTTP response from a RevOrgsDeleteWithResponse call
func ParseRevOrgsDeleteResponse(rsp *http.Response) (*RevOrgsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsGetResponse parses an HTTP response from a RevOrgsGetWithResponse call
func ParseRevOrgsGetResponse(rsp *http.Response) (*RevOrgsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsGetPostResponse parses an HTTP response from a RevOrgsGetPostWithResponse call
func ParseRevOrgsGetPostResponse(rsp *http.Response) (*RevOrgsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsListResponse parses an HTTP response from a RevOrgsListWithResponse call
func ParseRevOrgsListResponse(rsp *http.Response) (*RevOrgsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsListPostResponse parses an HTTP response from a RevOrgsListPostWithResponse call
func ParseRevOrgsListPostResponse(rsp *http.Response) (*RevOrgsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevOrgsUpdateResponse parses an HTTP response from a RevOrgsUpdateWithResponse call
func ParseRevOrgsUpdateResponse(rsp *http.Response) (*RevOrgsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevOrgsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevOrgsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersAssociationsAddResponse parses an HTTP response from a RevUsersAssociationsAddWithResponse call
func ParseRevUsersAssociationsAddResponse(rsp *http.Response) (*RevUsersAssociationsAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersAssociationsAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RevUsersAssociationsAddResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersAssociationsListResponse parses an HTTP response from a RevUsersAssociationsListWithResponse call
func ParseRevUsersAssociationsListResponse(rsp *http.Response) (*RevUsersAssociationsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersAssociationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersAssociationsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersAssociationsListPostResponse parses an HTTP response from a RevUsersAssociationsListPostWithResponse call
func ParseRevUsersAssociationsListPostResponse(rsp *http.Response) (*RevUsersAssociationsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersAssociationsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersAssociationsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersAssociationsRemoveResponse parses an HTTP response from a RevUsersAssociationsRemoveWithResponse call
func ParseRevUsersAssociationsRemoveResponse(rsp *http.Response) (*RevUsersAssociationsRemoveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersAssociationsRemoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest RevUsersAssociationsRemoveResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersCreateResponse parses an HTTP response from a RevUsersCreateWithResponse call
func ParseRevUsersCreateResponse(rsp *http.Response) (*RevUsersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RevUsersCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersDeleteResponse parses an HTTP response from a RevUsersDeleteWithResponse call
func ParseRevUsersDeleteResponse(rsp *http.Response) (*RevUsersDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteRevUsersPersonalDataResponse parses an HTTP response from a DeleteRevUsersPersonalDataWithResponse call
func ParseDeleteRevUsersPersonalDataResponse(rsp *http.Response) (*DeleteRevUsersPersonalDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRevUsersPersonalDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteRevUsersPersonalDataResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersGetResponse parses an HTTP response from a RevUsersGetWithResponse call
func ParseRevUsersGetResponse(rsp *http.Response) (*RevUsersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersGetPostResponse parses an HTTP response from a RevUsersGetPostWithResponse call
func ParseRevUsersGetPostResponse(rsp *http.Response) (*RevUsersGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLinkRevUserToRevOrgResponse parses an HTTP response from a LinkRevUserToRevOrgWithResponse call
func ParseLinkRevUserToRevOrgResponse(rsp *http.Response) (*LinkRevUserToRevOrgResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkRevUserToRevOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkRevUserToRevOrgResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersListResponse parses an HTTP response from a RevUsersListWithResponse call
func ParseRevUsersListResponse(rsp *http.Response) (*RevUsersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersListPostResponse parses an HTTP response from a RevUsersListPostWithResponse call
func ParseRevUsersListPostResponse(rsp *http.Response) (*RevUsersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersMergeResponse parses an HTTP response from a RevUsersMergeWithResponse call
func ParseRevUsersMergeResponse(rsp *http.Response) (*RevUsersMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersMergeResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetRevUsersPersonalDataResponse parses an HTTP response from a GetRevUsersPersonalDataWithResponse call
func ParseGetRevUsersPersonalDataResponse(rsp *http.Response) (*GetRevUsersPersonalDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRevUsersPersonalDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRevUsersPersonalDataResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersScanResponse parses an HTTP response from a RevUsersScanWithResponse call
func ParseRevUsersScanResponse(rsp *http.Response) (*RevUsersScanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersScanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersScanResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersScanPostResponse parses an HTTP response from a RevUsersScanPostWithResponse call
func ParseRevUsersScanPostResponse(rsp *http.Response) (*RevUsersScanPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersScanPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersScanResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUnlinkRevUserFromRevOrgResponse parses an HTTP response from a UnlinkRevUserFromRevOrgWithResponse call
func ParseUnlinkRevUserFromRevOrgResponse(rsp *http.Response) (*UnlinkRevUserFromRevOrgResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkRevUserFromRevOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnlinkRevUserFromRevOrgResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevUsersUpdateResponse parses an HTTP response from a RevUsersUpdateWithResponse call
func ParseRevUsersUpdateResponse(rsp *http.Response) (*RevUsersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevUsersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevUsersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRolesApplyResponse parses an HTTP response from a RolesApplyWithResponse call
func ParseRolesApplyResponse(rsp *http.Response) (*RolesApplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RolesApplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RolesApplyResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRolesCreateResponse parses an HTTP response from a RolesCreateWithResponse call
func ParseRolesCreateResponse(rsp *http.Response) (*RolesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RolesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RolesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAggregatedSchemaGetResponse parses an HTTP response from a AggregatedSchemaGetWithResponse call
func ParseAggregatedSchemaGetResponse(rsp *http.Response) (*AggregatedSchemaGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AggregatedSchemaGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AggregatedSchemaGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAggregatedSchemaGetPostResponse parses an HTTP response from a AggregatedSchemaGetPostWithResponse call
func ParseAggregatedSchemaGetPostResponse(rsp *http.Response) (*AggregatedSchemaGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AggregatedSchemaGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AggregatedSchemaGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomSchemaFragmentsGetResponse parses an HTTP response from a CustomSchemaFragmentsGetWithResponse call
func ParseCustomSchemaFragmentsGetResponse(rsp *http.Response) (*CustomSchemaFragmentsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomSchemaFragmentsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomSchemaFragmentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomSchemaFragmentsGetPostResponse parses an HTTP response from a CustomSchemaFragmentsGetPostWithResponse call
func ParseCustomSchemaFragmentsGetPostResponse(rsp *http.Response) (*CustomSchemaFragmentsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomSchemaFragmentsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomSchemaFragmentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomSchemaFragmentsListResponse parses an HTTP response from a CustomSchemaFragmentsListWithResponse call
func ParseCustomSchemaFragmentsListResponse(rsp *http.Response) (*CustomSchemaFragmentsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomSchemaFragmentsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomSchemaFragmentsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomSchemaFragmentsListPostResponse parses an HTTP response from a CustomSchemaFragmentsListPostWithResponse call
func ParseCustomSchemaFragmentsListPostResponse(rsp *http.Response) (*CustomSchemaFragmentsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomSchemaFragmentsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomSchemaFragmentsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomSchemaFragmentsSetResponse parses an HTTP response from a CustomSchemaFragmentsSetWithResponse call
func ParseCustomSchemaFragmentsSetResponse(rsp *http.Response) (*CustomSchemaFragmentsSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomSchemaFragmentsSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CustomSchemaFragmentsSetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStockSchemaFragmentsGetResponse parses an HTTP response from a StockSchemaFragmentsGetWithResponse call
func ParseStockSchemaFragmentsGetResponse(rsp *http.Response) (*StockSchemaFragmentsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StockSchemaFragmentsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StockSchemaFragmentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStockSchemaFragmentsGetPostResponse parses an HTTP response from a StockSchemaFragmentsGetPostWithResponse call
func ParseStockSchemaFragmentsGetPostResponse(rsp *http.Response) (*StockSchemaFragmentsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StockSchemaFragmentsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StockSchemaFragmentsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStockSchemaFragmentsListResponse parses an HTTP response from a StockSchemaFragmentsListWithResponse call
func ParseStockSchemaFragmentsListResponse(rsp *http.Response) (*StockSchemaFragmentsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StockSchemaFragmentsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StockSchemaFragmentsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStockSchemaFragmentsListPostResponse parses an HTTP response from a StockSchemaFragmentsListPostWithResponse call
func ParseStockSchemaFragmentsListPostResponse(rsp *http.Response) (*StockSchemaFragmentsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StockSchemaFragmentsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StockSchemaFragmentsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubtypesListResponse parses an HTTP response from a SubtypesListWithResponse call
func ParseSubtypesListResponse(rsp *http.Response) (*SubtypesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubtypesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubtypesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubtypesListPostResponse parses an HTTP response from a SubtypesListPostWithResponse call
func ParseSubtypesListPostResponse(rsp *http.Response) (*SubtypesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubtypesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubtypesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSchemasSubtypePrepareUpdateGetResponse parses an HTTP response from a SchemasSubtypePrepareUpdateGetWithResponse call
func ParseSchemasSubtypePrepareUpdateGetResponse(rsp *http.Response) (*SchemasSubtypePrepareUpdateGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasSubtypePrepareUpdateGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemasSubtypePrepareUpdateGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSearchCoreResponse parses an HTTP response from a SearchCoreWithResponse call
func ParseSearchCoreResponse(rsp *http.Response) (*SearchCoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCoreResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSearchCorePostResponse parses an HTTP response from a SearchCorePostWithResponse call
func ParseSearchCorePostResponse(rsp *http.Response) (*SearchCorePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCorePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCoreResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSearchHybridResponse parses an HTTP response from a SearchHybridWithResponse call
func ParseSearchHybridResponse(rsp *http.Response) (*SearchHybridResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchHybridResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchHybridResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSearchHybridPostResponse parses an HTTP response from a SearchHybridPostWithResponse call
func ParseSearchHybridPostResponse(rsp *http.Response) (*SearchHybridPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchHybridPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchHybridResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseServiceAccountsCreateResponse parses an HTTP response from a ServiceAccountsCreateWithResponse call
func ParseServiceAccountsCreateResponse(rsp *http.Response) (*ServiceAccountsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServiceAccountsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseServiceAccountsGetResponse parses an HTTP response from a ServiceAccountsGetWithResponse call
func ParseServiceAccountsGetResponse(rsp *http.Response) (*ServiceAccountsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServiceAccountsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseServiceAccountsGetPostResponse parses an HTTP response from a ServiceAccountsGetPostWithResponse call
func ParseServiceAccountsGetPostResponse(rsp *http.Response) (*ServiceAccountsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServiceAccountsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseServiceAccountsUpdateResponse parses an HTTP response from a ServiceAccountsUpdateWithResponse call
func ParseServiceAccountsUpdateResponse(rsp *http.Response) (*ServiceAccountsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServiceAccountsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlaTrackersGetResponse parses an HTTP response from a SlaTrackersGetWithResponse call
func ParseSlaTrackersGetResponse(rsp *http.Response) (*SlaTrackersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaTrackersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlaTrackersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlaTrackersGetPostResponse parses an HTTP response from a SlaTrackersGetPostWithResponse call
func ParseSlaTrackersGetPostResponse(rsp *http.Response) (*SlaTrackersGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaTrackersGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlaTrackersGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlaTrackersListResponse parses an HTTP response from a SlaTrackersListWithResponse call
func ParseSlaTrackersListResponse(rsp *http.Response) (*SlaTrackersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaTrackersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlaTrackersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlaTrackersListPostResponse parses an HTTP response from a SlaTrackersListPostWithResponse call
func ParseSlaTrackersListPostResponse(rsp *http.Response) (*SlaTrackersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaTrackersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlaTrackersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlaTrackersRemoveMetricResponse parses an HTTP response from a SlaTrackersRemoveMetricWithResponse call
func ParseSlaTrackersRemoveMetricResponse(rsp *http.Response) (*SlaTrackersRemoveMetricResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaTrackersRemoveMetricResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlaTrackersRemoveMetricResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasAssignResponse parses an HTTP response from a SlasAssignWithResponse call
func ParseSlasAssignResponse(rsp *http.Response) (*SlasAssignResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasAssignResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasAssignResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasCreateResponse parses an HTTP response from a SlasCreateWithResponse call
func ParseSlasCreateResponse(rsp *http.Response) (*SlasCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SlasCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasGetResponse parses an HTTP response from a SlasGetWithResponse call
func ParseSlasGetResponse(rsp *http.Response) (*SlasGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasGetPostResponse parses an HTTP response from a SlasGetPostWithResponse call
func ParseSlasGetPostResponse(rsp *http.Response) (*SlasGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasListResponse parses an HTTP response from a SlasListWithResponse call
func ParseSlasListResponse(rsp *http.Response) (*SlasListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasListPostResponse parses an HTTP response from a SlasListPostWithResponse call
func ParseSlasListPostResponse(rsp *http.Response) (*SlasListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasTransitionResponse parses an HTTP response from a SlasTransitionWithResponse call
func ParseSlasTransitionResponse(rsp *http.Response) (*SlasTransitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasTransitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlasTransitionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSlasUpdateResponse parses an HTTP response from a SlasUpdateWithResponse call
func ParseSlasUpdateResponse(rsp *http.Response) (*SlasUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlasUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SlasUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSnapInsResourcesResponse parses an HTTP response from a SnapInsResourcesWithResponse call
func ParseSnapInsResourcesResponse(rsp *http.Response) (*SnapInsResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapInsResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapInsResourcesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSnapInsResourcesPostResponse parses an HTTP response from a SnapInsResourcesPostWithResponse call
func ParseSnapInsResourcesPostResponse(rsp *http.Response) (*SnapInsResourcesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapInsResourcesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapInsResourcesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSnapInsUpdateResponse parses an HTTP response from a SnapInsUpdateWithResponse call
func ParseSnapInsUpdateResponse(rsp *http.Response) (*SnapInsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapInsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapInsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSnapKitActionExecuteDeferredResponse parses an HTTP response from a SnapKitActionExecuteDeferredWithResponse call
func ParseSnapKitActionExecuteDeferredResponse(rsp *http.Response) (*SnapKitActionExecuteDeferredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapKitActionExecuteDeferredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapKitActionExecuteDeferredResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSnapWidgetsCreateResponse parses an HTTP response from a SnapWidgetsCreateWithResponse call
func ParseSnapWidgetsCreateResponse(rsp *http.Response) (*SnapWidgetsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapWidgetsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SnapWidgetsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStageDiagramsCreateResponse parses an HTTP response from a StageDiagramsCreateWithResponse call
func ParseStageDiagramsCreateResponse(rsp *http.Response) (*StageDiagramsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StageDiagramsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StageDiagramsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStageDiagramsGetResponse parses an HTTP response from a StageDiagramsGetWithResponse call
func ParseStageDiagramsGetResponse(rsp *http.Response) (*StageDiagramsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StageDiagramsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StageDiagramsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStageDiagramsGetPostResponse parses an HTTP response from a StageDiagramsGetPostWithResponse call
func ParseStageDiagramsGetPostResponse(rsp *http.Response) (*StageDiagramsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StageDiagramsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StageDiagramsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStageDiagramsListResponse parses an HTTP response from a StageDiagramsListWithResponse call
func ParseStageDiagramsListResponse(rsp *http.Response) (*StageDiagramsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StageDiagramsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StageDiagramsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStageDiagramsListPostResponse parses an HTTP response from a StageDiagramsListPostWithResponse call
func ParseStageDiagramsListPostResponse(rsp *http.Response) (*StageDiagramsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StageDiagramsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StageDiagramsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseStageDiagramsUpdateResponse parses an HTTP response from a StageDiagramsUpdateWithResponse call
func ParseStageDiagramsUpdateResponse(rsp *http.Response) (*StageDiagramsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StageDiagramsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StageDiagramsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStagesCreateResponse parses an HTTP response from a CustomStagesCreateWithResponse call
func ParseCustomStagesCreateResponse(rsp *http.Response) (*CustomStagesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStagesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CustomStagesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStagesGetResponse parses an HTTP response from a CustomStagesGetWithResponse call
func ParseCustomStagesGetResponse(rsp *http.Response) (*CustomStagesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStagesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStagesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStagesGetPostResponse parses an HTTP response from a CustomStagesGetPostWithResponse call
func ParseCustomStagesGetPostResponse(rsp *http.Response) (*CustomStagesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStagesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStagesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStagesListResponse parses an HTTP response from a CustomStagesListWithResponse call
func ParseCustomStagesListResponse(rsp *http.Response) (*CustomStagesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStagesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStagesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStagesListPostResponse parses an HTTP response from a CustomStagesListPostWithResponse call
func ParseCustomStagesListPostResponse(rsp *http.Response) (*CustomStagesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStagesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStagesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStagesUpdateResponse parses an HTTP response from a CustomStagesUpdateWithResponse call
func ParseCustomStagesUpdateResponse(rsp *http.Response) (*CustomStagesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStagesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStagesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStatesCreateResponse parses an HTTP response from a CustomStatesCreateWithResponse call
func ParseCustomStatesCreateResponse(rsp *http.Response) (*CustomStatesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStatesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CustomStatesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStatesGetResponse parses an HTTP response from a CustomStatesGetWithResponse call
func ParseCustomStatesGetResponse(rsp *http.Response) (*CustomStatesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStatesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStatesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStatesGetPostResponse parses an HTTP response from a CustomStatesGetPostWithResponse call
func ParseCustomStatesGetPostResponse(rsp *http.Response) (*CustomStatesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStatesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStatesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStatesListResponse parses an HTTP response from a CustomStatesListWithResponse call
func ParseCustomStatesListResponse(rsp *http.Response) (*CustomStatesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStatesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStatesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStatesListPostResponse parses an HTTP response from a CustomStatesListPostWithResponse call
func ParseCustomStatesListPostResponse(rsp *http.Response) (*CustomStatesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStatesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStatesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomStatesUpdateResponse parses an HTTP response from a CustomStatesUpdateWithResponse call
func ParseCustomStatesUpdateResponse(rsp *http.Response) (*CustomStatesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomStatesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomStatesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubscribersListResponse parses an HTTP response from a SubscribersListWithResponse call
func ParseSubscribersListResponse(rsp *http.Response) (*SubscribersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscribersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubscribersListPostResponse parses an HTTP response from a SubscribersListPostWithResponse call
func ParseSubscribersListPostResponse(rsp *http.Response) (*SubscribersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscribersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubscribersUpdateResponse parses an HTTP response from a SubscribersUpdateWithResponse call
func ParseSubscribersUpdateResponse(rsp *http.Response) (*SubscribersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscribersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysCreateResponse parses an HTTP response from a SurveysCreateWithResponse call
func ParseSurveysCreateResponse(rsp *http.Response) (*SurveysCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SurveysCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysDeleteResponse parses an HTTP response from a SurveysDeleteWithResponse call
func ParseSurveysDeleteResponse(rsp *http.Response) (*SurveysDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysGetResponse parses an HTTP response from a SurveysGetWithResponse call
func ParseSurveysGetResponse(rsp *http.Response) (*SurveysGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysGetPostResponse parses an HTTP response from a SurveysGetPostWithResponse call
func ParseSurveysGetPostResponse(rsp *http.Response) (*SurveysGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysListResponse parses an HTTP response from a SurveysListWithResponse call
func ParseSurveysListResponse(rsp *http.Response) (*SurveysListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysListPostResponse parses an HTTP response from a SurveysListPostWithResponse call
func ParseSurveysListPostResponse(rsp *http.Response) (*SurveysListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysResponsesListResponse parses an HTTP response from a SurveysResponsesListWithResponse call
func ParseSurveysResponsesListResponse(rsp *http.Response) (*SurveysResponsesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysResponsesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysResponsesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysResponsesListPostResponse parses an HTTP response from a SurveysResponsesListPostWithResponse call
func ParseSurveysResponsesListPostResponse(rsp *http.Response) (*SurveysResponsesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysResponsesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysResponsesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysResponsesUpdateResponse parses an HTTP response from a SurveysResponsesUpdateWithResponse call
func ParseSurveysResponsesUpdateResponse(rsp *http.Response) (*SurveysResponsesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysResponsesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SurveysResponsesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysSendResponse parses an HTTP response from a SurveysSendWithResponse call
func ParseSurveysSendResponse(rsp *http.Response) (*SurveysSendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysSendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysSendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysSubmitResponse parses an HTTP response from a SurveysSubmitWithResponse call
func ParseSurveysSubmitResponse(rsp *http.Response) (*SurveysSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SurveysSubmitResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSurveysUpdateResponse parses an HTTP response from a SurveysUpdateWithResponse call
func ParseSurveysUpdateResponse(rsp *http.Response) (*SurveysUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SurveysUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SurveysUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSysUsersListResponse parses an HTTP response from a SysUsersListWithResponse call
func ParseSysUsersListResponse(rsp *http.Response) (*SysUsersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SysUsersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SysUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSysUsersListPostResponse parses an HTTP response from a SysUsersListPostWithResponse call
func ParseSysUsersListPostResponse(rsp *http.Response) (*SysUsersListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SysUsersListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SysUsersListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSysUsersUpdateResponse parses an HTTP response from a SysUsersUpdateWithResponse call
func ParseSysUsersUpdateResponse(rsp *http.Response) (*SysUsersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SysUsersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SysUsersUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsCreateResponse parses an HTTP response from a TagsCreateWithResponse call
func ParseTagsCreateResponse(rsp *http.Response) (*TagsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TagsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsDeleteResponse parses an HTTP response from a TagsDeleteWithResponse call
func ParseTagsDeleteResponse(rsp *http.Response) (*TagsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsGetResponse parses an HTTP response from a TagsGetWithResponse call
func ParseTagsGetResponse(rsp *http.Response) (*TagsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsGetPostResponse parses an HTTP response from a TagsGetPostWithResponse call
func ParseTagsGetPostResponse(rsp *http.Response) (*TagsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsListResponse parses an HTTP response from a TagsListWithResponse call
func ParseTagsListResponse(rsp *http.Response) (*TagsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsListPostResponse parses an HTTP response from a TagsListPostWithResponse call
func ParseTagsListPostResponse(rsp *http.Response) (*TagsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTagsUpdateResponse parses an HTTP response from a TagsUpdateWithResponse call
func ParseTagsUpdateResponse(rsp *http.Response) (*TagsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesCreateResponse parses an HTTP response from a TimelineEntriesCreateWithResponse call
func ParseTimelineEntriesCreateResponse(rsp *http.Response) (*TimelineEntriesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TimelineEntriesCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesDeleteResponse parses an HTTP response from a TimelineEntriesDeleteWithResponse call
func ParseTimelineEntriesDeleteResponse(rsp *http.Response) (*TimelineEntriesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesGetResponse parses an HTTP response from a TimelineEntriesGetWithResponse call
func ParseTimelineEntriesGetResponse(rsp *http.Response) (*TimelineEntriesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesGetPostResponse parses an HTTP response from a TimelineEntriesGetPostWithResponse call
func ParseTimelineEntriesGetPostResponse(rsp *http.Response) (*TimelineEntriesGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesListResponse parses an HTTP response from a TimelineEntriesListWithResponse call
func ParseTimelineEntriesListResponse(rsp *http.Response) (*TimelineEntriesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesListPostResponse parses an HTTP response from a TimelineEntriesListPostWithResponse call
func ParseTimelineEntriesListPostResponse(rsp *http.Response) (*TimelineEntriesListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTimelineEntriesUpdateResponse parses an HTTP response from a TimelineEntriesUpdateWithResponse call
func ParseTimelineEntriesUpdateResponse(rsp *http.Response) (*TimelineEntriesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelineEntriesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimelineEntriesUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTrackEventsPublishResponse parses an HTTP response from a TrackEventsPublishWithResponse call
func ParseTrackEventsPublishResponse(rsp *http.Response) (*TrackEventsPublishResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackEventsPublishResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrackEventsPublishResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUomsCountResponse parses an HTTP response from a UomsCountWithResponse call
func ParseUomsCountResponse(rsp *http.Response) (*UomsCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UomsCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UomsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUomsCountPostResponse parses an HTTP response from a UomsCountPostWithResponse call
func ParseUomsCountPostResponse(rsp *http.Response) (*UomsCountPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UomsCountPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UomsCountResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUomsCreateResponse parses an HTTP response from a UomsCreateWithResponse call
func ParseUomsCreateResponse(rsp *http.Response) (*UomsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UomsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UomsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUomsDeleteResponse parses an HTTP response from a UomsDeleteWithResponse call
func ParseUomsDeleteResponse(rsp *http.Response) (*UomsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UomsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUomsGetResponse parses an HTTP response from a UomsGetWithResponse call
func ParseUomsGetResponse(rsp *http.Response) (*UomsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UomsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UomsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUomsGetPostResponse parses an HTTP response from a UomsGetPostWithResponse call
func ParseUomsGetPostResponse(rsp *http.Response) (*UomsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UomsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UomsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUomsListResponse parses an HTTP response from a UomsListWithResponse call
func ParseUomsListResponse(rsp *http.Response) (*UomsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UomsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UomsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUomsListPostResponse parses an HTTP response from a UomsListPostWithResponse call
func ParseUomsListPostResponse(rsp *http.Response) (*UomsListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UomsListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UomsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUomsUpdateResponse parses an HTTP response from a UomsUpdateWithResponse call
func ParseUomsUpdateResponse(rsp *http.Response) (*UomsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UomsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UomsUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebCrawlerJobsControlResponse parses an HTTP response from a WebCrawlerJobsControlWithResponse call
func ParseWebCrawlerJobsControlResponse(rsp *http.Response) (*WebCrawlerJobsControlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebCrawlerJobsControlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsControlResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateWebCrawlerJobResponse parses an HTTP response from a CreateWebCrawlerJobWithResponse call
func ParseCreateWebCrawlerJobResponse(rsp *http.Response) (*CreateWebCrawlerJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebCrawlerJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebCrawlerJobsCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetWebCrawlerJobResponse parses an HTTP response from a GetWebCrawlerJobWithResponse call
func ParseGetWebCrawlerJobResponse(rsp *http.Response) (*GetWebCrawlerJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebCrawlerJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetWebCrawlerJobPostResponse parses an HTTP response from a GetWebCrawlerJobPostWithResponse call
func ParseGetWebCrawlerJobPostResponse(rsp *http.Response) (*GetWebCrawlerJobPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebCrawlerJobPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListWebCrawlerJobsResponse parses an HTTP response from a ListWebCrawlerJobsWithResponse call
func ParseListWebCrawlerJobsResponse(rsp *http.Response) (*ListWebCrawlerJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebCrawlerJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListWebCrawlerJobsPostResponse parses an HTTP response from a ListWebCrawlerJobsPostWithResponse call
func ParseListWebCrawlerJobsPostResponse(rsp *http.Response) (*ListWebCrawlerJobsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebCrawlerJobsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebCrawlerJobsListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksCreateResponse parses an HTTP response from a WebhooksCreateWithResponse call
func ParseWebhooksCreateResponse(rsp *http.Response) (*WebhooksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebhooksCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksDeleteResponse parses an HTTP response from a WebhooksDeleteWithResponse call
func ParseWebhooksDeleteResponse(rsp *http.Response) (*WebhooksDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksEventResponse parses an HTTP response from a WebhooksEventWithResponse call
func ParseWebhooksEventResponse(rsp *http.Response) (*WebhooksEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookEventResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksFetchResponse parses an HTTP response from a WebhooksFetchWithResponse call
func ParseWebhooksFetchResponse(rsp *http.Response) (*WebhooksFetchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksFetchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksFetchResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksGetResponse parses an HTTP response from a WebhooksGetWithResponse call
func ParseWebhooksGetResponse(rsp *http.Response) (*WebhooksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksGetPostResponse parses an HTTP response from a WebhooksGetPostWithResponse call
func ParseWebhooksGetPostResponse(rsp *http.Response) (*WebhooksGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksListResponse parses an HTTP response from a WebhooksListWithResponse call
func ParseWebhooksListResponse(rsp *http.Response) (*WebhooksListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksListPostResponse parses an HTTP response from a WebhooksListPostWithResponse call
func ParseWebhooksListPostResponse(rsp *http.Response) (*WebhooksListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWebhooksUpdateResponse parses an HTTP response from a WebhooksUpdateWithResponse call
func ParseWebhooksUpdateResponse(rsp *http.Response) (*WebhooksUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhooksUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWidgetsGetResponse parses an HTTP response from a WidgetsGetWithResponse call
func ParseWidgetsGetResponse(rsp *http.Response) (*WidgetsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WidgetsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WidgetsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWidgetsGetPostResponse parses an HTTP response from a WidgetsGetPostWithResponse call
func ParseWidgetsGetPostResponse(rsp *http.Response) (*WidgetsGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WidgetsGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WidgetsGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksCreateResponse parses an HTTP response from a WorksCreateWithResponse call
func ParseWorksCreateResponse(rsp *http.Response) (*WorksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WorksCreateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksDeleteResponse parses an HTTP response from a WorksDeleteWithResponse call
func ParseWorksDeleteResponse(rsp *http.Response) (*WorksDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksDeleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksExportResponse parses an HTTP response from a WorksExportWithResponse call
func ParseWorksExportResponse(rsp *http.Response) (*WorksExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksExportPostResponse parses an HTTP response from a WorksExportPostWithResponse call
func ParseWorksExportPostResponse(rsp *http.Response) (*WorksExportPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksExportPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksExportResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksGetResponse parses an HTTP response from a WorksGetWithResponse call
func ParseWorksGetResponse(rsp *http.Response) (*WorksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksGetPostResponse parses an HTTP response from a WorksGetPostWithResponse call
func ParseWorksGetPostResponse(rsp *http.Response) (*WorksGetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksGetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksGetResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksListResponse parses an HTTP response from a WorksListWithResponse call
func ParseWorksListResponse(rsp *http.Response) (*WorksListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksListPostResponse parses an HTTP response from a WorksListPostWithResponse call
func ParseWorksListPostResponse(rsp *http.Response) (*WorksListPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksListPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseWorksUpdateResponse parses an HTTP response from a WorksUpdateWithResponse call
func ParseWorksUpdateResponse(rsp *http.Response) (*WorksUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorksUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorksUpdateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
